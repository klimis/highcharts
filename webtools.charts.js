/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
(function(root, factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = root.document ? factory(root) : factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/highcharts', function() {
            return factory(root)
        })
    } else {
        if (root.Highcharts) {
            root.Highcharts.error(16, !0)
        }
        root.Highcharts = factory(root)
    }
}(typeof window !== 'undefined' ? window : this, function(window) {
    'use strict';
    var _modules = {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Core/Globals.js', [], function() {
        var Globals;
        (function(Globals) {
                Globals.SVG_NS = 'http://www.w3.org/2000/svg',
                    Globals.product = 'Highcharts',
                    Globals.version = '11.2.0',
                    Globals.win = (typeof window !== 'undefined' ? window : {}),
                    Globals.doc = Globals.win.document,
                    Globals.svg = (Globals.doc && Globals.doc.createElementNS && !!Globals.doc.createElementNS(Globals.SVG_NS, 'svg').createSVGRect),
                    Globals.userAgent = (Globals.win.navigator && Globals.win.navigator.userAgent) || '',
                    Globals.isChrome = Globals.userAgent.indexOf('Chrome') !== -1,
                    Globals.isFirefox = Globals.userAgent.indexOf('Firefox') !== -1,
                    Globals.isMS = /(edge|msie|trident)/i.test(Globals.userAgent) && !Globals.win.opera,
                    Globals.isSafari = !Globals.isChrome && Globals.userAgent.indexOf('Safari') !== -1,
                    Globals.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals.userAgent),
                    Globals.isWebKit = Globals.userAgent.indexOf('AppleWebKit') !== -1,
                    Globals.deg2rad = Math.PI * 2 / 360,
                    Globals.hasBidiBug = (Globals.isFirefox && parseInt(Globals.userAgent.split('Firefox/')[1], 10) < 4),
                    Globals.hasTouch = !!Globals.win.TouchEvent,
                    Globals.marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],
                    Globals.noop = function() {}
                    ,
                    Globals.supportsPassiveEvents = (function() {
                        let supportsPassive = !1;
                        if (!Globals.isMS) {
                            const opts = Object.defineProperty({}, 'passive', {
                                get: function() {
                                    supportsPassive = !0
                                }
                            });
                            if (Globals.win.addEventListener && Globals.win.removeEventListener) {
                                Globals.win.addEventListener('testPassive', Globals.noop, opts);
                                Globals.win.removeEventListener('testPassive', Globals.noop, opts)
                            }
                        }
                        return supportsPassive
                    }());
                Globals.charts = [];
                Globals.dateFormats = {};
                Globals.seriesTypes = {};
                Globals.symbolSizes = {};
                Globals.chartCount = 0
            }
        )(Globals || (Globals = {}));
        ('');
        return Globals
    });
    _registerModule(_modules, 'Core/Utilities.js', [_modules['Core/Globals.js']], function(H) {
        const {charts, doc, win} = H;
        function error(code, stop, chart, params) {
            const severity = stop ? 'Highcharts error' : 'Highcharts warning';
            if (code === 32) {
                code = `${severity}: Deprecated member`
            }
            const isCode = isNumber(code);
            let message = isCode ? `${severity} #${code}: www.highcharts.com/errors/${code}/` : code.toString();
            const defaultHandler = function() {
                if (stop) {
                    throw new Error(message)
                }
                if (win.console && error.messages.indexOf(message) === -1) {
                    console.warn(message)
                }
            };
            if (typeof params !== 'undefined') {
                let additionalMessages = '';
                if (isCode) {
                    message += '?'
                }
                objectEach(params, function(value, key) {
                    additionalMessages += `\n - ${key}: ${value}`;
                    if (isCode) {
                        message += encodeURI(key) + '=' + encodeURI(value)
                    }
                });
                message += additionalMessages
            }
            fireEvent(H, 'displayError', {
                chart,
                code,
                message,
                params
            }, defaultHandler);
            error.messages.push(message)
        }
        (function(error) {
                error.messages = []
            }
        )(error || (error = {}));
        function merge() {
            let i, args = arguments, ret = {};
            const doCopy = function(copy, original) {
                if (typeof copy !== 'object') {
                    copy = {}
                }
                objectEach(original, function(value, key) {
                    if (key === '__proto__' || key === 'constructor') {
                        return
                    }
                    if (isObject(value, !0) && !isClass(value) && !isDOMElement(value)) {
                        copy[key] = doCopy(copy[key] || {}, value)
                    } else {
                        copy[key] = original[key]
                    }
                });
                return copy
            };
            if (args[0] === !0) {
                ret = args[1];
                args = Array.prototype.slice.call(args, 2)
            }
            const len = args.length;
            for (i = 0; i < len; i++) {
                ret = doCopy(ret, args[i])
            }
            return ret
        }
        function clamp(value, min, max) {
            return value > min ? value < max ? value : max : min
        }
        function diffObjects(newer, older, keepOlder, collectionsWithUpdate) {
            const ret = {};
            function diff(newer, older, ret, depth) {
                const keeper = keepOlder ? older : newer;
                objectEach(newer, function(newerVal, key) {
                    if (!depth && collectionsWithUpdate && collectionsWithUpdate.indexOf(key) > -1 && older[key]) {
                        newerVal = splat(newerVal);
                        ret[key] = [];
                        for (let i = 0; i < Math.max(newerVal.length, older[key].length); i++) {
                            if (older[key][i]) {
                                if (newerVal[i] === void 0) {
                                    ret[key][i] = older[key][i]
                                } else {
                                    ret[key][i] = {};
                                    diff(newerVal[i], older[key][i], ret[key][i], depth + 1)
                                }
                            }
                        }
                    } else if (isObject(newerVal, !0) && !newerVal.nodeType) {
                        ret[key] = isArray(newerVal) ? [] : {};
                        diff(newerVal, older[key] || {}, ret[key], depth + 1);
                        if (Object.keys(ret[key]).length === 0 && !(key === 'colorAxis' && depth === 0)) {
                            delete ret[key]
                        }
                    } else if (newer[key] !== older[key] || (key in newer && !(key in older))) {
                        ret[key] = keeper[key]
                    }
                })
            }
            diff(newer, older, ret, 0);
            return ret
        }
        function pInt(s, mag) {
            return parseInt(s, mag || 10)
        }
        function isString(s) {
            return typeof s === 'string'
        }
        function isArray(obj) {
            const str = Object.prototype.toString.call(obj);
            return str === '[object Array]' || str === '[object Array Iterator]'
        }
        function isObject(obj, strict) {
            return (!!obj && typeof obj === 'object' && (!strict || !isArray(obj)))
        }
        function isDOMElement(obj) {
            return isObject(obj) && typeof obj.nodeType === 'number'
        }
        function isClass(obj) {
            const c = obj && obj.constructor;
            return !!(isObject(obj, !0) && !isDOMElement(obj) && (c && c.name && c.name !== 'Object'))
        }
        function isNumber(n) {
            return typeof n === 'number' && !isNaN(n) && n < Infinity && n > -Infinity
        }
        function erase(arr, item) {
            let i = arr.length;
            while (i--) {
                if (arr[i] === item) {
                    arr.splice(i, 1);
                    break
                }
            }
        }
        function insertItem(item, collection) {
            const indexOption = item.options.index
                , length = collection.length;
            let i;
            for (i = item.options.isInternal ? length : 0; i < length + 1; i++) {
                if (!collection[i] || (isNumber(indexOption) && indexOption < pick(collection[i].options.index, collection[i]._i)) || collection[i].options.isInternal) {
                    collection.splice(i, 0, item);
                    break
                }
            }
            return i
        }
        function pushUnique(array, item) {
            return array.indexOf(item) < 0 && !!array.push(item)
        }
        function defined(obj) {
            return typeof obj !== 'undefined' && obj !== null
        }
        function attr(elem, keyOrAttribs, value) {
            const isGetter = isString(keyOrAttribs) && !defined(value);
            let ret;
            const attrSingle = (value, key) => {
                    if (defined(value)) {
                        elem.setAttribute(key, value)
                    } else if (isGetter) {
                        ret = elem.getAttribute(key);
                        if (!ret && key === 'class') {
                            ret = elem.getAttribute(key + 'Name')
                        }
                    } else {
                        elem.removeAttribute(key)
                    }
                }
            ;
            if (isString(keyOrAttribs)) {
                attrSingle(value, keyOrAttribs)
            } else {
                objectEach(keyOrAttribs, attrSingle)
            }
            return ret
        }
        function splat(obj) {
            return isArray(obj) ? obj : [obj]
        }
        function syncTimeout(fn, delay, context) {
            if (delay > 0) {
                return setTimeout(fn, delay, context)
            }
            fn.call(0, context);
            return -1
        }
        function internalClearTimeout(id) {
            if (defined(id)) {
                clearTimeout(id)
            }
        }
        function extend(a, b) {
            let n;
            if (!a) {
                a = {}
            }
            for (n in b) {
                a[n] = b[n]
            }
            return a
        }
        function pick() {
            const args = arguments;
            const length = args.length;
            for (let i = 0; i < length; i++) {
                const arg = args[i];
                if (typeof arg !== 'undefined' && arg !== null) {
                    return arg
                }
            }
        }
        function css(el, styles) {
            if (H.isMS && !H.svg) {
                if (styles && defined(styles.opacity)) {
                    styles.filter = `alpha(opacity=${styles.opacity * 100})`
                }
            }
            extend(el.style, styles)
        }
        function createElement(tag, attribs, styles, parent, nopad) {
            const el = doc.createElement(tag);
            if (attribs) {
                extend(el, attribs)
            }
            if (nopad) {
                css(el, {
                    padding: '0',
                    border: 'none',
                    margin: '0'
                })
            }
            if (styles) {
                css(el, styles)
            }
            if (parent) {
                parent.appendChild(el)
            }
            return el
        }
        function extendClass(parent, members) {
            const obj = (function() {}
            );
            obj.prototype = new parent();
            extend(obj.prototype, members);
            return obj
        }
        function pad(number, length, padder) {
            return new Array((length || 2) + 1 - String(number).replace('-', '').length).join(padder || '0') + number
        }
        function relativeLength(value, base, offset) {
            return (/%$/).test(value) ? (base * parseFloat(value) / 100) + (offset || 0) : parseFloat(value)
        }
        function wrap(obj, method, func) {
            const proceed = obj[method];
            obj[method] = function() {
                const outerArgs = arguments
                    , scope = this;
                return func.apply(this, [function() {
                    return proceed.apply(scope, arguments.length ? arguments : outerArgs)
                }
                ].concat([].slice.call(arguments)))
            }
        }
        function getMagnitude(num) {
            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10))
        }
        function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, hasTickAmount) {
            let i, retInterval = interval;
            magnitude = pick(magnitude, getMagnitude(interval));
            const normalized = interval / magnitude;
            if (!multiples) {
                multiples = hasTickAmount ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10];
                if (allowDecimals === !1) {
                    if (magnitude === 1) {
                        multiples = multiples.filter(function(num) {
                            return num % 1 === 0
                        })
                    } else if (magnitude <= 0.1) {
                        multiples = [1 / magnitude]
                    }
                }
            }
            for (i = 0; i < multiples.length; i++) {
                retInterval = multiples[i];
                if ((hasTickAmount && retInterval * magnitude >= interval) || (!hasTickAmount && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
                    break
                }
            }
            retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10));
            return retInterval
        }
        function stableSort(arr, sortFunction) {
            const length = arr.length;
            let sortValue, i;
            for (i = 0; i < length; i++) {
                arr[i].safeI = i
            }
            arr.sort(function(a, b) {
                sortValue = sortFunction(a, b);
                return sortValue === 0 ? a.safeI - b.safeI : sortValue
            });
            for (i = 0; i < length; i++) {
                delete arr[i].safeI
            }
        }
        function arrayMin(data) {
            let i = data.length
                , min = data[0];
            while (i--) {
                if (data[i] < min) {
                    min = data[i]
                }
            }
            return min
        }
        function arrayMax(data) {
            let i = data.length
                , max = data[0];
            while (i--) {
                if (data[i] > max) {
                    max = data[i]
                }
            }
            return max
        }
        function destroyObjectProperties(obj, except) {
            objectEach(obj, function(val, n) {
                if (val && val !== except && val.destroy) {
                    val.destroy()
                }
                delete obj[n]
            })
        }
        function discardElement(element) {
            if (element && element.parentElement) {
                element.parentElement.removeChild(element)
            }
        }
        function correctFloat(num, prec) {
            return num > 1e14 ? num : parseFloat(num.toPrecision(prec || 14))
        }
        const timeUnits = {
            millisecond: 1,
            second: 1000,
            minute: 60000,
            hour: 3600000,
            day: 24 * 3600000,
            week: 7 * 24 * 3600000,
            month: 28 * 24 * 3600000,
            year: 364 * 24 * 3600000
        };
        Math.easeInOutSine = function(pos) {
            return -0.5 * (Math.cos(Math.PI * pos) - 1)
        }
        ;
        function getClosestDistance(arrays, onError) {
            const allowNegative = !onError;
            let closest, loopLength, distance, i;
            arrays.forEach( (xData) => {
                    if (xData.length > 1) {
                        loopLength = xData.length - 1;
                        for (i = loopLength; i > 0; i--) {
                            distance = xData[i] - xData[i - 1];
                            if (distance < 0 && !allowNegative) {
                                onError?.();
                                onError = void 0
                            } else if (distance && (typeof closest === 'undefined' || distance < closest)) {
                                closest = distance
                            }
                        }
                    }
                }
            );
            return closest
        }
        function getNestedProperty(path, parent) {
            const pathElements = path.split('.');
            while (pathElements.length && defined(parent)) {
                const pathElement = pathElements.shift();
                if (typeof pathElement === 'undefined' || pathElement === '__proto__') {
                    return
                }
                if (pathElement === 'this') {
                    let thisProp;
                    if (isObject(parent)) {
                        thisProp = parent['@this']
                    }
                    return thisProp ?? parent
                }
                const child = parent[pathElement];
                if (!defined(child) || typeof child === 'function' || typeof child.nodeType === 'number' || child === win) {
                    return
                }
                parent = child
            }
            return parent
        }
        function getStyle(el, prop, toInt) {
            let style;
            if (prop === 'width') {
                let offsetWidth = Math.min(el.offsetWidth, el.scrollWidth);
                const boundingClientRectWidth = el.getBoundingClientRect && el.getBoundingClientRect().width;
                if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
                    offsetWidth = Math.floor(boundingClientRectWidth)
                }
                return Math.max(0, (offsetWidth - (getStyle(el, 'padding-left', !0) || 0) - (getStyle(el, 'padding-right', !0) || 0)))
            }
            if (prop === 'height') {
                return Math.max(0, (Math.min(el.offsetHeight, el.scrollHeight) - (getStyle(el, 'padding-top', !0) || 0) - (getStyle(el, 'padding-bottom', !0) || 0)))
            }
            const css = win.getComputedStyle(el, void 0);
            if (css) {
                style = css.getPropertyValue(prop);
                if (pick(toInt, prop !== 'opacity')) {
                    style = pInt(style)
                }
            }
            return style
        }
        function inArray(item, arr, fromIndex) {
            error(32, !1, void 0, {
                'Highcharts.inArray': 'use Array.indexOf'
            });
            return arr.indexOf(item, fromIndex)
        }
        const find = Array.prototype.find ? function(arr, callback) {
                    return arr.find(callback)
                }
                : function(arr, callback) {
                    let i;
                    const length = arr.length;
                    for (i = 0; i < length; i++) {
                        if (callback(arr[i], i)) {
                            return arr[i]
                        }
                    }
                }
        ;
        function keys(obj) {
            error(32, !1, void 0, {
                'Highcharts.keys': 'use Object.keys'
            });
            return Object.keys(obj)
        }
        function offset(el) {
            const docElem = doc.documentElement
                , box = (el.parentElement || el.parentNode) ? el.getBoundingClientRect() : {
                top: 0,
                left: 0,
                width: 0,
                height: 0
            };
            return {
                top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
                width: box.width,
                height: box.height
            }
        }
        function objectEach(obj, fn, ctx) {
            for (const key in obj) {
                if (Object.hasOwnProperty.call(obj, key)) {
                    fn.call(ctx || obj[key], obj[key], key, obj)
                }
            }
        }
        objectEach({
            map: 'map',
            each: 'forEach',
            grep: 'filter',
            reduce: 'reduce',
            some: 'some'
        }, function(val, key) {
            H[key] = function(arr) {
                error(32, !1, void 0, {
                    [`Highcharts.${key}`]: `use Array.${val}`
                });
                return Array.prototype[val].apply(arr, [].slice.call(arguments, 1))
            }
        });
        function addEvent(el, type, fn, options={}) {
            const owner = typeof el === 'function' && el.prototype || el;
            if (!Object.hasOwnProperty.call(owner, 'hcEvents')) {
                owner.hcEvents = {}
            }
            const events = owner.hcEvents;
            if (H.Point && el instanceof H.Point && el.series && el.series.chart) {
                el.series.chart.runTrackerClick = !0
            }
            const addEventListener = el.addEventListener;
            if (addEventListener) {
                addEventListener.call(el, type, fn, H.supportsPassiveEvents ? {
                    passive: options.passive === void 0 ? type.indexOf('touch') !== -1 : options.passive,
                    capture: !1
                } : !1)
            }
            if (!events[type]) {
                events[type] = []
            }
            const eventObject = {
                fn,
                order: typeof options.order === 'number' ? options.order : Infinity
            };
            events[type].push(eventObject);
            events[type].sort( (a, b) => a.order - b.order);
            return function() {
                removeEvent(el, type, fn)
            }
        }
        function removeEvent(el, type, fn) {
            function removeOneEvent(type, fn) {
                const removeEventListener = el.removeEventListener;
                if (removeEventListener) {
                    removeEventListener.call(el, type, fn, !1)
                }
            }
            function removeAllEvents(eventCollection) {
                let types, len;
                if (!el.nodeName) {
                    return
                }
                if (type) {
                    types = {};
                    types[type] = !0
                } else {
                    types = eventCollection
                }
                objectEach(types, function(_val, n) {
                    if (eventCollection[n]) {
                        len = eventCollection[n].length;
                        while (len--) {
                            removeOneEvent(n, eventCollection[n][len].fn)
                        }
                    }
                })
            }
            const owner = typeof el === 'function' && el.prototype || el;
            if (Object.hasOwnProperty.call(owner, 'hcEvents')) {
                const events = owner.hcEvents;
                if (type) {
                    const typeEvents = (events[type] || []);
                    if (fn) {
                        events[type] = typeEvents.filter(function(obj) {
                            return fn !== obj.fn
                        });
                        removeOneEvent(type, fn)
                    } else {
                        removeAllEvents(events);
                        events[type] = []
                    }
                } else {
                    removeAllEvents(events);
                    delete owner.hcEvents
                }
            }
        }
        function fireEvent(el, type, eventArguments, defaultFunction) {
            let e, i;
            eventArguments = eventArguments || {};
            if (doc.createEvent && (el.dispatchEvent || (el.fireEvent && el !== H))) {
                e = doc.createEvent('Events');
                e.initEvent(type, !0, !0);
                eventArguments = extend(e, eventArguments);
                if (el.dispatchEvent) {
                    el.dispatchEvent(eventArguments)
                } else {
                    el.fireEvent(type, eventArguments)
                }
            } else if (el.hcEvents) {
                if (!eventArguments.target) {
                    extend(eventArguments, {
                        preventDefault: function() {
                            eventArguments.defaultPrevented = !0
                        },
                        target: el,
                        type: type
                    })
                }
                const events = [];
                let object = el;
                let multilevel = !1;
                while (object.hcEvents) {
                    if (Object.hasOwnProperty.call(object, 'hcEvents') && object.hcEvents[type]) {
                        if (events.length) {
                            multilevel = !0
                        }
                        events.unshift.apply(events, object.hcEvents[type])
                    }
                    object = Object.getPrototypeOf(object)
                }
                if (multilevel) {
                    events.sort( (a, b) => a.order - b.order)
                }
                events.forEach( (obj) => {
                        if (obj.fn.call(el, eventArguments) === !1) {
                            eventArguments.preventDefault()
                        }
                    }
                )
            }
            if (defaultFunction && !eventArguments.defaultPrevented) {
                defaultFunction.call(el, eventArguments)
            }
        }
        let serialMode;
        const uniqueKey = (function() {
            const hash = Math.random().toString(36).substring(2, 9) + '-';
            let id = 0;
            return function() {
                return 'highcharts-' + (serialMode ? '' : hash) + id++
            }
        }());
        function useSerialIds(mode) {
            return (serialMode = pick(mode, serialMode))
        }
        function isFunction(obj) {
            return typeof obj === 'function'
        }
        if (win.jQuery) {
            win.jQuery.fn.highcharts = function() {
                const args = [].slice.call(arguments);
                if (this[0]) {
                    if (args[0]) {
                        new H[isString(args[0]) ? args.shift() : 'Chart'](this[0],args[0],args[1]);
                        return this
                    }
                    return charts[attr(this[0], 'data-highcharts-chart')]
                }
            }
        }
        const Utilities = {
            addEvent,
            arrayMax,
            arrayMin,
            attr,
            clamp,
            clearTimeout: internalClearTimeout,
            correctFloat,
            createElement,
            css,
            defined,
            destroyObjectProperties,
            diffObjects,
            discardElement,
            erase,
            error,
            extend,
            extendClass,
            find,
            fireEvent,
            getClosestDistance,
            getMagnitude,
            getNestedProperty,
            getStyle,
            inArray,
            insertItem,
            isArray,
            isClass,
            isDOMElement,
            isFunction,
            isNumber,
            isObject,
            isString,
            keys,
            merge,
            normalizeTickInterval,
            objectEach,
            offset,
            pad,
            pick,
            pInt,
            pushUnique,
            relativeLength,
            removeEvent,
            splat,
            stableSort,
            syncTimeout,
            timeUnits,
            uniqueKey,
            useSerialIds,
            wrap
        };
        '';
        return Utilities
    });
    _registerModule(_modules, 'Core/Chart/ChartDefaults.js', [], function() {
        const ChartDefaults = {
            alignThresholds: !1,
            panning: {
                enabled: !1,
                type: 'x'
            },
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            allowMutatingData: !0,
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
                theme: {},
                position: {}
            },
            reflow: !0,
            type: 'line',
            zooming: {
                singleTouch: !1,
                resetButton: {
                    theme: {
                        zIndex: 6
                    },
                    position: {
                        align: 'right',
                        x: -10,
                        y: 10
                    }
                }
            },
            width: null,
            height: null,
            borderColor: "#334eff",
            backgroundColor: "#ffffff",
            plotBorderColor: "#cccccc"
        };
        return ChartDefaults
    });
    _registerModule(_modules, 'Core/Color/Palettes.js', [], function() {
        const SeriesPalettes = {
            colors: ['#2caffe', '#544fc5', '#00e272', '#fe6a35', '#6b8abc', '#d568fb', '#2ee0ca', '#fa4b42', '#feb56a', '#91e8e1']
        };
        return SeriesPalettes
    });
    _registerModule(_modules, 'Core/Time.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {win} = H;
        const {defined, error, extend, isObject, merge, objectEach, pad, pick, splat, timeUnits} = U;
        const hasNewSafariBug = H.isSafari && win.Intl && win.Intl.DateTimeFormat.prototype.formatRange;
        const hasOldSafariBug = H.isSafari && win.Intl && !win.Intl.DateTimeFormat.prototype.formatRange;
        class Time {
            constructor(options) {
                this.options = {};
                this.useUTC = !1;
                this.variableTimezone = !1;
                this.Date = win.Date;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                this.update(options)
            }
            get(unit, date) {
                if (this.variableTimezone || this.timezoneOffset) {
                    const realMs = date.getTime();
                    const ms = realMs - this.getTimezoneOffset(date);
                    date.setTime(ms);
                    const ret = date['getUTC' + unit]();
                    date.setTime(realMs);
                    return ret
                }
                if (this.useUTC) {
                    return date['getUTC' + unit]()
                }
                return date['get' + unit]()
            }
            set(unit, date, value) {
                if (this.variableTimezone || this.timezoneOffset) {
                    if (unit === 'Milliseconds' || unit === 'Seconds' || (unit === 'Minutes' && this.getTimezoneOffset(date) % 3600000 === 0)) {
                        return date['setUTC' + unit](value)
                    }
                    const offset = this.getTimezoneOffset(date);
                    let ms = date.getTime() - offset;
                    date.setTime(ms);
                    date['setUTC' + unit](value);
                    const newOffset = this.getTimezoneOffset(date);
                    ms = date.getTime() + newOffset;
                    return date.setTime(ms)
                }
                if (this.useUTC || (hasNewSafariBug && unit === 'FullYear')) {
                    return date['setUTC' + unit](value)
                }
                return date['set' + unit](value)
            }
            update(options={}) {
                const useUTC = pick(options.useUTC, !0);
                this.options = options = merge(!0, this.options, options);
                this.Date = options.Date || win.Date || Date;
                this.useUTC = useUTC;
                this.timezoneOffset = (useUTC && options.timezoneOffset) || void 0;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone)
            }
            makeTime(year, month, date, hours, minutes, seconds) {
                let d, offset, newOffset;
                if (this.useUTC) {
                    d = this.Date.UTC.apply(0, arguments);
                    offset = this.getTimezoneOffset(d);
                    d += offset;
                    newOffset = this.getTimezoneOffset(d);
                    if (offset !== newOffset) {
                        d += newOffset - offset
                    } else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
                        d -= 36e5
                    }
                } else {
                    d = new this.Date(year,month,pick(date, 1),pick(hours, 0),pick(minutes, 0),pick(seconds, 0)).getTime()
                }
                return d
            }
            timezoneOffsetFunction() {
                const time = this
                    , options = this.options
                    , getTimezoneOffset = options.getTimezoneOffset
                    , moment = options.moment || win.moment;
                if (!this.useUTC) {
                    return function(timestamp) {
                        return new Date(timestamp.toString()).getTimezoneOffset() * 60000
                    }
                }
                if (options.timezone) {
                    if (!moment) {
                        error(25)
                    } else {
                        return function(timestamp) {
                            return -moment.tz(timestamp, options.timezone).utcOffset() * 60000
                        }
                    }
                }
                if (this.useUTC && getTimezoneOffset) {
                    return function(timestamp) {
                        return getTimezoneOffset(timestamp.valueOf()) * 60000
                    }
                }
                return function() {
                    return (time.timezoneOffset || 0) * 60000
                }
            }
            dateFormat(format, timestamp, capitalize) {
                if (!defined(timestamp) || isNaN(timestamp)) {
                    return (H.defaultOptions.lang && H.defaultOptions.lang.invalidDate || '')
                }
                format = pick(format, '%Y-%m-%d %H:%M:%S');
                const time = this
                    , date = new this.Date(timestamp)
                    , hours = this.get('Hours', date)
                    , day = this.get('Day', date)
                    , dayOfMonth = this.get('Date', date)
                    , month = this.get('Month', date)
                    , fullYear = this.get('FullYear', date)
                    , lang = H.defaultOptions.lang
                    , langWeekdays = (lang && lang.weekdays)
                    , shortWeekdays = (lang && lang.shortWeekdays)
                    , replacements = extend({
                    a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
                    A: langWeekdays[day],
                    d: pad(dayOfMonth),
                    e: pad(dayOfMonth, 2, ' '),
                    w: day,
                    b: lang.shortMonths[month],
                    B: lang.months[month],
                    m: pad(month + 1),
                    o: month + 1,
                    y: fullYear.toString().substr(2, 2),
                    Y: fullYear,
                    H: pad(hours),
                    k: hours,
                    I: pad((hours % 12) || 12),
                    l: (hours % 12) || 12,
                    M: pad(this.get('Minutes', date)),
                    p: hours < 12 ? 'AM' : 'PM',
                    P: hours < 12 ? 'am' : 'pm',
                    S: pad(this.get('Seconds', date)),
                    L: pad(Math.floor(timestamp % 1000), 3)
                }, H.dateFormats);
                objectEach(replacements, function(val, key) {
                    while (format.indexOf('%' + key) !== -1) {
                        format = format.replace('%' + key, typeof val === 'function' ? val.call(time, timestamp) : val)
                    }
                });
                return capitalize ? (format.substr(0, 1).toUpperCase() + format.substr(1)) : format
            }
            resolveDTLFormat(f) {
                if (!isObject(f, !0)) {
                    f = splat(f);
                    return {
                        main: f[0],
                        from: f[1],
                        to: f[2]
                    }
                }
                return f
            }
            getTimeTicks(normalizedInterval, min, max, startOfWeek) {
                const time = this
                    , Date = time.Date
                    , tickPositions = []
                    , higherRanks = {}
                    , minDate = new Date(min)
                    , interval = normalizedInterval.unitRange
                    , count = normalizedInterval.count || 1;
                let i, minYear, variableDayLength, minDay;
                startOfWeek = pick(startOfWeek, 1);
                if (defined(min)) {
                    time.set('Milliseconds', minDate, interval >= timeUnits.second ? 0 : count * Math.floor(time.get('Milliseconds', minDate) / count));
                    if (interval >= timeUnits.second) {
                        time.set('Seconds', minDate, interval >= timeUnits.minute ? 0 : count * Math.floor(time.get('Seconds', minDate) / count))
                    }
                    if (interval >= timeUnits.minute) {
                        time.set('Minutes', minDate, interval >= timeUnits.hour ? 0 : count * Math.floor(time.get('Minutes', minDate) / count))
                    }
                    if (interval >= timeUnits.hour) {
                        time.set('Hours', minDate, interval >= timeUnits.day ? 0 : count * Math.floor(time.get('Hours', minDate) / count))
                    }
                    if (interval >= timeUnits.day) {
                        time.set('Date', minDate, interval >= timeUnits.month ? 1 : Math.max(1, count * Math.floor(time.get('Date', minDate) / count)))
                    }
                    if (interval >= timeUnits.month) {
                        time.set('Month', minDate, interval >= timeUnits.year ? 0 : count * Math.floor(time.get('Month', minDate) / count));
                        minYear = time.get('FullYear', minDate)
                    }
                    if (interval >= timeUnits.year) {
                        minYear -= minYear % count;
                        time.set('FullYear', minDate, minYear)
                    }
                    if (interval === timeUnits.week) {
                        minDay = time.get('Day', minDate);
                        time.set('Date', minDate, (time.get('Date', minDate) - minDay + startOfWeek + (minDay < startOfWeek ? -7 : 0)))
                    }
                    minYear = time.get('FullYear', minDate);
                    const minMonth = time.get('Month', minDate)
                        , minDateDate = time.get('Date', minDate)
                        , minHours = time.get('Hours', minDate);
                    min = minDate.getTime();
                    if ((time.variableTimezone || !time.useUTC) && defined(max)) {
                        variableDayLength = (max - min > 4 * timeUnits.month || time.getTimezoneOffset(min) !== time.getTimezoneOffset(max))
                    }
                    let t = minDate.getTime();
                    i = 1;
                    while (t < max) {
                        tickPositions.push(t);
                        if (interval === timeUnits.year) {
                            t = time.makeTime(minYear + i * count, 0)
                        } else if (interval === timeUnits.month) {
                            t = time.makeTime(minYear, minMonth + i * count)
                        } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {
                            t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval === timeUnits.day ? 1 : 7))
                        } else if (variableDayLength && interval === timeUnits.hour && count > 1) {
                            t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count)
                        } else {
                            t += interval * count
                        }
                        i++
                    }
                    tickPositions.push(t);
                    if (interval <= timeUnits.hour && tickPositions.length < 10000) {
                        tickPositions.forEach(function(t) {
                            if (t % 1800000 === 0 && time.dateFormat('%H%M%S%L', t) === '000000000') {
                                higherRanks[t] = 'day'
                            }
                        })
                    }
                }
                tickPositions.info = extend(normalizedInterval, {
                    higherRanks,
                    totalRange: interval * count
                });
                return tickPositions
            }
            getDateFormat(range, timestamp, startOfWeek, dateTimeLabelFormats) {
                const dateStr = this.dateFormat('%m-%d %H:%M:%S.%L', timestamp)
                    , blank = '01-01 00:00:00.000'
                    , strpos = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                };
                let n = 'millisecond'
                    , lastN = n;
                for (n in timeUnits) {
                    if (range === timeUnits.week && +this.dateFormat('%w', timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
                        n = 'week';
                        break
                    }
                    if (timeUnits[n] > range) {
                        n = lastN;
                        break
                    }
                    if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
                        break
                    }
                    if (n !== 'week') {
                        lastN = n
                    }
                }
                return this.resolveDTLFormat(dateTimeLabelFormats[n]).main
            }
        }
        '';
        return Time
    });
    _registerModule(_modules, 'Core/Defaults.js', [_modules['Core/Chart/ChartDefaults.js'], _modules['Core/Globals.js'], _modules['Core/Color/Palettes.js'], _modules['Core/Time.js'], _modules['Core/Utilities.js']], function(ChartDefaults, H, Palettes, Time, U) {
        const {isTouchDevice, svg} = H;
        const {merge} = U;
        const defaultOptions = {
            colors: Palettes.colors,
            symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
            lang: {
                loading: 'Loading...',
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                decimalPoint: '.',
                numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'],
                resetZoom: 'Reset zoom',
                resetZoomTitle: 'Reset zoom level 1:1',
                thousandsSep: ' '
            },
            global: {},
            time: {
                Date: void 0,
                getTimezoneOffset: void 0,
                timezone: void 0,
                timezoneOffset: 0,
                useUTC: !0
            },
            chart: ChartDefaults,
            title: {
                style: {
                    color: "#333333",
                    fontWeight: 'bold'
                },
                text: 'Chart title',
                align: 'center',
                margin: 15,
                widthAdjust: -44
            },
            subtitle: {
                style: {
                    color: "#666666",
                    fontSize: '0.8em'
                },
                text: '',
                align: 'center',
                widthAdjust: -44
            },
            caption: {
                margin: 15,
                style: {
                    color: "#666666",
                    fontSize: '0.8em'
                },
                text: '',
                align: 'left',
                verticalAlign: 'bottom'
            },
            plotOptions: {},
            legend: {
                enabled: !0,
                align: 'center',
                alignColumns: !0,
                className: 'highcharts-no-tooltip',
                layout: 'horizontal',
                itemMarginBottom: 2,
                itemMarginTop: 2,
                labelFormatter: function() {
                    return this.name
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                    style: {
                        fontSize: '0.8em'
                    },
                    activeColor: "#0022ff",
                    inactiveColor: "#cccccc"
                },
                itemStyle: {
                    color: "#333333",
                    cursor: 'pointer',
                    fontSize: '0.8em',
                    textDecoration: 'none',
                    textOverflow: 'ellipsis'
                },
                itemHoverStyle: {
                    color: "#000000"
                },
                itemHiddenStyle: {
                    color: "#666666",
                    textDecoration: 'line-through'
                },
                shadow: !1,
                itemCheckboxStyle: {
                    position: 'absolute',
                    width: '13px',
                    height: '13px'
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: 'bottom',
                x: 0,
                y: 0,
                title: {
                    style: {
                        fontSize: '0.8em',
                        fontWeight: 'bold'
                    }
                }
            },
            loading: {
                labelStyle: {
                    fontWeight: 'bold',
                    position: 'relative',
                    top: '45%'
                },
                style: {
                    position: 'absolute',
                    backgroundColor: "#ffffff",
                    opacity: 0.5,
                    textAlign: 'center'
                }
            },
            tooltip: {
                enabled: !0,
                animation: svg,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: '%A, %e %b, %H:%M:%S.%L',
                    second: '%A, %e %b, %H:%M:%S',
                    minute: '%A, %e %b, %H:%M',
                    hour: '%A, %e %b, %H:%M',
                    day: '%A, %e %b %Y',
                    week: 'Week from %A, %e %b %Y',
                    month: '%B %Y',
                    year: '%Y'
                },
                footerFormat: '',
                headerShape: 'callout',
                hideDelay: 500,
                padding: 8,
                shape: 'callout',
                shared: !1,
                snap: isTouchDevice ? 25 : 10,
                headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: "#ffffff",
                borderWidth: void 0,
                shadow: !0,
                stickOnContact: !1,
                style: {
                    color: "#333333",
                    cursor: 'default',
                    fontSize: '0.8em'
                },
                useHTML: !1
            },
            credits: {
                enabled: !0,
                href: 'https://www.highcharts.com?credits',
                position: {
                    align: 'right',
                    x: -10,
                    verticalAlign: 'bottom',
                    y: -5
                },
                style: {
                    cursor: 'pointer',
                    color: "#999999",
                    fontSize: '0.6em'
                },
                text: 'Highcharts.com'
            }
        };
        defaultOptions.chart.styledMode = !1;
        '';
        const defaultTime = new Time(defaultOptions.time);
        function getOptions() {
            return defaultOptions
        }
        function setOptions(options) {
            merge(!0, defaultOptions, options);
            if (options.time || options.global) {
                if (H.time) {
                    H.time.update(merge(defaultOptions.global, defaultOptions.time, options.global, options.time))
                } else {
                    H.time = defaultTime
                }
            }
            return defaultOptions
        }
        const DefaultOptions = {
            defaultOptions,
            defaultTime,
            getOptions,
            setOptions
        };
        ('');
        return DefaultOptions
    });
    _registerModule(_modules, 'Core/Color/Color.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {isNumber, merge, pInt} = U;
        class Color {
            static parse(input) {
                return input ? new Color(input) : Color.None
            }
            constructor(input) {
                this.rgba = [NaN, NaN, NaN, NaN];
                this.input = input;
                const GlobalColor = H.Color;
                if (GlobalColor && GlobalColor !== Color) {
                    return new GlobalColor(input)
                }
                this.init(input)
            }
            init(input) {
                let result, rgba, i, parser;
                if (typeof input === 'object' && typeof input.stops !== 'undefined') {
                    this.stops = input.stops.map( (stop) => new Color(stop[1]))
                } else if (typeof input === 'string') {
                    this.input = input = (Color.names[input.toLowerCase()] || input);
                    if (input.charAt(0) === '#') {
                        const len = input.length
                            , col = parseInt(input.substr(1), 16);
                        if (len === 7) {
                            rgba = [(col & 0xFF0000) >> 16, (col & 0xFF00) >> 8, (col & 0xFF), 1]
                        } else if (len === 4) {
                            rgba = [(((col & 0xF00) >> 4) | (col & 0xF00) >> 8), (((col & 0xF0) >> 4) | (col & 0xF0)), ((col & 0xF) << 4) | (col & 0xF), 1]
                        }
                    }
                    if (!rgba) {
                        i = Color.parsers.length;
                        while (i-- && !rgba) {
                            parser = Color.parsers[i];
                            result = parser.regex.exec(input);
                            if (result) {
                                rgba = parser.parse(result)
                            }
                        }
                    }
                }
                if (rgba) {
                    this.rgba = rgba
                }
            }
            get(format) {
                const input = this.input
                    , rgba = this.rgba;
                if (typeof input === 'object' && typeof this.stops !== 'undefined') {
                    const ret = merge(input);
                    ret.stops = [].slice.call(ret.stops);
                    this.stops.forEach( (stop, i) => {
                            ret.stops[i] = [ret.stops[i][0], stop.get(format)]
                        }
                    );
                    return ret
                }
                if (rgba && isNumber(rgba[0])) {
                    if (format === 'rgb' || (!format && rgba[3] === 1)) {
                        return 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')'
                    }
                    if (format === 'a') {
                        return `${rgba[3]}`
                    }
                    return 'rgba(' + rgba.join(',') + ')'
                }
                return input
            }
            brighten(alpha) {
                const rgba = this.rgba;
                if (this.stops) {
                    this.stops.forEach(function(stop) {
                        stop.brighten(alpha)
                    })
                } else if (isNumber(alpha) && alpha !== 0) {
                    for (let i = 0; i < 3; i++) {
                        rgba[i] += pInt(alpha * 255);
                        if (rgba[i] < 0) {
                            rgba[i] = 0
                        }
                        if (rgba[i] > 255) {
                            rgba[i] = 255
                        }
                    }
                }
                return this
            }
            setOpacity(alpha) {
                this.rgba[3] = alpha;
                return this
            }
            tweenTo(to, pos) {
                const fromRgba = this.rgba
                    , toRgba = to.rgba;
                if (!isNumber(fromRgba[0]) || !isNumber(toRgba[0])) {
                    return to.input || 'none'
                }
                const hasAlpha = (toRgba[3] !== 1 || fromRgba[3] !== 1);
                return (hasAlpha ? 'rgba(' : 'rgb(') + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + ',' + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + ',' + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? (',' + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos))) : '') + ')'
            }
        }
        Color.names = {
            white: '#ffffff',
            black: '#000000'
        };
        Color.parsers = [{
            regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
            parse: function(result) {
                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)]
            }
        }, {
            regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
            parse: function(result) {
                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1]
            }
        }];
        Color.None = new Color('');
        ('');
        return Color
    });
    _registerModule(_modules, 'Core/Animation/Fx.js', [_modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(Color, H, U) {
        const {parse: color} = Color;
        const {win} = H;
        const {isNumber, objectEach} = U;
        class Fx {
            constructor(elem, options, prop) {
                this.pos = NaN;
                this.options = options;
                this.elem = elem;
                this.prop = prop
            }
            dSetter() {
                const paths = this.paths
                    , start = paths && paths[0]
                    , end = paths && paths[1]
                    , now = this.now || 0;
                let path = [];
                if (now === 1 || !start || !end) {
                    path = this.toD || []
                } else if (start.length === end.length && now < 1) {
                    for (let i = 0; i < end.length; i++) {
                        const startSeg = start[i];
                        const endSeg = end[i];
                        const tweenSeg = [];
                        for (let j = 0; j < endSeg.length; j++) {
                            const startItem = startSeg[j];
                            const endItem = endSeg[j];
                            if (isNumber(startItem) && isNumber(endItem) && !(endSeg[0] === 'A' && (j === 4 || j === 5))) {
                                tweenSeg[j] = startItem + now * (endItem - startItem)
                            } else {
                                tweenSeg[j] = endItem
                            }
                        }
                        path.push(tweenSeg)
                    }
                } else {
                    path = end
                }
                this.elem.attr('d', path, void 0, !0)
            }
            update() {
                const elem = this.elem
                    , prop = this.prop
                    , now = this.now
                    , step = this.options.step;
                if (this[prop + 'Setter']) {
                    this[prop + 'Setter']()
                } else if (elem.attr) {
                    if (elem.element) {
                        elem.attr(prop, now, null, !0)
                    }
                } else {
                    elem.style[prop] = now + this.unit
                }
                if (step) {
                    step.call(elem, now, this)
                }
            }
            run(from, to, unit) {
                const self = this
                    , options = self.options
                    , timer = function(gotoEnd) {
                    return timer.stopped ? !1 : self.step(gotoEnd)
                }
                    , requestAnimationFrame = win.requestAnimationFrame || function(step) {
                    setTimeout(step, 13)
                }
                    , step = function() {
                    for (let i = 0; i < Fx.timers.length; i++) {
                        if (!Fx.timers[i]()) {
                            Fx.timers.splice(i--, 1)
                        }
                    }
                    if (Fx.timers.length) {
                        requestAnimationFrame(step)
                    }
                };
                if (from === to && !this.elem['forceAnimate:' + this.prop]) {
                    delete options.curAnim[this.prop];
                    if (options.complete && Object.keys(options.curAnim).length === 0) {
                        options.complete.call(this.elem)
                    }
                } else {
                    this.startTime = +new Date();
                    this.start = from;
                    this.end = to;
                    this.unit = unit;
                    this.now = this.start;
                    this.pos = 0;
                    timer.elem = this.elem;
                    timer.prop = this.prop;
                    if (timer() && Fx.timers.push(timer) === 1) {
                        requestAnimationFrame(step)
                    }
                }
            }
            step(gotoEnd) {
                const t = +new Date()
                    , options = this.options
                    , elem = this.elem
                    , complete = options.complete
                    , duration = options.duration
                    , curAnim = options.curAnim;
                let ret, done;
                if (!!elem.attr && !elem.element) {
                    ret = !1
                } else if (gotoEnd || t >= duration + this.startTime) {
                    this.now = this.end;
                    this.pos = 1;
                    this.update();
                    curAnim[this.prop] = !0;
                    done = !0;
                    objectEach(curAnim, function(val) {
                        if (val !== !0) {
                            done = !1
                        }
                    });
                    if (done && complete) {
                        complete.call(elem)
                    }
                    ret = !1
                } else {
                    this.pos = options.easing((t - this.startTime) / duration);
                    this.now = this.start + ((this.end - this.start) * this.pos);
                    this.update();
                    ret = !0
                }
                return ret
            }
            initPath(elem, fromD, toD) {
                const startX = elem.startX
                    , endX = elem.endX
                    , end = toD.slice()
                    , isArea = elem.isArea
                    , positionFactor = isArea ? 2 : 1;
                let shift, fullLength, i, reverse, start = fromD && fromD.slice();
                if (!start) {
                    return [end, end]
                }
                function prepend(arr, other) {
                    while (arr.length < fullLength) {
                        const moveSegment = arr[0]
                            , otherSegment = other[fullLength - arr.length];
                        if (otherSegment && moveSegment[0] === 'M') {
                            if (otherSegment[0] === 'C') {
                                arr[0] = ['C', moveSegment[1], moveSegment[2], moveSegment[1], moveSegment[2], moveSegment[1], moveSegment[2]]
                            } else {
                                arr[0] = ['L', moveSegment[1], moveSegment[2]]
                            }
                        }
                        arr.unshift(moveSegment);
                        if (isArea) {
                            const z = arr.pop();
                            arr.push(arr[arr.length - 1], z)
                        }
                    }
                }
                function append(arr, other) {
                    while (arr.length < fullLength) {
                        const segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
                        if (segmentToAdd[0] === 'C') {
                            segmentToAdd[1] = segmentToAdd[5];
                            segmentToAdd[2] = segmentToAdd[6]
                        }
                        if (!isArea) {
                            arr.push(segmentToAdd)
                        } else {
                            const lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
                            arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd)
                        }
                    }
                }
                if (startX && endX && endX.length) {
                    for (i = 0; i < startX.length; i++) {
                        if (startX[i] === endX[0]) {
                            shift = i;
                            break
                        } else if (startX[0] === endX[endX.length - startX.length + i]) {
                            shift = i;
                            reverse = !0;
                            break
                        } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
                            shift = startX.length - i;
                            break
                        }
                    }
                    if (typeof shift === 'undefined') {
                        start = []
                    }
                }
                if (start.length && isNumber(shift)) {
                    fullLength = end.length + shift * positionFactor;
                    if (!reverse) {
                        prepend(end, start);
                        append(start, end)
                    } else {
                        prepend(start, end);
                        append(end, start)
                    }
                }
                return [start, end]
            }
            fillSetter() {
                Fx.prototype.strokeSetter.apply(this, arguments)
            }
            strokeSetter() {
                this.elem.attr(this.prop, color(this.start).tweenTo(color(this.end), this.pos), void 0, !0)
            }
        }
        Fx.timers = [];
        return Fx
    });
    _registerModule(_modules, 'Core/Animation/AnimationUtilities.js', [_modules['Core/Animation/Fx.js'], _modules['Core/Utilities.js']], function(Fx, U) {
        const {defined, getStyle, isArray, isNumber, isObject, merge, objectEach, pick} = U;
        function setAnimation(animation, chart) {
            chart.renderer.globalAnimation = pick(animation, chart.options.chart.animation, !0)
        }
        function animObject(animation) {
            return isObject(animation) ? merge({
                duration: 500,
                defer: 0
            }, animation) : {
                duration: animation ? 500 : 0,
                defer: 0
            }
        }
        function getDeferredAnimation(chart, animation, series) {
            const labelAnimation = animObject(animation)
                , s = series ? [series] : chart.series;
            let defer = 0
                , duration = 0;
            s.forEach( (series) => {
                    const seriesAnim = animObject(series.options.animation);
                    defer = animation && defined(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
                    duration = Math.min(labelAnimation.duration, seriesAnim.duration)
                }
            );
            if (chart.renderer.forExport) {
                defer = 0
            }
            const anim = {
                defer: Math.max(0, defer - duration),
                duration: Math.min(defer, duration)
            };
            return anim
        }
        function animate(el, params, opt) {
            let start, unit = '', end, fx, args;
            if (!isObject(opt)) {
                args = arguments;
                opt = {
                    duration: args[2],
                    easing: args[3],
                    complete: args[4]
                }
            }
            if (!isNumber(opt.duration)) {
                opt.duration = 400
            }
            opt.easing = typeof opt.easing === 'function' ? opt.easing : (Math[opt.easing] || Math.easeInOutSine);
            opt.curAnim = merge(params);
            objectEach(params, function(val, prop) {
                stop(el, prop);
                fx = new Fx(el,opt,prop);
                end = void 0;
                if (prop === 'd' && isArray(params.d)) {
                    fx.paths = fx.initPath(el, el.pathArray, params.d);
                    fx.toD = params.d;
                    start = 0;
                    end = 1
                } else if (el.attr) {
                    start = el.attr(prop)
                } else {
                    start = parseFloat(getStyle(el, prop)) || 0;
                    if (prop !== 'opacity') {
                        unit = 'px'
                    }
                }
                if (!end) {
                    end = val
                }
                if (typeof end === 'string' && end.match('px')) {
                    end = end.replace(/px/g, '')
                }
                fx.run(start, end, unit)
            })
        }
        function stop(el, prop) {
            let i = Fx.timers.length;
            while (i--) {
                if (Fx.timers[i].elem === el && (!prop || prop === Fx.timers[i].prop)) {
                    Fx.timers[i].stopped = !0
                }
            }
        }
        const animationExports = {
            animate,
            animObject,
            getDeferredAnimation,
            setAnimation,
            stop
        };
        return animationExports
    });
    _registerModule(_modules, 'Core/Renderer/HTML/AST.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {SVG_NS, win} = H;
        const {attr, createElement, css, error, isFunction, isString, objectEach, splat} = U;
        const {trustedTypes} = win;
        const trustedTypesPolicy = (trustedTypes && isFunction(trustedTypes.createPolicy) && trustedTypes.createPolicy('highcharts', {
            createHTML: (s) => s
        }));
        const emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
        const hasValidDOMParser = (function() {
            try {
                return Boolean(new DOMParser().parseFromString(emptyHTML, 'text/html'))
            } catch (e) {
                return !1
            }
        }());
        class AST {
            static filterUserAttributes(attributes) {
                objectEach(attributes, (val, key) => {
                        let valid = !0;
                        if (AST.allowedAttributes.indexOf(key) === -1) {
                            valid = !1
                        }
                        if (['background', 'dynsrc', 'href', 'lowsrc', 'src'].indexOf(key) !== -1) {
                            valid = isString(val) && AST.allowedReferences.some( (ref) => val.indexOf(ref) === 0)
                        }
                        if (!valid) {
                            error(33, !1, void 0, {
                                'Invalid attribute in config': `${key}`
                            });
                            delete attributes[key]
                        }
                        if (isString(val) && attributes[key]) {
                            attributes[key] = val.replace(/</g, '&lt;')
                        }
                    }
                );
                return attributes
            }
            static parseStyle(style) {
                return style.split(';').reduce( (styles, line) => {
                        const pair = line.split(':').map( (s) => s.trim())
                            , key = pair.shift();
                        if (key && pair.length) {
                            styles[key.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = pair.join(':')
                        }
                        return styles
                    }
                    , {})
            }
            static setElementHTML(el, html) {
                el.innerHTML = AST.emptyHTML;
                if (html) {
                    const ast = new AST(html);
                    ast.addToDOM(el)
                }
            }
            constructor(source) {
                this.nodes = typeof source === 'string' ? this.parseMarkup(source) : source
            }
            addToDOM(parent) {
                function recurse(subtree, subParent) {
                    let ret;
                    splat(subtree).forEach(function(item) {
                        const tagName = item.tagName;
                        const textNode = item.textContent ? H.doc.createTextNode(item.textContent) : void 0;
                        const bypassHTMLFiltering = AST.bypassHTMLFiltering;
                        let node;
                        if (tagName) {
                            if (tagName === '#text') {
                                node = textNode
                            } else if (AST.allowedTags.indexOf(tagName) !== -1 || bypassHTMLFiltering) {
                                const NS = tagName === 'svg' ? SVG_NS : (subParent.namespaceURI || SVG_NS);
                                const element = H.doc.createElementNS(NS, tagName);
                                const attributes = item.attributes || {};
                                objectEach(item, function(val, key) {
                                    if (key !== 'tagName' && key !== 'attributes' && key !== 'children' && key !== 'style' && key !== 'textContent') {
                                        attributes[key] = val
                                    }
                                });
                                attr(element, bypassHTMLFiltering ? attributes : AST.filterUserAttributes(attributes));
                                if (item.style) {
                                    css(element, item.style)
                                }
                                if (textNode) {
                                    element.appendChild(textNode)
                                }
                                recurse(item.children || [], element);
                                node = element
                            } else {
                                error(33, !1, void 0, {
                                    'Invalid tagName in config': tagName
                                })
                            }
                        }
                        if (node) {
                            subParent.appendChild(node)
                        }
                        ret = node
                    });
                    return ret
                }
                return recurse(this.nodes, parent)
            }
            parseMarkup(markup) {
                const nodes = [];
                markup = markup.trim().replace(/ style=(["'])/g, ' data-style=$1');
                let doc;
                if (hasValidDOMParser) {
                    doc = new DOMParser().parseFromString(trustedTypesPolicy ? trustedTypesPolicy.createHTML(markup) : markup, 'text/html')
                } else {
                    const body = createElement('div');
                    body.innerHTML = markup;
                    doc = {
                        body
                    }
                }
                const appendChildNodes = (node, addTo) => {
                        const tagName = node.nodeName.toLowerCase();
                        const astNode = {
                            tagName
                        };
                        if (tagName === '#text') {
                            astNode.textContent = node.textContent || ''
                        }
                        const parsedAttributes = node.attributes;
                        if (parsedAttributes) {
                            const attributes = {};
                            [].forEach.call(parsedAttributes, (attrib) => {
                                    if (attrib.name === 'data-style') {
                                        astNode.style = AST.parseStyle(attrib.value)
                                    } else {
                                        attributes[attrib.name] = attrib.value
                                    }
                                }
                            );
                            astNode.attributes = attributes
                        }
                        if (node.childNodes.length) {
                            const children = [];
                            [].forEach.call(node.childNodes, (childNode) => {
                                    appendChildNodes(childNode, children)
                                }
                            );
                            if (children.length) {
                                astNode.children = children
                            }
                        }
                        addTo.push(astNode)
                    }
                ;
                [].forEach.call(doc.body.childNodes, (childNode) => appendChildNodes(childNode, nodes));
                return nodes
            }
        }
        AST.allowedAttributes = ['alt', 'aria-controls', 'aria-describedby', 'aria-expanded', 'aria-haspopup', 'aria-hidden', 'aria-label', 'aria-labelledby', 'aria-live', 'aria-pressed', 'aria-readonly', 'aria-roledescription', 'aria-selected', 'class', 'clip-path', 'color', 'colspan', 'cx', 'cy', 'd', 'dx', 'dy', 'disabled', 'fill', 'filterUnits', 'flood-color', 'flood-opacity', 'height', 'href', 'id', 'in', 'markerHeight', 'markerWidth', 'offset', 'opacity', 'orient', 'padding', 'paddingLeft', 'paddingRight', 'patternUnits', 'r', 'refX', 'refY', 'role', 'scope', 'slope', 'src', 'startOffset', 'stdDeviation', 'stroke', 'stroke-linecap', 'stroke-width', 'style', 'tableValues', 'result', 'rowspan', 'summary', 'target', 'tabindex', 'text-align', 'text-anchor', 'textAnchor', 'textLength', 'title', 'type', 'valign', 'width', 'x', 'x1', 'x2', 'xlink:href', 'y', 'y1', 'y2', 'zIndex'];
        AST.allowedReferences = ['https://', 'http://', 'mailto:', '/', '../', './', '#'];
        AST.allowedTags = ['a', 'abbr', 'b', 'br', 'button', 'caption', 'circle', 'clipPath', 'code', 'dd', 'defs', 'div', 'dl', 'dt', 'em', 'feComponentTransfer', 'feDropShadow', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feOffset', 'feMerge', 'feMergeNode', 'filter', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'li', 'linearGradient', 'marker', 'ol', 'p', 'path', 'pattern', 'pre', 'rect', 'small', 'span', 'stop', 'strong', 'style', 'sub', 'sup', 'svg', 'table', 'text', 'textPath', 'thead', 'title', 'tbody', 'tspan', 'td', 'th', 'tr', 'u', 'ul', '#text'];
        AST.emptyHTML = emptyHTML;
        AST.bypassHTMLFiltering = !1;
        ('');
        return AST
    });
    _registerModule(_modules, 'Core/Templating.js', [_modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function(D, U) {
        const {defaultOptions, defaultTime} = D;
        const {extend, getNestedProperty, isArray, isNumber, isObject, isString, pick, pInt} = U;
        const helpers = {
            add: (a, b) => a + b,
            divide: (a, b) => (b !== 0 ? a / b : ''),
            eq: (a, b) => a == b,
            each: function(arr) {
                const match = arguments[arguments.length - 1];
                return isArray(arr) ? arr.map( (item, i) => format(match.body, extend(isObject(item) ? item : {
                    '@this': item
                }, {
                    '@index': i,
                    '@first': i === 0,
                    '@last': i === arr.length - 1
                }))).join('') : !1
            },
            ge: (a, b) => a >= b,
            gt: (a, b) => a > b,
            'if': (condition) => !!condition,
            le: (a, b) => a <= b,
            lt: (a, b) => a < b,
            multiply: (a, b) => a * b,
            ne: (a, b) => a != b,
            subtract: (a, b) => a - b,
            unless: (condition) => !condition
        };
        function dateFormat(format, timestamp, capitalize) {
            return defaultTime.dateFormat(format, timestamp, capitalize)
        }
        function format(str='', ctx, chart) {
            const regex = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g
                , subRegex = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g
                , matches = []
                , floatRegex = /f$/
                , decRegex = /\.([0-9])/
                , lang = defaultOptions.lang
                , time = chart && chart.time || defaultTime
                , numberFormatter = chart && chart.numberFormatter || numberFormat;
            const resolveProperty = (key='') => {
                    let n;
                    if (key === 'true') {
                        return !0
                    }
                    if (key === 'false') {
                        return !1
                    }
                    if ((n = Number(key)).toString() === key) {
                        return n
                    }
                    return getNestedProperty(key, ctx)
                }
            ;
            let match, currentMatch, depth = 0, hasSub;
            while ((match = regex.exec(str)) !== null) {
                const subMatch = subRegex.exec(match[1]);
                if (subMatch) {
                    match = subMatch;
                    hasSub = !0
                }
                if (!currentMatch || !currentMatch.isBlock) {
                    currentMatch = {
                        ctx,
                        expression: match[1],
                        find: match[0],
                        isBlock: match[1].charAt(0) === '#',
                        start: match.index,
                        startInner: match.index + match[0].length,
                        length: match[0].length
                    }
                }
                const fn = match[1].split(' ')[0].replace('#', '');
                if (helpers[fn]) {
                    if (currentMatch.isBlock && fn === currentMatch.fn) {
                        depth++
                    }
                    if (!currentMatch.fn) {
                        currentMatch.fn = fn
                    }
                }
                const startingElseSection = match[1] === 'else';
                if (currentMatch.isBlock && currentMatch.fn && (match[1] === `/${currentMatch.fn}` || startingElseSection)) {
                    if (!depth) {
                        const start = currentMatch.startInner
                            , body = str.substr(start, match.index - start);
                        if (currentMatch.body === void 0) {
                            currentMatch.body = body;
                            currentMatch.startInner = match.index + match[0].length
                        } else {
                            currentMatch.elseBody = body
                        }
                        currentMatch.find += body + match[0];
                        if (!startingElseSection) {
                            matches.push(currentMatch);
                            currentMatch = void 0
                        }
                    } else if (!startingElseSection) {
                        depth--
                    }
                } else if (!currentMatch.isBlock) {
                    matches.push(currentMatch)
                }
                if (subMatch && !currentMatch?.isBlock) {
                    break
                }
            }
            matches.forEach( (match) => {
                    const {body, elseBody, expression, fn} = match;
                    let replacement, i;
                    if (fn) {
                        const args = [match]
                            , parts = expression.split(' ');
                        i = helpers[fn].length;
                        while (i--) {
                            args.unshift(resolveProperty(parts[i + 1]))
                        }
                        replacement = helpers[fn].apply(ctx, args);
                        if (match.isBlock && typeof replacement === 'boolean') {
                            replacement = format(replacement ? body : elseBody, ctx)
                        }
                    } else {
                        const valueAndFormat = expression.split(':');
                        replacement = resolveProperty(valueAndFormat.shift() || '');
                        if (valueAndFormat.length && typeof replacement === 'number') {
                            const segment = valueAndFormat.join(':');
                            if (floatRegex.test(segment)) {
                                const decimals = parseInt((segment.match(decRegex) || ['', '-1'])[1], 10);
                                if (replacement !== null) {
                                    replacement = numberFormatter(replacement, decimals, lang.decimalPoint, segment.indexOf(',') > -1 ? lang.thousandsSep : '')
                                }
                            } else {
                                replacement = time.dateFormat(segment, replacement)
                            }
                        }
                    }
                    str = str.replace(match.find, pick(replacement, ''))
                }
            );
            return hasSub ? format(str, ctx, chart) : str
        }
        function numberFormat(number, decimals, decimalPoint, thousandsSep) {
            number = +number || 0;
            decimals = +decimals;
            let ret, fractionDigits;
            const lang = defaultOptions.lang
                , origDec = (number.toString().split('.')[1] || '').split('e')[0].length
                , exponent = number.toString().split('e')
                , firstDecimals = decimals;
            if (decimals === -1) {
                decimals = Math.min(origDec, 20)
            } else if (!isNumber(decimals)) {
                decimals = 2
            } else if (decimals && exponent[1] && exponent[1] < 0) {
                fractionDigits = decimals + +exponent[1];
                if (fractionDigits >= 0) {
                    exponent[0] = (+exponent[0]).toExponential(fractionDigits).split('e')[0];
                    decimals = fractionDigits
                } else {
                    exponent[0] = exponent[0].split('.')[0] || 0;
                    if (decimals < 20) {
                        number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals)
                    } else {
                        number = 0
                    }
                    exponent[1] = 0
                }
            }
            const roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(decimals, origDec) - 1)).toFixed(decimals);
            const strinteger = String(pInt(roundedNumber));
            const thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
            decimalPoint = pick(decimalPoint, lang.decimalPoint);
            thousandsSep = pick(thousandsSep, lang.thousandsSep);
            ret = number < 0 ? '-' : '';
            ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';
            if (+exponent[1] < 0 && !firstDecimals) {
                ret = '0'
            } else {
                ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep)
            }
            if (decimals) {
                ret += decimalPoint + roundedNumber.slice(-decimals)
            }
            if (exponent[1] && +ret !== 0) {
                ret += 'e' + exponent[1]
            }
            return ret
        }
        const Templating = {
            dateFormat,
            format,
            helpers,
            numberFormat
        };
        return Templating
    });
    _registerModule(_modules, 'Core/Renderer/RendererUtilities.js', [_modules['Core/Utilities.js']], function(U) {
        const {clamp, pick, pushUnique, stableSort} = U;
        var RendererUtilities;
        (function(RendererUtilities) {
                function distribute(boxes, len, maxDistance) {
                    const origBoxes = boxes
                        , reducedLen = origBoxes.reducedLen || len
                        , sortByRank = (a, b) => (b.rank || 0) - (a.rank || 0)
                        , sortByTarget = (a, b) => a.target - b.target
                        , restBoxes = []
                        , boxesLength = boxes.length
                        , forDeletion = []
                        , push = restBoxes.push;
                    let i, cursor, step, overlapping = !0, box, target, total = 0, equalRank;
                    i = boxesLength;
                    while (i--) {
                        total += boxes[i].size
                    }
                    if (total > reducedLen) {
                        stableSort(boxes, sortByRank);
                        equalRank = boxes[0].rank === boxes[boxes.length - 1].rank;
                        step = equalRank ? boxesLength / 2 : -1;
                        cursor = equalRank ? step : boxesLength - 1;
                        while (step && total > reducedLen) {
                            i = Math.floor(cursor);
                            box = boxes[i];
                            if (pushUnique(forDeletion, i)) {
                                total -= box.size
                            }
                            cursor += step;
                            if (equalRank && cursor >= boxes.length) {
                                step /= 2;
                                cursor = step
                            }
                        }
                        forDeletion.sort( (a, b) => b - a).forEach( (i) => push.apply(restBoxes, boxes.splice(i, 1)))
                    }
                    stableSort(boxes, sortByTarget);
                    boxes = boxes.map( (box) => ({
                        size: box.size,
                        targets: [box.target],
                        align: pick(box.align, 0.5)
                    }));
                    while (overlapping) {
                        i = boxes.length;
                        while (i--) {
                            box = boxes[i];
                            target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
                            box.pos = clamp(target - box.size * box.align, 0, len - box.size)
                        }
                        i = boxes.length;
                        overlapping = !1;
                        while (i--) {
                            if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
                                boxes[i - 1].size += boxes[i].size;
                                boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
                                boxes[i - 1].align = 0.5;
                                if (boxes[i - 1].pos + boxes[i - 1].size > len) {
                                    boxes[i - 1].pos = len - boxes[i - 1].size
                                }
                                boxes.splice(i, 1);
                                overlapping = !0
                            }
                        }
                    }
                    push.apply(origBoxes, restBoxes);
                    i = 0;
                    boxes.some( (box) => {
                            let posInCompositeBox = 0;
                            return (box.targets || []).some( () => {
                                    origBoxes[i].pos = box.pos + posInCompositeBox;
                                    if (typeof maxDistance !== 'undefined' && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
                                        origBoxes.slice(0, i + 1).forEach( (box) => delete box.pos);
                                        origBoxes.reducedLen = (origBoxes.reducedLen || len) - (len * 0.1);
                                        if (origBoxes.reducedLen > len * 0.1) {
                                            distribute(origBoxes, len, maxDistance)
                                        }
                                        return !0
                                    }
                                    posInCompositeBox += origBoxes[i].size;
                                    i++;
                                    return !1
                                }
                            )
                        }
                    );
                    stableSort(origBoxes, sortByTarget);
                    return origBoxes
                }
                RendererUtilities.distribute = distribute
            }
        )(RendererUtilities || (RendererUtilities = {}));
        return RendererUtilities
    });
    _registerModule(_modules, 'Core/Renderer/SVG/SVGElement.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(A, Color, H, U) {
        const {animate, animObject, stop} = A;
        const {deg2rad, doc, noop, svg, SVG_NS, win} = H;
        const {addEvent, attr, createElement, css, defined, erase, extend, fireEvent, isArray, isFunction, isObject, isString, merge, objectEach, pick, pInt, syncTimeout, uniqueKey} = U;
        class SVGElement {
            constructor() {
                this.element = void 0;
                this.onEvents = {};
                this.opacity = 1;
                this.renderer = void 0;
                this.SVG_NS = SVG_NS
            }
            _defaultGetter(key) {
                let ret = pick(this[key + 'Value'], this[key], this.element ? this.element.getAttribute(key) : null, 0);
                if (/^[\-0-9\.]+$/.test(ret)) {
                    ret = parseFloat(ret)
                }
                return ret
            }
            _defaultSetter(value, key, element) {
                element.setAttribute(key, value)
            }
            add(parent) {
                const renderer = this.renderer
                    , element = this.element;
                let inserted;
                if (parent) {
                    this.parentGroup = parent
                }
                if (typeof this.textStr !== 'undefined' && this.element.nodeName === 'text') {
                    renderer.buildText(this)
                }
                this.added = !0;
                if (!parent || parent.handleZ || this.zIndex) {
                    inserted = this.zIndexSetter()
                }
                if (!inserted) {
                    (parent ? parent.element : renderer.box).appendChild(element)
                }
                if (this.onAdd) {
                    this.onAdd()
                }
                return this
            }
            addClass(className, replace) {
                const currentClassName = replace ? '' : (this.attr('class') || '');
                className = (className || '').split(/ /g).reduce(function(newClassName, name) {
                    if (currentClassName.indexOf(name) === -1) {
                        newClassName.push(name)
                    }
                    return newClassName
                }, (currentClassName ? [currentClassName] : [])).join(' ');
                if (className !== currentClassName) {
                    this.attr('class', className)
                }
                return this
            }
            afterSetters() {
                if (this.doTransform) {
                    this.updateTransform();
                    this.doTransform = !1
                }
            }
            align(alignOptions, alignByTranslate, box) {
                const attribs = {}
                    , renderer = this.renderer
                    , alignedObjects = renderer.alignedObjects;
                let x, y, alignTo, alignFactor, vAlignFactor;
                if (alignOptions) {
                    this.alignOptions = alignOptions;
                    this.alignByTranslate = alignByTranslate;
                    if (!box || isString(box)) {
                        this.alignTo = alignTo = box || 'renderer';
                        erase(alignedObjects, this);
                        alignedObjects.push(this);
                        box = void 0
                    }
                } else {
                    alignOptions = this.alignOptions;
                    alignByTranslate = this.alignByTranslate;
                    alignTo = this.alignTo
                }
                box = pick(box, renderer[alignTo], alignTo === 'scrollablePlotBox' ? renderer.plotBox : void 0, renderer);
                const align = alignOptions.align
                    , vAlign = alignOptions.verticalAlign;
                x = (box.x || 0) + (alignOptions.x || 0);
                y = (box.y || 0) + (alignOptions.y || 0);
                if (align === 'right') {
                    alignFactor = 1
                } else if (align === 'center') {
                    alignFactor = 2
                }
                if (alignFactor) {
                    x += (box.width - (alignOptions.width || 0)) / alignFactor
                }
                attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);
                if (vAlign === 'bottom') {
                    vAlignFactor = 1
                } else if (vAlign === 'middle') {
                    vAlignFactor = 2
                }
                if (vAlignFactor) {
                    y += (box.height - (alignOptions.height || 0)) / vAlignFactor
                }
                attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);
                this[this.placed ? 'animate' : 'attr'](attribs);
                this.placed = !0;
                this.alignAttr = attribs;
                return this
            }
            alignSetter(value) {
                const convert = {
                    left: 'start',
                    center: 'middle',
                    right: 'end'
                };
                if (convert[value]) {
                    this.alignValue = value;
                    this.element.setAttribute('text-anchor', convert[value])
                }
            }
            animate(params, options, complete) {
                const animOptions = animObject(pick(options, this.renderer.globalAnimation, !0))
                    , deferTime = animOptions.defer;
                if (doc.hidden) {
                    animOptions.duration = 0
                }
                if (animOptions.duration !== 0) {
                    if (complete) {
                        animOptions.complete = complete
                    }
                    syncTimeout( () => {
                            if (this.element) {
                                animate(this, params, animOptions)
                            }
                        }
                        , deferTime)
                } else {
                    this.attr(params, void 0, complete || animOptions.complete);
                    objectEach(params, function(val, prop) {
                        if (animOptions.step) {
                            animOptions.step.call(this, val, {
                                prop: prop,
                                pos: 1,
                                elem: this
                            })
                        }
                    }, this)
                }
                return this
            }
            applyTextOutline(textOutline) {
                const elem = this.element
                    , hasContrast = textOutline.indexOf('contrast') !== -1
                    , styles = {};
                if (hasContrast) {
                    styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill))
                }
                const parts = textOutline.split(' ');
                const color = parts[parts.length - 1];
                let strokeWidth = parts[0];
                if (strokeWidth && strokeWidth !== 'none' && H.svg) {
                    this.fakeTS = !0;
                    strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match, digit, unit) {
                        return (2 * Number(digit)) + unit
                    });
                    this.removeTextOutline();
                    const outline = doc.createElementNS(SVG_NS, 'tspan');
                    attr(outline, {
                        'class': 'highcharts-text-outline',
                        fill: color,
                        stroke: color,
                        'stroke-width': strokeWidth,
                        'stroke-linejoin': 'round'
                    });
                    const parentElem = elem.querySelector('textPath') || elem;
                    [].forEach.call(parentElem.childNodes, (childNode) => {
                            const clone = childNode.cloneNode(!0);
                            if (clone.removeAttribute) {
                                ['fill', 'stroke', 'stroke-width', 'stroke'].forEach( (prop) => clone.removeAttribute(prop))
                            }
                            outline.appendChild(clone)
                        }
                    );
                    let totalHeight = 0;
                    [].forEach.call(parentElem.querySelectorAll('text tspan'), (element) => {
                            totalHeight += Number(element.getAttribute('dy'))
                        }
                    );
                    const br = doc.createElementNS(SVG_NS, 'tspan');
                    br.textContent = '\u200B';
                    attr(br, {
                        x: Number(elem.getAttribute('x')),
                        dy: -totalHeight
                    });
                    outline.appendChild(br);
                    parentElem.insertBefore(outline, parentElem.firstChild)
                }
            }
            attr(hash, val, complete, continueAnimation) {
                const element = this.element
                    , symbolCustomAttribs = SVGElement.symbolCustomAttribs;
                let key, hasSetSymbolSize, ret = this, skipAttr, setter;
                if (typeof hash === 'string' && typeof val !== 'undefined') {
                    key = hash;
                    hash = {};
                    hash[key] = val
                }
                if (typeof hash === 'string') {
                    ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element)
                } else {
                    objectEach(hash, function eachAttribute(val, key) {
                        skipAttr = !1;
                        if (!continueAnimation) {
                            stop(this, key)
                        }
                        if (this.symbolName && symbolCustomAttribs.indexOf(key) !== -1) {
                            if (!hasSetSymbolSize) {
                                this.symbolAttr(hash);
                                hasSetSymbolSize = !0
                            }
                            skipAttr = !0
                        }
                        if (this.rotation && (key === 'x' || key === 'y')) {
                            this.doTransform = !0
                        }
                        if (!skipAttr) {
                            setter = (this[key + 'Setter'] || this._defaultSetter);
                            setter.call(this, val, key, element)
                        }
                    }, this);
                    this.afterSetters()
                }
                if (complete) {
                    complete.call(this)
                }
                return ret
            }
            clip(clipRect) {
                return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : 'none')
            }
            crisp(rect, strokeWidth) {
                const wrapper = this;
                strokeWidth = strokeWidth || rect.strokeWidth || 0;
                const normalizer = Math.round(strokeWidth) % 2 / 2;
                rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
                rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
                rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);
                rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);
                if (defined(rect.strokeWidth)) {
                    rect.strokeWidth = strokeWidth
                }
                return rect
            }
            complexColor(colorOptions, prop, elem) {
                const renderer = this.renderer;
                let colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id, key = [], value;
                fireEvent(this.renderer, 'complexColor', {
                    args: arguments
                }, function() {
                    if (colorOptions.radialGradient) {
                        gradName = 'radialGradient'
                    } else if (colorOptions.linearGradient) {
                        gradName = 'linearGradient'
                    }
                    if (gradName) {
                        gradAttr = colorOptions[gradName];
                        gradients = renderer.gradients;
                        stops = colorOptions.stops;
                        radialReference = elem.radialReference;
                        if (isArray(gradAttr)) {
                            colorOptions[gradName] = gradAttr = {
                                x1: gradAttr[0],
                                y1: gradAttr[1],
                                x2: gradAttr[2],
                                y2: gradAttr[3],
                                gradientUnits: 'userSpaceOnUse'
                            }
                        }
                        if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
                            radAttr = gradAttr;
                            gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), {
                                gradientUnits: 'userSpaceOnUse'
                            })
                        }
                        objectEach(gradAttr, function(value, n) {
                            if (n !== 'id') {
                                key.push(n, value)
                            }
                        });
                        objectEach(stops, function(val) {
                            key.push(val)
                        });
                        key = key.join(',');
                        if (gradients[key]) {
                            id = gradients[key].attr('id')
                        } else {
                            gradAttr.id = id = uniqueKey();
                            const gradientObject = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
                            gradientObject.radAttr = radAttr;
                            gradientObject.stops = [];
                            stops.forEach(function(stop) {
                                if (stop[1].indexOf('rgba') === 0) {
                                    colorObject = Color.parse(stop[1]);
                                    stopColor = colorObject.get('rgb');
                                    stopOpacity = colorObject.get('a')
                                } else {
                                    stopColor = stop[1];
                                    stopOpacity = 1
                                }
                                const stopObject = renderer.createElement('stop').attr({
                                    offset: stop[0],
                                    'stop-color': stopColor,
                                    'stop-opacity': stopOpacity
                                }).add(gradientObject);
                                gradientObject.stops.push(stopObject)
                            })
                        }
                        value = 'url(' + renderer.url + '#' + id + ')';
                        elem.setAttribute(prop, value);
                        elem.gradient = key;
                        colorOptions.toString = function() {
                            return value
                        }
                    }
                })
            }
            css(styles) {
                const oldStyles = this.styles
                    , newStyles = {}
                    , elem = this.element;
                let textWidth, hasNew = !oldStyles;
                if (oldStyles) {
                    objectEach(styles, function(value, n) {
                        if (oldStyles && oldStyles[n] !== value) {
                            newStyles[n] = value;
                            hasNew = !0
                        }
                    })
                }
                if (hasNew) {
                    if (oldStyles) {
                        styles = extend(oldStyles, newStyles)
                    }
                    if (styles.width === null || styles.width === 'auto') {
                        delete this.textWidth
                    } else if (elem.nodeName.toLowerCase() === 'text' && styles.width) {
                        textWidth = this.textWidth = pInt(styles.width)
                    }
                    this.styles = styles;
                    if (textWidth && (!svg && this.renderer.forExport)) {
                        delete styles.width
                    }
                    const stylesToApply = merge(styles);
                    if (elem.namespaceURI === this.SVG_NS) {
                        ['textOutline', 'textOverflow', 'width'].forEach( (key) => (stylesToApply && delete stylesToApply[key]));
                        if (stylesToApply.color) {
                            stylesToApply.fill = stylesToApply.color
                        }
                    }
                    css(elem, stylesToApply)
                }
                if (this.added) {
                    if (this.element.nodeName === 'text') {
                        this.renderer.buildText(this)
                    }
                    if (styles.textOutline) {
                        this.applyTextOutline(styles.textOutline)
                    }
                }
                return this
            }
            dashstyleSetter(value) {
                let i, strokeWidth = this['stroke-width'];
                if (strokeWidth === 'inherit') {
                    strokeWidth = 1
                }
                value = value && value.toLowerCase();
                if (value) {
                    const v = value.replace('shortdashdotdot', '3,1,1,1,1,1,').replace('shortdashdot', '3,1,1,1').replace('shortdot', '1,1,').replace('shortdash', '3,1,').replace('longdash', '8,3,').replace(/dot/g, '1,3,').replace('dash', '4,3,').replace(/,$/, '').split(',');
                    i = v.length;
                    while (i--) {
                        v[i] = '' + (pInt(v[i]) * pick(strokeWidth, NaN))
                    }
                    value = v.join(',').replace(/NaN/g, 'none');
                    this.element.setAttribute('stroke-dasharray', value)
                }
            }
            destroy() {
                const wrapper = this
                    , element = wrapper.element || {}
                    , renderer = wrapper.renderer
                    , ownerSVGElement = element.ownerSVGElement;
                let parentToClean = (element.nodeName === 'SPAN' && wrapper.parentGroup || void 0), grandParent, i;
                element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
                stop(wrapper);
                if (wrapper.clipPath && ownerSVGElement) {
                    const clipPath = wrapper.clipPath;
                    [].forEach.call(ownerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'), function(el) {
                        if (el.getAttribute('clip-path').indexOf(clipPath.element.id) > -1) {
                            el.removeAttribute('clip-path')
                        }
                    });
                    wrapper.clipPath = clipPath.destroy()
                }
                wrapper.connector = wrapper.connector?.destroy();
                if (wrapper.stops) {
                    for (i = 0; i < wrapper.stops.length; i++) {
                        wrapper.stops[i].destroy()
                    }
                    wrapper.stops.length = 0;
                    wrapper.stops = void 0
                }
                wrapper.safeRemoveChild(element);
                while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
                    grandParent = parentToClean.parentGroup;
                    wrapper.safeRemoveChild(parentToClean.div);
                    delete parentToClean.div;
                    parentToClean = grandParent
                }
                if (wrapper.alignTo) {
                    erase(renderer.alignedObjects, wrapper)
                }
                objectEach(wrapper, function(val, key) {
                    if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {
                        wrapper[key].destroy()
                    }
                    delete wrapper[key]
                });
                return
            }
            dSetter(value, key, element) {
                if (isArray(value)) {
                    if (typeof value[0] === 'string') {
                        value = this.renderer.pathToSegments(value)
                    }
                    this.pathArray = value;
                    value = value.reduce( (acc, seg, i) => {
                            if (!seg || !seg.join) {
                                return (seg || '').toString()
                            }
                            return (i ? acc + ' ' : '') + seg.join(' ')
                        }
                        , '')
                }
                if (/(NaN| {2}|^$)/.test(value)) {
                    value = 'M 0 0'
                }
                if (this[key] !== value) {
                    element.setAttribute(key, value);
                    this[key] = value
                }
            }
            fillSetter(value, key, element) {
                if (typeof value === 'string') {
                    element.setAttribute(key, value)
                } else if (value) {
                    this.complexColor(value, key, element)
                }
            }
            hrefSetter(value, key, element) {
                element.setAttributeNS('http://www.w3.org/1999/xlink', key, value)
            }
            getBBox(reload, rot) {
                const wrapper = this
                    , {alignValue, element, renderer, styles, textStr} = wrapper
                    , {cache, cacheKeys} = renderer
                    , isSVG = element.namespaceURI === wrapper.SVG_NS
                    , rotation = pick(rot, wrapper.rotation, 0)
                    , fontSize = renderer.styledMode ? (element && SVGElement.prototype.getStyle.call(element, 'font-size')) : (styles && styles.fontSize);
                let bBox, width, height, toggleTextShadowShim, cacheKey;
                if (defined(textStr)) {
                    cacheKey = textStr.toString();
                    if (cacheKey.indexOf('<') === -1) {
                        cacheKey = cacheKey.replace(/[0-9]/g, '0')
                    }
                    cacheKey += ['', renderer.rootFontSize, fontSize, rotation, wrapper.textWidth, alignValue, styles && styles.textOverflow, styles && styles.fontWeight].join(',')
                }
                if (cacheKey && !reload) {
                    bBox = cache[cacheKey]
                }
                if (!bBox) {
                    if (isSVG || renderer.forExport) {
                        try {
                            toggleTextShadowShim = this.fakeTS && function(display) {
                                const outline = element.querySelector('.highcharts-text-outline');
                                if (outline) {
                                    css(outline, {
                                        display
                                    })
                                }
                            }
                            ;
                            if (isFunction(toggleTextShadowShim)) {
                                toggleTextShadowShim('none')
                            }
                            bBox = element.getBBox ? extend({}, element.getBBox()) : {
                                width: element.offsetWidth,
                                height: element.offsetHeight,
                                x: 0,
                                y: 0
                            };
                            if (isFunction(toggleTextShadowShim)) {
                                toggleTextShadowShim('')
                            }
                        } catch (e) {
                            ''
                        }
                        if (!bBox || bBox.width < 0) {
                            bBox = {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            }
                        }
                    } else {
                        bBox = wrapper.htmlGetBBox()
                    }
                    width = bBox.width;
                    height = bBox.height;
                    if (isSVG) {
                        bBox.height = height = ({
                            '11px,17': 14,
                            '13px,20': 16
                        }[`${fontSize || ''},${Math.round(height)}`] || height)
                    }
                    if (rotation) {
                        const baseline = Number(element.getAttribute('y') || 0) - bBox.y
                            , alignFactor = {
                            'right': 1,
                            'center': 0.5
                        }[alignValue || 0] || 0
                            , rad = rotation * deg2rad
                            , rad90 = (rotation - 90) * deg2rad
                            , wCosRad = width * Math.cos(rad)
                            , wSinRad = width * Math.sin(rad)
                            , cosRad90 = Math.cos(rad90)
                            , sinRad90 = Math.sin(rad90)
                            , pX = bBox.x + alignFactor * (width - wCosRad)
                            , pY = bBox.y + baseline - alignFactor * wSinRad
                            , aX = pX + baseline * cosRad90
                            , bX = aX + wCosRad
                            , cX = bX - height * cosRad90
                            , dX = cX - wCosRad
                            , aY = pY + baseline * sinRad90
                            , bY = aY + wSinRad
                            , cY = bY - height * sinRad90
                            , dY = cY - wSinRad;
                        bBox.x = Math.min(aX, bX, cX, dX);
                        bBox.y = Math.min(aY, bY, cY, dY);
                        bBox.width = Math.max(aX, bX, cX, dX) - bBox.x;
                        bBox.height = Math.max(aY, bY, cY, dY) - bBox.y
                    }
                }
                if (cacheKey && (textStr === '' || bBox.height > 0)) {
                    while (cacheKeys.length > 250) {
                        delete cache[cacheKeys.shift()]
                    }
                    if (!cache[cacheKey]) {
                        cacheKeys.push(cacheKey)
                    }
                    cache[cacheKey] = bBox
                }
                return bBox
            }
            getStyle(prop) {
                return win.getComputedStyle(this.element || this, '').getPropertyValue(prop)
            }
            hasClass(className) {
                return ('' + this.attr('class')).split(' ').indexOf(className) !== -1
            }
            hide() {
                return this.attr({
                    visibility: 'hidden'
                })
            }
            htmlGetBBox() {
                return {
                    height: 0,
                    width: 0,
                    x: 0,
                    y: 0
                }
            }
            init(renderer, nodeName) {
                this.element = nodeName === 'span' ? createElement(nodeName) : doc.createElementNS(this.SVG_NS, nodeName);
                this.renderer = renderer;
                fireEvent(this, 'afterInit')
            }
            on(eventType, handler) {
                const {onEvents} = this;
                if (onEvents[eventType]) {
                    onEvents[eventType]()
                }
                onEvents[eventType] = addEvent(this.element, eventType, handler);
                return this
            }
            opacitySetter(value, key, element) {
                const opacity = Number(Number(value).toFixed(3));
                this.opacity = opacity;
                element.setAttribute(key, opacity)
            }
            removeClass(className) {
                return this.attr('class', ('' + this.attr('class')).replace(isString(className) ? new RegExp(`(^| )${className}( |$)`) : className, ' ').replace(/ +/g, ' ').trim())
            }
            removeTextOutline() {
                const outline = this.element.querySelector('tspan.highcharts-text-outline');
                if (outline) {
                    this.safeRemoveChild(outline)
                }
            }
            safeRemoveChild(element) {
                const parentNode = element.parentNode;
                if (parentNode) {
                    parentNode.removeChild(element)
                }
            }
            setRadialReference(coordinates) {
                const existingGradient = (this.element.gradient && this.renderer.gradients[this.element.gradient]);
                this.element.radialReference = coordinates;
                if (existingGradient && existingGradient.radAttr) {
                    existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr))
                }
                return this
            }
            setTextPath(path, textPathOptions) {
                textPathOptions = merge(!0, {
                    enabled: !0,
                    attributes: {
                        dy: -5,
                        startOffset: '50%',
                        textAnchor: 'middle'
                    }
                }, textPathOptions);
                const url = this.renderer.url
                    , textWrapper = this.text || this
                    , textPath = textWrapper.textPath
                    , {attributes, enabled} = textPathOptions;
                path = path || (textPath && textPath.path);
                if (textPath) {
                    textPath.undo()
                }
                if (path && enabled) {
                    const undo = addEvent(textWrapper, 'afterModifyTree', (e) => {
                            if (path && enabled) {
                                let textPathId = path.attr('id');
                                if (!textPathId) {
                                    path.attr('id', textPathId = uniqueKey())
                                }
                                const textAttribs = {
                                    x: 0,
                                    y: 0
                                };
                                if (defined(attributes.dx)) {
                                    textAttribs.dx = attributes.dx;
                                    delete attributes.dx
                                }
                                if (defined(attributes.dy)) {
                                    textAttribs.dy = attributes.dy;
                                    delete attributes.dy
                                }
                                textWrapper.attr(textAttribs);
                                this.attr({
                                    transform: ''
                                });
                                if (this.box) {
                                    this.box = this.box.destroy()
                                }
                                const children = e.nodes.slice(0);
                                e.nodes.length = 0;
                                e.nodes[0] = {
                                    tagName: 'textPath',
                                    attributes: extend(attributes, {
                                        'text-anchor': attributes.textAnchor,
                                        href: `${url}#${textPathId}`
                                    }),
                                    children
                                }
                            }
                        }
                    );
                    textWrapper.textPath = {
                        path,
                        undo
                    }
                } else {
                    textWrapper.attr({
                        dx: 0,
                        dy: 0
                    });
                    delete textWrapper.textPath
                }
                if (this.added) {
                    textWrapper.textCache = '';
                    this.renderer.buildText(textWrapper)
                }
                return this
            }
            shadow(shadowOptions) {
                const {renderer} = this
                    , options = merge(this.parentGroup?.rotation === 90 ? {
                    offsetX: -1,
                    offsetY: -1
                } : {}, isObject(shadowOptions) ? shadowOptions : {})
                    , id = renderer.shadowDefinition(options);
                return this.attr({
                    filter: shadowOptions ? `url(${renderer.url}#${id})` : 'none'
                })
            }
            show(inherit=!0) {
                return this.attr({
                    visibility: inherit ? 'inherit' : 'visible'
                })
            }
            'stroke-widthSetter'(value, key, element) {
                this[key] = value;
                element.setAttribute(key, value)
            }
            strokeWidth() {
                if (!this.renderer.styledMode) {
                    return this['stroke-width'] || 0
                }
                const val = this.getStyle('stroke-width');
                let ret = 0, dummy;
                if (val.indexOf('px') === val.length - 2) {
                    ret = pInt(val)
                } else if (val !== '') {
                    dummy = doc.createElementNS(SVG_NS, 'rect');
                    attr(dummy, {
                        width: val,
                        'stroke-width': 0
                    });
                    this.element.parentNode.appendChild(dummy);
                    ret = dummy.getBBox().width;
                    dummy.parentNode.removeChild(dummy)
                }
                return ret
            }
            symbolAttr(hash) {
                const wrapper = this;
                SVGElement.symbolCustomAttribs.forEach(function(key) {
                    wrapper[key] = pick(hash[key], wrapper[key])
                });
                wrapper.attr({
                    d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
                })
            }
            textSetter(value) {
                if (value !== this.textStr) {
                    delete this.textPxLength;
                    this.textStr = value;
                    if (this.added) {
                        this.renderer.buildText(this)
                    }
                }
            }
            titleSetter(value) {
                const el = this.element;
                const titleNode = el.getElementsByTagName('title')[0] || doc.createElementNS(this.SVG_NS, 'title');
                if (el.insertBefore) {
                    el.insertBefore(titleNode, el.firstChild)
                } else {
                    el.appendChild(titleNode)
                }
                titleNode.textContent = String(pick(value, '')).replace(/<[^>]*>/g, '').replace(/&lt;/g, '<').replace(/&gt;/g, '>')
            }
            toFront() {
                const element = this.element;
                element.parentNode.appendChild(element);
                return this
            }
            translate(x, y) {
                return this.attr({
                    translateX: x,
                    translateY: y
                })
            }
            updateTransform() {
                const {element, matrix, rotation=0, scaleX, scaleY, translateX=0, translateY=0} = this;
                const transform = ['translate(' + translateX + ',' + translateY + ')'];
                if (defined(matrix)) {
                    transform.push('matrix(' + matrix.join(',') + ')')
                }
                if (rotation) {
                    transform.push('rotate(' + rotation + ' ' + pick(this.rotationOriginX, element.getAttribute('x'), 0) + ' ' + pick(this.rotationOriginY, element.getAttribute('y') || 0) + ')')
                }
                if (defined(scaleX) || defined(scaleY)) {
                    transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')')
                }
                if (transform.length && !(this.text || this).textPath) {
                    element.setAttribute('transform', transform.join(' '))
                }
            }
            visibilitySetter(value, key, element) {
                if (value === 'inherit') {
                    element.removeAttribute(key)
                } else if (this[key] !== value) {
                    element.setAttribute(key, value)
                }
                this[key] = value
            }
            xGetter(key) {
                if (this.element.nodeName === 'circle') {
                    if (key === 'x') {
                        key = 'cx'
                    } else if (key === 'y') {
                        key = 'cy'
                    }
                }
                return this._defaultGetter(key)
            }
            zIndexSetter(value, key) {
                const renderer = this.renderer
                    , parentGroup = this.parentGroup
                    , parentWrapper = parentGroup || renderer
                    , parentNode = parentWrapper.element || renderer.box
                    , element = this.element
                    , svgParent = parentNode === renderer.box;
                let childNodes, otherElement, otherZIndex, inserted = !1, undefinedOtherZIndex, run = this.added, i;
                if (defined(value)) {
                    element.setAttribute('data-z-index', value);
                    value = +value;
                    if (this[key] === value) {
                        run = !1
                    }
                } else if (defined(this[key])) {
                    element.removeAttribute('data-z-index')
                }
                this[key] = value;
                if (run) {
                    value = this.zIndex;
                    if (value && parentGroup) {
                        parentGroup.handleZ = !0
                    }
                    childNodes = parentNode.childNodes;
                    for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
                        otherElement = childNodes[i];
                        otherZIndex = otherElement.getAttribute('data-z-index');
                        undefinedOtherZIndex = !defined(otherZIndex);
                        if (otherElement !== element) {
                            if (value < 0 && undefinedOtherZIndex && !svgParent && !i) {
                                parentNode.insertBefore(element, childNodes[i]);
                                inserted = !0
                            } else if (pInt(otherZIndex) <= value || (undefinedOtherZIndex && (!defined(value) || value >= 0))) {
                                parentNode.insertBefore(element, childNodes[i + 1]);
                                inserted = !0
                            }
                        }
                    }
                    if (!inserted) {
                        parentNode.insertBefore(element, childNodes[svgParent ? 3 : 0]);
                        inserted = !0
                    }
                }
                return inserted
            }
        }
        SVGElement.symbolCustomAttribs = ['anchorX', 'anchorY', 'clockwise', 'end', 'height', 'innerR', 'r', 'start', 'width', 'x', 'y'];
        SVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;
        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
        SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
            this[key] = value;
            this.doTransform = !0
        }
        ;
        '';
        return SVGElement
    });
    _registerModule(_modules, 'Core/Renderer/RendererRegistry.js', [_modules['Core/Globals.js']], function(H) {
        var RendererRegistry;
        (function(RendererRegistry) {
                RendererRegistry.rendererTypes = {};
                let defaultRenderer;
                function getRendererType(rendererType=defaultRenderer) {
                    return (RendererRegistry.rendererTypes[rendererType] || RendererRegistry.rendererTypes[defaultRenderer])
                }
                RendererRegistry.getRendererType = getRendererType;
                function registerRendererType(rendererType, rendererClass, setAsDefault) {
                    RendererRegistry.rendererTypes[rendererType] = rendererClass;
                    if (!defaultRenderer || setAsDefault) {
                        defaultRenderer = rendererType;
                        H.Renderer = rendererClass
                    }
                }
                RendererRegistry.registerRendererType = registerRendererType
            }
        )(RendererRegistry || (RendererRegistry = {}));
        return RendererRegistry
    });
    _registerModule(_modules, 'Core/Renderer/SVG/SVGLabel.js', [_modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function(SVGElement, U) {
        const {defined, extend, isNumber, merge, pick, removeEvent} = U;
        class SVGLabel extends SVGElement {
            constructor(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
                super();
                this.paddingLeftSetter = this.paddingSetter;
                this.paddingRightSetter = this.paddingSetter;
                this.init(renderer, 'g');
                this.textStr = str;
                this.x = x;
                this.y = y;
                this.anchorX = anchorX;
                this.anchorY = anchorY;
                this.baseline = baseline;
                this.className = className;
                this.addClass(className === 'button' ? 'highcharts-no-tooltip' : 'highcharts-label');
                if (className) {
                    this.addClass('highcharts-' + className)
                }
                this.text = renderer.text(void 0, 0, 0, useHTML).attr({
                    zIndex: 1
                });
                let hasBGImage;
                if (typeof shape === 'string') {
                    hasBGImage = /^url\((.*?)\)$/.test(shape);
                    if (hasBGImage || this.renderer.symbols[shape]) {
                        this.symbolKey = shape
                    }
                }
                this.bBox = SVGLabel.emptyBBox;
                this.padding = 3;
                this.baselineOffset = 0;
                this.needsBox = renderer.styledMode || hasBGImage;
                this.deferredAttr = {};
                this.alignFactor = 0
            }
            alignSetter(value) {
                const alignFactor = ({
                    left: 0,
                    center: 0.5,
                    right: 1
                })[value];
                if (alignFactor !== this.alignFactor) {
                    this.alignFactor = alignFactor;
                    if (this.bBox && isNumber(this.xSetting)) {
                        this.attr({
                            x: this.xSetting
                        })
                    }
                }
            }
            anchorXSetter(value, key) {
                this.anchorX = value;
                this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting)
            }
            anchorYSetter(value, key) {
                this.anchorY = value;
                this.boxAttr(key, value - this.ySetting)
            }
            boxAttr(key, value) {
                if (this.box) {
                    this.box.attr(key, value)
                } else {
                    this.deferredAttr[key] = value
                }
            }
            css(styles) {
                if (styles) {
                    const textStyles = {};
                    styles = merge(styles);
                    SVGLabel.textProps.forEach( (prop) => {
                            if (typeof styles[prop] !== 'undefined') {
                                textStyles[prop] = styles[prop];
                                delete styles[prop]
                            }
                        }
                    );
                    this.text.css(textStyles);
                    if ('fontSize'in textStyles || 'fontWeight'in textStyles) {
                        this.updateTextPadding()
                    } else if ('width'in textStyles || 'textOverflow'in textStyles) {
                        this.updateBoxSize()
                    }
                }
                return SVGElement.prototype.css.call(this, styles)
            }
            destroy() {
                removeEvent(this.element, 'mouseenter');
                removeEvent(this.element, 'mouseleave');
                if (this.text) {
                    this.text.destroy()
                }
                if (this.box) {
                    this.box = this.box.destroy()
                }
                SVGElement.prototype.destroy.call(this);
                return void 0
            }
            fillSetter(value, key) {
                if (value) {
                    this.needsBox = !0
                }
                this.fill = value;
                this.boxAttr(key, value)
            }
            getBBox() {
                if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
                    this.updateBoxSize()
                }
                const padding = this.padding;
                const paddingLeft = pick(this.paddingLeft, padding);
                return {
                    width: this.width || 0,
                    height: this.height || 0,
                    x: this.bBox.x - paddingLeft,
                    y: this.bBox.y - padding
                }
            }
            getCrispAdjust() {
                return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this['stroke-width'] ? parseInt(this['stroke-width'], 10) : 0) % 2 / 2
            }
            heightSetter(value) {
                this.heightSetting = value
            }
            onAdd() {
                this.text.add(this);
                this.attr({
                    text: pick(this.textStr, ''),
                    x: this.x || 0,
                    y: this.y || 0
                });
                if (this.box && defined(this.anchorX)) {
                    this.attr({
                        anchorX: this.anchorX,
                        anchorY: this.anchorY
                    })
                }
            }
            paddingSetter(value, key) {
                if (!isNumber(value)) {
                    this[key] = void 0
                } else if (value !== this[key]) {
                    this[key] = value;
                    this.updateTextPadding()
                }
            }
            rSetter(value, key) {
                this.boxAttr(key, value)
            }
            strokeSetter(value, key) {
                this.stroke = value;
                this.boxAttr(key, value)
            }
            'stroke-widthSetter'(value, key) {
                if (value) {
                    this.needsBox = !0
                }
                this['stroke-width'] = value;
                this.boxAttr(key, value)
            }
            'text-alignSetter'(value) {
                this.textAlign = value
            }
            textSetter(text) {
                if (typeof text !== 'undefined') {
                    this.text.attr({
                        text
                    })
                }
                this.updateTextPadding()
            }
            updateBoxSize() {
                const text = this.text
                    , attribs = {}
                    , padding = this.padding
                    , bBox = this.bBox = (((!isNumber(this.widthSetting) || !isNumber(this.heightSetting) || this.textAlign) && defined(text.textStr)) ? text.getBBox() : SVGLabel.emptyBBox);
                let crispAdjust;
                this.width = this.getPaddedWidth();
                this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
                const metrics = this.renderer.fontMetrics(text);
                this.baselineOffset = padding + Math.min((this.text.firstLineMetrics || metrics).b, bBox.height || Infinity);
                if (this.heightSetting) {
                    this.baselineOffset += (this.heightSetting - metrics.h) / 2
                }
                if (this.needsBox && !text.textPath) {
                    if (!this.box) {
                        const box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                        box.addClass((this.className === 'button' ? '' : 'highcharts-label-box') + (this.className ? ' highcharts-' + this.className + '-box' : ''));
                        box.add(this)
                    }
                    crispAdjust = this.getCrispAdjust();
                    attribs.x = crispAdjust;
                    attribs.y = ((this.baseline ? -this.baselineOffset : 0) + crispAdjust);
                    attribs.width = Math.round(this.width);
                    attribs.height = Math.round(this.height);
                    this.box.attr(extend(attribs, this.deferredAttr));
                    this.deferredAttr = {}
                }
            }
            updateTextPadding() {
                const text = this.text;
                if (!text.textPath) {
                    this.updateBoxSize();
                    const textY = this.baseline ? 0 : this.baselineOffset;
                    let textX = pick(this.paddingLeft, this.padding);
                    if (defined(this.widthSetting) && this.bBox && (this.textAlign === 'center' || this.textAlign === 'right')) {
                        textX += {
                            center: 0.5,
                            right: 1
                        }[this.textAlign] * (this.widthSetting - this.bBox.width)
                    }
                    if (textX !== text.x || textY !== text.y) {
                        text.attr('x', textX);
                        if (text.hasBoxWidthChanged) {
                            this.bBox = text.getBBox(!0)
                        }
                        if (typeof textY !== 'undefined') {
                            text.attr('y', textY)
                        }
                    }
                    text.x = textX;
                    text.y = textY
                }
            }
            widthSetter(value) {
                this.widthSetting = isNumber(value) ? value : void 0
            }
            getPaddedWidth() {
                const padding = this.padding;
                const paddingLeft = pick(this.paddingLeft, padding);
                const paddingRight = pick(this.paddingRight, padding);
                return ((this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight)
            }
            xSetter(value) {
                this.x = value;
                if (this.alignFactor) {
                    value -= this.alignFactor * this.getPaddedWidth();
                    this['forceAnimate:x'] = !0
                }
                this.xSetting = Math.round(value);
                this.attr('translateX', this.xSetting)
            }
            ySetter(value) {
                this.ySetting = this.y = Math.round(value);
                this.attr('translateY', this.ySetting)
            }
        }
        SVGLabel.emptyBBox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };
        SVGLabel.textProps = ['color', 'direction', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'lineHeight', 'textAlign', 'textDecoration', 'textOutline', 'textOverflow', 'whiteSpace', 'width'];
        return SVGLabel
    });
    _registerModule(_modules, 'Core/Renderer/SVG/Symbols.js', [_modules['Core/Utilities.js']], function(U) {
        const {defined, isNumber, pick} = U;
        function arc(cx, cy, w, h, options) {
            const arc = [];
            if (options) {
                const start = options.start || 0
                    , rx = pick(options.r, w)
                    , ry = pick(options.r, h || w)
                    , proximity = 0.001
                    , fullCircle = (Math.abs((options.end || 0) - start - 2 * Math.PI) < proximity)
                    , end = (options.end || 0) - proximity
                    , innerRadius = options.innerR
                    , open = pick(options.open, fullCircle)
                    , cosStart = Math.cos(start)
                    , sinStart = Math.sin(start)
                    , cosEnd = Math.cos(end)
                    , sinEnd = Math.sin(end)
                    , longArc = pick(options.longArc, end - start - Math.PI < proximity ? 0 : 1);
                let arcSegment = ['A', rx, ry, 0, longArc, pick(options.clockwise, 1), cx + rx * cosEnd, cy + ry * sinEnd];
                arcSegment.params = {
                    start,
                    end,
                    cx,
                    cy
                };
                arc.push(['M', cx + rx * cosStart, cy + ry * sinStart], arcSegment);
                if (defined(innerRadius)) {
                    arcSegment = ['A', innerRadius, innerRadius, 0, longArc, defined(options.clockwise) ? 1 - options.clockwise : 0, cx + innerRadius * cosStart, cy + innerRadius * sinStart];
                    arcSegment.params = {
                        start: end,
                        end: start,
                        cx,
                        cy
                    };
                    arc.push(open ? ['M', cx + innerRadius * cosEnd, cy + innerRadius * sinEnd] : ['L', cx + innerRadius * cosEnd, cy + innerRadius * sinEnd], arcSegment)
                }
                if (!open) {
                    arc.push(['Z'])
                }
            }
            return arc
        }
        function callout(x, y, w, h, options) {
            const arrowLength = 6
                , halfDistance = 6
                , r = Math.min((options && options.r) || 0, w, h)
                , safeDistance = r + halfDistance
                , anchorX = options && options.anchorX
                , anchorY = options && options.anchorY || 0;
            const path = roundedRect(x, y, w, h, {
                r
            });
            if (!isNumber(anchorX)) {
                return path
            }
            if (anchorX < w && anchorX > 0 && anchorY < h && anchorY > 0) {
                return path
            }
            if (x + anchorX > w - safeDistance) {
                if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
                    path.splice(3, 1, ['L', x + w, anchorY - halfDistance], ['L', x + w + arrowLength, anchorY], ['L', x + w, anchorY + halfDistance], ['L', x + w, y + h - r])
                } else {
                    if (anchorX < w) {
                        const isTopCorner = anchorY < y + safeDistance
                            , cornerY = isTopCorner ? y : y + h
                            , sliceStart = isTopCorner ? 2 : 5;
                        path.splice(sliceStart, 0, ['L', anchorX, anchorY], ['L', x + w - r, cornerY])
                    } else {
                        path.splice(3, 1, ['L', x + w, h / 2], ['L', anchorX, anchorY], ['L', x + w, h / 2], ['L', x + w, y + h - r])
                    }
                }
            } else if (x + anchorX < safeDistance) {
                if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {
                    path.splice(7, 1, ['L', x, anchorY + halfDistance], ['L', x - arrowLength, anchorY], ['L', x, anchorY - halfDistance], ['L', x, y + r])
                } else {
                    if (anchorX > 0) {
                        const isTopCorner = anchorY < y + safeDistance
                            , cornerY = isTopCorner ? y : y + h
                            , sliceStart = isTopCorner ? 1 : 6;
                        path.splice(sliceStart, 0, ['L', anchorX, anchorY], ['L', x + r, cornerY])
                    } else {
                        path.splice(7, 1, ['L', x, h / 2], ['L', anchorX, anchorY], ['L', x, h / 2], ['L', x, y + r])
                    }
                }
            } else if (anchorY > h && anchorX < w - safeDistance) {
                path.splice(5, 1, ['L', anchorX + halfDistance, y + h], ['L', anchorX, y + h + arrowLength], ['L', anchorX - halfDistance, y + h], ['L', x + r, y + h])
            } else if (anchorY < 0 && anchorX > safeDistance) {
                path.splice(1, 1, ['L', anchorX - halfDistance, y], ['L', anchorX, y - arrowLength], ['L', anchorX + halfDistance, y], ['L', w - r, y])
            }
            return path
        }
        function circle(x, y, w, h) {
            return arc(x + w / 2, y + h / 2, w / 2, h / 2, {
                start: Math.PI * 0.5,
                end: Math.PI * 2.5,
                open: !1
            })
        }
        function diamond(x, y, w, h) {
            return [['M', x + w / 2, y], ['L', x + w, y + h / 2], ['L', x + w / 2, y + h], ['L', x, y + h / 2], ['Z']]
        }
        function rect(x, y, w, h, options) {
            if (options && options.r) {
                return roundedRect(x, y, w, h, options)
            }
            return [['M', x, y], ['L', x + w, y], ['L', x + w, y + h], ['L', x, y + h], ['Z']]
        }
        function roundedRect(x, y, w, h, options) {
            const r = options?.r || 0;
            return [['M', x + r, y], ['L', x + w - r, y], ['A', r, r, 0, 0, 1, x + w, y + r], ['L', x + w, y + h - r], ['A', r, r, 0, 0, 1, x + w - r, y + h], ['L', x + r, y + h], ['A', r, r, 0, 0, 1, x, y + h - r], ['L', x, y + r], ['A', r, r, 0, 0, 1, x + r, y], ['Z']]
        }
        function triangle(x, y, w, h) {
            return [['M', x + w / 2, y], ['L', x + w, y + h], ['L', x, y + h], ['Z']]
        }
        function triangleDown(x, y, w, h) {
            return [['M', x, y], ['L', x + w, y], ['L', x + w / 2, y + h], ['Z']]
        }
        const Symbols = {
            arc,
            callout,
            circle,
            diamond,
            rect,
            roundedRect,
            square: rect,
            triangle,
            'triangle-down': triangleDown
        };
        return Symbols
    });
    _registerModule(_modules, 'Core/Renderer/SVG/TextBuilder.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(AST, H, U) {
        const {doc, SVG_NS, win} = H;
        const {attr, extend, fireEvent, isString, objectEach, pick} = U;
        class TextBuilder {
            constructor(svgElement) {
                const textStyles = svgElement.styles;
                this.renderer = svgElement.renderer;
                this.svgElement = svgElement;
                this.width = svgElement.textWidth;
                this.textLineHeight = textStyles && textStyles.lineHeight;
                this.textOutline = textStyles && textStyles.textOutline;
                this.ellipsis = Boolean(textStyles && textStyles.textOverflow === 'ellipsis');
                this.noWrap = Boolean(textStyles && textStyles.whiteSpace === 'nowrap')
            }
            buildSVG() {
                const wrapper = this.svgElement
                    , textNode = wrapper.element
                    , renderer = wrapper.renderer
                    , textStr = pick(wrapper.textStr, '').toString()
                    , hasMarkup = textStr.indexOf('<') !== -1
                    , childNodes = textNode.childNodes
                    , tempParent = !wrapper.added && renderer.box
                    , regexMatchBreaks = /<br.*?>/g
                    , textCache = [textStr, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, wrapper.getStyle('font-size'), this.width].join(',');
                if (textCache === wrapper.textCache) {
                    return
                }
                wrapper.textCache = textCache;
                delete wrapper.actualWidth;
                for (let i = childNodes.length; i--; ) {
                    textNode.removeChild(childNodes[i])
                }
                if (!hasMarkup && !this.ellipsis && !this.width && !wrapper.textPath && (textStr.indexOf(' ') === -1 || (this.noWrap && !regexMatchBreaks.test(textStr)))) {
                    textNode.appendChild(doc.createTextNode(this.unescapeEntities(textStr)))
                } else if (textStr !== '') {
                    if (tempParent) {
                        tempParent.appendChild(textNode)
                    }
                    const ast = new AST(textStr);
                    this.modifyTree(ast.nodes);
                    ast.addToDOM(textNode);
                    this.modifyDOM();
                    if (this.ellipsis && (textNode.textContent || '').indexOf('\u2026') !== -1) {
                        wrapper.attr('title', this.unescapeEntities(wrapper.textStr || '', ['&lt;', '&gt;']))
                    }
                    if (tempParent) {
                        tempParent.removeChild(textNode)
                    }
                }
                if (isString(this.textOutline) && wrapper.applyTextOutline) {
                    wrapper.applyTextOutline(this.textOutline)
                }
            }
            modifyDOM() {
                const wrapper = this.svgElement;
                const x = attr(wrapper.element, 'x');
                wrapper.firstLineMetrics = void 0;
                let firstChild;
                while ((firstChild = wrapper.element.firstChild)) {
                    if (/^[\s\u200B]*$/.test(firstChild.textContent || ' ')) {
                        wrapper.element.removeChild(firstChild)
                    } else {
                        break
                    }
                }
                [].forEach.call(wrapper.element.querySelectorAll('tspan.highcharts-br'), (br, i) => {
                        if (br.nextSibling && br.previousSibling) {
                            if (i === 0 && br.previousSibling.nodeType === 1) {
                                wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(br.previousSibling)
                            }
                            attr(br, {
                                dy: this.getLineHeight(br.nextSibling),
                                x
                            })
                        }
                    }
                );
                const width = this.width || 0;
                if (!width) {
                    return
                }
                const modifyTextNode = (textNode, parentElement) => {
                        const text = textNode.textContent || '';
                        const words = text.replace(/([^\^])-/g, '$1- ').split(' ');
                        const hasWhiteSpace = !this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
                        const dy = this.getLineHeight(parentElement);
                        let lineNo = 0;
                        let startAt = wrapper.actualWidth;
                        if (this.ellipsis) {
                            if (text) {
                                this.truncate(textNode, text, void 0, 0, Math.max(0, width - 0.8 * dy), (text, currentIndex) => text.substring(0, currentIndex) + '\u2026')
                            }
                        } else if (hasWhiteSpace) {
                            const lines = [];
                            const precedingSiblings = [];
                            while (parentElement.firstChild && parentElement.firstChild !== textNode) {
                                precedingSiblings.push(parentElement.firstChild);
                                parentElement.removeChild(parentElement.firstChild)
                            }
                            while (words.length) {
                                if (words.length && !this.noWrap && lineNo > 0) {
                                    lines.push(textNode.textContent || '');
                                    textNode.textContent = words.join(' ').replace(/- /g, '-')
                                }
                                this.truncate(textNode, void 0, words, lineNo === 0 ? (startAt || 0) : 0, width, (t, currentIndex) => words.slice(0, currentIndex).join(' ').replace(/- /g, '-'));
                                startAt = wrapper.actualWidth;
                                lineNo++
                            }
                            precedingSiblings.forEach( (childNode) => {
                                    parentElement.insertBefore(childNode, textNode)
                                }
                            );
                            lines.forEach( (line) => {
                                    parentElement.insertBefore(doc.createTextNode(line), textNode);
                                    const br = doc.createElementNS(SVG_NS, 'tspan');
                                    br.textContent = '\u200B';
                                    attr(br, {
                                        dy,
                                        x
                                    });
                                    parentElement.insertBefore(br, textNode)
                                }
                            )
                        }
                    }
                ;
                const modifyChildren = ( (node) => {
                        const childNodes = [].slice.call(node.childNodes);
                        childNodes.forEach( (childNode) => {
                                if (childNode.nodeType === win.Node.TEXT_NODE) {
                                    modifyTextNode(childNode, node)
                                } else {
                                    if (childNode.className.baseVal.indexOf('highcharts-br') !== -1) {
                                        wrapper.actualWidth = 0
                                    }
                                    modifyChildren(childNode)
                                }
                            }
                        )
                    }
                );
                modifyChildren(wrapper.element)
            }
            getLineHeight(node) {
                const element = (node.nodeType === win.Node.TEXT_NODE) ? node.parentElement : node;
                return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(element || this.svgElement.element).h
            }
            modifyTree(nodes) {
                const modifyChild = (node, i) => {
                        const {attributes={}, children, style={}, tagName} = node
                            , styledMode = this.renderer.styledMode;
                        if (tagName === 'b' || tagName === 'strong') {
                            if (styledMode) {
                                attributes['class'] = 'highcharts-strong'
                            } else {
                                style.fontWeight = 'bold'
                            }
                        } else if (tagName === 'i' || tagName === 'em') {
                            if (styledMode) {
                                attributes['class'] = 'highcharts-emphasized'
                            } else {
                                style.fontStyle = 'italic'
                            }
                        }
                        if (style && style.color) {
                            style.fill = style.color
                        }
                        if (tagName === 'br') {
                            attributes['class'] = 'highcharts-br';
                            node.textContent = '\u200B';
                            const nextNode = nodes[i + 1];
                            if (nextNode && nextNode.textContent) {
                                nextNode.textContent = nextNode.textContent.replace(/^ +/gm, '')
                            }
                        } else if (tagName === 'a' && children && children.some( (child) => child.tagName === '#text')) {
                            node.children = [{
                                children,
                                tagName: 'tspan'
                            }]
                        }
                        if (tagName !== '#text' && tagName !== 'a') {
                            node.tagName = 'tspan'
                        }
                        extend(node, {
                            attributes,
                            style
                        });
                        if (children) {
                            children.filter( (c) => c.tagName !== '#text').forEach(modifyChild)
                        }
                    }
                ;
                nodes.forEach(modifyChild);
                fireEvent(this.svgElement, 'afterModifyTree', {
                    nodes
                })
            }
            truncate(textNode, text, words, startAt, width, getString) {
                const svgElement = this.svgElement;
                const {renderer, rotation} = svgElement;
                const lengths = [];
                let minIndex = words ? 1 : 0;
                let maxIndex = (text || words || '').length;
                let currentIndex = maxIndex;
                let str;
                let actualWidth;
                const getSubStringLength = function(charEnd, concatenatedEnd) {
                    const end = concatenatedEnd || charEnd;
                    const parentNode = textNode.parentNode;
                    if (parentNode && typeof lengths[end] === 'undefined') {
                        if (parentNode.getSubStringLength) {
                            try {
                                lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end)
                            } catch (e) {
                                ''
                            }
                        }
                    }
                    return lengths[end]
                };
                svgElement.rotation = 0;
                actualWidth = getSubStringLength(textNode.textContent.length);
                if (startAt + actualWidth > width) {
                    while (minIndex <= maxIndex) {
                        currentIndex = Math.ceil((minIndex + maxIndex) / 2);
                        if (words) {
                            str = getString(words, currentIndex)
                        }
                        actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
                        if (minIndex === maxIndex) {
                            minIndex = maxIndex + 1
                        } else if (actualWidth > width) {
                            maxIndex = currentIndex - 1
                        } else {
                            minIndex = currentIndex
                        }
                    }
                    if (maxIndex === 0) {
                        textNode.textContent = ''
                    } else if (!(text && maxIndex === text.length - 1)) {
                        textNode.textContent = str || getString(text || words, currentIndex)
                    }
                }
                if (words) {
                    words.splice(0, currentIndex)
                }
                svgElement.actualWidth = actualWidth;
                svgElement.rotation = rotation
            }
            unescapeEntities(inputStr, except) {
                objectEach(this.renderer.escapes, function(value, key) {
                    if (!except || except.indexOf(value) === -1) {
                        inputStr = inputStr.toString().replace(new RegExp(value,'g'), key)
                    }
                });
                return inputStr
            }
        }
        return TextBuilder
    });
    _registerModule(_modules, 'Core/Renderer/SVG/SVGRenderer.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Renderer/SVG/SVGLabel.js'], _modules['Core/Renderer/SVG/Symbols.js'], _modules['Core/Renderer/SVG/TextBuilder.js'], _modules['Core/Utilities.js']], function(AST, Color, H, RendererRegistry, SVGElement, SVGLabel, Symbols, TextBuilder, U) {
        const {charts, deg2rad, doc, isFirefox, isMS, isWebKit, noop, SVG_NS, symbolSizes, win} = H;
        const {addEvent, attr, createElement, css, defined, destroyObjectProperties, extend, isArray, isNumber, isObject, isString, merge, pick, pInt, uniqueKey} = U;
        let hasInternalReferenceBug;
        class SVGRenderer {
            constructor(container, width, height, style, forExport, allowHTML, styledMode) {
                this.alignedObjects = void 0;
                this.box = void 0;
                this.boxWrapper = void 0;
                this.cache = void 0;
                this.cacheKeys = void 0;
                this.chartIndex = void 0;
                this.defs = void 0;
                this.globalAnimation = void 0;
                this.gradients = void 0;
                this.height = void 0;
                this.imgCount = void 0;
                this.style = void 0;
                this.url = void 0;
                this.width = void 0;
                this.init(container, width, height, style, forExport, allowHTML, styledMode)
            }
            init(container, width, height, style, forExport, allowHTML, styledMode) {
                const renderer = this
                    , boxWrapper = renderer.createElement('svg').attr({
                    version: '1.1',
                    'class': 'highcharts-root'
                })
                    , element = boxWrapper.element;
                if (!styledMode) {
                    boxWrapper.css(this.getStyle(style))
                }
                container.appendChild(element);
                attr(container, 'dir', 'ltr');
                if (container.innerHTML.indexOf('xmlns') === -1) {
                    attr(element, 'xmlns', this.SVG_NS)
                }
                this.box = element;
                this.boxWrapper = boxWrapper;
                renderer.alignedObjects = [];
                this.url = this.getReferenceURL();
                const desc = this.createElement('desc').add();
                desc.element.appendChild(doc.createTextNode('Created with Highcharts 11.2.0'));
                renderer.defs = this.createElement('defs').add();
                renderer.allowHTML = allowHTML;
                renderer.forExport = forExport;
                renderer.styledMode = styledMode;
                renderer.gradients = {};
                renderer.cache = {};
                renderer.cacheKeys = [];
                renderer.imgCount = 0;
                renderer.rootFontSize = boxWrapper.getStyle('font-size');
                renderer.setSize(width, height, !1);
                let subPixelFix, rect;
                if (isFirefox && container.getBoundingClientRect) {
                    subPixelFix = function() {
                        css(container, {
                            left: 0,
                            top: 0
                        });
                        rect = container.getBoundingClientRect();
                        css(container, {
                            left: (Math.ceil(rect.left) - rect.left) + 'px',
                            top: (Math.ceil(rect.top) - rect.top) + 'px'
                        })
                    }
                    ;
                    subPixelFix();
                    renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix)
                }
            }
            definition(def) {
                const ast = new AST([def]);
                return ast.addToDOM(this.defs.element)
            }
            getReferenceURL() {
                if ((isFirefox || isWebKit) && doc.getElementsByTagName('base').length) {
                    if (!defined(hasInternalReferenceBug)) {
                        const id = uniqueKey();
                        const ast = new AST([{
                            tagName: 'svg',
                            attributes: {
                                width: 8,
                                height: 8
                            },
                            children: [{
                                tagName: 'defs',
                                children: [{
                                    tagName: 'clipPath',
                                    attributes: {
                                        id
                                    },
                                    children: [{
                                        tagName: 'rect',
                                        attributes: {
                                            width: 4,
                                            height: 4
                                        }
                                    }]
                                }]
                            }, {
                                tagName: 'rect',
                                attributes: {
                                    id: 'hitme',
                                    width: 8,
                                    height: 8,
                                    'clip-path': `url(#${id})`,
                                    fill: 'rgba(0,0,0,0.001)'
                                }
                            }]
                        }]);
                        const svg = ast.addToDOM(doc.body);
                        css(svg, {
                            position: 'fixed',
                            top: 0,
                            left: 0,
                            zIndex: 9e5
                        });
                        const hitElement = doc.elementFromPoint(6, 6);
                        hasInternalReferenceBug = (hitElement && hitElement.id) === 'hitme';
                        doc.body.removeChild(svg)
                    }
                    if (hasInternalReferenceBug) {
                        return win.location.href.split('#')[0].replace(/<[^>]*>/g, '').replace(/([\('\)])/g, '\\$1').replace(/ /g, '%20')
                    }
                }
                return ''
            }
            getStyle(style) {
                this.style = extend({
                    fontFamily: 'Helvetica, Arial, sans-serif',
                    fontSize: '1rem'
                }, style);
                return this.style
            }
            setStyle(style) {
                this.boxWrapper.css(this.getStyle(style))
            }
            isHidden() {
                return !this.boxWrapper.getBBox().width
            }
            destroy() {
                const renderer = this
                    , rendererDefs = renderer.defs;
                renderer.box = null;
                renderer.boxWrapper = renderer.boxWrapper.destroy();
                destroyObjectProperties(renderer.gradients || {});
                renderer.gradients = null;
                renderer.defs = rendererDefs.destroy();
                if (renderer.unSubPixelFix) {
                    renderer.unSubPixelFix()
                }
                renderer.alignedObjects = null;
                return null
            }
            createElement(nodeName) {
                const wrapper = new this.Element();
                wrapper.init(this, nodeName);
                return wrapper
            }
            getRadialAttr(radialReference, gradAttr) {
                return {
                    cx: (radialReference[0] - radialReference[2] / 2) + (gradAttr.cx || 0) * radialReference[2],
                    cy: (radialReference[1] - radialReference[2] / 2) + (gradAttr.cy || 0) * radialReference[2],
                    r: (gradAttr.r || 0) * radialReference[2]
                }
            }
            shadowDefinition(shadowOptions) {
                const id = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys(shadowOptions).map( (key) => `${key}-${shadowOptions[key]}`)].join('-').toLowerCase().replace(/[^a-z0-9\-]/g, '')
                    , options = merge({
                    color: '#000000',
                    offsetX: 1,
                    offsetY: 1,
                    opacity: 0.15,
                    width: 5
                }, shadowOptions);
                if (!this.defs.element.querySelector(`#${id}`)) {
                    this.definition({
                        tagName: 'filter',
                        attributes: {
                            id,
                            filterUnits: options.filterUnits
                        },
                        children: [{
                            tagName: 'feDropShadow',
                            attributes: {
                                dx: options.offsetX,
                                dy: options.offsetY,
                                'flood-color': options.color,
                                'flood-opacity': Math.min(options.opacity * 5, 1),
                                stdDeviation: options.width / 2
                            }
                        }]
                    })
                }
                return id
            }
            buildText(wrapper) {
                new TextBuilder(wrapper).buildSVG()
            }
            getContrast(color) {
                const rgba = Color.parse(color).rgba.map( (b8) => {
                        const c = b8 / 255;
                        return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
                    }
                );
                const l = 0.2126 * rgba[0] + 0.7152 * rgba[1] + 0.0722 * rgba[2];
                return 1.05 / (l + 0.05) > (l + 0.05) / 0.05 ? '#FFFFFF' : '#000000'
            }
            button(text, x, y, callback, theme={}, hoverState, selectState, disabledState, shape, useHTML) {
                const label = this.label(text, x, y, shape, void 0, void 0, useHTML, void 0, 'button')
                    , styledMode = this.styledMode
                    , states = theme.states || {};
                let curState = 0;
                theme = merge(theme);
                delete theme.states;
                const normalStyle = merge({
                    color: "#333333",
                    cursor: 'pointer',
                    fontSize: '0.8em',
                    fontWeight: 'normal'
                }, theme.style);
                delete theme.style;
                let normalState = AST.filterUserAttributes(theme);
                label.attr(merge({
                    padding: 8,
                    r: 2
                }, normalState));
                let hoverStyle, selectStyle, disabledStyle;
                if (!styledMode) {
                    normalState = merge({
                        fill: "#f7f7f7",
                        stroke: "#cccccc",
                        'stroke-width': 1
                    }, normalState);
                    hoverState = merge(normalState, {
                        fill: "#e6e6e6"
                    }, AST.filterUserAttributes(hoverState || states.hover || {}));
                    hoverStyle = hoverState.style;
                    delete hoverState.style;
                    selectState = merge(normalState, {
                        fill: "#e6e9ff",
                        style: {
                            color: "#000000",
                            fontWeight: 'bold'
                        }
                    }, AST.filterUserAttributes(selectState || states.select || {}));
                    selectStyle = selectState.style;
                    delete selectState.style;
                    disabledState = merge(normalState, {
                        style: {
                            color: "#cccccc"
                        }
                    }, AST.filterUserAttributes(disabledState || states.disabled || {}));
                    disabledStyle = disabledState.style;
                    delete disabledState.style
                }
                addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function() {
                    if (curState !== 3) {
                        label.setState(1)
                    }
                });
                addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function() {
                    if (curState !== 3) {
                        label.setState(curState)
                    }
                });
                label.setState = function(state) {
                    if (state !== 1) {
                        label.state = curState = state
                    }
                    label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);
                    if (!styledMode) {
                        label.attr([normalState, hoverState, selectState, disabledState][state || 0]);
                        const css = [normalStyle, hoverStyle, selectStyle, disabledStyle][state || 0];
                        if (isObject(css)) {
                            label.css(css)
                        }
                    }
                }
                ;
                if (!styledMode) {
                    label.attr(normalState).css(extend({
                        cursor: 'default'
                    }, normalStyle));
                    if (useHTML) {
                        label.text.css({
                            pointerEvents: 'none'
                        })
                    }
                }
                return label.on('touchstart', (e) => e.stopPropagation()).on('click', function(e) {
                    if (curState !== 3) {
                        callback.call(label, e)
                    }
                })
            }
            crispLine(points, width, roundingFunction='round') {
                const start = points[0];
                const end = points[1];
                if (defined(start[1]) && start[1] === end[1]) {
                    start[1] = end[1] = Math[roundingFunction](start[1]) - (width % 2 / 2)
                }
                if (defined(start[2]) && start[2] === end[2]) {
                    start[2] = end[2] = Math[roundingFunction](start[2]) + (width % 2 / 2)
                }
                return points
            }
            path(path) {
                const attribs = (this.styledMode ? {} : {
                    fill: 'none'
                });
                if (isArray(path)) {
                    attribs.d = path
                } else if (isObject(path)) {
                    extend(attribs, path)
                }
                return this.createElement('path').attr(attribs)
            }
            circle(x, y, r) {
                const attribs = (isObject(x) ? x : typeof x === 'undefined' ? {} : {
                    x: x,
                    y: y,
                    r: r
                })
                    , wrapper = this.createElement('circle');
                wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
                    element.setAttribute('c' + key, value)
                }
                ;
                return wrapper.attr(attribs)
            }
            arc(x, y, r, innerR, start, end) {
                let options;
                if (isObject(x)) {
                    options = x;
                    y = options.y;
                    r = options.r;
                    innerR = options.innerR;
                    start = options.start;
                    end = options.end;
                    x = options.x
                } else {
                    options = {
                        innerR,
                        start,
                        end
                    }
                }
                const arc = this.symbol('arc', x, y, r, r, options);
                arc.r = r;
                return arc
            }
            rect(x, y, width, height, r, strokeWidth) {
                const attribs = (isObject(x) ? x : typeof x === 'undefined' ? {} : {
                    x,
                    y,
                    r,
                    width: Math.max(width || 0, 0),
                    height: Math.max(height || 0, 0)
                })
                    , wrapper = this.createElement('rect');
                if (!this.styledMode) {
                    if (typeof strokeWidth !== 'undefined') {
                        attribs['stroke-width'] = strokeWidth;
                        extend(attribs, wrapper.crisp(attribs))
                    }
                    attribs.fill = 'none'
                }
                wrapper.rSetter = function(value, _key, element) {
                    wrapper.r = value;
                    attr(element, {
                        rx: value,
                        ry: value
                    })
                }
                ;
                wrapper.rGetter = function() {
                    return wrapper.r || 0
                }
                ;
                return wrapper.attr(attribs)
            }
            roundedRect(attribs) {
                return this.symbol('roundedRect').attr(attribs)
            }
            setSize(width, height, animate) {
                const renderer = this;
                renderer.width = width;
                renderer.height = height;
                renderer.boxWrapper.animate({
                    width: width,
                    height: height
                }, {
                    step: function() {
                        this.attr({
                            viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')
                        })
                    },
                    duration: pick(animate, !0) ? void 0 : 0
                });
                renderer.alignElements()
            }
            g(name) {
                const elem = this.createElement('g');
                return name ? elem.attr({
                    'class': 'highcharts-' + name
                }) : elem
            }
            image(href, x, y, width, height, onload) {
                const attribs = {
                    preserveAspectRatio: 'none'
                };
                if (isNumber(x)) {
                    attribs.x = x
                }
                if (isNumber(y)) {
                    attribs.y = y
                }
                if (isNumber(width)) {
                    attribs.width = width
                }
                if (isNumber(height)) {
                    attribs.height = height
                }
                const elemWrapper = this.createElement('image').attr(attribs)
                    , onDummyLoad = function(e) {
                    elemWrapper.attr({
                        href
                    });
                    onload.call(elemWrapper, e)
                };
                if (onload) {
                    elemWrapper.attr({
                        href: 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=='
                    });
                    const dummy = new win.Image();
                    addEvent(dummy, 'load', onDummyLoad);
                    dummy.src = href;
                    if (dummy.complete) {
                        onDummyLoad({})
                    }
                } else {
                    elemWrapper.attr({
                        href
                    })
                }
                return elemWrapper
            }
            symbol(symbol, x, y, width, height, options) {
                const ren = this
                    , imageRegex = /^url\((.*?)\)$/
                    , isImage = imageRegex.test(symbol)
                    , sym = (!isImage && (this.symbols[symbol] ? symbol : 'circle'))
                    , symbolFn = (sym && this.symbols[sym]);
                let obj, path, imageSrc, centerImage;
                if (symbolFn) {
                    if (typeof x === 'number') {
                        path = symbolFn.call(this.symbols, Math.round(x || 0), Math.round(y || 0), width || 0, height || 0, options)
                    }
                    obj = this.path(path);
                    if (!ren.styledMode) {
                        obj.attr('fill', 'none')
                    }
                    extend(obj, {
                        symbolName: (sym || void 0),
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    });
                    if (options) {
                        extend(obj, options)
                    }
                } else if (isImage) {
                    imageSrc = symbol.match(imageRegex)[1];
                    const img = obj = this.image(imageSrc);
                    img.imgwidth = pick(options && options.width, symbolSizes[imageSrc] && symbolSizes[imageSrc].width);
                    img.imgheight = pick(options && options.height, symbolSizes[imageSrc] && symbolSizes[imageSrc].height);
                    centerImage = (obj) => obj.attr({
                        width: obj.width,
                        height: obj.height
                    });
                    ['width', 'height'].forEach( (key) => {
                            img[`${key}Setter`] = function(value, key) {
                                this[key] = value;
                                const {alignByTranslate, element, width, height, imgwidth, imgheight} = this
                                    , imgSize = key === 'width' ? imgwidth : imgheight;
                                let scale = 1;
                                if (options && options.backgroundSize === 'within' && width && height && imgwidth && imgheight) {
                                    scale = Math.min(width / imgwidth, height / imgheight);
                                    attr(element, {
                                        width: Math.round(imgwidth * scale),
                                        height: Math.round(imgheight * scale)
                                    })
                                } else if (element && imgSize) {
                                    element.setAttribute(key, imgSize)
                                }
                                if (!alignByTranslate && imgwidth && imgheight) {
                                    this.translate(((width || 0) - (imgwidth * scale)) / 2, ((height || 0) - (imgheight * scale)) / 2)
                                }
                            }
                        }
                    );
                    if (defined(x)) {
                        img.attr({
                            x: x,
                            y: y
                        })
                    }
                    img.isImg = !0;
                    if (defined(img.imgwidth) && defined(img.imgheight)) {
                        centerImage(img)
                    } else {
                        img.attr({
                            width: 0,
                            height: 0
                        });
                        createElement('img', {
                            onload: function() {
                                const chart = charts[ren.chartIndex];
                                if (this.width === 0) {
                                    css(this, {
                                        position: 'absolute',
                                        top: '-999em'
                                    });
                                    doc.body.appendChild(this)
                                }
                                symbolSizes[imageSrc] = {
                                    width: this.width,
                                    height: this.height
                                };
                                img.imgwidth = this.width;
                                img.imgheight = this.height;
                                if (img.element) {
                                    centerImage(img)
                                }
                                if (this.parentNode) {
                                    this.parentNode.removeChild(this)
                                }
                                ren.imgCount--;
                                if (!ren.imgCount && chart && !chart.hasLoaded) {
                                    chart.onload()
                                }
                            },
                            src: imageSrc
                        });
                        this.imgCount++
                    }
                }
                return obj
            }
            clipRect(x, y, width, height) {
                const id = uniqueKey() + '-'
                    , clipPath = this.createElement('clipPath').attr({
                    id: id
                }).add(this.defs)
                    , wrapper = this.rect(x, y, width, height, 0).add(clipPath);
                wrapper.id = id;
                wrapper.clipPath = clipPath;
                wrapper.count = 0;
                return wrapper
            }
            text(str, x, y, useHTML) {
                const renderer = this
                    , attribs = {};
                if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
                    return renderer.html(str, x, y)
                }
                attribs.x = Math.round(x || 0);
                if (y) {
                    attribs.y = Math.round(y)
                }
                if (defined(str)) {
                    attribs.text = str
                }
                const wrapper = renderer.createElement('text').attr(attribs);
                if (!useHTML || (renderer.forExport && !renderer.allowHTML)) {
                    wrapper.xSetter = function(value, key, element) {
                        const tspans = element.getElementsByTagName('tspan')
                            , parentVal = element.getAttribute(key);
                        for (let i = 0, tspan; i < tspans.length; i++) {
                            tspan = tspans[i];
                            if (tspan.getAttribute(key) === parentVal) {
                                tspan.setAttribute(key, value)
                            }
                        }
                        element.setAttribute(key, value)
                    }
                }
                return wrapper
            }
            fontMetrics(element) {
                const f = pInt(SVGElement.prototype.getStyle.call(element, 'font-size') || 0);
                const h = f < 24 ? f + 3 : Math.round(f * 1.2)
                    , b = Math.round(h * 0.8);
                return {
                    h,
                    b,
                    f
                }
            }
            rotCorr(baseline, rotation, alterY) {
                let y = baseline;
                if (rotation && alterY) {
                    y = Math.max(y * Math.cos(rotation * deg2rad), 4)
                }
                return {
                    x: (-baseline / 3) * Math.sin(rotation * deg2rad),
                    y: y
                }
            }
            pathToSegments(path) {
                const ret = [];
                const segment = [];
                const commandLength = {
                    A: 8,
                    C: 7,
                    H: 2,
                    L: 3,
                    M: 3,
                    Q: 5,
                    S: 5,
                    T: 3,
                    V: 2
                };
                for (let i = 0; i < path.length; i++) {
                    if (isString(segment[0]) && isNumber(path[i]) && segment.length === commandLength[(segment[0].toUpperCase())]) {
                        path.splice(i, 0, segment[0].replace('M', 'L').replace('m', 'l'))
                    }
                    if (typeof path[i] === 'string') {
                        if (segment.length) {
                            ret.push(segment.slice(0))
                        }
                        segment.length = 0
                    }
                    segment.push(path[i])
                }
                ret.push(segment.slice(0));
                return ret
            }
            label(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
                return new SVGLabel(this,str,x,y,shape,anchorX,anchorY,useHTML,baseline,className)
            }
            alignElements() {
                this.alignedObjects.forEach( (el) => el.align())
            }
        }
        extend(SVGRenderer.prototype, {
            Element: SVGElement,
            SVG_NS,
            escapes: {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                "'": '&#39;',
                '"': '&quot;'
            },
            symbols: Symbols,
            draw: noop
        });
        RendererRegistry.registerRendererType('svg', SVGRenderer, !0);
        ('');
        return SVGRenderer
    });
    _registerModule(_modules, 'Core/Renderer/HTML/HTMLElement.js', [_modules['Core/Globals.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function(H, SVGElement, U) {
        const {isFirefox, isMS, isWebKit, win} = H;
        const {css, defined, extend, pick, pInt} = U;
        const composedMembers = [];
        class HTMLElement extends SVGElement {
            static compose(SVGElementClass) {
                if (U.pushUnique(composedMembers, SVGElementClass)) {
                    const htmlElementProto = HTMLElement.prototype
                        , svgElementProto = SVGElementClass.prototype;
                    svgElementProto.getSpanCorrection = htmlElementProto.getSpanCorrection;
                    svgElementProto.htmlCss = htmlElementProto.htmlCss;
                    svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;
                    svgElementProto.htmlUpdateTransform = htmlElementProto.htmlUpdateTransform;
                    svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation
                }
                return SVGElementClass
            }
            getSpanCorrection(width, baseline, alignCorrection) {
                this.xCorr = -width * alignCorrection;
                this.yCorr = -baseline
            }
            htmlCss(styles) {
                const wrapper = this
                    , element = wrapper.element
                    , isSettingWidth = (element.tagName === 'SPAN' && styles && 'width'in styles)
                    , textWidth = pick(isSettingWidth && styles.width, void 0);
                let doTransform;
                if (isSettingWidth) {
                    delete styles.width;
                    wrapper.textWidth = textWidth;
                    doTransform = !0
                }
                if (styles && styles.textOverflow === 'ellipsis') {
                    styles.whiteSpace = 'nowrap';
                    styles.overflow = 'hidden'
                }
                wrapper.styles = extend(wrapper.styles, styles);
                css(wrapper.element, styles);
                if (doTransform) {
                    wrapper.htmlUpdateTransform()
                }
                return wrapper
            }
            htmlGetBBox() {
                const wrapper = this
                    , element = wrapper.element;
                return {
                    x: element.offsetLeft,
                    y: element.offsetTop,
                    width: element.offsetWidth,
                    height: element.offsetHeight
                }
            }
            htmlUpdateTransform() {
                if (!this.added) {
                    this.alignOnAdd = !0;
                    return
                }
                const wrapper = this
                    , renderer = wrapper.renderer
                    , elem = wrapper.element
                    , translateX = wrapper.translateX || 0
                    , translateY = wrapper.translateY || 0
                    , x = wrapper.x || 0
                    , y = wrapper.y || 0
                    , align = wrapper.textAlign || 'left'
                    , alignCorrection = {
                    left: 0,
                    center: 0.5,
                    right: 1
                }[align]
                    , styles = wrapper.styles
                    , whiteSpace = styles && styles.whiteSpace;
                function getTextPxLength() {
                    if (wrapper.textPxLength) {
                        return wrapper.textPxLength
                    }
                    css(elem, {
                        width: '',
                        whiteSpace: whiteSpace || 'nowrap'
                    });
                    return elem.offsetWidth
                }
                css(elem, {
                    marginLeft: translateX,
                    marginTop: translateY
                });
                if (elem.tagName === 'SPAN') {
                    const rotation = wrapper.rotation
                        , textWidth = wrapper.textWidth && pInt(wrapper.textWidth)
                        , currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');
                    let baseline, hasBoxWidthChanged = !1;
                    if (textWidth !== wrapper.oldTextWidth) {
                        const textPxLength = getTextPxLength();
                        if (((textWidth > wrapper.oldTextWidth) || textPxLength > textWidth) && (/[ \-]/.test(elem.textContent || elem.innerText) || elem.style.textOverflow === 'ellipsis')) {
                            css(elem, {
                                width: (textPxLength > textWidth) || rotation ? textWidth + 'px' : 'auto',
                                display: 'block',
                                whiteSpace: whiteSpace || 'normal'
                            });
                            wrapper.oldTextWidth = textWidth;
                            hasBoxWidthChanged = !0
                        }
                    }
                    wrapper.hasBoxWidthChanged = hasBoxWidthChanged;
                    if (currentTextTransform !== wrapper.cTT) {
                        baseline = renderer.fontMetrics(elem).b;
                        if (defined(rotation) && ((rotation !== (wrapper.oldRotation || 0)) || (align !== wrapper.oldAlign))) {
                            wrapper.setSpanRotation(rotation, alignCorrection, baseline)
                        }
                        wrapper.getSpanCorrection(((!defined(rotation) && wrapper.textPxLength) || elem.offsetWidth), baseline, alignCorrection, rotation, align)
                    }
                    css(elem, {
                        left: (x + (wrapper.xCorr || 0)) + 'px',
                        top: (y + (wrapper.yCorr || 0)) + 'px'
                    });
                    wrapper.cTT = currentTextTransform;
                    wrapper.oldRotation = rotation;
                    wrapper.oldAlign = align
                }
            }
            setSpanRotation(rotation, alignCorrection, baseline) {
                const getTransformKey = () => (isMS && !/Edge/.test(win.navigator.userAgent) ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : void 0);
                const rotationStyle = {}
                    , cssTransformKey = getTransformKey();
                if (cssTransformKey) {
                    rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
                    rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
                    css(this.element, rotationStyle)
                }
            }
        }
        return HTMLElement
    });
    _registerModule(_modules, 'Core/Renderer/HTML/HTMLRenderer.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Utilities.js']], function(AST, SVGElement, SVGRenderer, U) {
        const {attr, createElement, extend, pick} = U;
        const composedMembers = [];
        class HTMLRenderer extends SVGRenderer {
            static compose(SVGRendererClass) {
                if (U.pushUnique(composedMembers, SVGRendererClass)) {
                    const htmlRendererProto = HTMLRenderer.prototype
                        , svgRendererProto = SVGRendererClass.prototype;
                    svgRendererProto.html = htmlRendererProto.html
                }
                return SVGRendererClass
            }
            html(str, x, y) {
                const wrapper = this.createElement('span')
                    , element = wrapper.element
                    , renderer = wrapper.renderer
                    , addSetters = function(gWrapper, style) {
                    ['opacity', 'visibility'].forEach(function(prop) {
                        gWrapper[prop + 'Setter'] = function(value, key, elem) {
                            const styleObject = gWrapper.div ? gWrapper.div.style : style;
                            SVGElement.prototype[prop + 'Setter'].call(this, value, key, elem);
                            if (styleObject) {
                                styleObject[key] = value
                            }
                        }
                    });
                    gWrapper.addedSetters = !0
                };
                wrapper.textSetter = function(value) {
                    if (value !== this.textStr) {
                        delete this.bBox;
                        delete this.oldTextWidth;
                        AST.setElementHTML(this.element, pick(value, ''));
                        this.textStr = value;
                        wrapper.doTransform = !0
                    }
                }
                ;
                addSetters(wrapper, wrapper.element.style);
                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {
                    if (key === 'align') {
                        wrapper.alignValue = wrapper.textAlign = value
                    } else {
                        wrapper[key] = value
                    }
                    wrapper.doTransform = !0
                }
                ;
                wrapper.afterSetters = function() {
                    if (this.doTransform) {
                        this.htmlUpdateTransform();
                        this.doTransform = !1
                    }
                }
                ;
                wrapper.attr({
                    text: str,
                    x: Math.round(x),
                    y: Math.round(y)
                }).css({
                    position: 'absolute'
                });
                if (!renderer.styledMode) {
                    wrapper.css({
                        fontFamily: this.style.fontFamily,
                        fontSize: this.style.fontSize
                    })
                }
                element.style.whiteSpace = 'nowrap';
                wrapper.css = wrapper.htmlCss;
                wrapper.add = function(svgGroupWrapper) {
                    const container = renderer.box.parentNode
                        , parents = [];
                    let htmlGroup, parentGroup;
                    this.parentGroup = svgGroupWrapper;
                    if (svgGroupWrapper) {
                        htmlGroup = svgGroupWrapper.div;
                        if (!htmlGroup) {
                            parentGroup = svgGroupWrapper;
                            while (parentGroup) {
                                parents.push(parentGroup);
                                parentGroup = parentGroup.parentGroup
                            }
                            parents.reverse().forEach(function(parentGroup) {
                                const cls = attr(parentGroup.element, 'class')
                                    , parentProtoCss = parentGroup.css;
                                function translateSetter(value, key) {
                                    parentGroup[key] = value;
                                    if (key === 'translateX') {
                                        htmlGroupStyle.left = value + 'px'
                                    } else {
                                        htmlGroupStyle.top = value + 'px'
                                    }
                                    parentGroup.doTransform = !0
                                }
                                const parentGroupStyles = parentGroup.styles || {};
                                htmlGroup = parentGroup.div = parentGroup.div || createElement('div', cls ? {
                                    className: cls
                                } : void 0, {
                                    position: 'absolute',
                                    left: (parentGroup.translateX || 0) + 'px',
                                    top: (parentGroup.translateY || 0) + 'px',
                                    display: parentGroup.display,
                                    opacity: parentGroup.opacity,
                                    visibility: parentGroup.visibility
                                }, htmlGroup || container);
                                const htmlGroupStyle = htmlGroup.style;
                                extend(parentGroup, {
                                    classSetter: (function(htmlGroup) {
                                        return function(value) {
                                            this.element.setAttribute('class', value);
                                            htmlGroup.className = value
                                        }
                                    }(htmlGroup)),
                                    css: function(styles) {
                                        parentProtoCss.call(parentGroup, styles);
                                        ['cursor', 'pointerEvents'].forEach( (prop) => {
                                                if (styles[prop]) {
                                                    htmlGroupStyle[prop] = styles[prop]
                                                }
                                            }
                                        );
                                        return parentGroup
                                    },
                                    on: function() {
                                        if (parents[0].div) {
                                            wrapper.on.apply({
                                                element: parents[0].div,
                                                onEvents: parentGroup.onEvents
                                            }, arguments)
                                        }
                                        return parentGroup
                                    },
                                    translateXSetter: translateSetter,
                                    translateYSetter: translateSetter
                                });
                                if (!parentGroup.addedSetters) {
                                    addSetters(parentGroup)
                                }
                                parentGroup.css(parentGroupStyles)
                            })
                        }
                    } else {
                        htmlGroup = container
                    }
                    htmlGroup.appendChild(element);
                    wrapper.added = !0;
                    if (wrapper.alignOnAdd) {
                        wrapper.htmlUpdateTransform()
                    }
                    return wrapper
                }
                ;
                return wrapper
            }
        }
        return HTMLRenderer
    });
    _registerModule(_modules, 'Core/Axis/AxisDefaults.js', [], function() {
        var AxisDefaults;
        (function(AxisDefaults) {
                AxisDefaults.defaultXAxisOptions = {
                    alignTicks: !0,
                    allowDecimals: void 0,
                    panningEnabled: !0,
                    zIndex: 2,
                    zoomEnabled: !0,
                    dateTimeLabelFormats: {
                        millisecond: {
                            main: '%H:%M:%S.%L',
                            range: !1
                        },
                        second: {
                            main: '%H:%M:%S',
                            range: !1
                        },
                        minute: {
                            main: '%H:%M',
                            range: !1
                        },
                        hour: {
                            main: '%H:%M',
                            range: !1
                        },
                        day: {
                            main: '%e %b'
                        },
                        week: {
                            main: '%e %b'
                        },
                        month: {
                            main: '%b \'%y'
                        },
                        year: {
                            main: '%Y'
                        }
                    },
                    endOnTick: !1,
                    gridLineDashStyle: 'Solid',
                    gridZIndex: 1,
                    labels: {
                        autoRotation: void 0,
                        autoRotationLimit: 80,
                        distance: 15,
                        enabled: !0,
                        indentation: 10,
                        overflow: 'justify',
                        padding: 5,
                        reserveSpace: void 0,
                        rotation: void 0,
                        staggerLines: 0,
                        step: 0,
                        useHTML: !1,
                        zIndex: 7,
                        style: {
                            color: "#333333",
                            cursor: 'default',
                            fontSize: '0.8em'
                        }
                    },
                    maxPadding: 0.01,
                    minorGridLineDashStyle: 'Solid',
                    minorTickLength: 2,
                    minorTickPosition: 'outside',
                    minorTicksPerMajor: 5,
                    minPadding: 0.01,
                    offset: void 0,
                    opposite: !1,
                    reversed: void 0,
                    reversedStacks: !1,
                    showEmpty: !0,
                    showFirstLabel: !0,
                    showLastLabel: !0,
                    startOfWeek: 1,
                    startOnTick: !1,
                    tickLength: 10,
                    tickPixelInterval: 100,
                    tickmarkPlacement: 'between',
                    tickPosition: 'outside',
                    title: {
                        align: 'middle',
                        rotation: 0,
                        useHTML: !1,
                        x: 0,
                        y: 0,
                        style: {
                            color: "#666666",
                            fontSize: '0.8em'
                        }
                    },
                    type: 'linear',
                    uniqueNames: !0,
                    visible: !0,
                    minorGridLineColor: "#f2f2f2",
                    minorGridLineWidth: 1,
                    minorTickColor: "#999999",
                    lineColor: "#333333",
                    lineWidth: 1,
                    gridLineColor: "#e6e6e6",
                    gridLineWidth: void 0,
                    tickColor: "#333333"
                };
                AxisDefaults.defaultYAxisOptions = {
                    reversedStacks: !0,
                    endOnTick: !0,
                    maxPadding: 0.05,
                    minPadding: 0.05,
                    tickPixelInterval: 72,
                    showLastLabel: !0,
                    labels: {
                        x: void 0
                    },
                    startOnTick: !0,
                    title: {
                        rotation: 270,
                        text: 'Values'
                    },
                    stackLabels: {
                        animation: {},
                        allowOverlap: !1,
                        enabled: !1,
                        crop: !0,
                        overflow: 'justify',
                        formatter: function() {
                            const {numberFormatter} = this.axis.chart;
                            return numberFormatter(this.total || 0, -1)
                        },
                        style: {
                            color: "#000000",
                            fontSize: '0.7em',
                            fontWeight: 'bold',
                            textOutline: '1px contrast'
                        }
                    },
                    gridLineWidth: 1,
                    lineWidth: 0
                };
                AxisDefaults.defaultLeftAxisOptions = {
                    title: {
                        rotation: 270
                    }
                };
                AxisDefaults.defaultRightAxisOptions = {
                    title: {
                        rotation: 90
                    }
                };
                AxisDefaults.defaultBottomAxisOptions = {
                    labels: {
                        autoRotation: [-45]
                    },
                    margin: 15,
                    title: {
                        rotation: 0
                    }
                };
                AxisDefaults.defaultTopAxisOptions = {
                    labels: {
                        autoRotation: [-45]
                    },
                    margin: 15,
                    title: {
                        rotation: 0
                    }
                }
            }
        )(AxisDefaults || (AxisDefaults = {}));
        return AxisDefaults
    });
    _registerModule(_modules, 'Core/Foundation.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, isFunction, objectEach, removeEvent} = U;
        var Foundation;
        (function(Foundation) {
                function registerEventOptions(component, options) {
                    component.eventOptions = component.eventOptions || {};
                    objectEach(options.events, function(event, eventType) {
                        if (component.eventOptions[eventType] !== event) {
                            if (component.eventOptions[eventType]) {
                                removeEvent(component, eventType, component.eventOptions[eventType]);
                                delete component.eventOptions[eventType]
                            }
                            if (isFunction(event)) {
                                component.eventOptions[eventType] = event;
                                addEvent(component, eventType, event, {
                                    order: 0
                                })
                            }
                        }
                    })
                }
                Foundation.registerEventOptions = registerEventOptions
            }
        )(Foundation || (Foundation = {}));
        return Foundation
    });
    _registerModule(_modules, 'Core/Axis/Tick.js', [_modules['Core/Templating.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(F, H, U) {
        const {deg2rad} = H;
        const {clamp, correctFloat, defined, destroyObjectProperties, extend, fireEvent, isNumber, merge, objectEach, pick} = U;
        class Tick {
            constructor(axis, pos, type, noLabel, parameters) {
                this.isNew = !0;
                this.isNewLabel = !0;
                this.axis = axis;
                this.pos = pos;
                this.type = type || '';
                this.parameters = parameters || {};
                this.tickmarkOffset = this.parameters.tickmarkOffset;
                this.options = this.parameters.options;
                fireEvent(this, 'init');
                if (!type && !noLabel) {
                    this.addLabel()
                }
            }
            addLabel() {
                const tick = this
                    , axis = tick.axis
                    , options = axis.options
                    , chart = axis.chart
                    , categories = axis.categories
                    , log = axis.logarithmic
                    , names = axis.names
                    , pos = tick.pos
                    , labelOptions = pick(tick.options && tick.options.labels, options.labels)
                    , tickPositions = axis.tickPositions
                    , isFirst = pos === tickPositions[0]
                    , isLast = pos === tickPositions[tickPositions.length - 1]
                    , animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1
                    , tickPositionInfo = tickPositions.info;
                let label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
                let value = this.parameters.category || (categories ? pick(categories[pos], names[pos], pos) : pos);
                if (log && isNumber(value)) {
                    value = correctFloat(log.lin2log(value))
                }
                if (axis.dateTime) {
                    if (tickPositionInfo) {
                        dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[(!options.grid && tickPositionInfo.higherRanks[pos]) || tickPositionInfo.unitName]);
                        dateTimeLabelFormat = dateTimeLabelFormats.main
                    } else if (isNumber(value)) {
                        dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {})
                    }
                }
                tick.isFirst = isFirst;
                tick.isLast = isLast;
                const ctx = {
                    axis,
                    chart,
                    dateTimeLabelFormat: dateTimeLabelFormat,
                    isFirst,
                    isLast,
                    pos,
                    tick: tick,
                    tickPositionInfo,
                    value
                };
                fireEvent(this, 'labelFormat', ctx);
                const labelFormatter = (ctx) => {
                        if (labelOptions.formatter) {
                            return labelOptions.formatter.call(ctx, ctx)
                        }
                        if (labelOptions.format) {
                            ctx.text = axis.defaultLabelFormatter.call(ctx, ctx);
                            return F.format(labelOptions.format, ctx, chart)
                        }
                        return axis.defaultLabelFormatter.call(ctx, ctx)
                    }
                ;
                const str = labelFormatter.call(ctx, ctx);
                const list = dateTimeLabelFormats && dateTimeLabelFormats.list;
                if (list) {
                    tick.shortenLabel = function() {
                        for (i = 0; i < list.length; i++) {
                            extend(ctx, {
                                dateTimeLabelFormat: list[i]
                            });
                            label.attr({
                                text: labelFormatter.call(ctx, ctx)
                            });
                            if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * labelOptions.padding) {
                                return
                            }
                        }
                        label.attr({
                            text: ''
                        })
                    }
                } else {
                    tick.shortenLabel = void 0
                }
                if (animateLabels && axis._addedPlotLB) {
                    tick.moveLabel(str, labelOptions)
                }
                if (!defined(label) && !tick.movedLabel) {
                    tick.label = label = tick.createLabel({
                        x: 0,
                        y: 0
                    }, str, labelOptions);
                    tick.rotation = 0
                } else if (label && label.textStr !== str && !animateLabels) {
                    if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
                        label.css({
                            width: null
                        })
                    }
                    label.attr({
                        text: str
                    });
                    label.textPxLength = label.getBBox().width
                }
            }
            createLabel(xy, str, labelOptions) {
                const axis = this.axis
                    , chart = axis.chart
                    , label = defined(str) && labelOptions.enabled ? chart.renderer.text(str, xy.x, xy.y, labelOptions.useHTML).add(axis.labelGroup) : null;
                if (label) {
                    if (!chart.styledMode) {
                        label.css(merge(labelOptions.style))
                    }
                    label.textPxLength = label.getBBox().width
                }
                return label
            }
            destroy() {
                destroyObjectProperties(this, this.axis)
            }
            getPosition(horiz, tickPos, tickmarkOffset, old) {
                const axis = this.axis
                    , chart = axis.chart
                    , cHeight = (old && chart.oldChartHeight) || chart.chartHeight
                    , pos = {
                    x: horiz ? correctFloat(axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) + axis.transB) : (axis.left + axis.offset + (axis.opposite ? (((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left) : 0)),
                    y: horiz ? (cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0)) : correctFloat(cHeight - axis.translate(tickPos + tickmarkOffset, void 0, void 0, old) - axis.transB)
                };
                pos.y = clamp(pos.y, -1e5, 1e5);
                fireEvent(this, 'afterGetPosition', {
                    pos: pos
                });
                return pos
            }
            getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
                const axis = this.axis
                    , transA = axis.transA
                    , reversed = (axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed)
                    , staggerLines = axis.staggerLines
                    , rotCorr = axis.tickRotCorr || {
                    x: 0,
                    y: 0
                }
                    , labelOffsetCorrection = (!horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === 'center' ? 0.5 : 1) : 0)
                    , distance = labelOptions.distance
                    , pos = {};
                let yOffset, line;
                if (axis.side === 0) {
                    yOffset = label.rotation ? -distance : -label.getBBox().height
                } else if (axis.side === 2) {
                    yOffset = rotCorr.y + distance
                } else {
                    yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(!1, 0).height / 2)
                }
                if (defined(labelOptions.y)) {
                    yOffset = axis.side === 0 && axis.horiz ? labelOptions.y + yOffset : labelOptions.y
                }
                x = x + pick(labelOptions.x, [0, 1, 0, -1][axis.side] * distance) + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
                y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
                if (staggerLines) {
                    line = (index / (step || 1) % staggerLines);
                    if (axis.opposite) {
                        line = staggerLines - line - 1
                    }
                    y += line * (axis.labelOffset / staggerLines)
                }
                pos.x = x;
                pos.y = Math.round(y);
                fireEvent(this, 'afterGetLabelPosition', {
                    pos: pos,
                    tickmarkOffset: tickmarkOffset,
                    index: index
                });
                return pos
            }
            getLabelSize() {
                return this.label ? this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] : 0
            }
            getMarkPath(x, y, tickLength, tickWidth, horiz, renderer) {
                return renderer.crispLine([['M', x, y], ['L', x + (horiz ? 0 : -tickLength), y + (horiz ? tickLength : 0)]], tickWidth)
            }
            handleOverflow(xy) {
                const tick = this
                    , axis = this.axis
                    , labelOptions = axis.options.labels
                    , pxPos = xy.x
                    , chartWidth = axis.chart.chartWidth
                    , spacing = axis.chart.spacing
                    , leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3]))
                    , rightBound = pick(axis.labelRight, Math.max(!axis.isRadial ? axis.pos + axis.len : 0, chartWidth - spacing[1]))
                    , label = this.label
                    , rotation = this.rotation
                    , factor = {
                    left: 0,
                    center: 0.5,
                    right: 1
                }[axis.labelAlign || label.attr('align')]
                    , labelWidth = label.getBBox().width
                    , slotWidth = axis.getSlotWidth(tick)
                    , xCorrection = factor
                    , css = {};
                let modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
                if (!rotation && labelOptions.overflow === 'justify') {
                    leftPos = pxPos - factor * labelWidth;
                    rightPos = pxPos + (1 - factor) * labelWidth;
                    if (leftPos < leftBound) {
                        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound
                    } else if (rightPos > rightBound) {
                        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
                        goRight = -1
                    }
                    modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
                    if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
                        xy.x += (goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth))))
                    }
                    if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {
                        textWidth = modifiedSlotWidth
                    }
                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
                    textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound)
                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
                    textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad))
                }
                if (textWidth) {
                    if (tick.shortenLabel) {
                        tick.shortenLabel()
                    } else {
                        css.width = Math.floor(textWidth) + 'px';
                        if (!(labelOptions.style || {}).textOverflow) {
                            css.textOverflow = 'ellipsis'
                        }
                        label.css(css)
                    }
                }
            }
            moveLabel(str, labelOptions) {
                const tick = this
                    , label = tick.label
                    , axis = tick.axis;
                let moved = !1, labelPos;
                if (label && label.textStr === str) {
                    tick.movedLabel = label;
                    moved = !0;
                    delete tick.label
                } else {
                    objectEach(axis.ticks, function(currentTick) {
                        if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
                            tick.movedLabel = currentTick.label;
                            moved = !0;
                            currentTick.labelPos = tick.movedLabel.xy;
                            delete currentTick.label
                        }
                    })
                }
                if (!moved && (tick.labelPos || label)) {
                    labelPos = tick.labelPos || label.xy;
                    tick.movedLabel = tick.createLabel(labelPos, str, labelOptions);
                    if (tick.movedLabel) {
                        tick.movedLabel.attr({
                            opacity: 0
                        })
                    }
                }
            }
            render(index, old, opacity) {
                const tick = this
                    , axis = tick.axis
                    , horiz = axis.horiz
                    , pos = tick.pos
                    , tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset)
                    , xy = tick.getPosition(horiz, pos, tickmarkOffset, old)
                    , x = xy.x
                    , y = xy.y
                    , reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1;
                const labelOpacity = pick(opacity, tick.label && tick.label.newOpacity, 1);
                opacity = pick(opacity, 1);
                this.isActive = !0;
                this.renderGridLine(old, opacity, reverseCrisp);
                this.renderMark(xy, opacity, reverseCrisp);
                this.renderLabel(xy, old, labelOpacity, index);
                tick.isNew = !1;
                fireEvent(this, 'afterRender')
            }
            renderGridLine(old, opacity, reverseCrisp) {
                const tick = this
                    , axis = tick.axis
                    , options = axis.options
                    , attribs = {}
                    , pos = tick.pos
                    , type = tick.type
                    , tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset)
                    , renderer = axis.chart.renderer;
                let gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
                if (tick.type === 'minor') {
                    gridLineWidth = options.minorGridLineWidth;
                    gridLineColor = options.minorGridLineColor;
                    dashStyle = options.minorGridLineDashStyle
                }
                if (!gridLine) {
                    if (!axis.chart.styledMode) {
                        attribs.stroke = gridLineColor;
                        attribs['stroke-width'] = gridLineWidth || 0;
                        attribs.dashstyle = dashStyle
                    }
                    if (!type) {
                        attribs.zIndex = 1
                    }
                    if (old) {
                        opacity = 0
                    }
                    tick.gridLine = gridLine = renderer.path().attr(attribs).addClass('highcharts-' + (type ? type + '-' : '') + 'grid-line').add(axis.gridGroup)
                }
                if (gridLine) {
                    gridLinePath = axis.getPlotLinePath({
                        value: pos + tickmarkOffset,
                        lineWidth: gridLine.strokeWidth() * reverseCrisp,
                        force: 'pass',
                        old: old,
                        acrossPanes: !1
                    });
                    if (gridLinePath) {
                        gridLine[old || tick.isNew ? 'attr' : 'animate']({
                            d: gridLinePath,
                            opacity: opacity
                        })
                    }
                }
            }
            renderMark(xy, opacity, reverseCrisp) {
                const tick = this
                    , axis = tick.axis
                    , options = axis.options
                    , renderer = axis.chart.renderer
                    , type = tick.type
                    , tickSize = axis.tickSize(type ? type + 'Tick' : 'tick')
                    , x = xy.x
                    , y = xy.y
                    , tickWidth = pick(options[type !== 'minor' ? 'tickWidth' : 'minorTickWidth'], !type && axis.isXAxis ? 1 : 0)
                    , tickColor = options[type !== 'minor' ? 'tickColor' : 'minorTickColor'];
                let mark = tick.mark;
                const isNewMark = !mark;
                if (tickSize) {
                    if (axis.opposite) {
                        tickSize[0] = -tickSize[0]
                    }
                    if (!mark) {
                        tick.mark = mark = renderer.path().addClass('highcharts-' + (type ? type + '-' : '') + 'tick').add(axis.axisGroup);
                        if (!axis.chart.styledMode) {
                            mark.attr({
                                stroke: tickColor,
                                'stroke-width': tickWidth
                            })
                        }
                    }
                    mark[isNewMark ? 'attr' : 'animate']({
                        d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
                        opacity: opacity
                    })
                }
            }
            renderLabel(xy, old, opacity, index) {
                const tick = this
                    , axis = tick.axis
                    , horiz = axis.horiz
                    , options = axis.options
                    , label = tick.label
                    , labelOptions = options.labels
                    , step = labelOptions.step
                    , tickmarkOffset = pick(tick.tickmarkOffset, axis.tickmarkOffset)
                    , x = xy.x
                    , y = xy.y;
                let show = !0;
                if (label && isNumber(x)) {
                    label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                    if ((tick.isFirst && !tick.isLast && !options.showFirstLabel) || (tick.isLast && !tick.isFirst && !options.showLastLabel)) {
                        show = !1
                    } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
                        tick.handleOverflow(xy)
                    }
                    if (step && index % step) {
                        show = !1
                    }
                    if (show && isNumber(xy.y)) {
                        xy.opacity = opacity;
                        label[tick.isNewLabel ? 'attr' : 'animate'](xy).show(!0);
                        tick.isNewLabel = !1
                    } else {
                        label.hide();
                        tick.isNewLabel = !0
                    }
                }
            }
            replaceMovedLabel() {
                const tick = this
                    , label = tick.label
                    , axis = tick.axis;
                if (label && !tick.isNew) {
                    label.animate({
                        opacity: 0
                    }, void 0, label.destroy);
                    delete tick.label
                }
                axis.isDirty = !0;
                tick.label = tick.movedLabel;
                delete tick.movedLabel
            }
        }
        ('');
        return Tick
    });
    _registerModule(_modules, 'Core/Axis/Axis.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Axis/AxisDefaults.js'], _modules['Core/Color/Color.js'], _modules['Core/Defaults.js'], _modules['Core/Foundation.js'], _modules['Core/Globals.js'], _modules['Core/Axis/Tick.js'], _modules['Core/Utilities.js']], function(A, AxisDefaults, Color, D, F, H, Tick, U) {
        const {animObject} = A;
        const {defaultOptions} = D;
        const {registerEventOptions} = F;
        const {deg2rad} = H;
        const {arrayMax, arrayMin, clamp, correctFloat, defined, destroyObjectProperties, erase, error, extend, fireEvent, getClosestDistance, insertItem, isArray, isNumber, isString, merge, normalizeTickInterval, objectEach, pick, relativeLength, removeEvent, splat, syncTimeout} = U;
        const getNormalizedTickInterval = (axis, tickInterval) => normalizeTickInterval(tickInterval, void 0, void 0, pick(axis.options.allowDecimals, tickInterval < 0.5 || axis.tickAmount !== void 0), !!axis.tickAmount);
        class Axis {
            constructor(chart, userOptions, coll) {
                this.alternateBands = void 0;
                this.bottom = void 0;
                this.chart = void 0;
                this.closestPointRange = void 0;
                this.coll = void 0;
                this.eventOptions = void 0;
                this.hasNames = void 0;
                this.hasVisibleSeries = void 0;
                this.height = void 0;
                this.index = void 0;
                this.isLinked = void 0;
                this.labelEdge = void 0;
                this.labelFormatter = void 0;
                this.left = void 0;
                this.len = void 0;
                this.max = void 0;
                this.maxLabelLength = void 0;
                this.min = void 0;
                this.minorTickInterval = void 0;
                this.minorTicks = void 0;
                this.minPixelPadding = void 0;
                this.names = void 0;
                this.offset = void 0;
                this.options = void 0;
                this.overlap = void 0;
                this.paddedTicks = void 0;
                this.plotLinesAndBands = void 0;
                this.plotLinesAndBandsGroups = void 0;
                this.pointRange = void 0;
                this.pointRangePadding = void 0;
                this.pos = void 0;
                this.positiveValuesOnly = void 0;
                this.right = void 0;
                this.series = void 0;
                this.side = void 0;
                this.tickAmount = void 0;
                this.tickInterval = void 0;
                this.tickmarkOffset = void 0;
                this.tickPositions = void 0;
                this.tickRotCorr = void 0;
                this.ticks = void 0;
                this.top = void 0;
                this.transA = void 0;
                this.transB = void 0;
                this.translationSlope = void 0;
                this.userOptions = void 0;
                this.visible = void 0;
                this.width = void 0;
                this.zoomEnabled = void 0;
                this.init(chart, userOptions, coll)
            }
            init(chart, userOptions, coll=this.coll) {
                const isXAxis = coll === 'xAxis'
                    , axis = this;
                axis.chart = chart;
                axis.horiz = axis.isZAxis || (chart.inverted ? !isXAxis : isXAxis);
                axis.isXAxis = isXAxis;
                axis.coll = coll;
                fireEvent(this, 'init', {
                    userOptions: userOptions
                });
                axis.opposite = pick(userOptions.opposite, axis.opposite);
                axis.side = pick(userOptions.side, axis.side, (axis.horiz ? (axis.opposite ? 0 : 2) : (axis.opposite ? 1 : 3)));
                axis.setOptions(userOptions);
                const options = this.options
                    , labelsOptions = options.labels
                    , type = options.type;
                axis.userOptions = userOptions;
                axis.minPixelPadding = 0;
                axis.reversed = pick(options.reversed, axis.reversed);
                axis.visible = options.visible;
                axis.zoomEnabled = options.zoomEnabled;
                axis.hasNames = type === 'category' || options.categories === !0;
                axis.categories = options.categories || (axis.hasNames ? [] : void 0);
                if (!axis.names) {
                    axis.names = [];
                    axis.names.keys = {}
                }
                axis.plotLinesAndBandsGroups = {};
                axis.positiveValuesOnly = !!axis.logarithmic;
                axis.isLinked = defined(options.linkedTo);
                axis.ticks = {};
                axis.labelEdge = [];
                axis.minorTicks = {};
                axis.plotLinesAndBands = [];
                axis.alternateBands = {};
                axis.len = 0;
                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
                axis.range = options.range;
                axis.offset = options.offset || 0;
                axis.max = null;
                axis.min = null;
                const crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]);
                axis.crosshair = crosshair === !0 ? {} : crosshair;
                if (chart.axes.indexOf(axis) === -1) {
                    if (isXAxis) {
                        chart.axes.splice(chart.xAxis.length, 0, axis)
                    } else {
                        chart.axes.push(axis)
                    }
                    insertItem(this, chart[this.coll])
                }
                chart.orderItems(axis.coll);
                axis.series = axis.series || [];
                if (chart.inverted && !axis.isZAxis && isXAxis && typeof axis.reversed === 'undefined') {
                    axis.reversed = !0
                }
                axis.labelRotation = isNumber(labelsOptions.rotation) ? labelsOptions.rotation : void 0;
                registerEventOptions(axis, options);
                fireEvent(this, 'afterInit')
            }
            setOptions(userOptions) {
                this.options = merge(AxisDefaults.defaultXAxisOptions, (this.coll === 'yAxis') && AxisDefaults.defaultYAxisOptions, [AxisDefaults.defaultTopAxisOptions, AxisDefaults.defaultRightAxisOptions, AxisDefaults.defaultBottomAxisOptions, AxisDefaults.defaultLeftAxisOptions][this.side], merge(defaultOptions[this.coll], userOptions));
                fireEvent(this, 'afterSetOptions', {
                    userOptions: userOptions
                })
            }
            defaultLabelFormatter(ctx) {
                const axis = this.axis
                    , chart = this.chart
                    , {numberFormatter} = chart
                    , value = isNumber(this.value) ? this.value : NaN
                    , time = axis.chart.time
                    , categories = axis.categories
                    , dateTimeLabelFormat = this.dateTimeLabelFormat
                    , lang = defaultOptions.lang
                    , numericSymbols = lang.numericSymbols
                    , numSymMagnitude = lang.numericSymbolMagnitude || 1000
                    , numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
                let i = numericSymbols && numericSymbols.length, multi, ret;
                if (categories) {
                    ret = `${this.value}`
                } else if (dateTimeLabelFormat) {
                    ret = time.dateFormat(dateTimeLabelFormat, value)
                } else if (i && numericSymbolDetector >= 1000) {
                    while (i-- && typeof ret === 'undefined') {
                        multi = Math.pow(numSymMagnitude, i + 1);
                        if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null && value !== 0) {
                            ret = numberFormatter(value / multi, -1) + numericSymbols[i]
                        }
                    }
                }
                if (typeof ret === 'undefined') {
                    if (Math.abs(value) >= 10000) {
                        ret = numberFormatter(value, -1)
                    } else {
                        ret = numberFormatter(value, -1, void 0, '')
                    }
                }
                return ret
            }
            getSeriesExtremes() {
                const axis = this
                    , chart = axis.chart;
                let xExtremes;
                fireEvent(this, 'getSeriesExtremes', null, function() {
                    axis.hasVisibleSeries = !1;
                    axis.dataMin = axis.dataMax = axis.threshold = null;
                    axis.softThreshold = !axis.isXAxis;
                    axis.series.forEach(function(series) {
                        if (series.reserveSpace()) {
                            const seriesOptions = series.options;
                            let xData, threshold = seriesOptions.threshold, seriesDataMin, seriesDataMax;
                            axis.hasVisibleSeries = !0;
                            if (axis.positiveValuesOnly && threshold <= 0) {
                                threshold = null
                            }
                            if (axis.isXAxis) {
                                xData = series.xData;
                                if (xData && xData.length) {
                                    xData = axis.logarithmic ? xData.filter( (x) => x > 0) : xData;
                                    xExtremes = series.getXExtremes(xData);
                                    seriesDataMin = xExtremes.min;
                                    seriesDataMax = xExtremes.max;
                                    if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date)) {
                                        xData = xData.filter(isNumber);
                                        xExtremes = series.getXExtremes(xData);
                                        seriesDataMin = xExtremes.min;
                                        seriesDataMax = xExtremes.max
                                    }
                                    if (xData.length) {
                                        axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                                        axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax)
                                    }
                                }
                            } else {
                                const dataExtremes = series.applyExtremes();
                                if (isNumber(dataExtremes.dataMin)) {
                                    seriesDataMin = dataExtremes.dataMin;
                                    axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin)
                                }
                                if (isNumber(dataExtremes.dataMax)) {
                                    seriesDataMax = dataExtremes.dataMax;
                                    axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax)
                                }
                                if (defined(threshold)) {
                                    axis.threshold = threshold
                                }
                                if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
                                    axis.softThreshold = !1
                                }
                            }
                        }
                    })
                });
                fireEvent(this, 'afterGetSeriesExtremes')
            }
            translate(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
                const axis = (this.linkedParent || this)
                    , localMin = (old && axis.old ? axis.old.min : axis.min);
                if (!isNumber(localMin)) {
                    return NaN
                }
                const minPixelPadding = axis.minPixelPadding
                    , doPostTranslate = (axis.isOrdinal || axis.brokenAxis && axis.brokenAxis.hasBreaks || (axis.logarithmic && handleLog)) && axis.lin2val;
                let sign = 1
                    , cvsOffset = 0
                    , localA = old && axis.old ? axis.old.transA : axis.transA
                    , returnValue = 0;
                if (!localA) {
                    localA = axis.transA
                }
                if (cvsCoord) {
                    sign *= -1;
                    cvsOffset = axis.len
                }
                if (axis.reversed) {
                    sign *= -1;
                    cvsOffset -= sign * (axis.sector || axis.len)
                }
                if (backwards) {
                    val = val * sign + cvsOffset;
                    val -= minPixelPadding;
                    returnValue = val / localA + localMin;
                    if (doPostTranslate) {
                        returnValue = axis.lin2val(returnValue)
                    }
                } else {
                    if (doPostTranslate) {
                        val = axis.val2lin(val)
                    }
                    const value = sign * (val - localMin) * localA;
                    returnValue = (!axis.isRadial ? correctFloat(value) : value) + cvsOffset + (sign * minPixelPadding) + (isNumber(pointPlacement) ? localA * pointPlacement : 0)
                }
                return returnValue
            }
            toPixels(value, paneCoordinates) {
                return this.translate(value, !1, !this.horiz, void 0, !0) + (paneCoordinates ? 0 : this.pos)
            }
            toValue(pixel, paneCoordinates) {
                return this.translate(pixel - (paneCoordinates ? 0 : this.pos), !0, !this.horiz, void 0, !0)
            }
            getPlotLinePath(options) {
                const axis = this
                    , chart = axis.chart
                    , axisLeft = axis.left
                    , axisTop = axis.top
                    , old = options.old
                    , value = options.value
                    , lineWidth = options.lineWidth
                    , cHeight = (old && chart.oldChartHeight) || chart.chartHeight
                    , cWidth = (old && chart.oldChartWidth) || chart.chartWidth
                    , transB = axis.transB;
                let translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
                function between(x, a, b) {
                    if (force !== 'pass' && (x < a || x > b)) {
                        if (force) {
                            x = clamp(x, a, b)
                        } else {
                            skip = !0
                        }
                    }
                    return x
                }
                const evt = {
                    value: value,
                    lineWidth: lineWidth,
                    old: old,
                    force: force,
                    acrossPanes: options.acrossPanes,
                    translatedValue: translatedValue
                };
                fireEvent(this, 'getPlotLinePath', evt, function(e) {
                    translatedValue = pick(translatedValue, axis.translate(value, void 0, void 0, old));
                    translatedValue = clamp(translatedValue, -1e5, 1e5);
                    x1 = x2 = Math.round(translatedValue + transB);
                    y1 = y2 = Math.round(cHeight - translatedValue - transB);
                    if (!isNumber(translatedValue)) {
                        skip = !0;
                        force = !1
                    } else if (axis.horiz) {
                        y1 = axisTop;
                        y2 = cHeight - axis.bottom;
                        x1 = x2 = between(x1, axisLeft, axisLeft + axis.width)
                    } else {
                        x1 = axisLeft;
                        x2 = cWidth - axis.right;
                        y1 = y2 = between(y1, axisTop, axisTop + axis.height)
                    }
                    e.path = skip && !force ? void 0 : chart.renderer.crispLine([['M', x1, y1], ['L', x2, y2]], lineWidth || 1)
                });
                return (evt.path || null)
            }
            getLinearTickPositions(tickInterval, min, max) {
                const roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval)
                    , roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval)
                    , tickPositions = [];
                let pos, lastPos, precision;
                if (correctFloat(roundedMin + tickInterval) === roundedMin) {
                    precision = 20
                }
                if (this.single) {
                    return [min]
                }
                pos = roundedMin;
                while (pos <= roundedMax) {
                    tickPositions.push(pos);
                    pos = correctFloat(pos + tickInterval, precision);
                    if (pos === lastPos) {
                        break
                    }
                    lastPos = pos
                }
                return tickPositions
            }
            getMinorTickInterval() {
                const options = this.options;
                if (options.minorTicks === !0) {
                    return pick(options.minorTickInterval, 'auto')
                }
                if (options.minorTicks === !1) {
                    return null
                }
                return options.minorTickInterval
            }
            getMinorTickPositions() {
                const axis = this
                    , options = axis.options
                    , tickPositions = axis.tickPositions
                    , minorTickInterval = axis.minorTickInterval
                    , pointRangePadding = axis.pointRangePadding || 0
                    , min = axis.min - pointRangePadding
                    , max = axis.max + pointRangePadding
                    , range = max - min;
                let minorTickPositions = [], pos;
                if (range && range / minorTickInterval < axis.len / 3) {
                    const logarithmic = axis.logarithmic;
                    if (logarithmic) {
                        this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
                            if (i) {
                                minorTickPositions.push.apply(minorTickPositions, logarithmic.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], !0))
                            }
                        })
                    } else if (axis.dateTime && this.getMinorTickInterval() === 'auto') {
                        minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min, max, options.startOfWeek))
                    } else {
                        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
                            if (pos === minorTickPositions[0]) {
                                break
                            }
                            minorTickPositions.push(pos)
                        }
                    }
                }
                if (minorTickPositions.length !== 0) {
                    axis.trimTicks(minorTickPositions)
                }
                return minorTickPositions
            }
            adjustForMinRange() {
                const axis = this
                    , options = axis.options
                    , logarithmic = axis.logarithmic;
                let min = axis.min, max = axis.max, zoomOffset, spaceAvailable, closestDataRange, minArgs, maxArgs, minRange;
                if (axis.isXAxis && typeof axis.minRange === 'undefined' && !logarithmic) {
                    if (defined(options.min) || defined(options.max) || defined(options.floor) || defined(options.ceiling)) {
                        axis.minRange = null
                    } else {
                        closestDataRange = getClosestDistance(axis.series.map( (s) => (s.xIncrement ? s.xData?.slice(0, 2) : s.xData) || [])) || 0;
                        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin)
                    }
                }
                if (max - min < axis.minRange) {
                    spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
                    minRange = axis.minRange;
                    zoomOffset = (minRange - max + min) / 2;
                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
                    if (spaceAvailable) {
                        minArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMin) : axis.dataMin
                    }
                    min = arrayMax(minArgs);
                    maxArgs = [min + minRange, pick(options.max, min + minRange)];
                    if (spaceAvailable) {
                        maxArgs[2] = logarithmic ? logarithmic.log2lin(axis.dataMax) : axis.dataMax
                    }
                    max = arrayMin(maxArgs);
                    if (max - min < minRange) {
                        minArgs[0] = max - minRange;
                        minArgs[1] = pick(options.min, max - minRange);
                        min = arrayMax(minArgs)
                    }
                }
                axis.min = min;
                axis.max = max
            }
            getClosest() {
                let closestSingleDistance, closestDistance;
                if (this.categories) {
                    closestDistance = 1
                } else {
                    const singleXs = [];
                    this.series.forEach(function(series) {
                        const seriesClosest = series.closestPointRange;
                        if (series.xData?.length === 1) {
                            singleXs.push(series.xData[0])
                        } else if (!series.noSharedTooltip && defined(seriesClosest) && series.reserveSpace()) {
                            closestDistance = defined(closestDistance) ? Math.min(closestDistance, seriesClosest) : seriesClosest
                        }
                    });
                    if (singleXs.length) {
                        singleXs.sort( (a, b) => a - b);
                        closestSingleDistance = getClosestDistance([singleXs])
                    }
                }
                if (closestSingleDistance && closestDistance) {
                    return Math.min(closestSingleDistance, closestDistance)
                }
                return closestSingleDistance || closestDistance
            }
            nameToX(point) {
                const explicitCategories = isArray(this.options.categories)
                    , names = explicitCategories ? this.categories : this.names;
                let nameX = point.options.x, x;
                point.series.requireSorting = !1;
                if (!defined(nameX)) {
                    nameX = this.options.uniqueNames && names ? (explicitCategories ? names.indexOf(point.name) : pick(names.keys[point.name], -1)) : point.series.autoIncrement()
                }
                if (nameX === -1) {
                    if (!explicitCategories && names) {
                        x = names.length
                    }
                } else {
                    x = nameX
                }
                if (typeof x !== 'undefined') {
                    this.names[x] = point.name;
                    this.names.keys[point.name] = x
                } else if (point.x) {
                    x = point.x
                }
                return x
            }
            updateNames() {
                const axis = this
                    , names = this.names
                    , i = names.length;
                if (i > 0) {
                    Object.keys(names.keys).forEach(function(key) {
                        delete (names.keys)[key]
                    });
                    names.length = 0;
                    this.minRange = this.userMinRange;
                    (this.series || []).forEach(function(series) {
                        series.xIncrement = null;
                        if (!series.points || series.isDirtyData) {
                            axis.max = Math.max(axis.max, series.xData.length - 1);
                            series.processData();
                            series.generatePoints()
                        }
                        series.data.forEach(function(point, i) {
                            let x;
                            if (point && point.options && typeof point.name !== 'undefined') {
                                x = axis.nameToX(point);
                                if (typeof x !== 'undefined' && x !== point.x) {
                                    point.x = x;
                                    series.xData[i] = x
                                }
                            }
                        })
                    })
                }
            }
            setAxisTranslation() {
                const axis = this
                    , range = axis.max - axis.min
                    , linkedParent = axis.linkedParent
                    , hasCategories = !!axis.categories
                    , isXAxis = axis.isXAxis;
                let pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
                if (isXAxis || hasCategories || pointRange) {
                    closestPointRange = axis.getClosest();
                    if (linkedParent) {
                        minPointOffset = linkedParent.minPointOffset;
                        pointRangePadding = linkedParent.pointRangePadding
                    } else {
                        axis.series.forEach(function(series) {
                            const seriesPointRange = hasCategories ? 1 : (isXAxis ? pick(series.options.pointRange, closestPointRange, 0) : (axis.axisPointRange || 0))
                                , pointPlacement = series.options.pointPlacement;
                            pointRange = Math.max(pointRange, seriesPointRange);
                            if (!axis.single || hasCategories) {
                                const isPointPlacementAxis = series.is('xrange') ? !isXAxis : isXAxis;
                                minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString(pointPlacement) ? 0 : seriesPointRange / 2);
                                pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === 'on' ? 0 : seriesPointRange)
                            }
                        })
                    }
                    ordinalCorrection = (axis.ordinal && axis.ordinal.slope && closestPointRange) ? axis.ordinal.slope / closestPointRange : 1;
                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
                    axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
                    if (isXAxis && closestPointRange) {
                        axis.closestPointRange = closestPointRange
                    }
                }
                axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / ((range + pointRangePadding) || 1);
                axis.transB = axis.horiz ? axis.left : axis.bottom;
                axis.minPixelPadding = transA * minPointOffset;
                fireEvent(this, 'afterSetAxisTranslation')
            }
            minFromRange() {
                const axis = this;
                return axis.max - axis.range
            }
            setTickInterval(secondPass) {
                const axis = this
                    , chart = axis.chart
                    , log = axis.logarithmic
                    , options = axis.options
                    , isXAxis = axis.isXAxis
                    , isLinked = axis.isLinked
                    , tickPixelIntervalOption = options.tickPixelInterval
                    , categories = axis.categories
                    , softThreshold = axis.softThreshold;
                let maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = isNumber(options.tickInterval) && options.tickInterval >= 0 ? options.tickInterval : void 0, threshold = isNumber(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;
                if (!axis.dateTime && !categories && !isLinked) {
                    this.getTickAmount()
                }
                hardMin = pick(axis.userMin, options.min);
                hardMax = pick(axis.userMax, options.max);
                if (isLinked) {
                    axis.linkedParent = chart[axis.coll][options.linkedTo];
                    linkedParentExtremes = axis.linkedParent.getExtremes();
                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                    if (options.type !== axis.linkedParent.options.type) {
                        error(11, 1, chart)
                    }
                } else {
                    if (softThreshold && defined(threshold)) {
                        if (axis.dataMin >= threshold) {
                            thresholdMin = threshold;
                            minPadding = 0
                        } else if (axis.dataMax <= threshold) {
                            thresholdMax = threshold;
                            maxPadding = 0
                        }
                    }
                    axis.min = pick(hardMin, thresholdMin, axis.dataMin);
                    axis.max = pick(hardMax, thresholdMax, axis.dataMax)
                }
                if (log) {
                    if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) {
                        error(10, 1, chart)
                    }
                    axis.min = correctFloat(log.log2lin(axis.min), 16);
                    axis.max = correctFloat(log.log2lin(axis.max), 16)
                }
                if (axis.range && defined(axis.max)) {
                    axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange());
                    axis.userMax = hardMax = axis.max;
                    axis.range = null
                }
                fireEvent(axis, 'foundExtremes');
                if (axis.beforePadding) {
                    axis.beforePadding()
                }
                axis.adjustForMinRange();
                if (!isNumber(axis.userMin)) {
                    if (isNumber(options.softMin) && options.softMin < axis.min) {
                        axis.min = hardMin = options.softMin
                    }
                }
                if (!isNumber(axis.userMax)) {
                    if (isNumber(options.softMax) && options.softMax > axis.max) {
                        axis.max = hardMax = options.softMax
                    }
                }
                if (!categories && !axis.axisPointRange && !(axis.stacking && axis.stacking.usePercentage) && !isLinked && defined(axis.min) && defined(axis.max)) {
                    length = axis.max - axis.min;
                    if (length) {
                        if (!defined(hardMin) && minPadding) {
                            axis.min -= length * minPadding
                        }
                        if (!defined(hardMax) && maxPadding) {
                            axis.max += length * maxPadding
                        }
                    }
                }
                if (!isNumber(axis.userMin) && isNumber(options.floor)) {
                    axis.min = Math.max(axis.min, options.floor)
                }
                if (!isNumber(axis.userMax) && isNumber(options.ceiling)) {
                    axis.max = Math.min(axis.max, options.ceiling)
                }
                if (softThreshold && defined(axis.dataMin)) {
                    threshold = threshold || 0;
                    if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
                        axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold
                    } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
                        axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold
                    }
                }
                if (isNumber(axis.min) && isNumber(axis.max) && !this.chart.polar && (axis.min > axis.max)) {
                    if (defined(axis.options.min)) {
                        axis.max = axis.min
                    } else if (defined(axis.options.max)) {
                        axis.min = axis.max
                    }
                }
                if (axis.min === axis.max || typeof axis.min === 'undefined' || typeof axis.max === 'undefined') {
                    axis.tickInterval = 1
                } else if (isLinked && axis.linkedParent && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval
                } else {
                    axis.tickInterval = pick(tickIntervalOption, this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : void 0, categories ? 1 : (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption))
                }
                if (isXAxis && !secondPass) {
                    const hasExtremesChanged = axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);
                    axis.series.forEach(function(series) {
                        series.forceCrop = (series.forceCropping && series.forceCropping());
                        series.processData(hasExtremesChanged)
                    });
                    fireEvent(this, 'postProcessData', {
                        hasExtremesChanged
                    })
                }
                axis.setAxisTranslation();
                fireEvent(this, 'initialAxisTranslation');
                if (axis.pointRange && !tickIntervalOption) {
                    axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval)
                }
                const minTickInterval = pick(options.minTickInterval, axis.dateTime && !axis.series.some( (s) => s.noSharedTooltip) ? axis.closestPointRange : 0);
                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                    axis.tickInterval = minTickInterval
                }
                if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {
                    axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval)
                }
                if (!this.tickAmount) {
                    axis.tickInterval = axis.unsquish()
                }
                this.setTickPositions()
            }
            setTickPositions() {
                const axis = this
                    , options = this.options
                    , tickPositionsOption = options.tickPositions
                    , tickPositioner = options.tickPositioner
                    , minorTickIntervalOption = this.getMinorTickInterval()
                    , hasVerticalPanning = this.hasVerticalPanning()
                    , isColorAxis = this.coll === 'colorAxis'
                    , startOnTick = ((isColorAxis || !hasVerticalPanning) && options.startOnTick)
                    , endOnTick = ((isColorAxis || !hasVerticalPanning) && options.endOnTick);
                let tickPositions = [], tickPositionerResult;
                this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' && this.tickInterval === 1) ? 0.5 : 0;
                this.minorTickInterval = minorTickIntervalOption === 'auto' && this.tickInterval ? this.tickInterval / options.minorTicksPerMajor : minorTickIntervalOption;
                this.single = this.min === this.max && defined(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || options.allowDecimals !== !1);
                if (tickPositionsOption) {
                    tickPositions = tickPositionsOption.slice()
                } else if (isNumber(this.min) && isNumber(this.max)) {
                    if ((!axis.ordinal || !axis.ordinal.positions) && ((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {
                        tickPositions = [this.min, this.max];
                        error(19, !1, this.chart)
                    } else if (axis.dateTime) {
                        tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, !0)
                    } else if (axis.logarithmic) {
                        tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max)
                    } else {
                        const startingTickInterval = this.tickInterval;
                        let adjustedTickInterval = startingTickInterval;
                        while (adjustedTickInterval <= startingTickInterval * 2) {
                            tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
                            if (this.tickAmount && tickPositions.length > this.tickAmount) {
                                this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1)
                            } else {
                                break
                            }
                        }
                    }
                    if (tickPositions.length > this.len) {
                        tickPositions = [tickPositions[0], tickPositions[tickPositions.length - 1]];
                        if (tickPositions[0] === tickPositions[1]) {
                            tickPositions.length = 1
                        }
                    }
                    if (tickPositioner) {
                        this.tickPositions = tickPositions;
                        tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);
                        if (tickPositionerResult) {
                            tickPositions = tickPositionerResult
                        }
                    }
                }
                this.tickPositions = tickPositions;
                this.paddedTicks = tickPositions.slice(0);
                this.trimTicks(tickPositions, startOnTick, endOnTick);
                if (!this.isLinked && isNumber(this.min) && isNumber(this.max)) {
                    if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some( (s) => (s.is('heatmap') && s.options.pointPlacement === 'between'))) {
                        this.min -= 0.5;
                        this.max += 0.5
                    }
                    if (!tickPositionsOption && !tickPositionerResult) {
                        this.adjustTickAmount()
                    }
                }
                fireEvent(this, 'afterSetTickPositions')
            }
            trimTicks(tickPositions, startOnTick, endOnTick) {
                const roundedMin = tickPositions[0]
                    , roundedMax = tickPositions[tickPositions.length - 1]
                    , minPointOffset = (!this.isOrdinal && this.minPointOffset) || 0;
                fireEvent(this, 'trimTicks');
                if (!this.isLinked) {
                    if (startOnTick && roundedMin !== -Infinity) {
                        this.min = roundedMin
                    } else {
                        while (this.min - minPointOffset > tickPositions[0]) {
                            tickPositions.shift()
                        }
                    }
                    if (endOnTick) {
                        this.max = roundedMax
                    } else {
                        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
                            tickPositions.pop()
                        }
                    }
                    if (tickPositions.length === 0 && defined(roundedMin) && !this.options.tickPositions) {
                        tickPositions.push((roundedMax + roundedMin) / 2)
                    }
                }
            }
            alignToOthers() {
                const axis = this
                    , alignedAxes = [this]
                    , options = axis.options
                    , alignThresholds = (this.coll === 'yAxis' && this.chart.options.chart.alignThresholds)
                    , thresholdAlignments = [];
                let hasOther;
                axis.thresholdAlignment = void 0;
                if (((this.chart.options.chart.alignTicks !== !1 && options.alignTicks) || (alignThresholds)) && options.startOnTick !== !1 && options.endOnTick !== !1 && !axis.logarithmic) {
                    const getKey = (axis) => {
                            const {horiz, options} = axis;
                            return [horiz ? options.left : options.top, options.width, options.height, options.pane].join(',')
                        }
                    ;
                    const thisKey = getKey(this);
                    this.chart[this.coll].forEach(function(otherAxis) {
                        const {series} = otherAxis;
                        if (series.length && series.some( (s) => s.visible) && otherAxis !== axis && getKey(otherAxis) === thisKey) {
                            hasOther = !0;
                            alignedAxes.push(otherAxis)
                        }
                    })
                }
                if (hasOther && alignThresholds) {
                    alignedAxes.forEach( (otherAxis) => {
                            const threshAlign = otherAxis.getThresholdAlignment(axis);
                            if (isNumber(threshAlign)) {
                                thresholdAlignments.push(threshAlign)
                            }
                        }
                    );
                    const thresholdAlignment = thresholdAlignments.length > 1 ? thresholdAlignments.reduce( (sum, n) => (sum += n), 0) / thresholdAlignments.length : void 0;
                    alignedAxes.forEach( (axis) => {
                            axis.thresholdAlignment = thresholdAlignment
                        }
                    )
                }
                return hasOther
            }
            getThresholdAlignment(callerAxis) {
                if (!isNumber(this.dataMin) || (this !== callerAxis && this.series.some( (s) => (s.isDirty || s.isDirtyData)))) {
                    this.getSeriesExtremes()
                }
                if (isNumber(this.threshold)) {
                    let thresholdAlignment = clamp(((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0))), 0, 1);
                    if (this.options.reversed) {
                        thresholdAlignment = 1 - thresholdAlignment
                    }
                    return thresholdAlignment
                }
            }
            getTickAmount() {
                const axis = this
                    , options = this.options
                    , tickPixelInterval = options.tickPixelInterval;
                let tickAmount = options.tickAmount;
                if (!defined(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {
                    tickAmount = 2
                }
                if (!tickAmount && this.alignToOthers()) {
                    tickAmount = Math.ceil(this.len / tickPixelInterval) + 1
                }
                if (tickAmount < 4) {
                    this.finalTickAmt = tickAmount;
                    tickAmount = 5
                }
                this.tickAmount = tickAmount
            }
            adjustTickAmount() {
                const axis = this
                    , {finalTickAmt, max, min, options, tickPositions, tickAmount, thresholdAlignment} = axis
                    , currentTickAmount = tickPositions && tickPositions.length
                    , threshold = pick(axis.threshold, axis.softThreshold ? 0 : null);
                let len, i, tickInterval = axis.tickInterval, thresholdTickIndex;
                const append = () => tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + tickInterval))
                    , prepend = () => tickPositions.unshift(correctFloat(tickPositions[0] - tickInterval));
                if (isNumber(thresholdAlignment)) {
                    thresholdTickIndex = thresholdAlignment < 0.5 ? Math.ceil(thresholdAlignment * (tickAmount - 1)) : Math.floor(thresholdAlignment * (tickAmount - 1));
                    if (options.reversed) {
                        thresholdTickIndex = tickAmount - 1 - thresholdTickIndex
                    }
                }
                if (axis.hasData() && isNumber(min) && isNumber(max)) {
                    const adjustExtremes = () => {
                            axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                            axis.min = options.startOnTick ? tickPositions[0] : Math.min(min, tickPositions[0]);
                            axis.max = options.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(max, tickPositions[tickPositions.length - 1])
                        }
                    ;
                    if (isNumber(thresholdTickIndex) && isNumber(axis.threshold)) {
                        while (tickPositions[thresholdTickIndex] !== threshold || tickPositions.length !== tickAmount || tickPositions[0] > min || tickPositions[tickPositions.length - 1] < max) {
                            tickPositions.length = 0;
                            tickPositions.push(axis.threshold);
                            while (tickPositions.length < tickAmount) {
                                if (tickPositions[thresholdTickIndex] === void 0 || tickPositions[thresholdTickIndex] > axis.threshold) {
                                    prepend()
                                } else {
                                    append()
                                }
                            }
                            if (tickInterval > axis.tickInterval * 8) {
                                break
                            }
                            tickInterval *= 2
                        }
                        adjustExtremes()
                    } else if (currentTickAmount < tickAmount) {
                        while (tickPositions.length < tickAmount) {
                            if (tickPositions.length % 2 || min === threshold) {
                                append()
                            } else {
                                prepend()
                            }
                        }
                        adjustExtremes()
                    }
                    if (defined(finalTickAmt)) {
                        i = len = tickPositions.length;
                        while (i--) {
                            if ((finalTickAmt === 3 && i % 2 === 1) || (finalTickAmt <= 2 && i > 0 && i < len - 1)) {
                                tickPositions.splice(i, 1)
                            }
                        }
                        axis.finalTickAmt = void 0
                    }
                }
            }
            setScale() {
                const axis = this
                    , {coll, stacking} = axis;
                let isDirtyData = !1
                    , isXAxisDirty = !1;
                axis.series.forEach( (series) => {
                        isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
                        isXAxisDirty = (isXAxisDirty || (series.xAxis && series.xAxis.isDirty) || !1)
                    }
                );
                axis.setAxisSize();
                const isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
                if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {
                    if (stacking && coll === 'yAxis') {
                        stacking.buildStacks()
                    }
                    axis.forceRedraw = !1;
                    if (!axis.userMinRange) {
                        axis.minRange = void 0
                    }
                    axis.getSeriesExtremes();
                    axis.setTickInterval();
                    if (stacking && coll === 'xAxis') {
                        stacking.buildStacks()
                    }
                    if (!axis.isDirty) {
                        axis.isDirty = isDirtyAxisLength || axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max)
                    }
                } else if (stacking) {
                    stacking.cleanStacks()
                }
                if (isDirtyData && axis.panningState) {
                    axis.panningState.isDirty = !0
                }
                fireEvent(this, 'afterSetScale')
            }
            setExtremes(newMin, newMax, redraw, animation, eventArguments) {
                const axis = this
                    , chart = axis.chart;
                redraw = pick(redraw, !0);
                axis.series.forEach(function(serie) {
                    delete serie.kdTree
                });
                eventArguments = extend(eventArguments, {
                    min: newMin,
                    max: newMax
                });
                fireEvent(axis, 'setExtremes', eventArguments, function() {
                    axis.userMin = newMin;
                    axis.userMax = newMax;
                    axis.eventArgs = eventArguments;
                    if (redraw) {
                        chart.redraw(animation)
                    }
                })
            }
            zoom(newMin, newMax) {
                const axis = this
                    , dataMin = this.dataMin
                    , dataMax = this.dataMax
                    , options = this.options
                    , min = Math.min(dataMin, pick(options.min, dataMin))
                    , max = Math.max(dataMax, pick(options.max, dataMax))
                    , evt = {
                    newMin: newMin,
                    newMax: newMax
                };
                fireEvent(this, 'zoom', evt, function(e) {
                    let newMin = e.newMin
                        , newMax = e.newMax;
                    if (newMin !== axis.min || newMax !== axis.max) {
                        if (!axis.allowZoomOutside) {
                            if (defined(dataMin)) {
                                if (newMin < min) {
                                    newMin = min
                                }
                                if (newMin > max) {
                                    newMin = max
                                }
                            }
                            if (defined(dataMax)) {
                                if (newMax < min) {
                                    newMax = min
                                }
                                if (newMax > max) {
                                    newMax = max
                                }
                            }
                        }
                        axis.displayBtn = (typeof newMin !== 'undefined' || typeof newMax !== 'undefined');
                        axis.setExtremes(newMin, newMax, !1, void 0, {
                            trigger: 'zoom'
                        })
                    }
                    e.zoomed = !0
                });
                return evt.zoomed
            }
            setAxisSize() {
                const chart = this.chart
                    , options = this.options
                    , offsets = options.offsets || [0, 0, 0, 0]
                    , horiz = this.horiz
                    , width = this.width = Math.round(relativeLength(pick(options.width, chart.plotWidth - offsets[3] + offsets[1]), chart.plotWidth))
                    , height = this.height = Math.round(relativeLength(pick(options.height, chart.plotHeight - offsets[0] + offsets[2]), chart.plotHeight))
                    , top = this.top = Math.round(relativeLength(pick(options.top, chart.plotTop + offsets[0]), chart.plotHeight, chart.plotTop))
                    , left = this.left = Math.round(relativeLength(pick(options.left, chart.plotLeft + offsets[3]), chart.plotWidth, chart.plotLeft));
                this.bottom = chart.chartHeight - height - top;
                this.right = chart.chartWidth - width - left;
                this.len = Math.max(horiz ? width : height, 0);
                this.pos = horiz ? left : top
            }
            getExtremes() {
                const axis = this
                    , log = axis.logarithmic;
                return {
                    min: log ? correctFloat(log.lin2log(axis.min)) : axis.min,
                    max: log ? correctFloat(log.lin2log(axis.max)) : axis.max,
                    dataMin: axis.dataMin,
                    dataMax: axis.dataMax,
                    userMin: axis.userMin,
                    userMax: axis.userMax
                }
            }
            getThreshold(threshold) {
                const axis = this
                    , log = axis.logarithmic
                    , realMin = log ? log.lin2log(axis.min) : axis.min
                    , realMax = log ? log.lin2log(axis.max) : axis.max;
                if (threshold === null || threshold === -Infinity) {
                    threshold = realMin
                } else if (threshold === Infinity) {
                    threshold = realMax
                } else if (realMin > threshold) {
                    threshold = realMin
                } else if (realMax < threshold) {
                    threshold = realMax
                }
                return axis.translate(threshold, 0, 1, 0, 1)
            }
            autoLabelAlign(rotation) {
                const angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360
                    , evt = {
                    align: 'center'
                };
                fireEvent(this, 'autoLabelAlign', evt, function(e) {
                    if (angle > 15 && angle < 165) {
                        e.align = 'right'
                    } else if (angle > 195 && angle < 345) {
                        e.align = 'left'
                    }
                });
                return evt.align
            }
            tickSize(prefix) {
                const options = this.options
                    , tickWidth = pick(options[prefix === 'tick' ? 'tickWidth' : 'minorTickWidth'], prefix === 'tick' && this.isXAxis && !this.categories ? 1 : 0);
                let tickLength = options[prefix === 'tick' ? 'tickLength' : 'minorTickLength'], tickSize;
                if (tickWidth && tickLength) {
                    if (options[prefix + 'Position'] === 'inside') {
                        tickLength = -tickLength
                    }
                    tickSize = [tickLength, tickWidth]
                }
                const e = {
                    tickSize
                };
                fireEvent(this, 'afterTickSize', e);
                return e.tickSize
            }
            labelMetrics() {
                const renderer = this.chart.renderer
                    , ticks = this.ticks
                    , tick = ticks[Object.keys(ticks)[0]] || {};
                return this.chart.renderer.fontMetrics(tick.label || tick.movedLabel || renderer.box)
            }
            unsquish() {
                const labelOptions = this.options.labels
                    , horiz = this.horiz
                    , tickInterval = this.tickInterval
                    , slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval)
                    , rotationOption = labelOptions.rotation
                    , lineHeight = this.labelMetrics().h * 0.75
                    , range = Math.max(this.max - this.min, 0)
                    , getStep = function(spaceNeeded) {
                    let step = spaceNeeded / (slotSize || 1);
                    step = step > 1 ? Math.ceil(step) : 1;
                    if (step * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {
                        step = Math.ceil(range / tickInterval)
                    }
                    return correctFloat(step * tickInterval)
                };
                let newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;
                if (horiz) {
                    if (!labelOptions.staggerLines) {
                        if (isNumber(rotationOption)) {
                            autoRotation = [rotationOption]
                        } else if (slotSize < labelOptions.autoRotationLimit) {
                            autoRotation = labelOptions.autoRotation
                        }
                    }
                    if (autoRotation) {
                        let step, score;
                        for (const rot of autoRotation) {
                            if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) {
                                step = getStep(Math.abs(lineHeight / Math.sin(deg2rad * rot)));
                                score = step + Math.abs(rot / 360);
                                if (score < bestScore) {
                                    bestScore = score;
                                    rotation = rot;
                                    newTickInterval = step
                                }
                            }
                        }
                    }
                } else {
                    newTickInterval = getStep(lineHeight)
                }
                this.autoRotation = autoRotation;
                this.labelRotation = pick(rotation, isNumber(rotationOption) ? rotationOption : 0);
                return labelOptions.step ? tickInterval : newTickInterval
            }
            getSlotWidth(tick) {
                const chart = this.chart
                    , horiz = this.horiz
                    , labelOptions = this.options.labels
                    , slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1)
                    , marginLeft = chart.margin[3];
                if (tick && isNumber(tick.slotWidth)) {
                    return tick.slotWidth
                }
                if (horiz && labelOptions.step < 2) {
                    if (labelOptions.rotation) {
                        return 0
                    }
                    return ((this.staggerLines || 1) * this.len) / slotCount
                }
                if (!horiz) {
                    const cssWidth = labelOptions.style.width;
                    if (cssWidth !== void 0) {
                        return parseInt(String(cssWidth), 10)
                    }
                    if (marginLeft) {
                        return marginLeft - chart.spacing[3]
                    }
                }
                return chart.chartWidth * 0.33
            }
            renderUnsquish() {
                const chart = this.chart
                    , renderer = chart.renderer
                    , tickPositions = this.tickPositions
                    , ticks = this.ticks
                    , labelOptions = this.options.labels
                    , labelStyleOptions = labelOptions.style
                    , horiz = this.horiz
                    , slotWidth = this.getSlotWidth()
                    , innerWidth = Math.max(1, Math.round(slotWidth - 2 * labelOptions.padding))
                    , attr = {}
                    , labelMetrics = this.labelMetrics()
                    , textOverflowOption = labelStyleOptions.textOverflow;
                let commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
                if (!isString(labelOptions.rotation)) {
                    attr.rotation = labelOptions.rotation || 0
                }
                tickPositions.forEach(function(tickPosition) {
                    const tick = ticks[tickPosition];
                    if (tick.movedLabel) {
                        tick.replaceMovedLabel()
                    }
                    if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
                        maxLabelLength = tick.label.textPxLength
                    }
                });
                this.maxLabelLength = maxLabelLength;
                if (this.autoRotation) {
                    if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
                        attr.rotation = this.labelRotation
                    } else {
                        this.labelRotation = 0
                    }
                } else if (slotWidth) {
                    commonWidth = innerWidth;
                    if (!textOverflowOption) {
                        commonTextOverflow = 'clip';
                        i = tickPositions.length;
                        while (!horiz && i--) {
                            pos = tickPositions[i];
                            label = ticks[pos].label;
                            if (label) {
                                if (label.styles && label.styles.textOverflow === 'ellipsis') {
                                    label.css({
                                        textOverflow: 'clip'
                                    })
                                } else if (label.textPxLength > slotWidth) {
                                    label.css({
                                        width: slotWidth + 'px'
                                    })
                                }
                                if (label.getBBox().height > (this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f))) {
                                    label.specificTextOverflow = 'ellipsis'
                                }
                            }
                        }
                    }
                }
                if (attr.rotation) {
                    commonWidth = (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength);
                    if (!textOverflowOption) {
                        commonTextOverflow = 'ellipsis'
                    }
                }
                this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
                if (this.labelAlign) {
                    attr.align = this.labelAlign
                }
                tickPositions.forEach(function(pos) {
                    const tick = ticks[pos]
                        , label = tick && tick.label
                        , widthOption = labelStyleOptions.width
                        , css = {};
                    if (label) {
                        label.attr(attr);
                        if (tick.shortenLabel) {
                            tick.shortenLabel()
                        } else if (commonWidth && !widthOption && labelStyleOptions.whiteSpace !== 'nowrap' && (commonWidth < label.textPxLength || label.element.tagName === 'SPAN')) {
                            css.width = commonWidth + 'px';
                            if (!textOverflowOption) {
                                css.textOverflow = (label.specificTextOverflow || commonTextOverflow)
                            }
                            label.css(css)
                        } else if (label.styles && label.styles.width && !css.width && !widthOption) {
                            label.css({
                                width: null
                            })
                        }
                        delete label.specificTextOverflow;
                        tick.rotation = attr.rotation
                    }
                }, this);
                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0)
            }
            hasData() {
                return this.series.some(function(s) {
                    return s.hasData()
                }) || (this.options.showEmpty && defined(this.min) && defined(this.max))
            }
            addTitle(display) {
                const axis = this
                    , renderer = axis.chart.renderer
                    , horiz = axis.horiz
                    , opposite = axis.opposite
                    , options = axis.options
                    , axisTitleOptions = options.title
                    , styledMode = axis.chart.styledMode;
                let textAlign;
                if (!axis.axisTitle) {
                    textAlign = axisTitleOptions.textAlign;
                    if (!textAlign) {
                        textAlign = (horiz ? {
                            low: 'left',
                            middle: 'center',
                            high: 'right'
                        } : {
                            low: opposite ? 'right' : 'left',
                            middle: 'center',
                            high: opposite ? 'left' : 'right'
                        })[axisTitleOptions.align]
                    }
                    axis.axisTitle = renderer.text(axisTitleOptions.text || '', 0, 0, axisTitleOptions.useHTML).attr({
                        zIndex: 7,
                        rotation: axisTitleOptions.rotation,
                        align: textAlign
                    }).addClass('highcharts-axis-title');
                    if (!styledMode) {
                        axis.axisTitle.css(merge(axisTitleOptions.style))
                    }
                    axis.axisTitle.add(axis.axisGroup);
                    axis.axisTitle.isNew = !0
                }
                if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
                    axis.axisTitle.css({
                        width: axis.len + 'px'
                    })
                }
                axis.axisTitle[display ? 'show' : 'hide'](display)
            }
            generateTick(pos) {
                const axis = this
                    , ticks = axis.ticks;
                if (!ticks[pos]) {
                    ticks[pos] = new Tick(axis,pos)
                } else {
                    ticks[pos].addLabel()
                }
            }
            getOffset() {
                const axis = this
                    , {chart, horiz, options, side, ticks, tickPositions, coll, axisParent} = axis
                    , renderer = chart.renderer
                    , invertedSide = (chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side)
                    , hasData = axis.hasData()
                    , axisTitleOptions = options.title
                    , labelOptions = options.labels
                    , hasCrossing = isNumber(options.crossing)
                    , axisOffset = chart.axisOffset
                    , clipOffset = chart.clipOffset
                    , directionFactor = [-1, 1, 1, -1][side]
                    , className = options.className;
                let showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
                axis.showAxis = showAxis = hasData || options.showEmpty;
                axis.staggerLines = (axis.horiz && labelOptions.staggerLines) || void 0;
                if (!axis.axisGroup) {
                    const createGroup = (name, suffix, zIndex) => renderer.g(name).attr({
                        zIndex
                    }).addClass(`highcharts-${coll.toLowerCase()}${suffix} ` + (this.isRadial ? `highcharts-radial-axis${suffix} ` : '') + (className || '')).add(axisParent);
                    axis.gridGroup = createGroup('grid', '-grid', options.gridZIndex);
                    axis.axisGroup = createGroup('axis', '', options.zIndex);
                    axis.labelGroup = createGroup('axis-labels', '-labels', labelOptions.zIndex)
                }
                if (hasData || axis.isLinked) {
                    tickPositions.forEach(function(pos) {
                        axis.generateTick(pos)
                    });
                    axis.renderUnsquish();
                    axis.reserveSpaceDefault = (side === 0 || side === 2 || {
                        1: 'left',
                        3: 'right'
                    }[side] === axis.labelAlign);
                    if (pick(labelOptions.reserveSpace, hasCrossing ? !1 : null, axis.labelAlign === 'center' ? !0 : null, axis.reserveSpaceDefault)) {
                        tickPositions.forEach(function(pos) {
                            labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset)
                        })
                    }
                    if (axis.staggerLines) {
                        labelOffset *= axis.staggerLines
                    }
                    axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1)
                } else {
                    objectEach(ticks, function(tick, n) {
                        tick.destroy();
                        delete ticks[n]
                    })
                }
                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== !1) {
                    axis.addTitle(showAxis);
                    if (showAxis && !hasCrossing && axisTitleOptions.reserveSpace !== !1) {
                        axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
                        titleOffsetOption = axisTitleOptions.offset;
                        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10)
                    }
                }
                axis.renderLine();
                axis.offset = directionFactor * pick(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
                axis.tickRotCorr = axis.tickRotCorr || {
                    x: 0,
                    y: 0
                };
                if (side === 0) {
                    lineHeightCorrection = -axis.labelMetrics().h
                } else if (side === 2) {
                    lineHeightCorrection = axis.tickRotCorr.y
                } else {
                    lineHeightCorrection = 0
                }
                labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
                if (labelOffset) {
                    labelOffsetPadded -= lineHeightCorrection;
                    labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * labelOptions.distance) : pick(labelOptions.x, directionFactor * labelOptions.distance))
                }
                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);
                if (axis.getMaxLabelDimensions) {
                    axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions)
                }
                if (coll !== 'colorAxis') {
                    const tickSize = this.tickSize('tick');
                    axisOffset[side] = Math.max(axisOffset[side], (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset, labelOffsetPadded, tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0);
                    const clip = !axis.axisLine || options.offset ? 0 : Math.floor(axis.axisLine.strokeWidth() / 2) * 2;
                    clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip)
                }
                fireEvent(this, 'afterGetOffset')
            }
            getLinePath(lineWidth) {
                const chart = this.chart
                    , opposite = this.opposite
                    , offset = this.offset
                    , horiz = this.horiz
                    , lineLeft = this.left + (opposite ? this.width : 0) + offset
                    , lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;
                if (opposite) {
                    lineWidth *= -1
                }
                return chart.renderer.crispLine([['M', horiz ? this.left : lineLeft, horiz ? lineTop : this.top], ['L', horiz ? chart.chartWidth - this.right : lineLeft, horiz ? lineTop : chart.chartHeight - this.bottom]], lineWidth)
            }
            renderLine() {
                if (!this.axisLine) {
                    this.axisLine = this.chart.renderer.path().addClass('highcharts-axis-line').add(this.axisGroup);
                    if (!this.chart.styledMode) {
                        this.axisLine.attr({
                            stroke: this.options.lineColor,
                            'stroke-width': this.options.lineWidth,
                            zIndex: 7
                        })
                    }
                }
            }
            getTitlePosition(axisTitle) {
                const horiz = this.horiz
                    , axisLeft = this.left
                    , axisTop = this.top
                    , axisLength = this.len
                    , axisTitleOptions = this.options.title
                    , margin = horiz ? axisLeft : axisTop
                    , opposite = this.opposite
                    , offset = this.offset
                    , xOption = axisTitleOptions.x
                    , yOption = axisTitleOptions.y
                    , fontMetrics = this.chart.renderer.fontMetrics(axisTitle)
                    , textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(!1, 0).height - fontMetrics.h - 1, 0) : 0
                    , alongAxis = ({
                    low: margin + (horiz ? 0 : axisLength),
                    middle: margin + axisLength / 2,
                    high: margin + (horiz ? axisLength : 0)
                })[axisTitleOptions.align]
                    , offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * (opposite ? -1 : 1) * (this.axisTitleMargin || 0) + [-textHeightOvershoot, textHeightOvershoot, fontMetrics.f, -textHeightOvershoot][this.side]
                    , titlePosition = {
                    x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
                    y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption
                };
                fireEvent(this, 'afterGetTitlePosition', {
                    titlePosition: titlePosition
                });
                return titlePosition
            }
            renderMinorTick(pos, slideIn) {
                const axis = this;
                const minorTicks = axis.minorTicks;
                if (!minorTicks[pos]) {
                    minorTicks[pos] = new Tick(axis,pos,'minor')
                }
                if (slideIn && minorTicks[pos].isNew) {
                    minorTicks[pos].render(null, !0)
                }
                minorTicks[pos].render(null, !1, 1)
            }
            renderTick(pos, i, slideIn) {
                const axis = this
                    , isLinked = axis.isLinked
                    , ticks = axis.ticks;
                if (!isLinked || (pos >= axis.min && pos <= axis.max) || (axis.grid && axis.grid.isColumn)) {
                    if (!ticks[pos]) {
                        ticks[pos] = new Tick(axis,pos)
                    }
                    if (slideIn && ticks[pos].isNew) {
                        ticks[pos].render(i, !0, -1)
                    }
                    ticks[pos].render(i)
                }
            }
            render() {
                const axis = this
                    , chart = axis.chart
                    , log = axis.logarithmic
                    , renderer = chart.renderer
                    , options = axis.options
                    , isLinked = axis.isLinked
                    , tickPositions = axis.tickPositions
                    , axisTitle = axis.axisTitle
                    , ticks = axis.ticks
                    , minorTicks = axis.minorTicks
                    , alternateBands = axis.alternateBands
                    , stackLabelOptions = options.stackLabels
                    , alternateGridColor = options.alternateGridColor
                    , crossing = options.crossing
                    , tickmarkOffset = axis.tickmarkOffset
                    , axisLine = axis.axisLine
                    , showAxis = axis.showAxis
                    , animation = animObject(renderer.globalAnimation);
                let from, to;
                axis.labelEdge.length = 0;
                axis.overlap = !1;
                [ticks, minorTicks, alternateBands].forEach(function(coll) {
                    objectEach(coll, function(tick) {
                        tick.isActive = !1
                    })
                });
                if (isNumber(crossing)) {
                    const otherAxis = this.isXAxis ? chart.yAxis[0] : chart.xAxis[0]
                        , directionFactor = [1, -1, -1, 1][this.side];
                    if (otherAxis) {
                        let px = otherAxis.toPixels(crossing, !0);
                        if (axis.horiz) {
                            px = otherAxis.len - px
                        }
                        axis.offset = directionFactor * px
                    }
                }
                if (axis.hasData() || isLinked) {
                    const slideInTicks = axis.chart.hasRendered && axis.old && isNumber(axis.old.min);
                    if (axis.minorTickInterval && !axis.categories) {
                        axis.getMinorTickPositions().forEach(function(pos) {
                            axis.renderMinorTick(pos, slideInTicks)
                        })
                    }
                    if (tickPositions.length) {
                        tickPositions.forEach(function(pos, i) {
                            axis.renderTick(pos, i, slideInTicks)
                        });
                        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                            if (!ticks[-1]) {
                                ticks[-1] = new Tick(axis,-1,null,!0)
                            }
                            ticks[-1].render(-1)
                        }
                    }
                    if (alternateGridColor) {
                        tickPositions.forEach(function(pos, i) {
                            to = typeof tickPositions[i + 1] !== 'undefined' ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
                            if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
                                if (!alternateBands[pos]) {
                                    alternateBands[pos] = new H.PlotLineOrBand(axis)
                                }
                                from = pos + tickmarkOffset;
                                alternateBands[pos].options = {
                                    from: log ? log.lin2log(from) : from,
                                    to: log ? log.lin2log(to) : to,
                                    color: alternateGridColor,
                                    className: 'highcharts-alternate-grid'
                                };
                                alternateBands[pos].render();
                                alternateBands[pos].isActive = !0
                            }
                        })
                    }
                    if (!axis._addedPlotLB) {
                        axis._addedPlotLB = !0;
                        (options.plotLines || []).concat(options.plotBands || []).forEach(function(plotLineOptions) {
                            axis.addPlotBandOrLine(plotLineOptions)
                        })
                    }
                }
                [ticks, minorTicks, alternateBands].forEach(function(coll) {
                    const forDestruction = []
                        , delay = animation.duration
                        , destroyInactiveItems = function() {
                        let i = forDestruction.length;
                        while (i--) {
                            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                                coll[forDestruction[i]].destroy();
                                delete coll[forDestruction[i]]
                            }
                        }
                    };
                    objectEach(coll, function(tick, pos) {
                        if (!tick.isActive) {
                            tick.render(pos, !1, 0);
                            tick.isActive = !1;
                            forDestruction.push(pos)
                        }
                    });
                    syncTimeout(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay)
                });
                if (axisLine) {
                    axisLine[axisLine.isPlaced ? 'animate' : 'attr']({
                        d: this.getLinePath(axisLine.strokeWidth())
                    });
                    axisLine.isPlaced = !0;
                    axisLine[showAxis ? 'show' : 'hide'](showAxis)
                }
                if (axisTitle && showAxis) {
                    axisTitle[axisTitle.isNew ? 'attr' : 'animate'](axis.getTitlePosition(axisTitle));
                    axisTitle.isNew = !1
                }
                if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
                    axis.stacking.renderStackTotals()
                }
                axis.old = {
                    len: axis.len,
                    max: axis.max,
                    min: axis.min,
                    transA: axis.transA,
                    userMax: axis.userMax,
                    userMin: axis.userMin
                };
                axis.isDirty = !1;
                fireEvent(this, 'afterRender')
            }
            redraw() {
                if (this.visible) {
                    this.render();
                    this.plotLinesAndBands.forEach(function(plotLine) {
                        plotLine.render()
                    })
                }
                this.series.forEach(function(series) {
                    series.isDirty = !0
                })
            }
            getKeepProps() {
                return (this.keepProps || Axis.keepProps)
            }
            destroy(keepEvents) {
                const axis = this
                    , plotLinesAndBands = axis.plotLinesAndBands
                    , eventOptions = this.eventOptions;
                fireEvent(this, 'destroy', {
                    keepEvents: keepEvents
                });
                if (!keepEvents) {
                    removeEvent(axis)
                }
                [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
                    destroyObjectProperties(coll)
                });
                if (plotLinesAndBands) {
                    let i = plotLinesAndBands.length;
                    while (i--) {
                        plotLinesAndBands[i].destroy()
                    }
                }
                ['axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross', 'scrollbar'].forEach(function(prop) {
                    if (axis[prop]) {
                        axis[prop] = axis[prop].destroy()
                    }
                });
                for (const plotGroup in axis.plotLinesAndBandsGroups) {
                    axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy()
                }
                objectEach(axis, function(val, key) {
                    if (axis.getKeepProps().indexOf(key) === -1) {
                        delete axis[key]
                    }
                });
                this.eventOptions = eventOptions
            }
            drawCrosshair(e, point) {
                const options = this.crosshair
                    , snap = pick(options && options.snap, !0)
                    , chart = this.chart;
                let path, pos, categorized, graphic = this.cross, crossOptions;
                fireEvent(this, 'drawCrosshair', {
                    e: e,
                    point: point
                });
                if (!e) {
                    e = this.cross && this.cross.e
                }
                if (!options || ((defined(point) || !snap) === !1)) {
                    this.hideCrosshair()
                } else {
                    if (!snap) {
                        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos)
                    } else if (defined(point)) {
                        pos = pick(this.coll !== 'colorAxis' ? point.crosshairPos : null, this.isXAxis ? point.plotX : this.len - point.plotY)
                    }
                    if (defined(pos)) {
                        crossOptions = {
                            value: point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),
                            translatedValue: pos
                        };
                        if (chart.polar) {
                            extend(crossOptions, {
                                isCrosshair: !0,
                                chartX: e && e.chartX,
                                chartY: e && e.chartY,
                                point: point
                            })
                        }
                        path = this.getPlotLinePath(crossOptions) || null
                    }
                    if (!defined(path)) {
                        this.hideCrosshair();
                        return
                    }
                    categorized = this.categories && !this.isRadial;
                    if (!graphic) {
                        this.cross = graphic = chart.renderer.path().addClass('highcharts-crosshair highcharts-crosshair-' + (categorized ? 'category ' : 'thin ') + (options.className || '')).attr({
                            zIndex: pick(options.zIndex, 2)
                        }).add();
                        if (!chart.styledMode) {
                            graphic.attr({
                                stroke: options.color || (categorized ? Color.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"),
                                'stroke-width': pick(options.width, 1)
                            }).css({
                                'pointer-events': 'none'
                            });
                            if (options.dashStyle) {
                                graphic.attr({
                                    dashstyle: options.dashStyle
                                })
                            }
                        }
                    }
                    graphic.show().attr({
                        d: path
                    });
                    if (categorized && !options.width) {
                        graphic.attr({
                            'stroke-width': this.transA
                        })
                    }
                    this.cross.e = e
                }
                fireEvent(this, 'afterDrawCrosshair', {
                    e: e,
                    point: point
                })
            }
            hideCrosshair() {
                if (this.cross) {
                    this.cross.hide()
                }
                fireEvent(this, 'afterHideCrosshair')
            }
            hasVerticalPanning() {
                const panningOptions = this.chart.options.chart.panning;
                return Boolean(panningOptions && panningOptions.enabled && /y/.test(panningOptions.type))
            }
            update(options, redraw) {
                const chart = this.chart;
                options = merge(this.userOptions, options);
                this.destroy(!0);
                this.init(chart, options);
                chart.isDirtyBox = !0;
                if (pick(redraw, !0)) {
                    chart.redraw()
                }
            }
            remove(redraw) {
                const chart = this.chart
                    , coll = this.coll
                    , axisSeries = this.series;
                let i = axisSeries.length;
                while (i--) {
                    if (axisSeries[i]) {
                        axisSeries[i].remove(!1)
                    }
                }
                erase(chart.axes, this);
                erase(chart[coll] || [], this);
                chart.orderItems(coll);
                this.destroy();
                chart.isDirtyBox = !0;
                if (pick(redraw, !0)) {
                    chart.redraw()
                }
            }
            setTitle(titleOptions, redraw) {
                this.update({
                    title: titleOptions
                }, redraw)
            }
            setCategories(categories, redraw) {
                this.update({
                    categories: categories
                }, redraw)
            }
        }
        Axis.defaultOptions = AxisDefaults.defaultXAxisOptions;
        Axis.keepProps = ['coll', 'extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'];
        '';
        return Axis
    });
    _registerModule(_modules, 'Core/Axis/DateTimeAxis.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, getMagnitude, normalizeTickInterval, timeUnits} = U;
        var DateTimeAxis;
        (function(DateTimeAxis) {
                const composedMembers = [];
                function compose(AxisClass) {
                    if (U.pushUnique(composedMembers, AxisClass)) {
                        AxisClass.keepProps.push('dateTime');
                        const axisProto = AxisClass.prototype;
                        axisProto.getTimeTicks = getTimeTicks;
                        addEvent(AxisClass, 'init', onInit)
                    }
                    return AxisClass
                }
                DateTimeAxis.compose = compose;
                function getTimeTicks() {
                    return this.chart.time.getTimeTicks.apply(this.chart.time, arguments)
                }
                function onInit(e) {
                    const axis = this;
                    const options = e.userOptions;
                    if (options.type !== 'datetime') {
                        axis.dateTime = void 0;
                        return
                    }
                    if (!axis.dateTime) {
                        axis.dateTime = new Additions(axis)
                    }
                }
                class Additions {
                    constructor(axis) {
                        this.axis = axis
                    }
                    normalizeTimeTickInterval(tickInterval, unitsOption) {
                        const units = (unitsOption || [['millisecond', [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ['second', [1, 2, 5, 10, 15, 30]], ['minute', [1, 2, 5, 10, 15, 30]], ['hour', [1, 2, 3, 4, 6, 8, 12]], ['day', [1, 2]], ['week', [1, 2]], ['month', [1, 2, 3, 4, 6]], ['year', null]]);
                        let unit = units[units.length - 1], interval = timeUnits[unit[0]], multiples = unit[1], i;
                        for (i = 0; i < units.length; i++) {
                            unit = units[i];
                            interval = timeUnits[unit[0]];
                            multiples = unit[1];
                            if (units[i + 1]) {
                                const lessThan = (interval * multiples[multiples.length - 1] + timeUnits[units[i + 1][0]]) / 2;
                                if (tickInterval <= lessThan) {
                                    break
                                }
                            }
                        }
                        if (interval === timeUnits.year && tickInterval < 5 * interval) {
                            multiples = [1, 2, 5]
                        }
                        const count = normalizeTickInterval(tickInterval / interval, multiples, unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1);
                        return {
                            unitRange: interval,
                            count: count,
                            unitName: unit[0]
                        }
                    }
                    getXDateFormat(x, dateTimeLabelFormats) {
                        const {axis} = this
                            , time = axis.chart.time;
                        return axis.closestPointRange ? time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || time.resolveDTLFormat(dateTimeLabelFormats.year).main : time.resolveDTLFormat(dateTimeLabelFormats.day).main
                    }
                }
                DateTimeAxis.Additions = Additions
            }
        )(DateTimeAxis || (DateTimeAxis = {}));
        return DateTimeAxis
    });
    _registerModule(_modules, 'Core/Axis/LogarithmicAxis.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, normalizeTickInterval, pick} = U;
        var LogarithmicAxis;
        (function(LogarithmicAxis) {
                const composedMembers = [];
                function compose(AxisClass) {
                    if (U.pushUnique(composedMembers, AxisClass)) {
                        AxisClass.keepProps.push('logarithmic');
                        addEvent(AxisClass, 'init', onInit);
                        addEvent(AxisClass, 'afterInit', onAfterInit)
                    }
                    return AxisClass
                }
                LogarithmicAxis.compose = compose;
                function onInit(e) {
                    const axis = this;
                    const options = e.userOptions;
                    let logarithmic = axis.logarithmic;
                    if (options.type !== 'logarithmic') {
                        axis.logarithmic = void 0
                    } else {
                        if (!logarithmic) {
                            logarithmic = axis.logarithmic = new Additions(axis)
                        }
                    }
                }
                function onAfterInit() {
                    const axis = this;
                    const log = axis.logarithmic;
                    if (log) {
                        axis.lin2val = function(num) {
                            return log.lin2log(num)
                        }
                        ;
                        axis.val2lin = function(num) {
                            return log.log2lin(num)
                        }
                    }
                }
                class Additions {
                    constructor(axis) {
                        this.axis = axis
                    }
                    getLogTickPositions(interval, min, max, minor) {
                        const log = this;
                        const axis = log.axis;
                        const axisLength = axis.len;
                        const options = axis.options;
                        let positions = [];
                        if (!minor) {
                            log.minorAutoInterval = void 0
                        }
                        if (interval >= 0.5) {
                            interval = Math.round(interval);
                            positions = axis.getLinearTickPositions(interval, min, max)
                        } else if (interval >= 0.08) {
                            const roundedMin = Math.floor(min);
                            let intermediate, i, j, len, pos, lastPos, break2;
                            if (interval > 0.3) {
                                intermediate = [1, 2, 4]
                            } else if (interval > 0.15) {
                                intermediate = [1, 2, 4, 6, 8]
                            } else {
                                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9]
                            }
                            for (i = roundedMin; i < max + 1 && !break2; i++) {
                                len = intermediate.length;
                                for (j = 0; j < len && !break2; j++) {
                                    pos = log.log2lin(log.lin2log(i) * intermediate[j]);
                                    if (pos > min && (!minor || lastPos <= max) && typeof lastPos !== 'undefined') {
                                        positions.push(lastPos)
                                    }
                                    if (lastPos > max) {
                                        break2 = !0
                                    }
                                    lastPos = pos
                                }
                            }
                        } else {
                            const realMin = log.lin2log(min)
                                , realMax = log.lin2log(max)
                                , tickIntervalOption = minor ? axis.getMinorTickInterval() : options.tickInterval
                                , filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption
                                , tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1)
                                , totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
                            interval = pick(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
                            interval = normalizeTickInterval(interval);
                            positions = axis.getLinearTickPositions(interval, realMin, realMax).map(log.log2lin);
                            if (!minor) {
                                log.minorAutoInterval = interval / 5
                            }
                        }
                        if (!minor) {
                            axis.tickInterval = interval
                        }
                        return positions
                    }
                    lin2log(num) {
                        return Math.pow(10, num)
                    }
                    log2lin(num) {
                        return Math.log(num) / Math.LN10
                    }
                }
                LogarithmicAxis.Additions = Additions
            }
        )(LogarithmicAxis || (LogarithmicAxis = {}));
        return LogarithmicAxis
    });
    _registerModule(_modules, 'Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js', [_modules['Core/Utilities.js']], function(U) {
        const {erase, extend, isNumber} = U;
        var PlotLineOrBandAxis;
        (function(PlotLineOrBandAxis) {
                const composedMembers = [];
                let PlotLineOrBandClass;
                function addPlotBand(options) {
                    return this.addPlotBandOrLine(options, 'plotBands')
                }
                function addPlotBandOrLine(options, coll) {
                    const userOptions = this.userOptions;
                    let obj = new PlotLineOrBandClass(this,options);
                    if (this.visible) {
                        obj = obj.render()
                    }
                    if (obj) {
                        if (!this._addedPlotLB) {
                            this._addedPlotLB = !0;
                            (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach( (plotLineOptions) => {
                                    this.addPlotBandOrLine(plotLineOptions)
                                }
                            )
                        }
                        if (coll) {
                            const updatedOptions = (userOptions[coll] || []);
                            updatedOptions.push(options);
                            userOptions[coll] = updatedOptions
                        }
                        this.plotLinesAndBands.push(obj)
                    }
                    return obj
                }
                function addPlotLine(options) {
                    return this.addPlotBandOrLine(options, 'plotLines')
                }
                function compose(PlotLineOrBandType, AxisClass) {
                    if (!PlotLineOrBandClass) {
                        PlotLineOrBandClass = PlotLineOrBandType
                    }
                    if (U.pushUnique(composedMembers, AxisClass)) {
                        extend(AxisClass.prototype, {
                            addPlotBand,
                            addPlotLine,
                            addPlotBandOrLine,
                            getPlotBandPath,
                            removePlotBand,
                            removePlotLine,
                            removePlotBandOrLine
                        })
                    }
                    return AxisClass
                }
                PlotLineOrBandAxis.compose = compose;
                function getPlotBandPath(from, to, options) {
                    options = options || this.options;
                    const toPath = this.getPlotLinePath({
                        value: to,
                        force: !0,
                        acrossPanes: options.acrossPanes
                    })
                        , result = []
                        , horiz = this.horiz
                        , outside = !isNumber(this.min) || !isNumber(this.max) || (from < this.min && to < this.min) || (from > this.max && to > this.max);
                    let path = this.getPlotLinePath({
                        value: from,
                        force: !0,
                        acrossPanes: options.acrossPanes
                    }), i, plus = 1, isFlat;
                    if (path && toPath) {
                        if (outside) {
                            isFlat = path.toString() === toPath.toString();
                            plus = 0
                        }
                        for (i = 0; i < path.length; i += 2) {
                            const pathStart = path[i]
                                , pathEnd = path[i + 1]
                                , toPathStart = toPath[i]
                                , toPathEnd = toPath[i + 1];
                            if ((pathStart[0] === 'M' || pathStart[0] === 'L') && (pathEnd[0] === 'M' || pathEnd[0] === 'L') && (toPathStart[0] === 'M' || toPathStart[0] === 'L') && (toPathEnd[0] === 'M' || toPathEnd[0] === 'L')) {
                                if (horiz && toPathStart[1] === pathStart[1]) {
                                    toPathStart[1] += plus;
                                    toPathEnd[1] += plus
                                } else if (!horiz && toPathStart[2] === pathStart[2]) {
                                    toPathStart[2] += plus;
                                    toPathEnd[2] += plus
                                }
                                result.push(['M', pathStart[1], pathStart[2]], ['L', pathEnd[1], pathEnd[2]], ['L', toPathEnd[1], toPathEnd[2]], ['L', toPathStart[1], toPathStart[2]], ['Z'])
                            }
                            result.isFlat = isFlat
                        }
                    } else {
                        path = null
                    }
                    return result
                }
                function removePlotBand(id) {
                    this.removePlotBandOrLine(id)
                }
                function removePlotBandOrLine(id) {
                    const plotLinesAndBands = this.plotLinesAndBands
                        , options = this.options
                        , userOptions = this.userOptions;
                    if (plotLinesAndBands) {
                        let i = plotLinesAndBands.length;
                        while (i--) {
                            if (plotLinesAndBands[i].id === id) {
                                plotLinesAndBands[i].destroy()
                            }
                        }
                        ([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []]).forEach(function(arr) {
                            i = arr.length;
                            while (i--) {
                                if ((arr[i] || {}).id === id) {
                                    erase(arr, arr[i])
                                }
                            }
                        })
                    }
                }
                function removePlotLine(id) {
                    this.removePlotBandOrLine(id)
                }
            }
        )(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
        return PlotLineOrBandAxis
    });
    _registerModule(_modules, 'Core/Axis/PlotLineOrBand/PlotLineOrBand.js', [_modules['Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js'], _modules['Core/Utilities.js']], function(PlotLineOrBandAxis, U) {
        const {arrayMax, arrayMin, defined, destroyObjectProperties, erase, fireEvent, merge, objectEach, pick} = U;
        class PlotLineOrBand {
            static compose(AxisClass) {
                return PlotLineOrBandAxis.compose(PlotLineOrBand, AxisClass)
            }
            constructor(axis, options) {
                this.id = void 0;
                this.axis = axis;
                if (options) {
                    this.options = options;
                    this.id = options.id
                }
            }
            render() {
                fireEvent(this, 'render');
                const plotLine = this
                    , axis = plotLine.axis
                    , horiz = axis.horiz
                    , log = axis.logarithmic
                    , options = plotLine.options
                    , color = options.color
                    , zIndex = pick(options.zIndex, 0)
                    , events = options.events
                    , groupAttribs = {}
                    , renderer = axis.chart.renderer;
                let optionsLabel = options.label, label = plotLine.label, to = options.to, from = options.from, value = options.value, svgElem = plotLine.svgElem, path = [], group;
                const isBand = defined(from) && defined(to)
                    , isLine = defined(value)
                    , isNew = !svgElem
                    , attribs = {
                    'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')
                };
                let groupName = isBand ? 'bands' : 'lines';
                if (log) {
                    from = log.log2lin(from);
                    to = log.log2lin(to);
                    value = log.log2lin(value)
                }
                if (!axis.chart.styledMode) {
                    if (isLine) {
                        attribs.stroke = color || "#999999";
                        attribs['stroke-width'] = pick(options.width, 1);
                        if (options.dashStyle) {
                            attribs.dashstyle = options.dashStyle
                        }
                    } else if (isBand) {
                        attribs.fill = color || "#e6e9ff";
                        if (options.borderWidth) {
                            attribs.stroke = options.borderColor;
                            attribs['stroke-width'] = options.borderWidth
                        }
                    }
                }
                groupAttribs.zIndex = zIndex;
                groupName += '-' + zIndex;
                group = axis.plotLinesAndBandsGroups[groupName];
                if (!group) {
                    axis.plotLinesAndBandsGroups[groupName] = group = renderer.g('plot-' + groupName).attr(groupAttribs).add()
                }
                if (isNew) {
                    plotLine.svgElem = svgElem = renderer.path().attr(attribs).add(group)
                }
                if (isLine) {
                    path = axis.getPlotLinePath({
                        value: value,
                        lineWidth: svgElem.strokeWidth(),
                        acrossPanes: options.acrossPanes
                    })
                } else if (isBand) {
                    path = axis.getPlotBandPath(from, to, options)
                } else {
                    return
                }
                if (!plotLine.eventsAdded && events) {
                    objectEach(events, function(event, eventType) {
                        svgElem.on(eventType, function(e) {
                            events[eventType].apply(plotLine, [e])
                        })
                    });
                    plotLine.eventsAdded = !0
                }
                if ((isNew || !svgElem.d) && path && path.length) {
                    svgElem.attr({
                        d: path
                    })
                } else if (svgElem) {
                    if (path) {
                        svgElem.show();
                        svgElem.animate({
                            d: path
                        })
                    } else if (svgElem.d) {
                        svgElem.hide();
                        if (label) {
                            plotLine.label = label = label.destroy()
                        }
                    }
                }
                if (optionsLabel && (defined(optionsLabel.text) || defined(optionsLabel.formatter)) && path && path.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
                    optionsLabel = merge({
                        align: horiz && isBand && 'center',
                        x: horiz ? !isBand && 4 : 10,
                        verticalAlign: !horiz && isBand && 'middle',
                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                        rotation: horiz && !isBand && 90
                    }, optionsLabel);
                    this.renderLabel(optionsLabel, path, isBand, zIndex)
                } else if (label) {
                    label.hide()
                }
                return plotLine
            }
            renderLabel(optionsLabel, path, isBand, zIndex) {
                const plotLine = this
                    , axis = plotLine.axis
                    , renderer = axis.chart.renderer;
                let label = plotLine.label;
                if (!label) {
                    plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
                        align: optionsLabel.textAlign || optionsLabel.align,
                        rotation: optionsLabel.rotation,
                        'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || ''),
                        zIndex
                    });
                    if (!axis.chart.styledMode) {
                        label.css(merge({
                            fontSize: '0.8em',
                            textOverflow: 'ellipsis'
                        }, optionsLabel.style))
                    }
                    label.add()
                }
                const xBounds = path.xBounds || [path[0][1], path[1][1], (isBand ? path[2][1] : path[0][1])];
                const yBounds = path.yBounds || [path[0][2], path[1][2], (isBand ? path[2][2] : path[0][2])];
                const x = arrayMin(xBounds);
                const y = arrayMin(yBounds);
                label.align(optionsLabel, !1, {
                    x,
                    y,
                    width: arrayMax(xBounds) - x,
                    height: arrayMax(yBounds) - y
                });
                if (!label.alignValue || label.alignValue === 'left') {
                    const width = optionsLabel.clip ? axis.width : axis.chart.chartWidth;
                    label.css({
                        width: (label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : width - (label.alignAttr.x - axis.left)) + 'px'
                    })
                }
                label.show(!0)
            }
            getLabelText(optionsLabel) {
                return defined(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text
            }
            destroy() {
                erase(this.axis.plotLinesAndBands, this);
                delete this.axis;
                destroyObjectProperties(this)
            }
        }
        ('');
        ('');
        return PlotLineOrBand
    });
    _registerModule(_modules, 'Core/Tooltip.js', [_modules['Core/Templating.js'], _modules['Core/Globals.js'], _modules['Core/Renderer/RendererUtilities.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Utilities.js']], function(F, H, R, RendererRegistry, U) {
        const {format} = F;
        const {doc, isSafari} = H;
        const {distribute} = R;
        const {addEvent, clamp, css, discardElement, extend, fireEvent, isArray, isNumber, isString, merge, pick, splat, syncTimeout} = U;
        class Tooltip {
            constructor(chart, options) {
                this.allowShared = !0;
                this.crosshairs = [];
                this.distance = 0;
                this.isHidden = !0;
                this.isSticky = !1;
                this.now = {};
                this.options = {};
                this.outside = !1;
                this.chart = chart;
                this.init(chart, options)
            }
            bodyFormatter(items) {
                return items.map(function(item) {
                    const tooltipOptions = item.series.tooltipOptions;
                    return (tooltipOptions[(item.point.formatPrefix || 'point') + 'Formatter'] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || 'point') + 'Format'] || '')
                })
            }
            cleanSplit(force) {
                this.chart.series.forEach(function(series) {
                    const tt = series && series.tt;
                    if (tt) {
                        if (!tt.isActive || force) {
                            series.tt = tt.destroy()
                        } else {
                            tt.isActive = !1
                        }
                    }
                })
            }
            defaultFormatter(tooltip) {
                const items = this.points || splat(this);
                let s;
                s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
                s = s.concat(tooltip.bodyFormatter(items));
                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], !0));
                return s
            }
            destroy() {
                if (this.label) {
                    this.label = this.label.destroy()
                }
                if (this.split) {
                    this.cleanSplit(!0);
                    if (this.tt) {
                        this.tt = this.tt.destroy()
                    }
                }
                if (this.renderer) {
                    this.renderer = this.renderer.destroy();
                    discardElement(this.container)
                }
                U.clearTimeout(this.hideTimer);
                U.clearTimeout(this.tooltipTimeout)
            }
            getAnchor(points, mouseEvent) {
                const chart = this.chart
                    , pointer = chart.pointer
                    , inverted = chart.inverted
                    , plotTop = chart.plotTop
                    , plotLeft = chart.plotLeft;
                let ret;
                points = splat(points);
                if (points[0].series && points[0].series.yAxis && !points[0].series.yAxis.options.reversedStacks) {
                    points = points.slice().reverse()
                }
                if (this.followPointer && mouseEvent) {
                    if (typeof mouseEvent.chartX === 'undefined') {
                        mouseEvent = pointer.normalize(mouseEvent)
                    }
                    ret = [mouseEvent.chartX - plotLeft, mouseEvent.chartY - plotTop]
                } else if (points[0].tooltipPos) {
                    ret = points[0].tooltipPos
                } else {
                    let chartX = 0
                        , chartY = 0;
                    points.forEach(function(point) {
                        const pos = point.pos(!0);
                        if (pos) {
                            chartX += pos[0];
                            chartY += pos[1]
                        }
                    });
                    chartX /= points.length;
                    chartY /= points.length;
                    if (this.shared && points.length > 1 && mouseEvent) {
                        if (inverted) {
                            chartX = mouseEvent.chartX
                        } else {
                            chartY = mouseEvent.chartY
                        }
                    }
                    ret = [chartX - plotLeft, chartY - plotTop]
                }
                return ret.map(Math.round)
            }
            getClassName(point, isSplit, isHeader) {
                const options = this.options
                    , series = point.series
                    , seriesOptions = series.options;
                return [options.className, 'highcharts-label', isHeader && 'highcharts-tooltip-header', isSplit ? 'highcharts-tooltip-box' : 'highcharts-tooltip', !isHeader && 'highcharts-color-' + pick(point.colorIndex, series.colorIndex), (seriesOptions && seriesOptions.className)].filter(isString).join(' ')
            }
            getLabel() {
                const tooltip = this
                    , styledMode = this.chart.styledMode
                    , options = this.options
                    , doSplit = this.split && this.allowShared;
                let container = this.container
                    , renderer = this.chart.renderer;
                if (this.label) {
                    const wasSplit = !this.label.hasClass('highcharts-label');
                    if ((!doSplit && wasSplit) || (doSplit && !wasSplit)) {
                        this.destroy()
                    }
                }
                if (!this.label) {
                    if (this.outside) {
                        const chartStyle = this.chart.options.chart.style
                            , Renderer = RendererRegistry.getRendererType();
                        this.container = container = H.doc.createElement('div');
                        container.className = 'highcharts-tooltip-container';
                        css(container, {
                            position: 'absolute',
                            top: '1px',
                            pointerEvents: 'none',
                            zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)
                        });
                        this.renderer = renderer = new Renderer(container,0,0,chartStyle,void 0,void 0,renderer.styledMode)
                    }
                    if (doSplit) {
                        this.label = renderer.g('tooltip')
                    } else {
                        this.label = renderer.label('', 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, 'tooltip').attr({
                            padding: options.padding,
                            r: options.borderRadius
                        });
                        if (!styledMode) {
                            this.label.attr({
                                fill: options.backgroundColor,
                                'stroke-width': options.borderWidth || 0
                            }).css(options.style).css({
                                pointerEvents: (options.style.pointerEvents || (this.shouldStickOnContact() ? 'auto' : 'none'))
                            })
                        }
                    }
                    if (tooltip.outside) {
                        const label = this.label;
                        const {xSetter, ySetter} = label;
                        label.xSetter = function(value) {
                            xSetter.call(label, tooltip.distance);
                            if (container) {
                                container.style.left = value + 'px'
                            }
                        }
                        ;
                        label.ySetter = function(value) {
                            ySetter.call(label, tooltip.distance);
                            if (container) {
                                container.style.top = value + 'px'
                            }
                        }
                    }
                    this.label.attr({
                        zIndex: 8
                    }).shadow(options.shadow).add()
                }
                if (container && !container.parentElement) {
                    H.doc.body.appendChild(container)
                }
                return this.label
            }
            getPlayingField() {
                const {body, documentElement} = doc
                    , {chart, distance, outside} = this;
                return {
                    width: outside ? Math.max(body.scrollWidth, documentElement.scrollWidth, body.offsetWidth, documentElement.offsetWidth, documentElement.clientWidth) - 2 * distance : chart.chartWidth,
                    height: outside ? Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, documentElement.clientHeight) : chart.chartHeight
                }
            }
            getPosition(boxWidth, boxHeight, point) {
                const chart = this.chart
                    , distance = this.distance
                    , ret = {}
                    , h = (chart.inverted && point.h) || 0
                    , outside = this.outside
                    , playingField = this.getPlayingField()
                    , outerWidth = playingField.width
                    , outerHeight = playingField.height
                    , chartPosition = chart.pointer.getChartPosition()
                    , scaleX = (val) => (val * chartPosition.scaleX)
                    , scaleY = (val) => (val * chartPosition.scaleY)
                    , buildDimensionArray = (dim) => {
                        const isX = dim === 'x';
                        return [dim, isX ? outerWidth : outerHeight, isX ? boxWidth : boxHeight].concat(outside ? [isX ? scaleX(boxWidth) : scaleY(boxHeight), isX ? chartPosition.left - distance + scaleX(point.plotX + chart.plotLeft) : chartPosition.top - distance + scaleY(point.plotY + chart.plotTop), 0, isX ? outerWidth : outerHeight] : [isX ? boxWidth : boxHeight, isX ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop, isX ? chart.plotLeft : chart.plotTop, isX ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight])
                    }
                ;
                let first = buildDimensionArray('y'), second = buildDimensionArray('x'), swapped;
                let flipped = !!point.negative;
                if (!chart.polar && chart.hoverSeries && chart.hoverSeries.yAxis && chart.hoverSeries.yAxis.reversed) {
                    flipped = !flipped
                }
                const preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === flipped)
                    , firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point, min, max) {
                    const scaledDist = outside ? (dim === 'y' ? scaleY(distance) : scaleX(distance)) : distance
                        , scaleDiff = (innerSize - scaledInnerSize) / 2
                        , roomLeft = scaledInnerSize < point - distance
                        , roomRight = point + distance + scaledInnerSize < outerSize
                        , alignedLeft = point - scaledDist - innerSize + scaleDiff
                        , alignedRight = point + scaledDist - scaleDiff;
                    if (preferFarSide && roomRight) {
                        ret[dim] = alignedRight
                    } else if (!preferFarSide && roomLeft) {
                        ret[dim] = alignedLeft
                    } else if (roomLeft) {
                        ret[dim] = Math.min(max - scaledInnerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h)
                    } else if (roomRight) {
                        ret[dim] = Math.max(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h)
                    } else {
                        return !1
                    }
                }
                    , secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point) {
                    let retVal;
                    if (point < distance || point > outerSize - distance) {
                        retVal = !1
                    } else if (point < innerSize / 2) {
                        ret[dim] = 1
                    } else if (point > outerSize - scaledInnerSize / 2) {
                        ret[dim] = outerSize - scaledInnerSize - 2
                    } else {
                        ret[dim] = point - innerSize / 2
                    }
                    return retVal
                }
                    , swap = function(count) {
                    const temp = first;
                    first = second;
                    second = temp;
                    swapped = count
                }
                    , run = function() {
                    if (firstDimension.apply(0, first) !== !1) {
                        if (secondDimension.apply(0, second) === !1 && !swapped) {
                            swap(!0);
                            run()
                        }
                    } else if (!swapped) {
                        swap(!0);
                        run()
                    } else {
                        ret.x = ret.y = 0
                    }
                };
                if (chart.inverted || this.len > 1) {
                    swap()
                }
                run();
                return ret
            }
            hide(delay) {
                const tooltip = this;
                U.clearTimeout(this.hideTimer);
                delay = pick(delay, this.options.hideDelay);
                if (!this.isHidden) {
                    this.hideTimer = syncTimeout(function() {
                        const label = tooltip.getLabel();
                        tooltip.getLabel().animate({
                            opacity: 0
                        }, {
                            duration: delay ? 150 : delay,
                            complete: () => {
                                label.hide();
                                if (tooltip.container) {
                                    tooltip.container.remove()
                                }
                            }
                        });
                        tooltip.isHidden = !0
                    }, delay)
                }
            }
            init(chart, options) {
                this.chart = chart;
                this.options = options;
                this.crosshairs = [];
                this.now = {
                    x: 0,
                    y: 0
                };
                this.isHidden = !0;
                this.split = options.split && !chart.inverted && !chart.polar;
                this.shared = options.shared || this.split;
                this.outside = pick(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY))
            }
            shouldStickOnContact(pointerEvent) {
                return !!(!this.followPointer && this.options.stickOnContact && (!pointerEvent || this.chart.pointer.inClass(pointerEvent.target, 'highcharts-tooltip')))
            }
            move(x, y, anchorX, anchorY) {
                const tooltip = this
                    , now = tooltip.now
                    , animate = tooltip.options.animation !== !1 && !tooltip.isHidden && (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1)
                    , skipAnchor = tooltip.followPointer || tooltip.len > 1;
                extend(now, {
                    x: animate ? (2 * now.x + x) / 3 : x,
                    y: animate ? (now.y + y) / 2 : y,
                    anchorX: skipAnchor ? void 0 : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                    anchorY: skipAnchor ? void 0 : animate ? (now.anchorY + anchorY) / 2 : anchorY
                });
                tooltip.getLabel().attr(now);
                tooltip.drawTracker();
                if (animate) {
                    U.clearTimeout(this.tooltipTimeout);
                    this.tooltipTimeout = setTimeout(function() {
                        if (tooltip) {
                            tooltip.move(x, y, anchorX, anchorY)
                        }
                    }, 32)
                }
            }
            refresh(pointOrPoints, mouseEvent) {
                const tooltip = this
                    , chart = this.chart
                    , options = tooltip.options
                    , pointer = chart.pointer
                    , points = splat(pointOrPoints)
                    , point = points[0]
                    , pointConfig = []
                    , formatString = options.format
                    , formatter = options.formatter || tooltip.defaultFormatter
                    , shared = tooltip.shared
                    , styledMode = chart.styledMode;
                let formatterContext = {};
                if (!options.enabled || !point.series) {
                    return
                }
                U.clearTimeout(this.hideTimer);
                tooltip.allowShared = !(!isArray(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip);
                tooltip.followPointer = (!tooltip.split && point.series.tooltipOptions.followPointer);
                const anchor = tooltip.getAnchor(pointOrPoints, mouseEvent)
                    , x = anchor[0]
                    , y = anchor[1];
                if (shared && tooltip.allowShared) {
                    pointer.applyInactiveState(points);
                    points.forEach(function(item) {
                        item.setState('hover');
                        pointConfig.push(item.getLabelConfig())
                    });
                    formatterContext = point.getLabelConfig();
                    formatterContext.points = pointConfig
                } else {
                    formatterContext = point.getLabelConfig()
                }
                this.len = pointConfig.length;
                const text = isString(formatString) ? format(formatString, formatterContext, chart) : formatter.call(formatterContext, tooltip);
                const currentSeries = point.series;
                this.distance = pick(currentSeries.tooltipOptions.distance, 16);
                if (text === !1) {
                    this.hide()
                } else {
                    if (tooltip.split && tooltip.allowShared) {
                        this.renderSplit(text, points)
                    } else {
                        let checkX = x;
                        let checkY = y;
                        if (mouseEvent && pointer.isDirectTouch) {
                            checkX = mouseEvent.chartX - chart.plotLeft;
                            checkY = mouseEvent.chartY - chart.plotTop
                        }
                        if (chart.polar || currentSeries.options.clip === !1 || points.some( (p) => pointer.isDirectTouch || p.series.shouldShowTooltip(checkX, checkY))) {
                            const label = tooltip.getLabel();
                            if (!options.style.width || styledMode) {
                                label.css({
                                    width: (this.outside ? this.getPlayingField() : chart.spacingBox).width + 'px'
                                })
                            }
                            label.attr({
                                text: text && text.join ? text.join('') : text
                            });
                            label.addClass(tooltip.getClassName(point), !0);
                            if (!styledMode) {
                                label.attr({
                                    stroke: (options.borderColor || point.color || currentSeries.color || "#666666")
                                })
                            }
                            tooltip.updatePosition({
                                plotX: x,
                                plotY: y,
                                negative: point.negative,
                                ttBelow: point.ttBelow,
                                h: anchor[2] || 0
                            })
                        } else {
                            tooltip.hide();
                            return
                        }
                    }
                    if (tooltip.isHidden && tooltip.label) {
                        tooltip.label.attr({
                            opacity: 1
                        }).show()
                    }
                    tooltip.isHidden = !1
                }
                fireEvent(this, 'refresh')
            }
            renderSplit(labels, points) {
                const tooltip = this;
                const {chart, chart: {chartWidth, chartHeight, plotHeight, plotLeft, plotTop, pointer, scrollablePixelsY=0, scrollablePixelsX, scrollingContainer: {scrollLeft, scrollTop}={
                    scrollLeft: 0,
                    scrollTop: 0
                }, styledMode}, distance, options, options: {positioner}} = tooltip;
                const bounds = (tooltip.outside && typeof scrollablePixelsX !== 'number') ? doc.documentElement.getBoundingClientRect() : {
                    left: scrollLeft,
                    right: scrollLeft + chartWidth,
                    top: scrollTop,
                    bottom: scrollTop + chartHeight
                };
                const tooltipLabel = tooltip.getLabel();
                const ren = this.renderer || chart.renderer;
                const headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);
                const {left: chartLeft, top: chartTop} = pointer.getChartPosition();
                let distributionBoxTop = plotTop + scrollTop;
                let headerHeight = 0;
                let adjustedPlotHeight = plotHeight - scrollablePixelsY;
                function getAnchor(point) {
                    const {isHeader, plotX=0, plotY=0, series} = point;
                    let anchorX;
                    let anchorY;
                    if (isHeader) {
                        anchorX = Math.max(plotLeft + plotX, plotLeft);
                        anchorY = plotTop + plotHeight / 2
                    } else {
                        const {xAxis, yAxis} = series;
                        anchorX = xAxis.pos + clamp(plotX, -distance, xAxis.len + distance);
                        if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {
                            ignoreX: !0
                        })) {
                            anchorY = yAxis.pos + plotY
                        }
                    }
                    anchorX = clamp(anchorX, bounds.left - distance, bounds.right + distance);
                    return {
                        anchorX,
                        anchorY
                    }
                }
                function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft=!0) {
                    let y;
                    let x;
                    if (isHeader) {
                        y = headerTop ? 0 : adjustedPlotHeight;
                        x = clamp(anchorX - (boxWidth / 2), bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0))
                    } else {
                        y = anchorY - distributionBoxTop;
                        x = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;
                        x = clamp(x, alignedLeft ? x : bounds.left, bounds.right)
                    }
                    return {
                        x,
                        y
                    }
                }
                function updatePartialTooltip(partialTooltip, point, str) {
                    let tt = partialTooltip;
                    const {isHeader, series} = point;
                    if (!tt) {
                        const attribs = {
                            padding: options.padding,
                            r: options.borderRadius
                        };
                        if (!styledMode) {
                            attribs.fill = options.backgroundColor;
                            attribs['stroke-width'] = options.borderWidth ?? 1
                        }
                        tt = ren.label('', 0, 0, (options[isHeader ? 'headerShape' : 'shape']), void 0, void 0, options.useHTML).addClass(tooltip.getClassName(point, !0, isHeader)).attr(attribs).add(tooltipLabel)
                    }
                    tt.isActive = !0;
                    tt.attr({
                        text: str
                    });
                    if (!styledMode) {
                        tt.css(options.style).attr({
                            stroke: (options.borderColor || point.color || series.color || "#333333")
                        })
                    }
                    return tt
                }
                if (isString(labels)) {
                    labels = [!1, labels]
                }
                let boxes = labels.slice(0, points.length + 1).reduce(function(boxes, str, i) {
                    if (str !== !1 && str !== '') {
                        const point = (points[i - 1] || {
                            isHeader: !0,
                            plotX: points[0].plotX,
                            plotY: plotHeight,
                            series: {}
                        });
                        const isHeader = point.isHeader;
                        const owner = isHeader ? tooltip : point.series;
                        const tt = owner.tt = updatePartialTooltip(owner.tt, point, str.toString());
                        const bBox = tt.getBBox();
                        const boxWidth = bBox.width + tt.strokeWidth();
                        if (isHeader) {
                            headerHeight = bBox.height;
                            adjustedPlotHeight += headerHeight;
                            if (headerTop) {
                                distributionBoxTop -= headerHeight
                            }
                        }
                        const {anchorX, anchorY} = getAnchor(point);
                        if (typeof anchorY === 'number') {
                            const size = bBox.height + 1;
                            const boxPosition = (positioner ? positioner.call(tooltip, boxWidth, size, point) : defaultPositioner(anchorX, anchorY, isHeader, boxWidth));
                            boxes.push({
                                align: positioner ? 0 : void 0,
                                anchorX,
                                anchorY,
                                boxWidth,
                                point,
                                rank: pick(boxPosition.rank, isHeader ? 1 : 0),
                                size,
                                target: boxPosition.y,
                                tt,
                                x: boxPosition.x
                            })
                        } else {
                            tt.isActive = !1
                        }
                    }
                    return boxes
                }, []);
                if (!positioner && boxes.some( (box) => {
                        const {outside} = tooltip;
                        const boxStart = (outside ? chartLeft : 0) + box.anchorX;
                        if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
                            return !0
                        }
                        return boxStart < (chartLeft - bounds.left) + box.boxWidth && bounds.right - boxStart > boxStart
                    }
                )) {
                    boxes = boxes.map( (box) => {
                            const {x, y} = defaultPositioner(box.anchorX, box.anchorY, box.point.isHeader, box.boxWidth, !1);
                            return extend(box, {
                                target: y,
                                x
                            })
                        }
                    )
                }
                tooltip.cleanSplit();
                distribute(boxes, adjustedPlotHeight);
                const boxExtremes = {
                    left: chartLeft,
                    right: chartLeft
                };
                boxes.forEach(function(box) {
                    const {x, boxWidth, isHeader} = box;
                    if (!isHeader) {
                        if (tooltip.outside && chartLeft + x < boxExtremes.left) {
                            boxExtremes.left = chartLeft + x
                        }
                        if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
                            boxExtremes.right = chartLeft + x
                        }
                    }
                });
                boxes.forEach(function(box) {
                    const {x, anchorX, anchorY, pos, point: {isHeader}} = box;
                    const attributes = {
                        visibility: typeof pos === 'undefined' ? 'hidden' : 'inherit',
                        x,
                        y: (pos || 0) + distributionBoxTop,
                        anchorX,
                        anchorY
                    };
                    if (tooltip.outside && x < anchorX) {
                        const offset = chartLeft - boxExtremes.left;
                        if (offset > 0) {
                            if (!isHeader) {
                                attributes.x = x + offset;
                                attributes.anchorX = anchorX + offset
                            }
                            if (isHeader) {
                                attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
                                attributes.anchorX = anchorX + offset
                            }
                        }
                    }
                    box.tt.attr(attributes)
                });
                const {container, outside, renderer} = tooltip;
                if (outside && container && renderer) {
                    const {width, height, x, y} = tooltipLabel.getBBox();
                    renderer.setSize(width + x, height + y, !1);
                    container.style.left = boxExtremes.left + 'px';
                    container.style.top = chartTop + 'px'
                }
                if (isSafari) {
                    tooltipLabel.attr({
                        opacity: tooltipLabel.opacity === 1 ? 0.999 : 1
                    })
                }
            }
            drawTracker() {
                const tooltip = this;
                if (!this.shouldStickOnContact()) {
                    if (tooltip.tracker) {
                        tooltip.tracker = tooltip.tracker.destroy()
                    }
                    return
                }
                const chart = tooltip.chart;
                const label = tooltip.label;
                const points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
                if (!label || !points) {
                    return
                }
                const box = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                const anchorPos = this.getAnchor(points);
                const labelBBox = label.getBBox();
                anchorPos[0] += chart.plotLeft - (label.translateX || 0);
                anchorPos[1] += chart.plotTop - (label.translateY || 0);
                box.x = Math.min(0, anchorPos[0]);
                box.y = Math.min(0, anchorPos[1]);
                box.width = (anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), (labelBBox.width - anchorPos[0])) : Math.max(Math.abs(anchorPos[0]), labelBBox.width));
                box.height = (anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), (labelBBox.height - Math.abs(anchorPos[1]))) : Math.max(Math.abs(anchorPos[1]), labelBBox.height));
                if (tooltip.tracker) {
                    tooltip.tracker.attr(box)
                } else {
                    tooltip.tracker = label.renderer.rect(box).addClass('highcharts-tracker').add(label);
                    if (!chart.styledMode) {
                        tooltip.tracker.attr({
                            fill: 'rgba(0,0,0,0)'
                        })
                    }
                }
            }
            styledModeFormat(formatString) {
                return formatString.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} ' + '{series.options.className} ' + '{point.options.className}"')
            }
            tooltipFooterHeaderFormatter(labelConfig, isFooter) {
                const series = labelConfig.series
                    , tooltipOptions = series.tooltipOptions
                    , xAxis = series.xAxis
                    , dateTime = xAxis && xAxis.dateTime
                    , e = {
                    isFooter: isFooter,
                    labelConfig: labelConfig
                };
                let xDateFormat = tooltipOptions.xDateFormat
                    , formatString = tooltipOptions[isFooter ? 'footerFormat' : 'headerFormat'];
                fireEvent(this, 'headerFormatter', e, function(e) {
                    if (dateTime && !xDateFormat && isNumber(labelConfig.key)) {
                        xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats)
                    }
                    if (dateTime && xDateFormat) {
                        ((labelConfig.point && labelConfig.point.tooltipDateKeys) || ['key']).forEach(function(key) {
                            formatString = formatString.replace('{point.' + key + '}', '{point.' + key + ':' + xDateFormat + '}')
                        })
                    }
                    if (series.chart.styledMode) {
                        formatString = this.styledModeFormat(formatString)
                    }
                    e.text = format(formatString, {
                        point: labelConfig,
                        series: series
                    }, this.chart)
                });
                return e.text
            }
            update(options) {
                this.destroy();
                this.init(this.chart, merge(!0, this.options, options))
            }
            updatePosition(point) {
                const {chart, container, distance, options, renderer} = this
                    , {height=0, width=0} = this.getLabel()
                    , pointer = chart.pointer
                    , {left, top, scaleX, scaleY} = pointer.getChartPosition()
                    , pos = (options.positioner || this.getPosition).call(this, width, height, point);
                let anchorX = (point.plotX || 0) + chart.plotLeft, anchorY = (point.plotY || 0) + chart.plotTop, pad;
                if (renderer && container) {
                    if (options.positioner) {
                        pos.x += left - distance;
                        pos.y += top - distance
                    }
                    pad = (options.borderWidth || 0) + 2 * distance + 2;
                    renderer.setSize(width + pad, height + pad, !1);
                    if (scaleX !== 1 || scaleY !== 1) {
                        css(container, {
                            transform: `scale(${scaleX}, ${scaleY})`
                        });
                        anchorX *= scaleX;
                        anchorY *= scaleY
                    }
                    anchorX += left - pos.x;
                    anchorY += top - pos.y
                }
                this.move(Math.round(pos.x), Math.round(pos.y || 0), anchorX, anchorY)
            }
        }
        (function(Tooltip) {
                const composedMembers = [];
                function compose(PointerClass) {
                    if (U.pushUnique(composedMembers, PointerClass)) {
                        addEvent(PointerClass, 'afterInit', function() {
                            const chart = this.chart;
                            if (chart.options.tooltip) {
                                chart.tooltip = new Tooltip(chart,chart.options.tooltip)
                            }
                        })
                    }
                }
                Tooltip.compose = compose
            }
        )(Tooltip || (Tooltip = {}));
        '';
        return Tooltip
    });
    _registerModule(_modules, 'Core/Series/Point.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Core/Templating.js'], _modules['Core/Utilities.js']], function(AST, A, D, F, U) {
        const {animObject} = A;
        const {defaultOptions} = D;
        const {format} = F;
        const {addEvent, defined, erase, extend, fireEvent, getNestedProperty, isArray, isFunction, isNumber, isObject, merge, objectEach, pick, syncTimeout, removeEvent, uniqueKey} = U;
        class Point {
            constructor() {
                this.category = void 0;
                this.destroyed = !1;
                this.formatPrefix = 'point';
                this.id = void 0;
                this.isNull = !1;
                this.name = void 0;
                this.options = void 0;
                this.percentage = void 0;
                this.selected = !1;
                this.series = void 0;
                this.shapeArgs = void 0;
                this.total = void 0;
                this.visible = !0;
                this.x = void 0
            }
            animateBeforeDestroy() {
                const point = this
                    , animateParams = {
                    x: point.startXPos,
                    opacity: 0
                }
                    , graphicalProps = point.getGraphicalProps();
                graphicalProps.singular.forEach(function(prop) {
                    const isDataLabel = prop === 'dataLabel';
                    point[prop] = point[prop].animate(isDataLabel ? {
                        x: point[prop].startXPos,
                        y: point[prop].startYPos,
                        opacity: 0
                    } : animateParams)
                });
                graphicalProps.plural.forEach(function(plural) {
                    point[plural].forEach(function(item) {
                        if (item.element) {
                            item.animate(extend({
                                x: point.startXPos
                            }, (item.startYPos ? {
                                x: item.startXPos,
                                y: item.startYPos
                            } : {})))
                        }
                    })
                })
            }
            applyOptions(options, x) {
                const point = this
                    , series = point.series
                    , pointValKey = series.options.pointValKey || series.pointValKey;
                options = Point.prototype.optionsToObject.call(this, options);
                extend(point, options);
                point.options = point.options ? extend(point.options, options) : options;
                if (options.group) {
                    delete point.group
                }
                if (options.dataLabels) {
                    delete point.dataLabels
                }
                if (pointValKey) {
                    point.y = Point.prototype.getNestedProperty.call(point, pointValKey)
                }
                if (point.selected) {
                    point.state = 'select'
                }
                if ('name'in point && typeof x === 'undefined' && series.xAxis && series.xAxis.hasNames) {
                    point.x = series.xAxis.nameToX(point)
                }
                if (typeof point.x === 'undefined' && series) {
                    if (typeof x === 'undefined') {
                        point.x = series.autoIncrement()
                    } else {
                        point.x = x
                    }
                } else if (isNumber(options.x) && series.options.relativeXValue) {
                    point.x = series.autoIncrement(options.x)
                }
                point.isNull = this.isValid && !this.isValid();
                point.formatPrefix = point.isNull ? 'null' : 'point';
                return point
            }
            destroy() {
                if (!this.destroyed) {
                    const point = this
                        , series = point.series
                        , chart = series.chart
                        , dataSorting = series.options.dataSorting
                        , hoverPoints = chart.hoverPoints
                        , globalAnimation = point.series.chart.renderer.globalAnimation
                        , animation = animObject(globalAnimation);
                    const destroyPoint = () => {
                            if (point.graphic || point.graphics || point.dataLabel || point.dataLabels) {
                                removeEvent(point);
                                point.destroyElements()
                            }
                            for (const prop in point) {
                                delete point[prop]
                            }
                        }
                    ;
                    if (point.legendItem) {
                        chart.legend.destroyItem(point)
                    }
                    if (hoverPoints) {
                        point.setState();
                        erase(hoverPoints, point);
                        if (!hoverPoints.length) {
                            chart.hoverPoints = null
                        }
                    }
                    if (point === chart.hoverPoint) {
                        point.onMouseOut()
                    }
                    if (!dataSorting || !dataSorting.enabled) {
                        destroyPoint()
                    } else {
                        this.animateBeforeDestroy();
                        syncTimeout(destroyPoint, animation.duration)
                    }
                    chart.pointCount--
                }
                this.destroyed = !0
            }
            destroyElements(kinds) {
                const point = this
                    , props = point.getGraphicalProps(kinds);
                props.singular.forEach(function(prop) {
                    point[prop] = point[prop].destroy()
                });
                props.plural.forEach(function(plural) {
                    point[plural].forEach(function(item) {
                        if (item && item.element) {
                            item.destroy()
                        }
                    });
                    delete point[plural]
                })
            }
            firePointEvent(eventType, eventArgs, defaultFunction) {
                const point = this
                    , series = this.series
                    , seriesOptions = series.options;
                if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
                    point.importEvents()
                }
                if (eventType === 'click' && seriesOptions.allowPointSelect) {
                    defaultFunction = function(event) {
                        if (!point.destroyed && point.select) {
                            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey)
                        }
                    }
                }
                fireEvent(point, eventType, eventArgs, defaultFunction)
            }
            getClassName() {
                const point = this;
                return 'highcharts-point' + (point.selected ? ' highcharts-point-select' : '') + (point.negative ? ' highcharts-negative' : '') + (point.isNull ? ' highcharts-null-point' : '') + (typeof point.colorIndex !== 'undefined' ? ' highcharts-color-' + point.colorIndex : '') + (point.options.className ? ' ' + point.options.className : '') + (point.zone && point.zone.className ? ' ' + point.zone.className.replace('highcharts-negative', '') : '')
            }
            getGraphicalProps(kinds) {
                const point = this
                    , props = []
                    , graphicalProps = {
                    singular: [],
                    plural: []
                };
                let prop, i;
                kinds = kinds || {
                    graphic: 1,
                    dataLabel: 1
                };
                if (kinds.graphic) {
                    props.push('graphic', 'connector')
                }
                if (kinds.dataLabel) {
                    props.push('dataLabel', 'dataLabelPath', 'dataLabelUpper')
                }
                i = props.length;
                while (i--) {
                    prop = props[i];
                    if (point[prop]) {
                        graphicalProps.singular.push(prop)
                    }
                }
                ['graphic', 'dataLabel'].forEach(function(prop) {
                    const plural = prop + 's';
                    if (kinds[prop] && point[plural]) {
                        graphicalProps.plural.push(plural)
                    }
                });
                return graphicalProps
            }
            getLabelConfig() {
                return {
                    x: this.category,
                    y: this.y,
                    color: this.color,
                    colorIndex: this.colorIndex,
                    key: this.name || this.category,
                    series: this.series,
                    point: this,
                    percentage: this.percentage,
                    total: this.total || this.stackTotal
                }
            }
            getNestedProperty(key) {
                if (!key) {
                    return
                }
                if (key.indexOf('custom.') === 0) {
                    return getNestedProperty(key, this.options)
                }
                return this[key]
            }
            getZone() {
                const series = this.series
                    , zones = series.zones
                    , zoneAxis = series.zoneAxis || 'y';
                let zone, i = 0;
                zone = zones[i];
                while (this[zoneAxis] >= zone.value) {
                    zone = zones[++i]
                }
                if (!this.nonZonedColor) {
                    this.nonZonedColor = this.color
                }
                if (zone && zone.color && !this.options.color) {
                    this.color = zone.color
                } else {
                    this.color = this.nonZonedColor
                }
                return zone
            }
            hasNewShapeType() {
                const point = this;
                const oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
                return oldShapeType !== this.shapeType
            }
            init(series, options, x) {
                this.series = series;
                this.applyOptions(options, x);
                this.id = defined(this.id) ? this.id : uniqueKey();
                this.resolveColor();
                series.chart.pointCount++;
                fireEvent(this, 'afterInit');
                return this
            }
            isValid() {
                return ((isNumber(this.x) || this.x instanceof Date) && isNumber(this.y))
            }
            optionsToObject(options) {
                const series = this.series
                    , keys = series.options.keys
                    , pointArrayMap = keys || series.pointArrayMap || ['y']
                    , valueCount = pointArrayMap.length;
                let ret = {}, firstItemType, i = 0, j = 0;
                if (isNumber(options) || options === null) {
                    ret[pointArrayMap[0]] = options
                } else if (isArray(options)) {
                    if (!keys && options.length > valueCount) {
                        firstItemType = typeof options[0];
                        if (firstItemType === 'string') {
                            ret.name = options[0]
                        } else if (firstItemType === 'number') {
                            ret.x = options[0]
                        }
                        i++
                    }
                    while (j < valueCount) {
                        if (!keys || typeof options[i] !== 'undefined') {
                            if (pointArrayMap[j].indexOf('.') > 0) {
                                Point.prototype.setNestedProperty(ret, options[i], pointArrayMap[j])
                            } else {
                                ret[pointArrayMap[j]] = options[i]
                            }
                        }
                        i++;
                        j++
                    }
                } else if (typeof options === 'object') {
                    ret = options;
                    if (options.dataLabels) {
                        series.hasDataLabels = () => !0
                    }
                    if (options.marker) {
                        series._hasPointMarkers = !0
                    }
                }
                return ret
            }
            pos(chartCoordinates, plotY=this.plotY) {
                if (!this.destroyed) {
                    const {plotX, series} = this
                        , {chart, xAxis, yAxis} = series;
                    let posX = 0
                        , posY = 0;
                    if (isNumber(plotX) && isNumber(plotY)) {
                        if (chartCoordinates) {
                            posX = xAxis ? xAxis.pos : chart.plotLeft;
                            posY = yAxis ? yAxis.pos : chart.plotTop
                        }
                        return chart.inverted && xAxis && yAxis ? [yAxis.len - plotY + posY, xAxis.len - plotX + posX] : [plotX + posX, plotY + posY]
                    }
                }
            }
            resolveColor() {
                const series = this.series
                    , optionsChart = series.chart.options.chart
                    , styledMode = series.chart.styledMode;
                let color, colors, colorCount = optionsChart.colorCount, colorIndex;
                delete this.nonZonedColor;
                if (series.options.colorByPoint) {
                    if (!styledMode) {
                        colors = series.options.colors || series.chart.options.colors;
                        color = colors[series.colorCounter];
                        colorCount = colors.length
                    }
                    colorIndex = series.colorCounter;
                    series.colorCounter++;
                    if (series.colorCounter === colorCount) {
                        series.colorCounter = 0
                    }
                } else {
                    if (!styledMode) {
                        color = series.color
                    }
                    colorIndex = series.colorIndex
                }
                this.colorIndex = pick(this.options.colorIndex, colorIndex);
                this.color = pick(this.options.color, color)
            }
            setNestedProperty(object, value, key) {
                const nestedKeys = key.split('.');
                nestedKeys.reduce(function(result, key, i, arr) {
                    const isLastKey = arr.length - 1 === i;
                    result[key] = (isLastKey ? value : isObject(result[key], !0) ? result[key] : {});
                    return result[key]
                }, object);
                return object
            }
            shouldDraw() {
                return !this.isNull
            }
            tooltipFormatter(pointFormat) {
                const series = this.series
                    , seriesTooltipOptions = series.tooltipOptions
                    , valueDecimals = pick(seriesTooltipOptions.valueDecimals, '')
                    , valuePrefix = seriesTooltipOptions.valuePrefix || ''
                    , valueSuffix = seriesTooltipOptions.valueSuffix || '';
                if (series.chart.styledMode) {
                    pointFormat = series.chart.tooltip.styledModeFormat(pointFormat)
                }
                (series.pointArrayMap || ['y']).forEach(function(key) {
                    key = '{point.' + key;
                    if (valuePrefix || valueSuffix) {
                        pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), valuePrefix + key + '}' + valueSuffix)
                    }
                    pointFormat = pointFormat.replace(RegExp(key + '}', 'g'), key + ':,.' + valueDecimals + 'f}')
                });
                return format(pointFormat, {
                    point: this,
                    series: this.series
                }, series.chart)
            }
            update(options, redraw, animation, runEvent) {
                const point = this
                    , series = point.series
                    , graphic = point.graphic
                    , chart = series.chart
                    , seriesOptions = series.options;
                let i;
                redraw = pick(redraw, !0);
                function update() {
                    point.applyOptions(options);
                    const hasMockGraphic = graphic && point.hasMockGraphic;
                    const shouldDestroyGraphic = point.y === null ? !hasMockGraphic : hasMockGraphic;
                    if (graphic && shouldDestroyGraphic) {
                        point.graphic = graphic.destroy();
                        delete point.hasMockGraphic
                    }
                    if (isObject(options, !0)) {
                        if (graphic && graphic.element) {
                            if (options && options.marker && typeof options.marker.symbol !== 'undefined') {
                                point.graphic = graphic.destroy()
                            }
                        }
                        if (options?.dataLabels && point.dataLabel) {
                            point.dataLabel = point.dataLabel.destroy()
                        }
                    }
                    i = point.index;
                    series.updateParallelArrays(point, i);
                    seriesOptions.data[i] = (isObject(seriesOptions.data[i], !0) || isObject(options, !0)) ? point.options : pick(options, seriesOptions.data[i]);
                    series.isDirty = series.isDirtyData = !0;
                    if (!series.fixedBox && series.hasCartesianSeries) {
                        chart.isDirtyBox = !0
                    }
                    if (seriesOptions.legendType === 'point') {
                        chart.isDirtyLegend = !0
                    }
                    if (redraw) {
                        chart.redraw(animation)
                    }
                }
                if (runEvent === !1) {
                    update()
                } else {
                    point.firePointEvent('update', {
                        options: options
                    }, update)
                }
            }
            remove(redraw, animation) {
                this.series.removePoint(this.series.data.indexOf(this), redraw, animation)
            }
            select(selected, accumulate) {
                const point = this
                    , series = point.series
                    , chart = series.chart;
                selected = pick(selected, !point.selected);
                this.selectedStaging = selected;
                point.firePointEvent(selected ? 'select' : 'unselect', {
                    accumulate: accumulate
                }, function() {
                    point.selected = point.options.selected = selected;
                    series.options.data[series.data.indexOf(point)] = point.options;
                    point.setState(selected && 'select');
                    if (!accumulate) {
                        chart.getSelectedPoints().forEach(function(loopPoint) {
                            const loopSeries = loopPoint.series;
                            if (loopPoint.selected && loopPoint !== point) {
                                loopPoint.selected = loopPoint.options.selected = !1;
                                loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
                                loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? 'inactive' : '');
                                loopPoint.firePointEvent('unselect')
                            }
                        })
                    }
                });
                delete this.selectedStaging
            }
            onMouseOver(e) {
                const point = this
                    , series = point.series
                    , chart = series.chart
                    , pointer = chart.pointer;
                e = e ? pointer.normalize(e) : pointer.getChartCoordinatesFromPoint(point, chart.inverted);
                pointer.runPointActions(e, point)
            }
            onMouseOut() {
                const point = this
                    , chart = point.series.chart;
                point.firePointEvent('mouseOut');
                if (!point.series.options.inactiveOtherPoints) {
                    (chart.hoverPoints || []).forEach(function(p) {
                        p.setState()
                    })
                }
                chart.hoverPoints = chart.hoverPoint = null
            }
            importEvents() {
                if (!this.hasImportedEvents) {
                    const point = this
                        , options = merge(point.series.options.point, point.options)
                        , events = options.events;
                    point.events = events;
                    objectEach(events, function(event, eventType) {
                        if (isFunction(event)) {
                            addEvent(point, eventType, event)
                        }
                    });
                    this.hasImportedEvents = !0
                }
            }
            setState(state, move) {
                const point = this
                    , series = point.series
                    , previousState = point.state
                    , stateOptions = (series.options.states[state || 'normal'] || {})
                    , markerOptions = (defaultOptions.plotOptions[series.type].marker && series.options.marker)
                    , normalDisabled = (markerOptions && markerOptions.enabled === !1)
                    , markerStateOptions = ((markerOptions && markerOptions.states && markerOptions.states[state || 'normal']) || {})
                    , stateDisabled = markerStateOptions.enabled === !1
                    , pointMarker = point.marker || {}
                    , chart = series.chart
                    , hasMarkers = (markerOptions && series.markerAttribs);
                let halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
                state = state || '';
                if ((state === point.state && !move) || (point.selected && state !== 'select') || (stateOptions.enabled === !1) || (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === !1))) || (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === !1)) {
                    return
                }
                point.state = state;
                if (hasMarkers) {
                    markerAttribs = series.markerAttribs(point, state)
                }
                if (point.graphic && !point.hasMockGraphic) {
                    if (previousState) {
                        point.graphic.removeClass('highcharts-point-' + previousState)
                    }
                    if (state) {
                        point.graphic.addClass('highcharts-point-' + state)
                    }
                    if (!chart.styledMode) {
                        pointAttribs = series.pointAttribs(point, state);
                        pointAttribsAnimation = pick(chart.options.chart.animation, stateOptions.animation);
                        const opacity = pointAttribs.opacity;
                        if (series.options.inactiveOtherPoints && isNumber(opacity)) {
                            (point.dataLabels || []).forEach(function(label) {
                                if (label && !label.hasClass('highcharts-data-label-hidden')) {
                                    label.animate({
                                        opacity
                                    }, pointAttribsAnimation);
                                    if (label.connector) {
                                        label.connector.animate({
                                            opacity
                                        }, pointAttribsAnimation)
                                    }
                                }
                            })
                        }
                        point.graphic.animate(pointAttribs, pointAttribsAnimation)
                    }
                    if (markerAttribs) {
                        point.graphic.animate(markerAttribs, pick(chart.options.chart.animation, markerStateOptions.animation, markerOptions.animation))
                    }
                    if (stateMarkerGraphic) {
                        stateMarkerGraphic.hide()
                    }
                } else {
                    if (state && markerStateOptions) {
                        newSymbol = pointMarker.symbol || series.symbol;
                        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                            stateMarkerGraphic = stateMarkerGraphic.destroy()
                        }
                        if (markerAttribs) {
                            if (!stateMarkerGraphic) {
                                if (newSymbol) {
                                    series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
                                    stateMarkerGraphic.currentSymbol = newSymbol
                                }
                            } else {
                                stateMarkerGraphic[move ? 'animate' : 'attr']({
                                    x: markerAttribs.x,
                                    y: markerAttribs.y
                                })
                            }
                        }
                        if (!chart.styledMode && stateMarkerGraphic && point.state !== 'inactive') {
                            stateMarkerGraphic.attr(series.pointAttribs(point, state))
                        }
                    }
                    if (stateMarkerGraphic) {
                        stateMarkerGraphic[state && point.isInside ? 'show' : 'hide']();
                        stateMarkerGraphic.element.point = point;
                        stateMarkerGraphic.addClass(point.getClassName(), !0)
                    }
                }
                const haloOptions = stateOptions.halo;
                const markerGraphic = (point.graphic || stateMarkerGraphic);
                const markerVisibility = (markerGraphic && markerGraphic.visibility || 'inherit');
                if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== 'hidden' && !point.isCluster) {
                    if (!halo) {
                        series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup)
                    }
                    halo.show()[move ? 'animate' : 'attr']({
                        d: point.haloPath(haloOptions.size)
                    });
                    halo.attr({
                        'class': 'highcharts-halo highcharts-color-' + pick(point.colorIndex, series.colorIndex) + (point.className ? ' ' + point.className : ''),
                        'visibility': markerVisibility,
                        'zIndex': -1
                    });
                    halo.point = point;
                    if (!chart.styledMode) {
                        halo.attr(extend({
                            'fill': point.color || series.color,
                            'fill-opacity': haloOptions.opacity
                        }, AST.filterUserAttributes(haloOptions.attributes || {})))
                    }
                } else if (halo && halo.point && halo.point.haloPath) {
                    halo.animate({
                        d: halo.point.haloPath(0)
                    }, null, halo.hide)
                }
                fireEvent(point, 'afterSetState', {
                    state
                })
            }
            haloPath(size) {
                const pos = this.pos();
                return pos ? this.series.chart.renderer.symbols.circle(Math.floor(pos[0]) - size, pos[1] - size, size * 2, size * 2) : []
            }
        }
        '';
        return Point
    });
    _registerModule(_modules, 'Core/Pointer.js', [_modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(Color, H, U) {
        const {parse: color} = Color;
        const {charts, noop} = H;
        const {addEvent, attr, css, defined, extend, find, fireEvent, isNumber, isObject, objectEach, offset, pick, splat} = U;
        class Pointer {
            constructor(chart, options) {
                this.lastValidTouch = {};
                this.pinchDown = [];
                this.runChartClick = !1;
                this.eventsToUnbind = [];
                this.chart = chart;
                this.hasDragged = !1;
                this.options = options;
                this.init(chart, options)
            }
            applyInactiveState(points) {
                let activeSeries = [], series;
                (points || []).forEach(function(item) {
                    series = item.series;
                    activeSeries.push(series);
                    if (series.linkedParent) {
                        activeSeries.push(series.linkedParent)
                    }
                    if (series.linkedSeries) {
                        activeSeries = activeSeries.concat(series.linkedSeries)
                    }
                    if (series.navigatorSeries) {
                        activeSeries.push(series.navigatorSeries)
                    }
                });
                this.chart.series.forEach(function(inactiveSeries) {
                    if (activeSeries.indexOf(inactiveSeries) === -1) {
                        inactiveSeries.setState('inactive', !0)
                    } else if (inactiveSeries.options.inactiveOtherPoints) {
                        inactiveSeries.setAllPointsToState('inactive')
                    }
                })
            }
            destroy() {
                const pointer = this;
                this.eventsToUnbind.forEach( (unbind) => unbind());
                this.eventsToUnbind = [];
                if (!H.chartCount) {
                    if (Pointer.unbindDocumentMouseUp) {
                        Pointer.unbindDocumentMouseUp = Pointer.unbindDocumentMouseUp()
                    }
                    if (Pointer.unbindDocumentTouchEnd) {
                        Pointer.unbindDocumentTouchEnd = (Pointer.unbindDocumentTouchEnd())
                    }
                }
                clearInterval(pointer.tooltipTimeout);
                objectEach(pointer, function(_val, prop) {
                    pointer[prop] = void 0
                })
            }
            getSelectionMarkerAttrs(chartX, chartY) {
                const e = {
                    args: {
                        chartX,
                        chartY
                    },
                    attrs: {},
                    shapeType: 'rect'
                };
                fireEvent(this, 'getSelectionMarkerAttrs', e, (e) => {
                        const {chart, mouseDownX=0, mouseDownY=0, zoomHor, zoomVert} = this
                            , attrs = e.attrs;
                        let size;
                        attrs.x = chart.plotLeft;
                        attrs.y = chart.plotTop;
                        attrs.width = zoomHor ? 1 : chart.plotWidth;
                        attrs.height = zoomVert ? 1 : chart.plotHeight;
                        if (zoomHor) {
                            size = chartX - mouseDownX;
                            attrs.width = Math.abs(size);
                            attrs.x = (size > 0 ? 0 : size) + mouseDownX
                        }
                        if (zoomVert) {
                            size = chartY - mouseDownY;
                            attrs.height = Math.abs(size);
                            attrs.y = (size > 0 ? 0 : size) + mouseDownY
                        }
                    }
                );
                return e
            }
            drag(e) {
                const chart = this.chart
                    , chartOptions = chart.options.chart
                    , plotLeft = chart.plotLeft
                    , plotTop = chart.plotTop
                    , plotWidth = chart.plotWidth
                    , plotHeight = chart.plotHeight
                    , mouseDownX = (this.mouseDownX || 0)
                    , mouseDownY = (this.mouseDownY || 0)
                    , panningEnabled = isObject(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning
                    , panKey = (chartOptions.panKey && e[chartOptions.panKey + 'Key']);
                let chartX = e.chartX, chartY = e.chartY, clickedInside, selectionMarker = this.selectionMarker;
                if (selectionMarker && selectionMarker.touch) {
                    return
                }
                if (chartX < plotLeft) {
                    chartX = plotLeft
                } else if (chartX > plotLeft + plotWidth) {
                    chartX = plotLeft + plotWidth
                }
                if (chartY < plotTop) {
                    chartY = plotTop
                } else if (chartY > plotTop + plotHeight) {
                    chartY = plotTop + plotHeight
                }
                this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
                if (this.hasDragged > 10) {
                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
                        visiblePlotOnly: !0
                    });
                    const {shapeType, attrs} = this.getSelectionMarkerAttrs(chartX, chartY);
                    if ((chart.hasCartesianSeries || chart.mapView) && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
                        if (!selectionMarker) {
                            this.selectionMarker = selectionMarker = chart.renderer[shapeType]();
                            selectionMarker.attr({
                                'class': 'highcharts-selection-marker',
                                zIndex: 7
                            }).add();
                            if (!chart.styledMode) {
                                selectionMarker.attr({
                                    fill: chartOptions.selectionMarkerFill || color("#334eff").setOpacity(0.25).get()
                                })
                            }
                        }
                    }
                    if (selectionMarker) {
                        selectionMarker.attr(attrs)
                    }
                    if (clickedInside && !selectionMarker && panningEnabled) {
                        chart.pan(e, chartOptions.panning)
                    }
                }
            }
            dragStart(e) {
                const chart = this.chart;
                chart.mouseIsDown = e.type;
                chart.cancelClick = !1;
                chart.mouseDownX = this.mouseDownX = e.chartX;
                chart.mouseDownY = this.mouseDownY = e.chartY
            }
            getSelectionBox(marker) {
                const e = {
                    args: {
                        marker
                    },
                    result: {}
                };
                fireEvent(this, 'getSelectionBox', e, (e) => {
                        e.result = {
                            x: marker.attr ? +marker.attr('x') : marker.x,
                            y: marker.attr ? +marker.attr('y') : marker.y,
                            width: marker.attr ? marker.attr('width') : marker.width,
                            height: marker.attr ? marker.attr('height') : marker.height
                        }
                    }
                );
                return e.result
            }
            drop(e) {
                const pointer = this
                    , chart = this.chart
                    , hasPinched = this.hasPinched;
                if (this.selectionMarker) {
                    const {x, y, width, height} = this.getSelectionBox(this.selectionMarker);
                    const selectionData = {
                        originalEvent: e,
                        xAxis: [],
                        yAxis: [],
                        x,
                        y,
                        width,
                        height
                    };
                    let runZoom = Boolean(chart.mapView);
                    if (this.hasDragged || hasPinched) {
                        chart.axes.forEach(function(axis) {
                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{
                                xAxis: 'zoomX',
                                yAxis: 'zoomY'
                            }[axis.coll]]) && isNumber(x) && isNumber(y) && isNumber(width) && isNumber(height)) {
                                const horiz = axis.horiz
                                    , minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0
                                    , selectionMin = axis.toValue((horiz ? x : y) + minPixelPadding)
                                    , selectionMax = axis.toValue((horiz ? x + width : y + height) - minPixelPadding);
                                selectionData[axis.coll].push({
                                    axis: axis,
                                    min: Math.min(selectionMin, selectionMax),
                                    max: Math.max(selectionMin, selectionMax)
                                });
                                runZoom = !0
                            }
                        });
                        if (runZoom) {
                            fireEvent(chart, 'selection', selectionData, function(args) {
                                chart.zoom(extend(args, hasPinched ? {
                                    animation: !1
                                } : null))
                            })
                        }
                    }
                    if (isNumber(chart.index)) {
                        this.selectionMarker = this.selectionMarker.destroy()
                    }
                    if (hasPinched) {
                        this.scaleGroups()
                    }
                }
                if (chart && isNumber(chart.index)) {
                    css(chart.container, {
                        cursor: chart._cursor
                    });
                    chart.cancelClick = +this.hasDragged > 10;
                    chart.mouseIsDown = this.hasDragged = this.hasPinched = !1;
                    this.pinchDown = []
                }
            }
            findNearestKDPoint(series, shared, e) {
                let closest;
                function sort(p1, p2) {
                    const isCloserX = p1.distX - p2.distX
                        , isCloser = p1.dist - p2.dist
                        , isAbove = ((p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex));
                    let result;
                    if (isCloserX !== 0 && shared) {
                        result = isCloserX
                    } else if (isCloser !== 0) {
                        result = isCloser
                    } else if (isAbove !== 0) {
                        result = isAbove
                    } else {
                        result = p1.series.index > p2.series.index ? -1 : 1
                    }
                    return result
                }
                series.forEach(function(s) {
                    const noSharedTooltip = s.noSharedTooltip && shared
                        , compareX = (!noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0)
                        , point = s.searchPoint(e, compareX);
                    if (isObject(point, !0) && point.series && (!isObject(closest, !0) || (sort(closest, point) > 0))) {
                        closest = point
                    }
                });
                return closest
            }
            getChartCoordinatesFromPoint(point, inverted) {
                const series = point.series
                    , xAxis = series.xAxis
                    , yAxis = series.yAxis
                    , shapeArgs = point.shapeArgs;
                if (xAxis && yAxis) {
                    let x = pick(point.clientX, point.plotX);
                    let y = point.plotY || 0;
                    if (point.isNode && shapeArgs && isNumber(shapeArgs.x) && isNumber(shapeArgs.y)) {
                        x = shapeArgs.x;
                        y = shapeArgs.y
                    }
                    return inverted ? {
                        chartX: yAxis.len + yAxis.pos - y,
                        chartY: xAxis.len + xAxis.pos - x
                    } : {
                        chartX: x + xAxis.pos,
                        chartY: y + yAxis.pos
                    }
                }
                if (shapeArgs && shapeArgs.x && shapeArgs.y) {
                    return {
                        chartX: shapeArgs.x,
                        chartY: shapeArgs.y
                    }
                }
            }
            getChartPosition() {
                if (this.chartPosition) {
                    return this.chartPosition
                }
                const {container} = this.chart;
                const pos = offset(container);
                this.chartPosition = {
                    left: pos.left,
                    top: pos.top,
                    scaleX: 1,
                    scaleY: 1
                };
                const offsetWidth = container.offsetWidth;
                const offsetHeight = container.offsetHeight;
                if (offsetWidth > 2 && offsetHeight > 2) {
                    this.chartPosition.scaleX = pos.width / offsetWidth;
                    this.chartPosition.scaleY = pos.height / offsetHeight
                }
                return this.chartPosition
            }
            getCoordinates(e) {
                const coordinates = {
                    xAxis: [],
                    yAxis: []
                };
                this.chart.axes.forEach(function(axis) {
                    coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
                        axis: axis,
                        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
                    })
                });
                return coordinates
            }
            getHoverData(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e) {
                const hoverPoints = []
                    , useExisting = !!(isDirectTouch && existingHoverPoint)
                    , filter = function(s) {
                    return (s.visible && !(!shared && s.directTouch) && pick(s.options.enableMouseTracking, !0))
                };
                let hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
                    chartX: e ? e.chartX : void 0,
                    chartY: e ? e.chartY : void 0,
                    shared: shared
                };
                fireEvent(this, 'beforeGetHoverData', eventArgs);
                const notSticky = hoverSeries && !hoverSeries.stickyTracking;
                searchSeries = notSticky ? [hoverSeries] : series.filter( (s) => s.stickyTracking && (eventArgs.filter || filter)(s));
                const hoverPoint = useExisting || !e ? existingHoverPoint : this.findNearestKDPoint(searchSeries, shared, e);
                hoverSeries = hoverPoint && hoverPoint.series;
                if (hoverPoint) {
                    if (shared && !hoverSeries.noSharedTooltip) {
                        searchSeries = series.filter(function(s) {
                            return eventArgs.filter ? eventArgs.filter(s) : filter(s) && !s.noSharedTooltip
                        });
                        searchSeries.forEach(function(s) {
                            let point = find(s.points, function(p) {
                                return p.x === hoverPoint.x && !p.isNull
                            });
                            if (isObject(point)) {
                                if (s.boosted && s.boost) {
                                    point = s.boost.getPoint(point)
                                }
                                hoverPoints.push(point)
                            }
                        })
                    } else {
                        hoverPoints.push(hoverPoint)
                    }
                }
                eventArgs = {
                    hoverPoint: hoverPoint
                };
                fireEvent(this, 'afterGetHoverData', eventArgs);
                return {
                    hoverPoint: eventArgs.hoverPoint,
                    hoverSeries: hoverSeries,
                    hoverPoints: hoverPoints
                }
            }
            getPointFromEvent(e) {
                let target = e.target, point;
                while (target && !point) {
                    point = target.point;
                    target = target.parentNode
                }
                return point
            }
            onTrackerMouseOut(e) {
                const chart = this.chart;
                const relatedTarget = e.relatedTarget;
                const series = chart.hoverSeries;
                this.isDirectTouch = !1;
                if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, 'highcharts-tooltip') && (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || !this.inClass(relatedTarget, 'highcharts-tracker'))) {
                    series.onMouseOut()
                }
            }
            inClass(element, className) {
                let elem = element, elemClassName;
                while (elem) {
                    elemClassName = attr(elem, 'class');
                    if (elemClassName) {
                        if (elemClassName.indexOf(className) !== -1) {
                            return !0
                        }
                        if (elemClassName.indexOf('highcharts-container') !== -1) {
                            return !1
                        }
                    }
                    elem = elem.parentElement
                }
            }
            init(chart, options) {
                this.options = options;
                this.chart = chart;
                this.runChartClick = Boolean(options.chart.events && options.chart.events.click);
                this.pinchDown = [];
                this.lastValidTouch = {};
                this.setDOMEvents();
                fireEvent(this, 'afterInit')
            }
            normalize(e, chartPosition) {
                const touches = e.touches;
                const ePos = (touches ? touches.length ? touches.item(0) : (pick(touches.changedTouches, e.changedTouches))[0] : e);
                if (!chartPosition) {
                    chartPosition = this.getChartPosition()
                }
                let chartX = ePos.pageX - chartPosition.left
                    , chartY = ePos.pageY - chartPosition.top;
                chartX /= chartPosition.scaleX;
                chartY /= chartPosition.scaleY;
                return extend(e, {
                    chartX: Math.round(chartX),
                    chartY: Math.round(chartY)
                })
            }
            onContainerClick(e) {
                const chart = this.chart;
                const hoverPoint = chart.hoverPoint;
                const pEvt = this.normalize(e);
                const plotLeft = chart.plotLeft;
                const plotTop = chart.plotTop;
                if (!chart.cancelClick) {
                    if (hoverPoint && this.inClass(pEvt.target, 'highcharts-tracker')) {
                        fireEvent(hoverPoint.series, 'click', extend(pEvt, {
                            point: hoverPoint
                        }));
                        if (chart.hoverPoint) {
                            hoverPoint.firePointEvent('click', pEvt)
                        }
                    } else {
                        extend(pEvt, this.getCoordinates(pEvt));
                        if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
                            visiblePlotOnly: !0
                        })) {
                            fireEvent(chart, 'click', pEvt)
                        }
                    }
                }
            }
            onContainerMouseDown(e) {
                const isPrimaryButton = ((e.buttons || e.button) & 1) === 1;
                e = this.normalize(e);
                if (H.isFirefox && e.button !== 0) {
                    this.onContainerMouseMove(e)
                }
                if (typeof e.button === 'undefined' || isPrimaryButton) {
                    this.zoomOption(e);
                    if (isPrimaryButton && e.preventDefault) {
                        e.preventDefault()
                    }
                    this.dragStart(e)
                }
            }
            onContainerMouseLeave(e) {
                const chart = charts[pick(Pointer.hoverChartIndex, -1)];
                e = this.normalize(e);
                this.onContainerMouseMove(e);
                if (chart && e.relatedTarget && !this.inClass(e.relatedTarget, 'highcharts-tooltip')) {
                    chart.pointer.reset();
                    chart.pointer.chartPosition = void 0
                }
            }
            onContainerMouseEnter(e) {
                delete this.chartPosition
            }
            onContainerMouseMove(e) {
                const chart = this.chart
                    , tooltip = chart.tooltip
                    , pEvt = this.normalize(e);
                this.setHoverChartIndex(e);
                if (chart.mouseIsDown === 'mousedown' || this.touchSelect(pEvt)) {
                    this.drag(pEvt)
                }
                if (!chart.openMenu && (this.inClass(pEvt.target, 'highcharts-tracker') || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
                    visiblePlotOnly: !0
                })) && !(tooltip && tooltip.shouldStickOnContact(pEvt))) {
                    if (this.inClass(pEvt.target, 'highcharts-no-tooltip')) {
                        this.reset(!1, 0)
                    } else {
                        this.runPointActions(pEvt)
                    }
                }
            }
            onDocumentTouchEnd(e) {
                const hoverChart = charts[pick(Pointer.hoverChartIndex, -1)];
                if (hoverChart) {
                    hoverChart.pointer.drop(e)
                }
            }
            onContainerTouchMove(e) {
                if (this.touchSelect(e)) {
                    this.onContainerMouseMove(e)
                } else {
                    this.touch(e)
                }
            }
            onContainerTouchStart(e) {
                if (this.touchSelect(e)) {
                    this.onContainerMouseDown(e)
                } else {
                    this.zoomOption(e);
                    this.touch(e, !0)
                }
            }
            onDocumentMouseMove(e) {
                const chart = this.chart;
                const tooltip = chart.tooltip;
                const chartPosition = this.chartPosition;
                const pEvt = this.normalize(e, chartPosition);
                if (chartPosition && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
                    visiblePlotOnly: !0
                }) && !(tooltip && tooltip.shouldStickOnContact(pEvt)) && !this.inClass(pEvt.target, 'highcharts-tracker')) {
                    this.reset()
                }
            }
            onDocumentMouseUp(e) {
                const chart = charts[pick(Pointer.hoverChartIndex, -1)];
                if (chart) {
                    chart.pointer.drop(e)
                }
            }
            pinch(e) {
                const self = this
                    , chart = self.chart
                    , pinchDown = self.pinchDown
                    , touches = (e.touches || [])
                    , touchesLength = touches.length
                    , lastValidTouch = self.lastValidTouch
                    , hasZoom = self.hasZoom
                    , transform = {}
                    , fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') && chart.runTrackerClick) || self.runChartClick)
                    , clip = {}
                    , tooltip = self.chart.tooltip
                    , followTouchMove = touchesLength === 1 && pick((tooltip && tooltip.options.followTouchMove), !0);
                let selectionMarker = self.selectionMarker;
                if (touchesLength > 1) {
                    self.initiated = !0
                } else if (followTouchMove) {
                    self.initiated = !1
                }
                if (hasZoom && self.initiated && !fireClickEvent && e.cancelable !== !1) {
                    e.preventDefault()
                }
                [].map.call(touches, function(e) {
                    return self.normalize(e)
                });
                if (e.type === 'touchstart') {
                    [].forEach.call(touches, function(e, i) {
                        pinchDown[i] = {
                            chartX: e.chartX,
                            chartY: e.chartY
                        }
                    });
                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
                    chart.axes.forEach(function(axis) {
                        if (axis.zoomEnabled) {
                            const bounds = chart.bounds[axis.horiz ? 'h' : 'v']
                                , minPixelPadding = axis.minPixelPadding
                                , min = axis.toPixels(Math.min(pick(axis.options.min, axis.dataMin), axis.dataMin))
                                , max = axis.toPixels(Math.max(pick(axis.options.max, axis.dataMax), axis.dataMax))
                                , absMin = Math.min(min, max)
                                , absMax = Math.max(min, max);
                            bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
                            bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding)
                        }
                    });
                    self.res = !0
                } else if (followTouchMove) {
                    this.runPointActions(self.normalize(e))
                } else if (pinchDown.length) {
                    fireEvent(chart, 'touchpan', {
                            originalEvent: e
                        }, () => {
                            if (!selectionMarker) {
                                self.selectionMarker = selectionMarker = extend({
                                    destroy: noop,
                                    touch: !0
                                }, chart.plotBox)
                            }
                            self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                            self.hasPinched = hasZoom;
                            self.scaleGroups(transform, clip)
                        }
                    );
                    if (self.res) {
                        self.res = !1;
                        this.reset(!1, 0)
                    }
                }
            }
            pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
                if (this.zoomHor) {
                    this.pinchTranslateDirection(!0, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch)
                }
                if (this.zoomVert) {
                    this.pinchTranslateDirection(!1, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch)
                }
            }
            pinchTranslateDirection(horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
                const chart = this.chart
                    , xy = horiz ? 'x' : 'y'
                    , XY = horiz ? 'X' : 'Y'
                    , sChartXY = ('chart' + XY)
                    , wh = horiz ? 'width' : 'height'
                    , plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')]
                    , inverted = chart.inverted
                    , bounds = chart.bounds[horiz ? 'h' : 'v']
                    , singleTouch = pinchDown.length === 1
                    , touch0Start = pinchDown[0][sChartXY]
                    , touch1Start = !singleTouch && pinchDown[1][sChartXY]
                    , setScale = function() {
                    if (typeof touch1Now === 'number' && Math.abs(touch0Start - touch1Start) > 20) {
                        scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start)
                    }
                    clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
                    selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale
                };
                let selectionWH, selectionXY, clipXY, scale = forcedScale || 1, touch0Now = touches[0][sChartXY], touch1Now = !singleTouch && touches[1][sChartXY], outOfBounds;
                setScale();
                selectionXY = clipXY;
                if (selectionXY < bounds.min) {
                    selectionXY = bounds.min;
                    outOfBounds = !0
                } else if (selectionXY + selectionWH > bounds.max) {
                    selectionXY = bounds.max - selectionWH;
                    outOfBounds = !0
                }
                if (outOfBounds) {
                    touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
                    if (typeof touch1Now === 'number') {
                        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1])
                    }
                    setScale()
                } else {
                    lastValidTouch[xy] = [touch0Now, touch1Now]
                }
                if (!inverted) {
                    clip[xy] = clipXY - plotLeftTop;
                    clip[wh] = selectionWH
                }
                const scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
                const transformScale = inverted ? 1 / scale : scale;
                selectionMarker[wh] = selectionWH;
                selectionMarker[xy] = selectionXY;
                transform[scaleKey] = scale * (inverted && !horiz ? -1 : 1);
                transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start))
            }
            reset(allowMove, delay) {
                const pointer = this
                    , chart = pointer.chart
                    , hoverSeries = chart.hoverSeries
                    , hoverPoint = chart.hoverPoint
                    , hoverPoints = chart.hoverPoints
                    , tooltip = chart.tooltip
                    , tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
                if (allowMove && tooltipPoints) {
                    splat(tooltipPoints).forEach(function(point) {
                        if (point.series.isCartesian && typeof point.plotX === 'undefined') {
                            allowMove = !1
                        }
                    })
                }
                if (allowMove) {
                    if (tooltip && tooltipPoints && splat(tooltipPoints).length) {
                        tooltip.refresh(tooltipPoints);
                        if (tooltip.shared && hoverPoints) {
                            hoverPoints.forEach(function(point) {
                                point.setState(point.state, !0);
                                if (point.series.isCartesian) {
                                    if (point.series.xAxis.crosshair) {
                                        point.series.xAxis.drawCrosshair(null, point)
                                    }
                                    if (point.series.yAxis.crosshair) {
                                        point.series.yAxis.drawCrosshair(null, point)
                                    }
                                }
                            })
                        } else if (hoverPoint) {
                            hoverPoint.setState(hoverPoint.state, !0);
                            chart.axes.forEach(function(axis) {
                                if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
                                    axis.drawCrosshair(null, hoverPoint)
                                }
                            })
                        }
                    }
                } else {
                    if (hoverPoint) {
                        hoverPoint.onMouseOut()
                    }
                    if (hoverPoints) {
                        hoverPoints.forEach(function(point) {
                            point.setState()
                        })
                    }
                    if (hoverSeries) {
                        hoverSeries.onMouseOut()
                    }
                    if (tooltip) {
                        tooltip.hide(delay)
                    }
                    if (pointer.unDocMouseMove) {
                        pointer.unDocMouseMove = pointer.unDocMouseMove()
                    }
                    chart.axes.forEach(function(axis) {
                        axis.hideCrosshair()
                    });
                    pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null
                }
            }
            runPointActions(e, p, force) {
                const pointer = this
                    , chart = pointer.chart
                    , series = chart.series
                    , tooltip = (chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0)
                    , shared = (tooltip ? tooltip.shared : !1);
                let hoverPoint = p || chart.hoverPoint
                    , hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;
                const isDirectTouch = (!e || e.type !== 'touchmove') && (!!p || ((hoverSeries && hoverSeries.directTouch) && pointer.isDirectTouch))
                    , hoverData = this.getHoverData(hoverPoint, hoverSeries, series, isDirectTouch, shared, e);
                hoverPoint = hoverData.hoverPoint;
                hoverSeries = hoverData.hoverSeries;
                const points = hoverData.hoverPoints
                    , followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split
                    , useSharedTooltip = (shared && hoverSeries && !hoverSeries.noSharedTooltip);
                if (hoverPoint && (force || hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))) {
                    (chart.hoverPoints || []).forEach(function(p) {
                        if (points.indexOf(p) === -1) {
                            p.setState()
                        }
                    });
                    if (chart.hoverSeries !== hoverSeries) {
                        hoverSeries.onMouseOver()
                    }
                    pointer.applyInactiveState(points);
                    (points || []).forEach(function(p) {
                        p.setState('hover')
                    });
                    if (chart.hoverPoint) {
                        chart.hoverPoint.firePointEvent('mouseOut')
                    }
                    if (!hoverPoint.series) {
                        return
                    }
                    chart.hoverPoints = points;
                    chart.hoverPoint = hoverPoint;
                    hoverPoint.firePointEvent('mouseOver', void 0, () => {
                            if (tooltip && hoverPoint) {
                                tooltip.refresh(useSharedTooltip ? points : hoverPoint, e)
                            }
                        }
                    )
                } else if (followPointer && tooltip && !tooltip.isHidden) {
                    const anchor = tooltip.getAnchor([{}], e);
                    if (chart.isInsidePlot(anchor[0], anchor[1], {
                        visiblePlotOnly: !0
                    })) {
                        tooltip.updatePosition({
                            plotX: anchor[0],
                            plotY: anchor[1]
                        })
                    }
                }
                if (!pointer.unDocMouseMove) {
                    pointer.unDocMouseMove = addEvent(chart.container.ownerDocument, 'mousemove', function(e) {
                        const chart = charts[Pointer.hoverChartIndex];
                        if (chart) {
                            chart.pointer.onDocumentMouseMove(e)
                        }
                    });
                    pointer.eventsToUnbind.push(pointer.unDocMouseMove)
                }
                chart.axes.forEach(function drawAxisCrosshair(axis) {
                    const snap = pick((axis.crosshair || {}).snap, !0);
                    let point;
                    if (snap) {
                        point = chart.hoverPoint;
                        if (!point || point.series[axis.coll] !== axis) {
                            point = find(points, (p) => p.series && p.series[axis.coll] === axis)
                        }
                    }
                    if (point || !snap) {
                        axis.drawCrosshair(e, point)
                    } else {
                        axis.hideCrosshair()
                    }
                })
            }
            scaleGroups(attribs, clip) {
                const chart = this.chart;
                chart.series.forEach(function(series) {
                    const seriesAttribs = attribs || series.getPlotBox('series');
                    if (series.group && ((series.xAxis && series.xAxis.zoomEnabled) || chart.mapView)) {
                        series.group.attr(seriesAttribs);
                        if (series.markerGroup) {
                            series.markerGroup.attr(attribs || series.getPlotBox('marker'));
                            series.markerGroup.clip(clip ? chart.clipRect : null)
                        }
                        if (series.dataLabelsGroup) {
                            series.dataLabelsGroup.attr(seriesAttribs)
                        }
                    }
                });
                chart.clipRect.attr(clip || chart.clipBox)
            }
            setDOMEvents() {
                const container = this.chart.container
                    , ownerDoc = container.ownerDocument;
                container.onmousedown = this.onContainerMouseDown.bind(this);
                container.onmousemove = this.onContainerMouseMove.bind(this);
                container.onclick = this.onContainerClick.bind(this);
                this.eventsToUnbind.push(addEvent(container, 'mouseenter', this.onContainerMouseEnter.bind(this)));
                this.eventsToUnbind.push(addEvent(container, 'mouseleave', this.onContainerMouseLeave.bind(this)));
                if (!Pointer.unbindDocumentMouseUp) {
                    Pointer.unbindDocumentMouseUp = addEvent(ownerDoc, 'mouseup', this.onDocumentMouseUp.bind(this))
                }
                let parent = this.chart.renderTo.parentElement;
                while (parent && parent.tagName !== 'BODY') {
                    this.eventsToUnbind.push(addEvent(parent, 'scroll', () => {
                            delete this.chartPosition
                        }
                    ));
                    parent = parent.parentElement
                }
                if (H.hasTouch) {
                    this.eventsToUnbind.push(addEvent(container, 'touchstart', this.onContainerTouchStart.bind(this), {
                        passive: !1
                    }));
                    this.eventsToUnbind.push(addEvent(container, 'touchmove', this.onContainerTouchMove.bind(this), {
                        passive: !1
                    }));
                    if (!Pointer.unbindDocumentTouchEnd) {
                        Pointer.unbindDocumentTouchEnd = addEvent(ownerDoc, 'touchend', this.onDocumentTouchEnd.bind(this), {
                            passive: !1
                        })
                    }
                }
            }
            setHoverChartIndex(e) {
                const chart = this.chart;
                const hoverChart = H.charts[pick(Pointer.hoverChartIndex, -1)];
                if (hoverChart && hoverChart !== chart) {
                    hoverChart.pointer.onContainerMouseLeave(e || {
                        relatedTarget: chart.container
                    })
                }
                if (!hoverChart || !hoverChart.mouseIsDown) {
                    Pointer.hoverChartIndex = chart.index
                }
            }
            touch(e, start) {
                const chart = this.chart;
                let hasMoved, pinchDown, isInside;
                this.setHoverChartIndex();
                if (e.touches.length === 1) {
                    e = this.normalize(e);
                    isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {
                        visiblePlotOnly: !0
                    });
                    if (isInside && !chart.openMenu) {
                        if (start) {
                            this.runPointActions(e)
                        }
                        if (e.type === 'touchmove') {
                            pinchDown = this.pinchDown;
                            hasMoved = pinchDown[0] ? Math.sqrt(Math.pow(pinchDown[0].chartX - e.chartX, 2) + Math.pow(pinchDown[0].chartY - e.chartY, 2)) >= 4 : !1
                        }
                        if (pick(hasMoved, !0)) {
                            this.pinch(e)
                        }
                    } else if (start) {
                        this.reset()
                    }
                } else if (e.touches.length === 2) {
                    this.pinch(e)
                }
            }
            touchSelect(e) {
                return Boolean(this.chart.zooming.singleTouch && e.touches && e.touches.length === 1)
            }
            zoomOption(e) {
                const chart = this.chart
                    , options = chart.options.chart
                    , inverted = chart.inverted;
                let zoomType = chart.zooming.type || '', zoomX, zoomY;
                if (/touch/.test(e.type)) {
                    zoomType = pick(chart.zooming.pinchType, zoomType)
                }
                this.zoomX = zoomX = /x/.test(zoomType);
                this.zoomY = zoomY = /y/.test(zoomType);
                this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
                this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
                this.hasZoom = zoomX || zoomY
            }
        }
        (function(Pointer) {
                const composedEvents = [];
                const composedMembers = [];
                function compose(ChartClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        addEvent(ChartClass, 'beforeRender', function() {
                            this.pointer = new Pointer(this,this.options)
                        })
                    }
                }
                Pointer.compose = compose;
                function dissolve() {
                    for (let i = 0, iEnd = composedEvents.length; i < iEnd; ++i) {
                        composedEvents[i]()
                    }
                    composedEvents.length = 0
                }
                Pointer.dissolve = dissolve
            }
        )(Pointer || (Pointer = {}));
        '';
        return Pointer
    });
    _registerModule(_modules, 'Core/Legend/Legend.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Templating.js'], _modules['Core/Globals.js'], _modules['Core/Series/Point.js'], _modules['Core/Renderer/RendererUtilities.js'], _modules['Core/Utilities.js']], function(A, F, H, Point, R, U) {
        const {animObject, setAnimation} = A;
        const {format} = F;
        const {marginNames} = H;
        const {distribute} = R;
        const {addEvent, createElement, css, defined, discardElement, find, fireEvent, isNumber, merge, pick, relativeLength, stableSort, syncTimeout} = U;
        class Legend {
            constructor(chart, options) {
                this.allItems = [];
                this.box = void 0;
                this.contentGroup = void 0;
                this.display = !1;
                this.group = void 0;
                this.initialItemY = 0;
                this.itemHeight = 0;
                this.itemMarginBottom = 0;
                this.itemMarginTop = 0;
                this.itemX = 0;
                this.itemY = 0;
                this.lastItemY = 0;
                this.lastLineHeight = 0;
                this.legendHeight = 0;
                this.legendWidth = 0;
                this.maxItemWidth = 0;
                this.maxLegendWidth = 0;
                this.offsetWidth = 0;
                this.options = void 0;
                this.padding = 0;
                this.pages = [];
                this.proximate = !1;
                this.scrollGroup = void 0;
                this.symbolHeight = 0;
                this.symbolWidth = 0;
                this.titleHeight = 0;
                this.totalItemWidth = 0;
                this.widthOption = 0;
                this.chart = chart;
                this.init(chart, options)
            }
            init(chart, options) {
                this.chart = chart;
                this.setOptions(options);
                if (options.enabled) {
                    this.render();
                    addEvent(this.chart, 'endResize', function() {
                        this.legend.positionCheckboxes()
                    })
                }
                addEvent(this.chart, 'render', () => {
                        if (this.options.enabled && this.proximate) {
                            this.proximatePositions();
                            this.positionItems()
                        }
                    }
                )
            }
            setOptions(options) {
                const padding = pick(options.padding, 8);
                this.options = options;
                if (!this.chart.styledMode) {
                    this.itemStyle = options.itemStyle;
                    this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle)
                }
                this.itemMarginTop = options.itemMarginTop;
                this.itemMarginBottom = options.itemMarginBottom;
                this.padding = padding;
                this.initialItemY = padding - 5;
                this.symbolWidth = pick(options.symbolWidth, 16);
                this.pages = [];
                this.proximate = options.layout === 'proximate' && !this.chart.inverted;
                this.baseline = void 0
            }
            update(options, redraw) {
                const chart = this.chart;
                this.setOptions(merge(!0, this.options, options));
                this.destroy();
                chart.isDirtyLegend = chart.isDirtyBox = !0;
                if (pick(redraw, !0)) {
                    chart.redraw()
                }
                fireEvent(this, 'afterUpdate', {
                    redraw
                })
            }
            colorizeItem(item, visible) {
                const {group, label, line, symbol} = item.legendItem || {};
                if (group) {
                    group[visible ? 'removeClass' : 'addClass']('highcharts-legend-item-hidden')
                }
                if (!this.chart.styledMode) {
                    const {itemHiddenStyle} = this
                        , hiddenColor = itemHiddenStyle.color
                        , symbolColor = visible ? (item.color || hiddenColor) : hiddenColor
                        , markerOptions = item.options && item.options.marker;
                    let symbolAttr = {
                        fill: symbolColor
                    };
                    label?.css(merge(visible ? this.itemStyle : itemHiddenStyle));
                    line?.attr({
                        stroke: symbolColor
                    });
                    if (symbol) {
                        if (markerOptions && symbol.isMarker) {
                            symbolAttr = item.pointAttribs();
                            if (!visible) {
                                symbolAttr.stroke = symbolAttr.fill = hiddenColor
                            }
                        }
                        symbol.attr(symbolAttr)
                    }
                }
                fireEvent(this, 'afterColorizeItem', {
                    item,
                    visible
                })
            }
            positionItems() {
                this.allItems.forEach(this.positionItem, this);
                if (!this.chart.isResizing) {
                    this.positionCheckboxes()
                }
            }
            positionItem(item) {
                const legend = this
                    , {group, x=0, y=0} = item.legendItem || {}
                    , options = legend.options
                    , symbolPadding = options.symbolPadding
                    , ltr = !options.rtl
                    , checkbox = item.checkbox;
                if (group && group.element) {
                    const attribs = {
                        translateX: ltr ? x : legend.legendWidth - x - 2 * symbolPadding - 4,
                        translateY: y
                    };
                    const complete = () => {
                            fireEvent(this, 'afterPositionItem', {
                                item
                            })
                        }
                    ;
                    group[defined(group.translateY) ? 'animate' : 'attr'](attribs, void 0, complete)
                }
                if (checkbox) {
                    checkbox.x = x;
                    checkbox.y = y
                }
            }
            destroyItem(item) {
                const checkbox = item.checkbox
                    , legendItem = item.legendItem || {};
                for (const key of ['group', 'label', 'line', 'symbol']) {
                    if (legendItem[key]) {
                        legendItem[key] = legendItem[key].destroy()
                    }
                }
                if (checkbox) {
                    discardElement(checkbox)
                }
                item.legendItem = void 0
            }
            destroy() {
                const legend = this;
                for (const item of this.getAllItems()) {
                    this.destroyItem(item)
                }
                for (const key of ['clipRect', 'up', 'down', 'pager', 'nav', 'box', 'title', 'group']) {
                    if (legend[key]) {
                        legend[key] = legend[key].destroy()
                    }
                }
                this.display = null
            }
            positionCheckboxes() {
                const alignAttr = this.group && this.group.alignAttr
                    , clipHeight = this.clipHeight || this.legendHeight
                    , titleHeight = this.titleHeight;
                let translateY;
                if (alignAttr) {
                    translateY = alignAttr.translateY;
                    this.allItems.forEach(function(item) {
                        const checkbox = item.checkbox;
                        let top;
                        if (checkbox) {
                            top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
                            css(checkbox, {
                                left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + 'px',
                                top: top + 'px',
                                display: this.proximate || (top > translateY - 6 && top < translateY + clipHeight - 6) ? '' : 'none'
                            })
                        }
                    }, this)
                }
            }
            renderTitle() {
                const options = this.options
                    , padding = this.padding
                    , titleOptions = options.title;
                let bBox, titleHeight = 0;
                if (titleOptions.text) {
                    if (!this.title) {
                        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, void 0, void 0, void 0, options.useHTML, void 0, 'legend-title').attr({
                            zIndex: 1
                        });
                        if (!this.chart.styledMode) {
                            this.title.css(titleOptions.style)
                        }
                        this.title.add(this.group)
                    }
                    if (!titleOptions.width) {
                        this.title.css({
                            width: this.maxLegendWidth + 'px'
                        })
                    }
                    bBox = this.title.getBBox();
                    titleHeight = bBox.height;
                    this.offsetWidth = bBox.width;
                    this.contentGroup.attr({
                        translateY: titleHeight
                    })
                }
                this.titleHeight = titleHeight
            }
            setText(item) {
                const options = this.options;
                item.legendItem.label.attr({
                    text: options.labelFormat ? format(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)
                })
            }
            renderItem(item) {
                const legend = this
                    , legendItem = item.legendItem = item.legendItem || {}
                    , chart = legend.chart
                    , renderer = chart.renderer
                    , options = legend.options
                    , horizontal = options.layout === 'horizontal'
                    , symbolWidth = legend.symbolWidth
                    , symbolPadding = options.symbolPadding || 0
                    , itemStyle = legend.itemStyle
                    , itemHiddenStyle = legend.itemHiddenStyle
                    , itemDistance = horizontal ? pick(options.itemDistance, 20) : 0
                    , ltr = !options.rtl
                    , isSeries = !item.series
                    , series = !isSeries && item.series.drawLegendSymbol ? item.series : item
                    , seriesOptions = series.options
                    , showCheckbox = (!!legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox)
                    , useHTML = options.useHTML
                    , itemClassName = item.options.className;
                let label = legendItem.label
                    , itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
                if (!label) {
                    legendItem.group = renderer.g('legend-item').addClass('highcharts-' + series.type + '-series ' + 'highcharts-color-' + item.colorIndex + (itemClassName ? ' ' + itemClassName : '') + (isSeries ? ' highcharts-series-' + item.index : '')).attr({
                        zIndex: 1
                    }).add(legend.scrollGroup);
                    legendItem.label = label = renderer.text('', ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
                    if (!chart.styledMode) {
                        label.css(merge(item.visible ? itemStyle : itemHiddenStyle))
                    }
                    label.attr({
                        align: ltr ? 'left' : 'right',
                        zIndex: 2
                    }).add(legendItem.group);
                    if (!legend.baseline) {
                        legend.fontMetrics = renderer.fontMetrics(label);
                        legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
                        label.attr('y', legend.baseline);
                        legend.symbolHeight = pick(options.symbolHeight, legend.fontMetrics.f);
                        if (options.squareSymbol) {
                            legend.symbolWidth = pick(options.symbolWidth, Math.max(legend.symbolHeight, 16));
                            itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
                            if (ltr) {
                                label.attr('x', legend.symbolWidth + symbolPadding)
                            }
                        }
                    }
                    series.drawLegendSymbol(legend, item);
                    if (legend.setItemEvents) {
                        legend.setItemEvents(item, label, useHTML)
                    }
                }
                if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {
                    legend.createCheckboxForItem(item)
                }
                legend.colorizeItem(item, item.visible);
                if (chart.styledMode || !itemStyle.width) {
                    label.css({
                        width: ((options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth) + 'px'
                    })
                }
                legend.setText(item);
                const bBox = label.getBBox();
                const fontMetricsH = (legend.fontMetrics && legend.fontMetrics.h) || 0;
                item.itemWidth = item.checkboxOffset = options.itemWidth || legendItem.labelWidth || bBox.width + itemExtraWidth;
                legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
                legend.totalItemWidth += item.itemWidth;
                legend.itemHeight = item.itemHeight = Math.round(legendItem.labelHeight || (bBox.height > fontMetricsH * 1.5 ? bBox.height : fontMetricsH))
            }
            layoutItem(item) {
                const options = this.options
                    , padding = this.padding
                    , horizontal = options.layout === 'horizontal'
                    , itemHeight = item.itemHeight
                    , itemMarginBottom = this.itemMarginBottom
                    , itemMarginTop = this.itemMarginTop
                    , itemDistance = horizontal ? pick(options.itemDistance, 20) : 0
                    , maxLegendWidth = this.maxLegendWidth
                    , itemWidth = (options.alignColumns && this.totalItemWidth > maxLegendWidth) ? this.maxItemWidth : item.itemWidth
                    , legendItem = item.legendItem || {};
                if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
                    this.itemX = padding;
                    if (this.lastLineHeight) {
                        this.itemY += (itemMarginTop + this.lastLineHeight + itemMarginBottom)
                    }
                    this.lastLineHeight = 0
                }
                this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
                this.lastLineHeight = Math.max(itemHeight, this.lastLineHeight);
                legendItem.x = this.itemX;
                legendItem.y = this.itemY;
                if (horizontal) {
                    this.itemX += itemWidth
                } else {
                    this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                    this.lastLineHeight = itemHeight
                }
                this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? 0 : itemDistance) : itemWidth) + padding, this.offsetWidth)
            }
            getAllItems() {
                let allItems = [];
                this.chart.series.forEach(function(series) {
                    const seriesOptions = series && series.options;
                    if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? void 0 : !1, !0)) {
                        allItems = allItems.concat((series.legendItem || {}).labels || (seriesOptions.legendType === 'point' ? series.data : series))
                    }
                });
                fireEvent(this, 'afterGetAllItems', {
                    allItems
                });
                return allItems
            }
            getAlignment() {
                const options = this.options;
                if (this.proximate) {
                    return options.align.charAt(0) + 'tv'
                }
                return options.floating ? '' : (options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0))
            }
            adjustMargins(margin, spacing) {
                const chart = this.chart
                    , options = this.options
                    , alignment = this.getAlignment();
                if (alignment) {
                    ([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/]).forEach(function(alignments, side) {
                        if (alignments.test(alignment) && !defined(margin[side])) {
                            chart[marginNames[side]] = Math.max(chart[marginNames[side]], (chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] + [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] + pick(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0)))
                        }
                    })
                }
            }
            proximatePositions() {
                const chart = this.chart
                    , boxes = []
                    , alignLeft = this.options.align === 'left';
                this.allItems.forEach(function(item) {
                    let lastPoint, height, useFirstPoint = alignLeft, target, top;
                    if (item.yAxis) {
                        if (item.xAxis.options.reversed) {
                            useFirstPoint = !useFirstPoint
                        }
                        if (item.points) {
                            lastPoint = find(useFirstPoint ? item.points : item.points.slice(0).reverse(), function(item) {
                                return isNumber(item.plotY)
                            })
                        }
                        height = this.itemMarginTop + item.legendItem.label.getBBox().height + this.itemMarginBottom;
                        top = item.yAxis.top - chart.plotTop;
                        if (item.visible) {
                            target = lastPoint ? lastPoint.plotY : item.yAxis.height;
                            target += top - 0.3 * height
                        } else {
                            target = top + item.yAxis.height
                        }
                        boxes.push({
                            target: target,
                            size: height,
                            item
                        })
                    }
                }, this);
                let legendItem;
                for (const box of distribute(boxes, chart.plotHeight)) {
                    legendItem = box.item.legendItem || {};
                    if (isNumber(box.pos)) {
                        legendItem.y = chart.plotTop - chart.spacing[0] + box.pos
                    }
                }
            }
            render() {
                const legend = this
                    , chart = legend.chart
                    , renderer = chart.renderer
                    , options = legend.options
                    , padding = legend.padding
                    , allItems = legend.getAllItems();
                let display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
                legend.itemX = padding;
                legend.itemY = legend.initialItemY;
                legend.offsetWidth = 0;
                legend.lastItemY = 0;
                legend.widthOption = relativeLength(options.width, chart.spacingBox.width - padding);
                allowedWidth = chart.spacingBox.width - 2 * padding - options.x;
                if (['rm', 'lm'].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
                    allowedWidth /= 2
                }
                legend.maxLegendWidth = legend.widthOption || allowedWidth;
                if (!legendGroup) {
                    legend.group = legendGroup = renderer.g('legend').addClass(options.className || '').attr({
                        zIndex: 7
                    }).add();
                    legend.contentGroup = renderer.g().attr({
                        zIndex: 1
                    }).add(legendGroup);
                    legend.scrollGroup = renderer.g().add(legend.contentGroup)
                }
                legend.renderTitle();
                stableSort(allItems, (a, b) => ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0));
                if (options.reversed) {
                    allItems.reverse()
                }
                legend.allItems = allItems;
                legend.display = display = !!allItems.length;
                legend.lastLineHeight = 0;
                legend.maxItemWidth = 0;
                legend.totalItemWidth = 0;
                legend.itemHeight = 0;
                allItems.forEach(legend.renderItem, legend);
                allItems.forEach(legend.layoutItem, legend);
                legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
                legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
                legendHeight = legend.handleOverflow(legendHeight);
                legendHeight += padding;
                if (!box) {
                    legend.box = box = renderer.rect().addClass('highcharts-legend-box').attr({
                        r: options.borderRadius
                    }).add(legendGroup)
                }
                if (!chart.styledMode) {
                    box.attr({
                        stroke: options.borderColor,
                        'stroke-width': options.borderWidth || 0,
                        fill: options.backgroundColor || 'none'
                    }).shadow(options.shadow)
                }
                if (legendWidth > 0 && legendHeight > 0) {
                    box[box.placed ? 'animate' : 'attr'](box.crisp.call({}, {
                        x: 0,
                        y: 0,
                        width: legendWidth,
                        height: legendHeight
                    }, box.strokeWidth()))
                }
                legendGroup[display ? 'show' : 'hide']();
                if (chart.styledMode && legendGroup.getStyle('display') === 'none') {
                    legendWidth = legendHeight = 0
                }
                legend.legendWidth = legendWidth;
                legend.legendHeight = legendHeight;
                if (display) {
                    legend.align()
                }
                if (!this.proximate) {
                    this.positionItems()
                }
                fireEvent(this, 'afterRender')
            }
            align(alignTo=this.chart.spacingBox) {
                const chart = this.chart
                    , options = this.options;
                let y = alignTo.y;
                if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
                    y += chart.titleOffset[0]
                } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
                    y -= chart.titleOffset[2]
                }
                if (y !== alignTo.y) {
                    alignTo = merge(alignTo, {
                        y
                    })
                }
                if (!chart.hasRendered) {
                    this.group.placed = !1
                }
                this.group.align(merge(options, {
                    width: this.legendWidth,
                    height: this.legendHeight,
                    verticalAlign: this.proximate ? 'top' : options.verticalAlign
                }), !0, alignTo)
            }
            handleOverflow(legendHeight) {
                const legend = this
                    , chart = this.chart
                    , renderer = chart.renderer
                    , options = this.options
                    , optionsY = options.y
                    , alignTop = options.verticalAlign === 'top'
                    , padding = this.padding
                    , maxHeight = options.maxHeight
                    , navOptions = options.navigation
                    , animation = pick(navOptions.animation, !0)
                    , arrowSize = navOptions.arrowSize || 12
                    , pages = this.pages
                    , allItems = this.allItems
                    , clipToHeight = function(height) {
                    if (typeof height === 'number') {
                        clipRect.attr({
                            height: height
                        })
                    } else if (clipRect) {
                        legend.clipRect = clipRect.destroy();
                        legend.contentGroup.clip()
                    }
                    if (legend.contentGroup.div) {
                        legend.contentGroup.div.style.clip = height ? 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)' : 'auto'
                    }
                }
                    , addTracker = function(key) {
                    legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
                    if (!chart.styledMode) {
                        legend[key].attr('fill', 'rgba(0,0,0,0.0001)')
                    }
                    return legend[key]
                };
                let clipHeight, lastY, legendItem, spaceHeight = (chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding), nav = this.nav, clipRect = this.clipRect;
                if (options.layout === 'horizontal' && options.verticalAlign !== 'middle' && !options.floating) {
                    spaceHeight /= 2
                }
                if (maxHeight) {
                    spaceHeight = Math.min(spaceHeight, maxHeight)
                }
                pages.length = 0;
                if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== !1) {
                    this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
                    this.currentPage = pick(this.currentPage, 1);
                    this.fullHeight = legendHeight;
                    allItems.forEach( (item, i) => {
                            legendItem = item.legendItem || {};
                            const y = legendItem.y || 0
                                , h = Math.round(legendItem.label.getBBox().height);
                            let len = pages.length;
                            if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
                                pages.push(lastY || y);
                                len++
                            }
                            legendItem.pageIx = len - 1;
                            if (lastY) {
                                (allItems[i - 1].legendItem || {}).pageIx = len - 1
                            }
                            if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight && y > pages[len - 1]) {
                                pages.push(y);
                                legendItem.pageIx = len
                            }
                            if (y !== lastY) {
                                lastY = y
                            }
                        }
                    );
                    if (!clipRect) {
                        clipRect = legend.clipRect = renderer.clipRect(0, padding - 2, 9999, 0);
                        legend.contentGroup.clip(clipRect)
                    }
                    clipToHeight(clipHeight);
                    if (!nav) {
                        this.nav = nav = renderer.g().attr({
                            zIndex: 1
                        }).add(this.group);
                        this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize).add(nav);
                        addTracker('upTracker').on('click', function() {
                            legend.scroll(-1, animation)
                        });
                        this.pager = renderer.text('', 15, 10).addClass('highcharts-legend-navigation');
                        if (!chart.styledMode && navOptions.style) {
                            this.pager.css(navOptions.style)
                        }
                        this.pager.add(nav);
                        this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize).add(nav);
                        addTracker('downTracker').on('click', function() {
                            legend.scroll(1, animation)
                        })
                    }
                    legend.scroll(0);
                    legendHeight = spaceHeight
                } else if (nav) {
                    clipToHeight();
                    this.nav = nav.destroy();
                    this.scrollGroup.attr({
                        translateY: 1
                    });
                    this.clipHeight = 0
                }
                return legendHeight
            }
            scroll(scrollBy, animation) {
                const chart = this.chart
                    , pages = this.pages
                    , pageCount = pages.length
                    , clipHeight = this.clipHeight
                    , navOptions = this.options.navigation
                    , pager = this.pager
                    , padding = this.padding;
                let currentPage = this.currentPage + scrollBy;
                if (currentPage > pageCount) {
                    currentPage = pageCount
                }
                if (currentPage > 0) {
                    if (typeof animation !== 'undefined') {
                        setAnimation(animation, chart)
                    }
                    this.nav.attr({
                        translateX: padding,
                        translateY: clipHeight + this.padding + 7 + this.titleHeight,
                        visibility: 'inherit'
                    });
                    [this.up, this.upTracker].forEach(function(elem) {
                        elem.attr({
                            'class': currentPage === 1 ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
                        })
                    });
                    pager.attr({
                        text: currentPage + '/' + pageCount
                    });
                    [this.down, this.downTracker].forEach(function(elem) {
                        elem.attr({
                            x: 18 + this.pager.getBBox().width,
                            'class': currentPage === pageCount ? 'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'
                        })
                    }, this);
                    if (!chart.styledMode) {
                        this.up.attr({
                            fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
                        });
                        this.upTracker.css({
                            cursor: currentPage === 1 ? 'default' : 'pointer'
                        });
                        this.down.attr({
                            fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
                        });
                        this.downTracker.css({
                            cursor: currentPage === pageCount ? 'default' : 'pointer'
                        })
                    }
                    this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
                    this.scrollGroup.animate({
                        translateY: this.scrollOffset
                    });
                    this.currentPage = currentPage;
                    this.positionCheckboxes();
                    const animOptions = animObject(pick(animation, chart.renderer.globalAnimation, !0));
                    syncTimeout( () => {
                            fireEvent(this, 'afterScroll', {
                                currentPage
                            })
                        }
                        , animOptions.duration)
                }
            }
            setItemEvents(item, legendLabel, useHTML) {
                const legend = this
                    , legendItem = item.legendItem || {}
                    , boxWrapper = legend.chart.renderer.boxWrapper
                    , isPoint = item instanceof Point
                    , activeClass = 'highcharts-legend-' + (isPoint ? 'point' : 'series') + '-active'
                    , styledMode = legend.chart.styledMode
                    , legendElements = useHTML ? [legendLabel, legendItem.symbol] : [legendItem.group];
                const setOtherItemsState = (state) => {
                        legend.allItems.forEach( (otherItem) => {
                                if (item !== otherItem) {
                                    [otherItem].concat(otherItem.linkedSeries || []).forEach( (otherItem) => {
                                            otherItem.setState(state, !isPoint)
                                        }
                                    )
                                }
                            }
                        )
                    }
                ;
                for (const element of legendElements) {
                    if (element) {
                        element.on('mouseover', function() {
                            if (item.visible) {
                                setOtherItemsState('inactive')
                            }
                            item.setState('hover');
                            if (item.visible) {
                                boxWrapper.addClass(activeClass)
                            }
                            if (!styledMode) {
                                legendLabel.css(legend.options.itemHoverStyle)
                            }
                        }).on('mouseout', function() {
                            if (!legend.chart.styledMode) {
                                legendLabel.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle))
                            }
                            setOtherItemsState('');
                            boxWrapper.removeClass(activeClass);
                            item.setState()
                        }).on('click', function(event) {
                            const strLegendItemClick = 'legendItemClick'
                                , fnLegendItemClick = function() {
                                if (item.setVisible) {
                                    item.setVisible()
                                }
                                setOtherItemsState(item.visible ? 'inactive' : '')
                            };
                            boxWrapper.removeClass(activeClass);
                            event = {
                                browserEvent: event
                            };
                            if (item.firePointEvent) {
                                item.firePointEvent(strLegendItemClick, event, fnLegendItemClick)
                            } else {
                                fireEvent(item, strLegendItemClick, event, fnLegendItemClick)
                            }
                        })
                    }
                }
            }
            createCheckboxForItem(item) {
                const legend = this;
                item.checkbox = createElement('input', {
                    type: 'checkbox',
                    className: 'highcharts-legend-checkbox',
                    checked: item.selected,
                    defaultChecked: item.selected
                }, legend.options.itemCheckboxStyle, legend.chart.container);
                addEvent(item.checkbox, 'click', function(event) {
                    const target = event.target;
                    fireEvent(item.series || item, 'checkboxClick', {
                        checked: target.checked,
                        item: item
                    }, function() {
                        item.select()
                    })
                })
            }
        }
        (function(Legend) {
                const composedMembers = [];
                function compose(ChartClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        addEvent(ChartClass, 'beforeMargins', function() {
                            this.legend = new Legend(this,this.options.legend)
                        })
                    }
                }
                Legend.compose = compose
            }
        )(Legend || (Legend = {}));
        ('');
        return Legend
    });
    _registerModule(_modules, 'Core/Legend/LegendSymbol.js', [_modules['Core/Utilities.js']], function(U) {
        const {extend, merge, pick} = U;
        var LegendSymbol;
        (function(LegendSymbol) {
                function lineMarker(legend, item) {
                    const legendItem = this.legendItem = this.legendItem || {}
                        , options = this.options
                        , symbolWidth = legend.symbolWidth
                        , symbolHeight = legend.symbolHeight
                        , symbol = this.symbol || 'circle'
                        , generalRadius = symbolHeight / 2
                        , renderer = this.chart.renderer
                        , legendItemGroup = legendItem.group
                        , verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3);
                    let attr = {}, legendSymbol, markerOptions = options.marker, lineSizer = 0;
                    if (!this.chart.styledMode) {
                        attr = {
                            'stroke-width': Math.min(options.lineWidth || 0, 24)
                        };
                        if (options.dashStyle) {
                            attr.dashstyle = options.dashStyle
                        } else if (options.linecap !== 'square') {
                            attr['stroke-linecap'] = 'round'
                        }
                    }
                    legendItem.line = renderer.path().addClass('highcharts-graph').attr(attr).add(legendItemGroup);
                    if (attr['stroke-linecap']) {
                        lineSizer = Math.min(legendItem.line.strokeWidth(), symbolWidth) / 2
                    }
                    if (symbolWidth) {
                        legendItem.line.attr({
                            d: [['M', lineSizer, verticalCenter], ['L', symbolWidth - lineSizer, verticalCenter]]
                        })
                    }
                    if (markerOptions && markerOptions.enabled !== !1 && symbolWidth) {
                        let radius = Math.min(pick(markerOptions.radius, generalRadius), generalRadius);
                        if (symbol.indexOf('url') === 0) {
                            markerOptions = merge(markerOptions, {
                                width: symbolHeight,
                                height: symbolHeight
                            });
                            radius = 0
                        }
                        legendItem.symbol = legendSymbol = renderer.symbol(symbol, (symbolWidth / 2) - radius, verticalCenter - radius, 2 * radius, 2 * radius, extend({
                            context: 'legend'
                        }, markerOptions)).addClass('highcharts-point').add(legendItemGroup);
                        legendSymbol.isMarker = !0
                    }
                }
                LegendSymbol.lineMarker = lineMarker;
                function rectangle(legend, item) {
                    const legendItem = item.legendItem || {}
                        , options = legend.options
                        , symbolHeight = legend.symbolHeight
                        , square = options.squareSymbol
                        , symbolWidth = square ? symbolHeight : legend.symbolWidth;
                    legendItem.symbol = this.chart.renderer.rect(square ? (legend.symbolWidth - symbolHeight) / 2 : 0, legend.baseline - symbolHeight + 1, symbolWidth, symbolHeight, pick(legend.options.symbolRadius, symbolHeight / 2)).addClass('highcharts-point').attr({
                        zIndex: 3
                    }).add(legendItem.group)
                }
                LegendSymbol.rectangle = rectangle
            }
        )(LegendSymbol || (LegendSymbol = {}));
        return LegendSymbol
    });
    _registerModule(_modules, 'Core/Series/SeriesDefaults.js', [], function() {
        const seriesDefaults = {
            lineWidth: 2,
            allowPointSelect: !1,
            crisp: !0,
            showCheckbox: !1,
            animation: {
                duration: 1000
            },
            enableMouseTracking: !0,
            events: {},
            marker: {
                enabledThreshold: 2,
                lineColor: "#ffffff",
                lineWidth: 0,
                radius: 4,
                states: {
                    normal: {
                        animation: !0
                    },
                    hover: {
                        animation: {
                            duration: 150
                        },
                        enabled: !0,
                        radiusPlus: 2,
                        lineWidthPlus: 1
                    },
                    select: {
                        fillColor: "#cccccc",
                        lineColor: "#000000",
                        lineWidth: 2
                    }
                }
            },
            point: {
                events: {}
            },
            dataLabels: {
                animation: {},
                align: 'center',
                borderWidth: 0,
                defer: !0,
                formatter: function() {
                    const {numberFormatter} = this.series.chart;
                    return typeof this.y !== 'number' ? '' : numberFormatter(this.y, -1)
                },
                padding: 5,
                style: {
                    fontSize: '0.7em',
                    fontWeight: 'bold',
                    color: 'contrast',
                    textOutline: '1px contrast'
                },
                verticalAlign: 'bottom',
                x: 0,
                y: 0
            },
            cropThreshold: 300,
            opacity: 1,
            pointRange: 0,
            softThreshold: !0,
            states: {
                normal: {
                    animation: !0
                },
                hover: {
                    animation: {
                        duration: 150
                    },
                    lineWidthPlus: 1,
                    marker: {},
                    halo: {
                        size: 10,
                        opacity: 0.25
                    }
                },
                select: {
                    animation: {
                        duration: 0
                    }
                },
                inactive: {
                    animation: {
                        duration: 150
                    },
                    opacity: 0.2
                }
            },
            stickyTracking: !0,
            turboThreshold: 1000,
            findNearestPointBy: 'x'
        };
        return seriesDefaults
    });
    _registerModule(_modules, 'Core/Series/SeriesRegistry.js', [_modules['Core/Globals.js'], _modules['Core/Defaults.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function(H, D, Point, U) {
        const {defaultOptions} = D;
        const {extendClass, merge} = U;
        var SeriesRegistry;
        (function(SeriesRegistry) {
                SeriesRegistry.seriesTypes = H.seriesTypes;
                function registerSeriesType(seriesType, SeriesClass) {
                    const defaultPlotOptions = defaultOptions.plotOptions || {}
                        , seriesOptions = SeriesClass.defaultOptions
                        , seriesProto = SeriesClass.prototype;
                    seriesProto.type = seriesType;
                    if (!seriesProto.pointClass) {
                        seriesProto.pointClass = Point
                    }
                    if (seriesOptions) {
                        defaultPlotOptions[seriesType] = seriesOptions
                    }
                    SeriesRegistry.seriesTypes[seriesType] = SeriesClass
                }
                SeriesRegistry.registerSeriesType = registerSeriesType;
                function seriesType(type, parent, options, seriesProto, pointProto) {
                    const defaultPlotOptions = defaultOptions.plotOptions || {};
                    parent = parent || '';
                    defaultPlotOptions[type] = merge(defaultPlotOptions[parent], options);
                    registerSeriesType(type, extendClass(SeriesRegistry.seriesTypes[parent] || function() {}
                        , seriesProto));
                    SeriesRegistry.seriesTypes[type].prototype.type = type;
                    if (pointProto) {
                        SeriesRegistry.seriesTypes[type].prototype.pointClass = extendClass(Point, pointProto)
                    }
                    return SeriesRegistry.seriesTypes[type]
                }
                SeriesRegistry.seriesType = seriesType
            }
        )(SeriesRegistry || (SeriesRegistry = {}));
        return SeriesRegistry
    });
    _registerModule(_modules, 'Core/Series/Series.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Defaults.js'], _modules['Core/Foundation.js'], _modules['Core/Globals.js'], _modules['Core/Legend/LegendSymbol.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/SeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function(A, D, F, H, LegendSymbol, Point, SeriesDefaults, SeriesRegistry, SVGElement, U) {
        const {animObject, setAnimation} = A;
        const {defaultOptions} = D;
        const {registerEventOptions} = F;
        const {hasTouch, svg, win} = H;
        const {seriesTypes} = SeriesRegistry;
        const {addEvent, arrayMax, arrayMin, clamp, correctFloat, defined, diffObjects, erase, error, extend, find, fireEvent, getClosestDistance, getNestedProperty, insertItem, isArray, isNumber, isString, merge, objectEach, pick, removeEvent, splat, syncTimeout} = U;
        class Series {
            constructor() {
                this._i = void 0;
                this.chart = void 0;
                this.data = void 0;
                this.eventOptions = void 0;
                this.eventsToUnbind = void 0;
                this.index = void 0;
                this.linkedSeries = void 0;
                this.options = void 0;
                this.points = void 0;
                this.processedXData = void 0;
                this.processedYData = void 0;
                this.tooltipOptions = void 0;
                this.userOptions = void 0;
                this.xAxis = void 0;
                this.yAxis = void 0;
                this.zones = void 0
            }
            init(chart, userOptions) {
                fireEvent(this, 'init', {
                    options: userOptions
                });
                const series = this
                    , chartSeries = chart.series;
                this.eventsToUnbind = [];
                series.chart = chart;
                series.options = series.setOptions(userOptions);
                const options = series.options
                    , visible = options.visible !== !1;
                series.linkedSeries = [];
                series.bindAxes();
                extend(series, {
                    name: options.name,
                    state: '',
                    visible,
                    selected: options.selected === !0
                });
                registerEventOptions(this, options);
                const events = options.events;
                if ((events && events.click) || (options.point && options.point.events && options.point.events.click) || options.allowPointSelect) {
                    chart.runTrackerClick = !0
                }
                series.getColor();
                series.getSymbol();
                series.parallelArrays.forEach(function(key) {
                    if (!series[key + 'Data']) {
                        series[key + 'Data'] = []
                    }
                });
                if (series.isCartesian) {
                    chart.hasCartesianSeries = !0
                }
                let lastSeries;
                if (chartSeries.length) {
                    lastSeries = chartSeries[chartSeries.length - 1]
                }
                series._i = pick(lastSeries && lastSeries._i, -1) + 1;
                series.opacity = series.options.opacity;
                chart.orderItems('series', insertItem(this, chartSeries));
                if (options.dataSorting && options.dataSorting.enabled) {
                    series.setDataSortingOptions()
                } else if (!series.points && !series.data) {
                    series.setData(options.data, !1)
                }
                fireEvent(this, 'afterInit')
            }
            is(type) {
                return seriesTypes[type] && this instanceof seriesTypes[type]
            }
            bindAxes() {
                const series = this
                    , seriesOptions = series.options
                    , chart = series.chart;
                let axisOptions;
                fireEvent(this, 'bindAxes', null, function() {
                    (series.axisTypes || []).forEach(function(coll) {
                        chart[coll].forEach(function(axis) {
                            axisOptions = axis.options;
                            if (pick(seriesOptions[coll], 0) === axis.index || (typeof seriesOptions[coll] !== 'undefined' && seriesOptions[coll] === axisOptions.id)) {
                                insertItem(series, axis.series);
                                series[coll] = axis;
                                axis.isDirty = !0
                            }
                        });
                        if (!series[coll] && series.optionalAxis !== coll) {
                            error(18, !0, chart)
                        }
                    })
                });
                fireEvent(this, 'afterBindAxes')
            }
            updateParallelArrays(point, i, iArgs) {
                const series = point.series
                    , fn = isNumber(i) ? function(key) {
                            const val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
                            series[key + 'Data'][i] = val
                        }
                        : function(key) {
                            Array.prototype[i].apply(series[key + 'Data'], iArgs)
                        }
                ;
                series.parallelArrays.forEach(fn)
            }
            hasData() {
                return ((this.visible && typeof this.dataMax !== 'undefined' && typeof this.dataMin !== 'undefined') || (this.visible && this.yData && this.yData.length > 0))
            }
            hasMarkerChanged(options, oldOptions) {
                const series = this
                    , marker = options.marker
                    , oldMarker = oldOptions.marker || {};
                return marker && ((oldMarker.enabled && !marker.enabled) || oldMarker.symbol !== marker.symbol || oldMarker.height !== marker.height || oldMarker.width !== marker.width)
            }
            autoIncrement(x) {
                const options = this.options
                    , pointIntervalUnit = options.pointIntervalUnit
                    , relativeXValue = options.relativeXValue
                    , time = this.chart.time;
                let xIncrement = this.xIncrement, date, pointInterval;
                xIncrement = pick(xIncrement, options.pointStart, 0);
                this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
                if (relativeXValue && isNumber(x)) {
                    pointInterval *= x
                }
                if (pointIntervalUnit) {
                    date = new time.Date(xIncrement);
                    if (pointIntervalUnit === 'day') {
                        time.set('Date', date, time.get('Date', date) + pointInterval)
                    } else if (pointIntervalUnit === 'month') {
                        time.set('Month', date, time.get('Month', date) + pointInterval)
                    } else if (pointIntervalUnit === 'year') {
                        time.set('FullYear', date, time.get('FullYear', date) + pointInterval)
                    }
                    pointInterval = date.getTime() - xIncrement
                }
                if (relativeXValue && isNumber(x)) {
                    return xIncrement + pointInterval
                }
                this.xIncrement = xIncrement + pointInterval;
                return xIncrement
            }
            setDataSortingOptions() {
                const options = this.options;
                extend(this, {
                    requireSorting: !1,
                    sorted: !1,
                    enabledDataSorting: !0,
                    allowDG: !1
                });
                if (!defined(options.pointRange)) {
                    options.pointRange = 1
                }
            }
            setOptions(itemOptions) {
                const chart = this.chart
                    , chartOptions = chart.options
                    , plotOptions = chartOptions.plotOptions
                    , userOptions = chart.userOptions || {}
                    , seriesUserOptions = merge(itemOptions)
                    , styledMode = chart.styledMode
                    , e = {
                    plotOptions: plotOptions,
                    userOptions: seriesUserOptions
                };
                let zone;
                fireEvent(this, 'setOptions', e);
                const typeOptions = e.plotOptions[this.type]
                    , userPlotOptions = (userOptions.plotOptions || {})
                    , userPlotOptionsSeries = userPlotOptions.series || {}
                    , defaultPlotOptionsType = (defaultOptions.plotOptions[this.type] || {})
                    , userPlotOptionsType = userPlotOptions[this.type] || {};
                this.userOptions = e.userOptions;
                const options = merge(typeOptions, plotOptions.series, userPlotOptionsType, seriesUserOptions);
                this.tooltipOptions = merge(defaultOptions.tooltip, defaultOptions.plotOptions.series?.tooltip, defaultPlotOptionsType?.tooltip, chart.userOptions.tooltip, userPlotOptions.series?.tooltip, userPlotOptionsType.tooltip, seriesUserOptions.tooltip);
                this.stickyTracking = pick(seriesUserOptions.stickyTracking, userPlotOptionsType.stickyTracking, userPlotOptionsSeries.stickyTracking, (this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : options.stickyTracking));
                if (typeOptions.marker === null) {
                    delete options.marker
                }
                this.zoneAxis = options.zoneAxis;
                const zones = this.zones = (options.zones || []).slice();
                if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
                    zone = {
                        value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
                        className: 'highcharts-negative'
                    };
                    if (!styledMode) {
                        zone.color = options.negativeColor;
                        zone.fillColor = options.negativeFillColor
                    }
                    zones.push(zone)
                }
                if (zones.length) {
                    if (defined(zones[zones.length - 1].value)) {
                        zones.push(styledMode ? {} : {
                            color: this.color,
                            fillColor: this.fillColor
                        })
                    }
                }
                fireEvent(this, 'afterSetOptions', {
                    options: options
                });
                return options
            }
            getName() {
                return pick(this.options.name, 'Series ' + (this.index + 1))
            }
            getCyclic(prop, value, defaults) {
                const chart = this.chart
                    , indexName = `${prop}Index`
                    , counterName = `${prop}Counter`
                    , len = (defaults?.length || chart.options.chart.colorCount);
                let i, setting;
                if (!value) {
                    setting = pick(prop === 'color' ? this.options.colorIndex : void 0, this[indexName]);
                    if (defined(setting)) {
                        i = setting
                    } else {
                        if (!chart.series.length) {
                            chart[counterName] = 0
                        }
                        i = chart[counterName] % len;
                        chart[counterName] += 1
                    }
                    if (defaults) {
                        value = defaults[i]
                    }
                }
                if (typeof i !== 'undefined') {
                    this[indexName] = i
                }
                this[prop] = value
            }
            getColor() {
                if (this.chart.styledMode) {
                    this.getCyclic('color')
                } else if (this.options.colorByPoint) {
                    this.color = "#cccccc"
                } else {
                    this.getCyclic('color', this.options.color || defaultOptions.plotOptions[this.type].color, this.chart.options.colors)
                }
            }
            getPointsCollection() {
                return (this.hasGroupedData ? this.points : this.data) || []
            }
            getSymbol() {
                const seriesMarkerOption = this.options.marker;
                this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols)
            }
            findPointIndex(optionsObject, fromIndex) {
                const id = optionsObject.id
                    , x = optionsObject.x
                    , oldData = this.points
                    , dataSorting = this.options.dataSorting;
                let matchingPoint, matchedById, pointIndex;
                if (id) {
                    const item = this.chart.get(id);
                    if (item instanceof Point) {
                        matchingPoint = item
                    }
                } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
                    let matcher = (oldPoint) => !oldPoint.touched && oldPoint.index === optionsObject.index;
                    if (dataSorting && dataSorting.matchByName) {
                        matcher = (oldPoint) => !oldPoint.touched && oldPoint.name === optionsObject.name
                    } else if (this.options.relativeXValue) {
                        matcher = (oldPoint) => !oldPoint.touched && oldPoint.options.x === optionsObject.x
                    }
                    matchingPoint = find(oldData, matcher);
                    if (!matchingPoint) {
                        return void 0
                    }
                }
                if (matchingPoint) {
                    pointIndex = matchingPoint && matchingPoint.index;
                    if (typeof pointIndex !== 'undefined') {
                        matchedById = !0
                    }
                }
                if (typeof pointIndex === 'undefined' && isNumber(x)) {
                    pointIndex = this.xData.indexOf(x, fromIndex)
                }
                if (pointIndex !== -1 && typeof pointIndex !== 'undefined' && this.cropped) {
                    pointIndex = (pointIndex >= this.cropStart) ? pointIndex - this.cropStart : pointIndex
                }
                if (!matchedById && isNumber(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {
                    pointIndex = void 0
                }
                return pointIndex
            }
            updateData(data, animation) {
                const options = this.options
                    , dataSorting = options.dataSorting
                    , oldData = this.points
                    , pointsToAdd = []
                    , requireSorting = this.requireSorting
                    , equalLength = data.length === oldData.length;
                let hasUpdatedByKey, i, point, lastIndex, succeeded = !0;
                this.xIncrement = null;
                data.forEach(function(pointOptions, i) {
                    const optionsObject = (defined(pointOptions) && this.pointClass.prototype.optionsToObject.call({
                        series: this
                    }, pointOptions)) || {};
                    let pointIndex;
                    const x = optionsObject.x
                        , id = optionsObject.id;
                    if (id || isNumber(x)) {
                        pointIndex = this.findPointIndex(optionsObject, lastIndex);
                        if (pointIndex === -1 || typeof pointIndex === 'undefined') {
                            pointsToAdd.push(pointOptions)
                        } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {
                            oldData[pointIndex].update(pointOptions, !1, null, !1);
                            oldData[pointIndex].touched = !0;
                            if (requireSorting) {
                                lastIndex = pointIndex + 1
                            }
                        } else if (oldData[pointIndex]) {
                            oldData[pointIndex].touched = !0
                        }
                        if (!equalLength || i !== pointIndex || (dataSorting && dataSorting.enabled) || this.hasDerivedData) {
                            hasUpdatedByKey = !0
                        }
                    } else {
                        pointsToAdd.push(pointOptions)
                    }
                }, this);
                if (hasUpdatedByKey) {
                    i = oldData.length;
                    while (i--) {
                        point = oldData[i];
                        if (point && !point.touched && point.remove) {
                            point.remove(!1, animation)
                        }
                    }
                } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
                    data.forEach(function(point, i) {
                        if (point !== oldData[i].y && !oldData[i].destroyed) {
                            oldData[i].update(point, !1, null, !1)
                        }
                    });
                    pointsToAdd.length = 0
                } else {
                    succeeded = !1
                }
                oldData.forEach(function(point) {
                    if (point) {
                        point.touched = !1
                    }
                });
                if (!succeeded) {
                    return !1
                }
                pointsToAdd.forEach(function(point) {
                    this.addPoint(point, !1, null, null, !1)
                }, this);
                if (this.xIncrement === null && this.xData && this.xData.length) {
                    this.xIncrement = arrayMax(this.xData);
                    this.autoIncrement()
                }
                return !0
            }
            setData(data, redraw=!0, animation, updatePoints) {
                const series = this
                    , oldData = series.points
                    , oldDataLength = (oldData && oldData.length) || 0
                    , options = series.options
                    , chart = series.chart
                    , dataSorting = options.dataSorting
                    , xAxis = series.xAxis
                    , turboThreshold = options.turboThreshold
                    , xData = this.xData
                    , yData = this.yData
                    , pointArrayMap = series.pointArrayMap
                    , valueCount = pointArrayMap && pointArrayMap.length
                    , keys = options.keys;
                let i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null, copiedData;
                if (!chart.options.chart.allowMutatingData) {
                    if (options.data) {
                        delete series.options.data
                    }
                    if (series.userOptions.data) {
                        delete series.userOptions.data
                    }
                    copiedData = merge(!0, data)
                }
                data = copiedData || data || [];
                const dataLength = data.length;
                if (dataSorting && dataSorting.enabled) {
                    data = this.sortData(data)
                }
                if (chart.options.chart.allowMutatingData && updatePoints !== !1 && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && !series.boosted) {
                    updatedData = this.updateData(data, animation)
                }
                if (!updatedData) {
                    series.xIncrement = null;
                    series.colorCounter = 0;
                    this.parallelArrays.forEach(function(key) {
                        series[key + 'Data'].length = 0
                    });
                    if (turboThreshold && dataLength > turboThreshold) {
                        firstPoint = series.getFirstValidPoint(data);
                        if (isNumber(firstPoint)) {
                            for (i = 0; i < dataLength; i++) {
                                xData[i] = this.autoIncrement();
                                yData[i] = data[i]
                            }
                        } else if (isArray(firstPoint)) {
                            if (valueCount) {
                                if (firstPoint.length === valueCount) {
                                    for (i = 0; i < dataLength; i++) {
                                        xData[i] = this.autoIncrement();
                                        yData[i] = data[i]
                                    }
                                } else {
                                    for (i = 0; i < dataLength; i++) {
                                        pt = data[i];
                                        xData[i] = pt[0];
                                        yData[i] = pt.slice(1, valueCount + 1)
                                    }
                                }
                            } else {
                                if (keys) {
                                    indexOfX = keys.indexOf('x');
                                    indexOfY = keys.indexOf('y');
                                    indexOfX = indexOfX >= 0 ? indexOfX : 0;
                                    indexOfY = indexOfY >= 0 ? indexOfY : 1
                                }
                                if (firstPoint.length === 1) {
                                    indexOfY = 0
                                }
                                if (indexOfX === indexOfY) {
                                    for (i = 0; i < dataLength; i++) {
                                        xData[i] = this.autoIncrement();
                                        yData[i] = data[i][indexOfY]
                                    }
                                } else {
                                    for (i = 0; i < dataLength; i++) {
                                        pt = data[i];
                                        xData[i] = pt[indexOfX];
                                        yData[i] = pt[indexOfY]
                                    }
                                }
                            }
                        } else {
                            error(12, !1, chart)
                        }
                    } else {
                        for (i = 0; i < dataLength; i++) {
                            pt = {
                                series: series
                            };
                            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                            series.updateParallelArrays(pt, i)
                        }
                    }
                    if (yData && isString(yData[0])) {
                        error(14, !0, chart)
                    }
                    series.data = [];
                    series.options.data = series.userOptions.data = data;
                    i = oldDataLength;
                    while (i--) {
                        oldData[i]?.destroy()
                    }
                    if (xAxis) {
                        xAxis.minRange = xAxis.userMinRange
                    }
                    series.isDirty = chart.isDirtyBox = !0;
                    series.isDirtyData = !!oldData;
                    animation = !1
                }
                if (options.legendType === 'point') {
                    this.processData();
                    this.generatePoints()
                }
                if (redraw) {
                    chart.redraw(animation)
                }
            }
            sortData(data) {
                const series = this
                    , options = series.options
                    , dataSorting = options.dataSorting
                    , sortKey = dataSorting.sortKey || 'y'
                    , getPointOptionsObject = function(series, pointOptions) {
                    return (defined(pointOptions) && series.pointClass.prototype.optionsToObject.call({
                        series: series
                    }, pointOptions)) || {}
                };
                data.forEach(function(pointOptions, i) {
                    data[i] = getPointOptionsObject(series, pointOptions);
                    data[i].index = i
                }, this);
                const sortedData = data.concat().sort( (a, b) => {
                        const aValue = getNestedProperty(sortKey, a);
                        const bValue = getNestedProperty(sortKey, b);
                        return bValue < aValue ? -1 : bValue > aValue ? 1 : 0
                    }
                );
                sortedData.forEach(function(point, i) {
                    point.x = i
                }, this);
                if (series.linkedSeries) {
                    series.linkedSeries.forEach(function(linkedSeries) {
                        const options = linkedSeries.options
                            , seriesData = options.data;
                        if ((!options.dataSorting || !options.dataSorting.enabled) && seriesData) {
                            seriesData.forEach(function(pointOptions, i) {
                                seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
                                if (data[i]) {
                                    seriesData[i].x = data[i].x;
                                    seriesData[i].index = i
                                }
                            });
                            linkedSeries.setData(seriesData, !1)
                        }
                    })
                }
                return data
            }
            getProcessedData(forceExtremesFromAll) {
                const series = this
                    , xAxis = series.xAxis
                    , options = series.options
                    , cropThreshold = options.cropThreshold
                    , getExtremesFromAll = forceExtremesFromAll || series.getExtremesFromAll || options.getExtremesFromAll
                    , logarithmic = xAxis?.logarithmic
                    , isCartesian = series.isCartesian;
                let croppedData, cropped, cropStart = 0, xExtremes, min, max, processedXData = series.xData, processedYData = series.yData, updatingNames = !1;
                const dataLength = processedXData.length;
                if (xAxis) {
                    xExtremes = xAxis.getExtremes();
                    min = xExtremes.min;
                    max = xExtremes.max;
                    updatingNames = !!(xAxis.categories && !xAxis.names.length)
                }
                if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
                    if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
                        processedXData = [];
                        processedYData = []
                    } else if (series.yData && (processedXData[0] < min || processedXData[dataLength - 1] > max)) {
                        croppedData = this.cropData(series.xData, series.yData, min, max);
                        processedXData = croppedData.xData;
                        processedYData = croppedData.yData;
                        cropStart = croppedData.start;
                        cropped = !0
                    }
                }
                const closestPointRange = getClosestDistance([logarithmic ? processedXData.map(logarithmic.log2lin) : processedXData], () => (series.requireSorting && !updatingNames && error(15, !1, series.chart)));
                return {
                    xData: processedXData,
                    yData: processedYData,
                    cropped: cropped,
                    cropStart: cropStart,
                    closestPointRange: closestPointRange
                }
            }
            processData(force) {
                const series = this
                    , xAxis = series.xAxis;
                if (series.isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
                    return !1
                }
                const processedData = series.getProcessedData();
                series.cropped = processedData.cropped;
                series.cropStart = processedData.cropStart;
                series.processedXData = processedData.xData;
                series.processedYData = processedData.yData;
                series.closestPointRange = (series.basePointRange = processedData.closestPointRange);
                fireEvent(series, 'afterProcessData')
            }
            cropData(xData, yData, min, max) {
                const dataLength = xData.length;
                let i, j, start = 0, end = dataLength;
                for (i = 0; i < dataLength; i++) {
                    if (xData[i] >= min) {
                        start = Math.max(0, i - 1);
                        break
                    }
                }
                for (j = i; j < dataLength; j++) {
                    if (xData[j] > max) {
                        end = j + 1;
                        break
                    }
                }
                return {
                    xData: xData.slice(start, end),
                    yData: yData.slice(start, end),
                    start,
                    end
                }
            }
            generatePoints() {
                const series = this
                    , options = series.options
                    , dataOptions = (series.processedData || options.data)
                    , processedXData = series.processedXData
                    , processedYData = series.processedYData
                    , PointClass = series.pointClass
                    , processedDataLength = processedXData.length
                    , cropStart = series.cropStart || 0
                    , hasGroupedData = series.hasGroupedData
                    , keys = options.keys
                    , points = []
                    , groupCropStartIndex = (options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0);
                let dataLength, cursor, point, i, data = series.data;
                if (!data && !hasGroupedData) {
                    const arr = [];
                    arr.length = dataOptions.length;
                    data = series.data = arr
                }
                if (keys && hasGroupedData) {
                    series.options.keys = !1
                }
                for (i = 0; i < processedDataLength; i++) {
                    cursor = cropStart + i;
                    if (!hasGroupedData) {
                        point = data[cursor];
                        if (!point && typeof dataOptions[cursor] !== 'undefined') {
                            data[cursor] = point = (new PointClass()).init(series, dataOptions[cursor], processedXData[i])
                        }
                    } else {
                        point = (new PointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
                        point.dataGroup = series.groupMap[groupCropStartIndex + i];
                        if (point.dataGroup.options) {
                            point.options = point.dataGroup.options;
                            extend(point, point.dataGroup.options);
                            delete point.dataLabels
                        }
                    }
                    if (point) {
                        point.index = hasGroupedData ? (groupCropStartIndex + i) : cursor;
                        points[i] = point
                    }
                }
                series.options.keys = keys;
                if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                    for (i = 0; i < dataLength; i++) {
                        if (i === cropStart && !hasGroupedData) {
                            i += processedDataLength
                        }
                        if (data[i]) {
                            data[i].destroyElements();
                            data[i].plotX = void 0
                        }
                    }
                }
                series.data = data;
                series.points = points;
                fireEvent(this, 'afterGeneratePoints')
            }
            getXExtremes(xData) {
                return {
                    min: arrayMin(xData),
                    max: arrayMax(xData)
                }
            }
            getExtremes(yData, forceExtremesFromAll) {
                const xAxis = this.xAxis
                    , yAxis = this.yAxis
                    , xData = this.processedXData || this.xData
                    , activeYData = []
                    , shoulder = this.requireSorting && !this.is('column') ? 1 : 0
                    , positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : !1;
                let xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
                yData = yData || this.stackedYData || this.processedYData || [];
                const yDataLength = yData.length;
                if (xAxis) {
                    xExtremes = xAxis.getExtremes();
                    xMin = xExtremes.min;
                    xMax = xExtremes.max
                }
                for (i = 0; i < yDataLength; i++) {
                    x = xData[i];
                    y = yData[i];
                    validValue = ((isNumber(y) || isArray(y)) && ((isNumber(y) ? y > 0 : y.length) || !positiveValuesOnly));
                    withinRange = (forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis || ((xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax));
                    if (validValue && withinRange) {
                        j = y.length;
                        if (j) {
                            while (j--) {
                                if (isNumber(y[j])) {
                                    activeYData[activeCounter++] = y[j]
                                }
                            }
                        } else {
                            activeYData[activeCounter++] = y
                        }
                    }
                }
                const dataExtremes = {
                    activeYData,
                    dataMin: arrayMin(activeYData),
                    dataMax: arrayMax(activeYData)
                };
                fireEvent(this, 'afterGetExtremes', {
                    dataExtremes
                });
                return dataExtremes
            }
            applyExtremes() {
                const dataExtremes = this.getExtremes();
                this.dataMin = dataExtremes.dataMin;
                this.dataMax = dataExtremes.dataMax;
                return dataExtremes
            }
            getFirstValidPoint(data) {
                const dataLength = data.length;
                let i = 0
                    , firstPoint = null;
                while (firstPoint === null && i < dataLength) {
                    firstPoint = data[i];
                    i++
                }
                return firstPoint
            }
            translate() {
                if (!this.processedXData) {
                    this.processData()
                }
                this.generatePoints();
                const series = this
                    , options = series.options
                    , stacking = options.stacking
                    , xAxis = series.xAxis
                    , categories = xAxis.categories
                    , enabledDataSorting = series.enabledDataSorting
                    , yAxis = series.yAxis
                    , points = series.points
                    , dataLength = points.length
                    , pointPlacement = series.pointPlacementToXValue()
                    , dynamicallyPlaced = Boolean(pointPlacement)
                    , threshold = options.threshold
                    , stackThreshold = options.startFromThreshold ? threshold : 0;
                let i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
                function limitedRange(val) {
                    return clamp(val, -1e5, 1e5)
                }
                for (i = 0; i < dataLength; i++) {
                    const point = points[i]
                        , xValue = point.x;
                    let stackItem, stackValues, yValue = point.y, lowValue = point.low;
                    const stacks = stacking && yAxis.stacking?.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey];
                    plotX = xAxis.translate(xValue, !1, !1, !1, !0, pointPlacement);
                    point.plotX = isNumber(plotX) ? correctFloat(limitedRange(plotX)) : void 0;
                    if (stacking && series.visible && stacks && stacks[xValue]) {
                        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
                        if (!point.isNull && stackIndicator.key) {
                            stackItem = stacks[xValue];
                            stackValues = stackItem.points[stackIndicator.key]
                        }
                        if (stackItem && isArray(stackValues)) {
                            lowValue = stackValues[0];
                            yValue = stackValues[1];
                            if (lowValue === stackThreshold && stackIndicator.key === stacks[xValue].base) {
                                lowValue = pick(isNumber(threshold) ? threshold : yAxis.min)
                            }
                            if (yAxis.positiveValuesOnly && defined(lowValue) && lowValue <= 0) {
                                lowValue = void 0
                            }
                            point.total = point.stackTotal = pick(stackItem.total);
                            point.percentage = defined(point.y) && stackItem.total ? (point.y / stackItem.total * 100) : void 0;
                            point.stackY = yValue;
                            if (!series.irregularWidths) {
                                stackItem.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis)
                            }
                        }
                    }
                    point.yBottom = defined(lowValue) ? limitedRange(yAxis.translate(lowValue, !1, !0, !1, !0)) : void 0;
                    if (series.dataModify) {
                        yValue = series.dataModify.modifyValue(yValue, i)
                    }
                    let plotY;
                    if (isNumber(yValue) && point.plotX !== void 0) {
                        plotY = yAxis.translate(yValue, !1, !0, !1, !0);
                        plotY = isNumber(plotY) ? limitedRange(plotY) : void 0
                    }
                    point.plotY = plotY;
                    point.isInside = this.isPointInside(point);
                    point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, !1, !1, !1, !0, pointPlacement)) : plotX;
                    point.negative = (point.y || 0) < (threshold || 0);
                    point.category = pick(categories && categories[point.x], point.x);
                    if (!point.isNull && point.visible !== !1) {
                        if (typeof lastPlotX !== 'undefined') {
                            closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX))
                        }
                        lastPlotX = plotX
                    }
                    point.zone = this.zones.length ? point.getZone() : void 0;
                    if (!point.graphic && series.group && enabledDataSorting) {
                        point.isNew = !0
                    }
                }
                series.closestPointRangePx = closestPointRangePx;
                fireEvent(this, 'afterTranslate')
            }
            getValidPoints(points, insideOnly, allowNull) {
                const chart = this.chart;
                return (points || this.points || []).filter(function(point) {
                    const {plotX, plotY} = point
                        , asNull = !allowNull && (point.isNull || !isNumber(plotY));
                    if (asNull || (insideOnly && !chart.isInsidePlot(plotX, plotY, {
                        inverted: chart.inverted
                    }))) {
                        return !1
                    }
                    return point.visible !== !1
                })
            }
            getClipBox() {
                const {chart, xAxis, yAxis} = this;
                const seriesBox = merge(chart.clipBox);
                if (xAxis && xAxis.len !== chart.plotSizeX) {
                    seriesBox.width = xAxis.len
                }
                if (yAxis && yAxis.len !== chart.plotSizeY) {
                    seriesBox.height = yAxis.len
                }
                return seriesBox
            }
            getSharedClipKey() {
                this.sharedClipKey = (this.options.xAxis || 0) + ',' + (this.options.yAxis || 0);
                return this.sharedClipKey
            }
            setClip() {
                const {chart, group, markerGroup} = this
                    , sharedClips = chart.sharedClips
                    , renderer = chart.renderer
                    , clipBox = this.getClipBox()
                    , sharedClipKey = this.getSharedClipKey();
                let clipRect = sharedClips[sharedClipKey];
                if (!clipRect) {
                    sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox)
                } else {
                    clipRect.animate(clipBox)
                }
                if (group) {
                    group.clip(this.options.clip === !1 ? void 0 : clipRect)
                }
                if (markerGroup) {
                    markerGroup.clip()
                }
            }
            animate(init) {
                const {chart, group, markerGroup} = this
                    , inverted = chart.inverted
                    , animation = animObject(this.options.animation)
                    , animationClipKey = [this.getSharedClipKey(), animation.duration, animation.easing, animation.defer].join(',');
                let animationClipRect = chart.sharedClips[animationClipKey]
                    , markerAnimationClipRect = chart.sharedClips[animationClipKey + 'm'];
                if (init && group) {
                    const clipBox = this.getClipBox();
                    if (!animationClipRect) {
                        clipBox.width = 0;
                        if (inverted) {
                            clipBox.x = chart.plotHeight
                        }
                        animationClipRect = chart.renderer.clipRect(clipBox);
                        chart.sharedClips[animationClipKey] = animationClipRect;
                        const markerClipBox = {
                            x: inverted ? -99 : -99,
                            y: inverted ? -99 : -99,
                            width: inverted ? chart.plotWidth + 199 : 99,
                            height: inverted ? 99 : chart.plotHeight + 199
                        };
                        markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);
                        chart.sharedClips[animationClipKey + 'm'] = markerAnimationClipRect
                    } else {
                        animationClipRect.attr('height', clipBox.height)
                    }
                    group.clip(animationClipRect);
                    if (markerGroup) {
                        markerGroup.clip(markerAnimationClipRect)
                    }
                } else if (animationClipRect && !animationClipRect.hasClass('highcharts-animating')) {
                    const finalBox = this.getClipBox()
                        , step = animation.step;
                    if (markerGroup && markerGroup.element.childNodes.length) {
                        animation.step = function(val, fx) {
                            if (step) {
                                step.apply(fx, arguments)
                            }
                            if (fx.prop === 'width' && markerAnimationClipRect && markerAnimationClipRect.element) {
                                markerAnimationClipRect.attr(inverted ? 'height' : 'width', val + 99)
                            }
                        }
                    }
                    animationClipRect.addClass('highcharts-animating').animate(finalBox, animation)
                }
            }
            afterAnimate() {
                this.setClip();
                objectEach(this.chart.sharedClips, (clip, key, sharedClips) => {
                        if (clip && !this.chart.container.querySelector(`[clip-path="url(#${clip.id})"]`)) {
                            clip.destroy();
                            delete sharedClips[key]
                        }
                    }
                );
                this.finishedAnimating = !0;
                fireEvent(this, 'afterAnimate')
            }
            drawPoints(points=this.points) {
                const series = this
                    , chart = series.chart
                    , styledMode = chart.styledMode
                    , {colorAxis, options} = series
                    , seriesMarkerOptions = options.marker
                    , markerGroup = series[series.specialGroup || 'markerGroup']
                    , xAxis = series.xAxis
                    , globallyEnabled = pick(seriesMarkerOptions.enabled, !xAxis || xAxis.isRadial ? !0 : null, series.closestPointRangePx >= (seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius));
                let i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
                if (seriesMarkerOptions.enabled !== !1 || series._hasPointMarkers) {
                    for (i = 0; i < points.length; i++) {
                        point = points[i];
                        graphic = point.graphic;
                        verb = graphic ? 'animate' : 'attr';
                        pointMarkerOptions = point.marker || {};
                        hasPointMarker = !!point.marker;
                        const shouldDrawMarker = ((globallyEnabled && typeof pointMarkerOptions.enabled === 'undefined') || pointMarkerOptions.enabled) && !point.isNull && point.visible !== !1;
                        if (shouldDrawMarker) {
                            const symbol = pick(pointMarkerOptions.symbol, series.symbol, 'rect');
                            markerAttribs = series.markerAttribs(point, (point.selected && 'select'));
                            if (series.enabledDataSorting) {
                                point.startXPos = xAxis.reversed ? -(markerAttribs.width || 0) : xAxis.width
                            }
                            const isInside = point.isInside !== !1;
                            if (!graphic && isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
                                point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
                                if (series.enabledDataSorting && chart.hasRendered) {
                                    graphic.attr({
                                        x: point.startXPos
                                    });
                                    verb = 'animate'
                                }
                            }
                            if (graphic && verb === 'animate') {
                                graphic[isInside ? 'show' : 'hide'](isInside).animate(markerAttribs)
                            }
                            if (graphic) {
                                const pointAttr = series.pointAttribs(point, ((styledMode || !point.selected) ? void 0 : 'select'));
                                if (!styledMode) {
                                    graphic[verb](pointAttr)
                                } else if (colorAxis) {
                                    graphic.css({
                                        fill: pointAttr.fill
                                    })
                                }
                            }
                            if (graphic) {
                                graphic.addClass(point.getClassName(), !0)
                            }
                        } else if (graphic) {
                            point.graphic = graphic.destroy()
                        }
                    }
                }
            }
            markerAttribs(point, state) {
                const seriesOptions = this.options
                    , seriesMarkerOptions = seriesOptions.marker
                    , pointMarkerOptions = point.marker || {}
                    , symbol = (pointMarkerOptions.symbol || seriesMarkerOptions.symbol)
                    , attribs = {};
                let seriesStateOptions, pointStateOptions, radius = pick(pointMarkerOptions.radius, seriesMarkerOptions && seriesMarkerOptions.radius);
                if (state) {
                    seriesStateOptions = seriesMarkerOptions.states[state];
                    pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
                    radius = pick(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0))
                }
                point.hasImage = symbol && symbol.indexOf('url') === 0;
                if (point.hasImage) {
                    radius = 0
                }
                const pos = point.pos();
                if (isNumber(radius) && pos) {
                    attribs.x = pos[0] - radius;
                    attribs.y = pos[1] - radius;
                    if (seriesOptions.crisp) {
                        attribs.x = Math.floor(attribs.x)
                    }
                }
                if (radius) {
                    attribs.width = attribs.height = 2 * radius
                }
                return attribs
            }
            pointAttribs(point, state) {
                const seriesMarkerOptions = this.options.marker
                    , pointOptions = point && point.options
                    , pointMarkerOptions = ((pointOptions && pointOptions.marker) || {})
                    , pointColorOption = pointOptions && pointOptions.color
                    , pointColor = point && point.color
                    , zoneColor = point && point.zone && point.zone.color;
                let seriesStateOptions, pointStateOptions, color = this.color, fill, stroke, strokeWidth = pick(pointMarkerOptions.lineWidth, seriesMarkerOptions.lineWidth), opacity = 1;
                color = (pointColorOption || zoneColor || pointColor || color);
                fill = (pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color);
                stroke = (pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color);
                state = state || 'normal';
                if (state) {
                    seriesStateOptions = (seriesMarkerOptions.states[state] || {});
                    pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};
                    strokeWidth = pick(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
                    fill = (pointStateOptions.fillColor || seriesStateOptions.fillColor || fill);
                    stroke = (pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke);
                    opacity = pick(pointStateOptions.opacity, seriesStateOptions.opacity, opacity)
                }
                return {
                    'stroke': stroke,
                    'stroke-width': strokeWidth,
                    'fill': fill,
                    'opacity': opacity
                }
            }
            destroy(keepEventsForUpdate) {
                const series = this
                    , chart = series.chart
                    , issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent)
                    , data = series.data || [];
                let destroy, i, point, axis;
                fireEvent(series, 'destroy', {
                    keepEventsForUpdate
                });
                this.removeEvents(keepEventsForUpdate);
                (series.axisTypes || []).forEach(function(AXIS) {
                    axis = series[AXIS];
                    if (axis && axis.series) {
                        erase(axis.series, series);
                        axis.isDirty = axis.forceRedraw = !0
                    }
                });
                if (series.legendItem) {
                    series.chart.legend.destroyItem(series)
                }
                i = data.length;
                while (i--) {
                    point = data[i];
                    if (point && point.destroy) {
                        point.destroy()
                    }
                }
                if (series.clips) {
                    series.clips.forEach( (clip) => clip.destroy())
                }
                U.clearTimeout(series.animationTimeout);
                objectEach(series, function(val, prop) {
                    if (val instanceof SVGElement && !val.survive) {
                        destroy = issue134 && prop === 'group' ? 'hide' : 'destroy';
                        val[destroy]()
                    }
                });
                if (chart.hoverSeries === series) {
                    chart.hoverSeries = void 0
                }
                erase(chart.series, series);
                chart.orderItems('series');
                objectEach(series, function(val, prop) {
                    if (!keepEventsForUpdate || prop !== 'hcEvents') {
                        delete series[prop]
                    }
                })
            }
            applyZones() {
                const series = this
                    , chart = this.chart
                    , renderer = chart.renderer
                    , zones = this.zones
                    , clips = (this.clips || [])
                    , graph = this.graph
                    , area = this.area
                    , plotSizeMax = Math.max(chart.plotWidth, chart.plotHeight)
                    , axis = this[(this.zoneAxis || 'y') + 'Axis']
                    , inverted = chart.inverted;
                let translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = !1;
                if (zones.length && (graph || area) && axis && typeof axis.min !== 'undefined') {
                    reversed = axis.reversed;
                    horiz = axis.horiz;
                    if (graph && !this.showLine) {
                        graph.hide()
                    }
                    if (area) {
                        area.hide()
                    }
                    extremes = axis.getExtremes();
                    zones.forEach(function(threshold, i) {
                        translatedFrom = reversed ? (horiz ? chart.plotWidth : 0) : (horiz ? 0 : (axis.toPixels(extremes.min) || 0));
                        translatedFrom = clamp(pick(translatedTo, translatedFrom), 0, plotSizeMax);
                        translatedTo = clamp(Math.round(axis.toPixels(pick(threshold.value, extremes.max), !0) || 0), 0, plotSizeMax);
                        if (ignoreZones) {
                            translatedFrom = translatedTo = axis.toPixels(extremes.max)
                        }
                        pxRange = Math.abs(translatedFrom - translatedTo);
                        pxPosMin = Math.min(translatedFrom, translatedTo);
                        pxPosMax = Math.max(translatedFrom, translatedTo);
                        if (axis.isXAxis) {
                            clipAttr = {
                                x: inverted ? pxPosMax : pxPosMin,
                                y: 0,
                                width: pxRange,
                                height: plotSizeMax
                            };
                            if (!horiz) {
                                clipAttr.x = chart.plotHeight - clipAttr.x
                            }
                        } else {
                            clipAttr = {
                                x: 0,
                                y: inverted ? pxPosMax : pxPosMin,
                                width: plotSizeMax,
                                height: pxRange
                            };
                            if (horiz) {
                                clipAttr.y = chart.plotWidth - clipAttr.y
                            }
                        }
                        if (clips[i]) {
                            clips[i].animate(clipAttr)
                        } else {
                            clips[i] = renderer.clipRect(clipAttr)
                        }
                        zoneArea = series['zone-area-' + i];
                        zoneGraph = series['zone-graph-' + i];
                        if (graph && zoneGraph) {
                            zoneGraph.clip(clips[i])
                        }
                        if (area && zoneArea) {
                            zoneArea.clip(clips[i])
                        }
                        ignoreZones = threshold.value > extremes.max;
                        if (series.resetZones && translatedTo === 0) {
                            translatedTo = void 0
                        }
                    });
                    this.clips = clips
                } else if (series.visible) {
                    if (graph) {
                        graph.show()
                    }
                    if (area) {
                        area.show()
                    }
                }
            }
            plotGroup(prop, name, visibility, zIndex, parent) {
                let group = this[prop];
                const isNew = !group
                    , attrs = {
                    visibility,
                    zIndex: zIndex || 0.1
                };
                if (typeof this.opacity !== 'undefined' && !this.chart.styledMode && this.state !== 'inactive') {
                    attrs.opacity = this.opacity
                }
                if (isNew) {
                    this[prop] = group = this.chart.renderer.g().add(parent)
                }
                group.addClass(('highcharts-' + name + ' highcharts-series-' + this.index + ' highcharts-' + this.type + '-series ' + (defined(this.colorIndex) ? 'highcharts-color-' + this.colorIndex + ' ' : '') + (this.options.className || '') + (group.hasClass('highcharts-tracker') ? ' highcharts-tracker' : '')), !0);
                group.attr(attrs)[isNew ? 'attr' : 'animate'](this.getPlotBox(name));
                return group
            }
            getPlotBox(name) {
                let horAxis = this.xAxis
                    , vertAxis = this.yAxis;
                const chart = this.chart
                    , inverted = (chart.inverted && !chart.polar && horAxis && this.invertible !== !1 && name === 'series');
                if (chart.inverted) {
                    horAxis = vertAxis;
                    vertAxis = this.xAxis
                }
                return {
                    translateX: horAxis ? horAxis.left : chart.plotLeft,
                    translateY: vertAxis ? vertAxis.top : chart.plotTop,
                    rotation: inverted ? 90 : 0,
                    rotationOriginX: inverted ? (horAxis.len - vertAxis.len) / 2 : 0,
                    rotationOriginY: inverted ? (horAxis.len + vertAxis.len) / 2 : 0,
                    scaleX: inverted ? -1 : 1,
                    scaleY: 1
                }
            }
            removeEvents(keepEventsForUpdate) {
                const series = this;
                if (!keepEventsForUpdate) {
                    removeEvent(series)
                }
                if (series.eventsToUnbind.length) {
                    series.eventsToUnbind.forEach(function(unbind) {
                        unbind()
                    });
                    series.eventsToUnbind.length = 0
                }
            }
            render() {
                const series = this
                    , chart = series.chart
                    , options = series.options
                    , animOptions = animObject(options.animation)
                    , visibility = series.visible ? 'inherit' : 'hidden'
                    , zIndex = options.zIndex
                    , hasRendered = series.hasRendered
                    , chartSeriesGroup = chart.seriesGroup
                    , inverted = chart.inverted;
                let animDuration = (!series.finishedAnimating) ? animOptions.duration : 0;
                fireEvent(this, 'render');
                const group = series.plotGroup('group', 'series', visibility, zIndex, chartSeriesGroup);
                series.markerGroup = series.plotGroup('markerGroup', 'markers', visibility, zIndex, chartSeriesGroup);
                if (options.clip !== !1) {
                    series.setClip()
                }
                if (series.animate && animDuration) {
                    series.animate(!0)
                }
                if (series.drawGraph) {
                    series.drawGraph();
                    series.applyZones()
                }
                if (series.visible) {
                    series.drawPoints()
                }
                if (series.drawDataLabels) {
                    series.drawDataLabels()
                }
                if (series.redrawPoints) {
                    series.redrawPoints()
                }
                if (series.drawTracker && options.enableMouseTracking) {
                    series.drawTracker()
                }
                if (series.animate && animDuration) {
                    series.animate()
                }
                if (!hasRendered) {
                    if (animDuration && animOptions.defer) {
                        animDuration += animOptions.defer
                    }
                    series.animationTimeout = syncTimeout(function() {
                        series.afterAnimate()
                    }, animDuration || 0)
                }
                series.isDirty = !1;
                series.hasRendered = !0;
                fireEvent(series, 'afterRender')
            }
            redraw() {
                const wasDirty = this.isDirty || this.isDirtyData;
                this.translate();
                this.render();
                if (wasDirty) {
                    delete this.kdTree
                }
            }
            reserveSpace() {
                return this.visible || !this.chart.options.chart.ignoreHiddenSeries
            }
            searchPoint(e, compareX) {
                const series = this
                    , xAxis = series.xAxis
                    , yAxis = series.yAxis
                    , inverted = series.chart.inverted;
                return this.searchKDTree({
                    clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
                    plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
                }, compareX, e)
            }
            buildKDTree(e) {
                this.buildingKdTree = !0;
                const series = this
                    , dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ? 2 : 1;
                function _kdtree(points, depth, dimensions) {
                    const length = points && points.length;
                    let axis, median;
                    if (length) {
                        axis = series.kdAxisArray[depth % dimensions];
                        points.sort(function(a, b) {
                            return a[axis] - b[axis]
                        });
                        median = Math.floor(length / 2);
                        return {
                            point: points[median],
                            left: _kdtree(points.slice(0, median), depth + 1, dimensions),
                            right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
                        }
                    }
                }
                function startRecursive() {
                    series.kdTree = _kdtree(series.getValidPoints(null, !series.directTouch), dimensions, dimensions);
                    series.buildingKdTree = !1
                }
                delete series.kdTree;
                syncTimeout(startRecursive, series.options.kdNow || (e && e.type === 'touchstart') ? 0 : 1)
            }
            searchKDTree(point, compareX, e) {
                const series = this
                    , [kdX,kdY] = this.kdAxisArray
                    , kdComparer = compareX ? 'distX' : 'dist'
                    , kdDimensions = (series.options.findNearestPointBy || '').indexOf('y') > -1 ? 2 : 1
                    , useRadius = !!series.isBubble;
                function setDistance(p1, p2) {
                    const p1kdX = p1[kdX]
                        , p2kdX = p2[kdX]
                        , x = (defined(p1kdX) && defined(p2kdX)) ? p1kdX - p2kdX : null
                        , p1kdY = p1[kdY]
                        , p2kdY = p2[kdY]
                        , y = (defined(p1kdY) && defined(p2kdY)) ? p1kdY - p2kdY : 0
                        , radius = useRadius ? (p2.marker?.radius || 0) : 0;
                    p2.dist = Math.sqrt(((x && x * x) || 0) + y * y) - radius;
                    p2.distX = defined(x) ? (Math.abs(x) - radius) : Number.MAX_VALUE
                }
                function _search(search, tree, depth, dimensions) {
                    const point = tree.point
                        , axis = series.kdAxisArray[depth % dimensions];
                    let nPoint1, nPoint2, ret = point;
                    setDistance(search, point);
                    const tdist = (search[axis] || 0) - (point[axis] || 0) + (useRadius ? (point.marker?.radius || 0) : 0)
                        , sideA = tdist < 0 ? 'left' : 'right'
                        , sideB = tdist < 0 ? 'right' : 'left';
                    if (tree[sideA]) {
                        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
                        ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point)
                    }
                    if (tree[sideB]) {
                        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                            nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
                            ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret)
                        }
                    }
                    return ret
                }
                if (!this.kdTree && !this.buildingKdTree) {
                    this.buildKDTree(e)
                }
                if (this.kdTree) {
                    return _search(point, this.kdTree, kdDimensions, kdDimensions)
                }
            }
            pointPlacementToXValue() {
                const {options: {pointPlacement, pointRange}, xAxis: axis} = this;
                let factor = pointPlacement;
                if (factor === 'between') {
                    factor = axis.reversed ? -0.5 : 0.5
                }
                return isNumber(factor) ? factor * (pointRange || axis.pointRange) : 0
            }
            isPointInside(point) {
                const {chart, xAxis, yAxis} = this
                    , isInside = (typeof point.plotY !== 'undefined' && typeof point.plotX !== 'undefined' && point.plotY >= 0 && point.plotY <= (yAxis ? yAxis.len : chart.plotHeight) && point.plotX >= 0 && point.plotX <= (xAxis ? xAxis.len : chart.plotWidth));
                return isInside
            }
            drawTracker() {
                const series = this
                    , options = series.options
                    , trackByArea = options.trackByArea
                    , trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath)
                    , chart = series.chart
                    , pointer = chart.pointer
                    , renderer = chart.renderer
                    , snap = chart.options.tooltip.snap
                    , tracker = series.tracker
                    , onMouseOver = function(e) {
                    if (options.enableMouseTracking && chart.hoverSeries !== series) {
                        series.onMouseOver()
                    }
                }
                    , TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';
                let i;
                if (tracker) {
                    tracker.attr({
                        d: trackerPath
                    })
                } else if (series.graph) {
                    series.tracker = renderer.path(trackerPath).attr({
                        visibility: series.visible ? 'inherit' : 'hidden',
                        zIndex: 2
                    }).addClass(trackByArea ? 'highcharts-tracker-area' : 'highcharts-tracker-line').add(series.group);
                    if (!chart.styledMode) {
                        series.tracker.attr({
                            'stroke-linecap': 'round',
                            'stroke-linejoin': 'round',
                            stroke: TRACKER_FILL,
                            fill: trackByArea ? TRACKER_FILL : 'none',
                            'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
                        })
                    }
                    [series.tracker, series.markerGroup, series.dataLabelsGroup].forEach(function(tracker) {
                        if (tracker) {
                            tracker.addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function(e) {
                                pointer.onTrackerMouseOut(e)
                            });
                            if (options.cursor && !chart.styledMode) {
                                tracker.css({
                                    cursor: options.cursor
                                })
                            }
                            if (hasTouch) {
                                tracker.on('touchstart', onMouseOver)
                            }
                        }
                    })
                }
                fireEvent(this, 'afterDrawTracker')
            }
            addPoint(options, redraw, shift, animation, withEvent) {
                const series = this
                    , seriesOptions = series.options
                    , data = series.data
                    , chart = series.chart
                    , xAxis = series.xAxis
                    , names = xAxis && xAxis.hasNames && xAxis.names
                    , dataOptions = seriesOptions.data
                    , xData = series.xData;
                let isInTheMiddle, i;
                redraw = pick(redraw, !0);
                const point = {
                    series: series
                };
                series.pointClass.prototype.applyOptions.apply(point, [options]);
                const x = point.x;
                i = xData.length;
                if (series.requireSorting && x < xData[i - 1]) {
                    isInTheMiddle = !0;
                    while (i && xData[i - 1] > x) {
                        i--
                    }
                }
                series.updateParallelArrays(point, 'splice', [i, 0, 0]);
                series.updateParallelArrays(point, i);
                if (names && point.name) {
                    names[x] = point.name
                }
                dataOptions.splice(i, 0, options);
                if (isInTheMiddle || series.processedData) {
                    series.data.splice(i, 0, null);
                    series.processData()
                }
                if (seriesOptions.legendType === 'point') {
                    series.generatePoints()
                }
                if (shift) {
                    if (data[0] && !!data[0].remove) {
                        data[0].remove(!1)
                    } else {
                        data.shift();
                        series.updateParallelArrays(point, 'shift');
                        dataOptions.shift()
                    }
                }
                if (withEvent !== !1) {
                    fireEvent(series, 'addPoint', {
                        point: point
                    })
                }
                series.isDirty = !0;
                series.isDirtyData = !0;
                if (redraw) {
                    chart.redraw(animation)
                }
            }
            removePoint(i, redraw, animation) {
                const series = this
                    , data = series.data
                    , point = data[i]
                    , points = series.points
                    , chart = series.chart
                    , remove = function() {
                    if (points && points.length === data.length) {
                        points.splice(i, 1)
                    }
                    data.splice(i, 1);
                    series.options.data.splice(i, 1);
                    series.updateParallelArrays(point || {
                        series: series
                    }, 'splice', [i, 1]);
                    if (point) {
                        point.destroy()
                    }
                    series.isDirty = !0;
                    series.isDirtyData = !0;
                    if (redraw) {
                        chart.redraw()
                    }
                };
                setAnimation(animation, chart);
                redraw = pick(redraw, !0);
                if (point) {
                    point.firePointEvent('remove', null, remove)
                } else {
                    remove()
                }
            }
            remove(redraw, animation, withEvent, keepEvents) {
                const series = this
                    , chart = series.chart;
                function remove() {
                    series.destroy(keepEvents);
                    chart.isDirtyLegend = chart.isDirtyBox = !0;
                    chart.linkSeries(keepEvents);
                    if (pick(redraw, !0)) {
                        chart.redraw(animation)
                    }
                }
                if (withEvent !== !1) {
                    fireEvent(series, 'remove', null, remove)
                } else {
                    remove()
                }
            }
            update(options, redraw) {
                options = diffObjects(options, this.userOptions);
                fireEvent(this, 'update', {
                    options: options
                });
                const series = this
                    , chart = series.chart
                    , oldOptions = series.userOptions
                    , initialType = series.initialType || series.type
                    , plotOptions = chart.options.plotOptions
                    , initialSeriesProto = seriesTypes[initialType].prototype
                    , groups = ['group', 'markerGroup', 'dataLabelsGroup', 'transformGroup']
                    , optionsToCheck = ['dataGrouping', 'pointStart', 'pointInterval', 'pointIntervalUnit', 'keys']
                    , animation = series.finishedAnimating && {
                    animation: !1
                }
                    , kinds = {};
                let seriesOptions, n, preserve = ['colorIndex', 'eventOptions', 'navigatorSeries', 'symbolIndex', 'baseSeries'], newType = (options.type || oldOptions.type || chart.options.chart.type);
                const keepPoints = !(this.hasDerivedData || (newType && newType !== this.type) || typeof options.pointStart !== 'undefined' || typeof options.pointInterval !== 'undefined' || typeof options.relativeXValue !== 'undefined' || options.joinBy || options.mapData || optionsToCheck.some( (option) => series.hasOptionChanged(option)));
                newType = newType || initialType;
                if (keepPoints) {
                    preserve.push('data', 'isDirtyData', 'isDirtyCanvas', 'points', 'processedData', 'processedXData', 'processedYData', 'xIncrement', 'cropped', '_hasPointMarkers', 'hasDataLabels', 'clips', 'nodes', 'layout', 'level', 'mapMap', 'mapData', 'minY', 'maxY', 'minX', 'maxX');
                    if (options.visible !== !1) {
                        preserve.push('area', 'graph')
                    }
                    series.parallelArrays.forEach(function(key) {
                        preserve.push(key + 'Data')
                    });
                    if (options.data) {
                        if (options.dataSorting) {
                            extend(series.options.dataSorting, options.dataSorting)
                        }
                        this.setData(options.data, !1)
                    }
                }
                options = merge(oldOptions, animation, {
                    index: typeof oldOptions.index === 'undefined' ? series.index : oldOptions.index,
                    pointStart: pick(plotOptions?.series?.pointStart, oldOptions.pointStart, series.xData[0])
                }, (!keepPoints && {
                    data: series.options.data
                }), options);
                if (keepPoints && options.data) {
                    options.data = series.options.data
                }
                preserve = groups.concat(preserve);
                preserve.forEach(function(prop) {
                    preserve[prop] = series[prop];
                    delete series[prop]
                });
                let casting = !1;
                if (seriesTypes[newType]) {
                    casting = newType !== series.type;
                    series.remove(!1, !1, !1, !0);
                    if (casting) {
                        if (Object.setPrototypeOf) {
                            Object.setPrototypeOf(series, seriesTypes[newType].prototype)
                        } else {
                            const ownEvents = Object.hasOwnProperty.call(series, 'hcEvents') && series.hcEvents;
                            for (n in initialSeriesProto) {
                                series[n] = void 0
                            }
                            extend(series, seriesTypes[newType].prototype);
                            if (ownEvents) {
                                series.hcEvents = ownEvents
                            } else {
                                delete series.hcEvents
                            }
                        }
                    }
                } else {
                    error(17, !0, chart, {
                        missingModuleFor: newType
                    })
                }
                preserve.forEach(function(prop) {
                    series[prop] = preserve[prop]
                });
                series.init(chart, options);
                if (keepPoints && this.points) {
                    seriesOptions = series.options;
                    if (seriesOptions.visible === !1) {
                        kinds.graphic = 1;
                        kinds.dataLabel = 1
                    } else {
                        if (this.hasMarkerChanged(seriesOptions, oldOptions)) {
                            kinds.graphic = 1
                        }
                        if (!series.hasDataLabels?.()) {
                            kinds.dataLabel = 1
                        }
                    }
                    for (const point of this.points) {
                        if (point && point.series) {
                            point.resolveColor();
                            if (Object.keys(kinds).length) {
                                point.destroyElements(kinds)
                            }
                            if (seriesOptions.showInLegend === !1 && point.legendItem) {
                                chart.legend.destroyItem(point)
                            }
                        }
                    }
                }
                series.initialType = initialType;
                chart.linkSeries();
                if (casting && series.linkedSeries.length) {
                    series.isDirtyData = !0
                }
                fireEvent(this, 'afterUpdate');
                if (pick(redraw, !0)) {
                    chart.redraw(keepPoints ? void 0 : !1)
                }
            }
            setName(name) {
                this.name = this.options.name = this.userOptions.name = name;
                this.chart.isDirtyLegend = !0
            }
            hasOptionChanged(optionName) {
                const chart = this.chart
                    , option = this.options[optionName]
                    , plotOptions = chart.options.plotOptions
                    , oldOption = this.userOptions[optionName]
                    , plotOptionsOption = pick(plotOptions?.[this.type]?.[optionName], plotOptions?.series?.[optionName]);
                if (oldOption && !defined(plotOptionsOption)) {
                    return option !== oldOption
                }
                return option !== pick(plotOptionsOption, option)
            }
            onMouseOver() {
                const series = this
                    , chart = series.chart
                    , hoverSeries = chart.hoverSeries
                    , pointer = chart.pointer;
                pointer.setHoverChartIndex();
                if (hoverSeries && hoverSeries !== series) {
                    hoverSeries.onMouseOut()
                }
                if (series.options.events.mouseOver) {
                    fireEvent(series, 'mouseOver')
                }
                series.setState('hover');
                chart.hoverSeries = series
            }
            onMouseOut() {
                const series = this
                    , options = series.options
                    , chart = series.chart
                    , tooltip = chart.tooltip
                    , hoverPoint = chart.hoverPoint;
                chart.hoverSeries = null;
                if (hoverPoint) {
                    hoverPoint.onMouseOut()
                }
                if (series && options.events.mouseOut) {
                    fireEvent(series, 'mouseOut')
                }
                if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
                    tooltip.hide()
                }
                chart.series.forEach(function(s) {
                    s.setState('', !0)
                })
            }
            setState(state, inherit) {
                const series = this
                    , options = series.options
                    , graph = series.graph
                    , inactiveOtherPoints = options.inactiveOtherPoints
                    , stateOptions = options.states
                    , stateAnimation = pick((stateOptions[state || 'normal'] && stateOptions[state || 'normal'].animation), series.chart.options.chart.animation);
                let attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;
                state = state || '';
                if (series.state !== state) {
                    [series.group, series.markerGroup, series.dataLabelsGroup].forEach(function(group) {
                        if (group) {
                            if (series.state) {
                                group.removeClass('highcharts-series-' + series.state)
                            }
                            if (state) {
                                group.addClass('highcharts-series-' + state)
                            }
                        }
                    });
                    series.state = state;
                    if (!series.chart.styledMode) {
                        if (stateOptions[state] && stateOptions[state].enabled === !1) {
                            return
                        }
                        if (state) {
                            lineWidth = (stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0));
                            opacity = pick(stateOptions[state].opacity, opacity)
                        }
                        if (graph && !graph.dashstyle && isNumber(lineWidth)) {
                            attribs = {
                                'stroke-width': lineWidth
                            };
                            graph.animate(attribs, stateAnimation);
                            while (series['zone-graph-' + i]) {
                                series['zone-graph-' + i].animate(attribs, stateAnimation);
                                i = i + 1
                            }
                        }
                        if (!inactiveOtherPoints) {
                            [series.group, series.markerGroup, series.dataLabelsGroup, series.labelBySeries].forEach(function(group) {
                                if (group) {
                                    group.animate({
                                        opacity: opacity
                                    }, stateAnimation)
                                }
                            })
                        }
                    }
                }
                if (inherit && inactiveOtherPoints && series.points) {
                    series.setAllPointsToState(state || void 0)
                }
            }
            setAllPointsToState(state) {
                this.points.forEach(function(point) {
                    if (point.setState) {
                        point.setState(state)
                    }
                })
            }
            setVisible(vis, redraw) {
                const series = this
                    , chart = series.chart
                    , ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries
                    , oldVisibility = series.visible;
                series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === 'undefined' ? !oldVisibility : vis;
                const showOrHide = vis ? 'show' : 'hide';
                ['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'].forEach( (key) => {
                        series[key]?.[showOrHide]()
                    }
                );
                if (chart.hoverSeries === series || chart.hoverPoint?.series === series) {
                    series.onMouseOut()
                }
                if (series.legendItem) {
                    chart.legend.colorizeItem(series, vis)
                }
                series.isDirty = !0;
                if (series.options.stacking) {
                    chart.series.forEach( (otherSeries) => {
                            if (otherSeries.options.stacking && otherSeries.visible) {
                                otherSeries.isDirty = !0
                            }
                        }
                    )
                }
                series.linkedSeries.forEach( (otherSeries) => {
                        otherSeries.setVisible(vis, !1)
                    }
                );
                if (ignoreHiddenSeries) {
                    chart.isDirtyBox = !0
                }
                fireEvent(series, showOrHide);
                if (redraw !== !1) {
                    chart.redraw()
                }
            }
            show() {
                this.setVisible(!0)
            }
            hide() {
                this.setVisible(!1)
            }
            select(selected) {
                const series = this;
                series.selected = selected = this.options.selected = (typeof selected === 'undefined' ? !series.selected : selected);
                if (series.checkbox) {
                    series.checkbox.checked = selected
                }
                fireEvent(series, selected ? 'select' : 'unselect')
            }
            shouldShowTooltip(plotX, plotY, options={}) {
                options.series = this;
                options.visiblePlotOnly = !0;
                return this.chart.isInsidePlot(plotX, plotY, options)
            }
            drawLegendSymbol(legend, item) {
                LegendSymbol[this.options.legendSymbol || 'rectangle']?.call(this, legend, item)
            }
        }
        Series.defaultOptions = SeriesDefaults;
        Series.types = SeriesRegistry.seriesTypes;
        Series.registerType = SeriesRegistry.registerSeriesType;
        extend(Series.prototype, {
            axisTypes: ['xAxis', 'yAxis'],
            coll: 'series',
            colorCounter: 0,
            directTouch: !1,
            isCartesian: !0,
            kdAxisArray: ['clientX', 'plotY'],
            parallelArrays: ['x', 'y'],
            pointClass: Point,
            requireSorting: !0,
            sorted: !0
        });
        SeriesRegistry.series = Series;
        '';
        '';
        return Series
    });
    _registerModule(_modules, 'Core/Chart/Chart.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Axis/Axis.js'], _modules['Core/Defaults.js'], _modules['Core/Templating.js'], _modules['Core/Foundation.js'], _modules['Core/Globals.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Time.js'], _modules['Core/Utilities.js'], _modules['Core/Renderer/HTML/AST.js']], function(A, Axis, D, Templating, Foundation, H, RendererRegistry, Series, SeriesRegistry, SVGRenderer, Time, U, AST) {
        const {animate, animObject, setAnimation} = A;
        const {defaultOptions, defaultTime} = D;
        const {numberFormat} = Templating;
        const {registerEventOptions} = Foundation;
        const {charts, doc, marginNames, svg, win} = H;
        const {seriesTypes} = SeriesRegistry;
        const {addEvent, attr, createElement, css, defined, diffObjects, discardElement, erase, error, extend, find, fireEvent, getStyle, isArray, isNumber, isObject, isString, merge, objectEach, pick, pInt, relativeLength, removeEvent, splat, syncTimeout, uniqueKey} = U;
        class Chart {
            static chart(a, b, c) {
                return new Chart(a,b,c)
            }
            constructor(a, b, c) {
                this.axes = void 0;
                this.axisOffset = void 0;
                this.bounds = void 0;
                this.chartHeight = void 0;
                this.chartWidth = void 0;
                this.clipBox = void 0;
                this.colorCounter = void 0;
                this.container = void 0;
                this.eventOptions = void 0;
                this.index = void 0;
                this.isResizing = void 0;
                this.labelCollectors = void 0;
                this.margin = void 0;
                this.numberFormatter = void 0;
                this.options = void 0;
                this.plotBox = void 0;
                this.plotHeight = void 0;
                this.plotLeft = void 0;
                this.plotTop = void 0;
                this.plotWidth = void 0;
                this.pointCount = void 0;
                this.pointer = void 0;
                this.renderer = void 0;
                this.renderTo = void 0;
                this.series = void 0;
                this.sharedClips = {};
                this.spacing = void 0;
                this.spacingBox = void 0;
                this.symbolCounter = void 0;
                this.time = void 0;
                this.titleOffset = void 0;
                this.userOptions = void 0;
                this.xAxis = void 0;
                this.yAxis = void 0;
                this.zooming = void 0;
                this.getArgs(a, b, c)
            }
            getArgs(a, b, c) {
                if (isString(a) || a.nodeName) {
                    this.renderTo = a;
                    this.init(b, c)
                } else {
                    this.init(a, b)
                }
            }
            setZoomOptions() {
                const chart = this
                    , options = chart.options.chart
                    , zooming = options.zooming;
                chart.zooming = {
                    ...zooming,
                    type: pick(options.zoomType, zooming.type),
                    key: pick(options.zoomKey, zooming.key),
                    pinchType: pick(options.pinchType, zooming.pinchType),
                    singleTouch: pick(options.zoomBySingleTouch, zooming.singleTouch, !1),
                    resetButton: merge(zooming.resetButton, options.resetZoomButton)
                }
            }
            init(userOptions, callback) {
                fireEvent(this, 'init', {
                    args: arguments
                }, function() {
                    const options = merge(defaultOptions, userOptions)
                        , optionsChart = options.chart;
                    this.userOptions = extend({}, userOptions);
                    this.margin = [];
                    this.spacing = [];
                    this.bounds = {
                        h: {},
                        v: {}
                    };
                    this.labelCollectors = [];
                    this.callback = callback;
                    this.isResizing = 0;
                    this.options = options;
                    this.axes = [];
                    this.series = [];
                    this.time = userOptions.time && Object.keys(userOptions.time).length ? new Time(userOptions.time) : H.time;
                    this.numberFormatter = optionsChart.numberFormatter || numberFormat;
                    this.styledMode = optionsChart.styledMode;
                    this.hasCartesianSeries = optionsChart.showAxes;
                    const chart = this;
                    chart.index = charts.length;
                    charts.push(chart);
                    H.chartCount++;
                    registerEventOptions(this, optionsChart);
                    chart.xAxis = [];
                    chart.yAxis = [];
                    chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
                    this.setZoomOptions();
                    fireEvent(chart, 'afterInit');
                    chart.firstRender()
                })
            }
            initSeries(options) {
                const chart = this
                    , optionsChart = chart.options.chart
                    , type = (options.type || optionsChart.type)
                    , SeriesClass = seriesTypes[type];
                if (!SeriesClass) {
                    error(17, !0, chart, {
                        missingModuleFor: type
                    })
                }
                const series = new SeriesClass();
                if (typeof series.init === 'function') {
                    series.init(chart, options)
                }
                return series
            }
            setSeriesData() {
                this.getSeriesOrderByLinks().forEach(function(series) {
                    if (!series.points && !series.data && series.enabledDataSorting) {
                        series.setData(series.options.data, !1)
                    }
                })
            }
            getSeriesOrderByLinks() {
                return this.series.concat().sort(function(a, b) {
                    if (a.linkedSeries.length || b.linkedSeries.length) {
                        return b.linkedSeries.length - a.linkedSeries.length
                    }
                    return 0
                })
            }
            orderItems(coll, fromIndex=0) {
                const collection = this[coll]
                    , optionsArray = this.options[coll] = splat(this.options[coll]).slice()
                    , userOptionsArray = this.userOptions[coll] = this.userOptions[coll] ? splat(this.userOptions[coll]).slice() : [];
                if (this.hasRendered) {
                    optionsArray.splice(fromIndex);
                    userOptionsArray.splice(fromIndex)
                }
                if (collection) {
                    for (let i = fromIndex, iEnd = collection.length; i < iEnd; ++i) {
                        const item = collection[i];
                        if (item) {
                            item.index = i;
                            if (item instanceof Series) {
                                item.name = item.getName()
                            }
                            if (!item.options.isInternal) {
                                optionsArray[i] = item.options;
                                userOptionsArray[i] = item.userOptions
                            }
                        }
                    }
                }
            }
            isInsidePlot(plotX, plotY, options={}) {
                const {inverted, plotBox, plotLeft, plotTop, scrollablePlotBox} = this;
                let scrollLeft = 0
                    , scrollTop = 0;
                if (options.visiblePlotOnly && this.scrollingContainer) {
                    ({scrollLeft, scrollTop} = this.scrollingContainer)
                }
                const series = options.series
                    , box = (options.visiblePlotOnly && scrollablePlotBox) || plotBox
                    , x = options.inverted ? plotY : plotX
                    , y = options.inverted ? plotX : plotY
                    , e = {
                    x,
                    y,
                    isInsidePlot: !0,
                    options
                };
                if (!options.ignoreX) {
                    const xAxis = (series && (inverted && !this.polar ? series.yAxis : series.xAxis)) || {
                        pos: plotLeft,
                        len: Infinity
                    };
                    const chartX = options.paneCoordinates ? xAxis.pos + x : plotLeft + x;
                    if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
                        e.isInsidePlot = !1
                    }
                }
                if (!options.ignoreY && e.isInsidePlot) {
                    const yAxis = (!inverted && options.axis && !options.axis.isXAxis && options.axis) || (series && (inverted ? series.xAxis : series.yAxis)) || {
                        pos: plotTop,
                        len: Infinity
                    };
                    const chartY = options.paneCoordinates ? yAxis.pos + y : plotTop + y;
                    if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
                        e.isInsidePlot = !1
                    }
                }
                fireEvent(this, 'afterIsInsidePlot', e);
                return e.isInsidePlot
            }
            redraw(animation) {
                fireEvent(this, 'beforeRedraw');
                const chart = this
                    , axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || []
                    , series = chart.series
                    , pointer = chart.pointer
                    , legend = chart.legend
                    , legendUserOptions = chart.userOptions.legend
                    , renderer = chart.renderer
                    , isHiddenChart = renderer.isHidden()
                    , afterRedraw = [];
                let hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
                renderer.rootFontSize = renderer.boxWrapper.getStyle('font-size');
                if (chart.setResponsive) {
                    chart.setResponsive(!1)
                }
                setAnimation(chart.hasRendered ? animation : !1, chart);
                if (isHiddenChart) {
                    chart.temporaryDisplay()
                }
                chart.layOutTitles(!1);
                i = series.length;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking || serie.options.centerInCategory) {
                        hasStackedSeries = !0;
                        if (serie.isDirty) {
                            hasDirtyStacks = !0;
                            break
                        }
                    }
                }
                if (hasDirtyStacks) {
                    i = series.length;
                    while (i--) {
                        serie = series[i];
                        if (serie.options.stacking) {
                            serie.isDirty = !0
                        }
                    }
                }
                series.forEach(function(serie) {
                    if (serie.isDirty) {
                        if (serie.options.legendType === 'point') {
                            if (typeof serie.updateTotals === 'function') {
                                serie.updateTotals()
                            }
                            redrawLegend = !0
                        } else if (legendUserOptions && (!!legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
                            redrawLegend = !0
                        }
                    }
                    if (serie.isDirtyData) {
                        fireEvent(serie, 'updatedData')
                    }
                });
                if (redrawLegend && legend && legend.options.enabled) {
                    legend.render();
                    chart.isDirtyLegend = !1
                }
                if (hasStackedSeries) {
                    chart.getStacks()
                }
                axes.forEach(function(axis) {
                    axis.updateNames();
                    axis.setScale()
                });
                chart.getMargins();
                axes.forEach(function(axis) {
                    if (axis.isDirty) {
                        isDirtyBox = !0
                    }
                });
                axes.forEach(function(axis) {
                    const key = axis.min + ',' + axis.max;
                    if (axis.extKey !== key) {
                        axis.extKey = key;
                        afterRedraw.push(function() {
                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes()));
                            delete axis.eventArgs
                        })
                    }
                    if (isDirtyBox || hasStackedSeries) {
                        axis.redraw()
                    }
                });
                if (isDirtyBox) {
                    chart.drawChartBox()
                }
                fireEvent(chart, 'predraw');
                series.forEach(function(serie) {
                    if ((isDirtyBox || serie.isDirty) && serie.visible) {
                        serie.redraw()
                    }
                    serie.isDirtyData = !1
                });
                if (pointer) {
                    pointer.reset(!0)
                }
                renderer.draw();
                fireEvent(chart, 'redraw');
                fireEvent(chart, 'render');
                if (isHiddenChart) {
                    chart.temporaryDisplay(!0)
                }
                afterRedraw.forEach(function(callback) {
                    callback.call()
                })
            }
            get(id) {
                const series = this.series;
                function itemById(item) {
                    return (item.id === id || (item.options && item.options.id === id))
                }
                let ret = find(this.axes, itemById) || find(this.series, itemById);
                for (let i = 0; !ret && i < series.length; i++) {
                    ret = find(series[i].points || [], itemById)
                }
                return ret
            }
            getAxes() {
                const options = this.options;
                fireEvent(this, 'getAxes');
                for (const coll of ['xAxis', 'yAxis']) {
                    const arr = options[coll] = splat(options[coll] || {});
                    for (const axisOptions of arr) {
                        new Axis(this,axisOptions,coll)
                    }
                }
                fireEvent(this, 'afterGetAxes')
            }
            getSelectedPoints() {
                return this.series.reduce( (acc, series) => {
                        series.getPointsCollection().forEach( (point) => {
                                if (pick(point.selectedStaging, point.selected)) {
                                    acc.push(point)
                                }
                            }
                        );
                        return acc
                    }
                    , [])
            }
            getSelectedSeries() {
                return this.series.filter(function(serie) {
                    return serie.selected
                })
            }
            setTitle(titleOptions, subtitleOptions, redraw) {
                this.applyDescription('title', titleOptions);
                this.applyDescription('subtitle', subtitleOptions);
                this.applyDescription('caption', void 0);
                this.layOutTitles(redraw)
            }
            applyDescription(name, explicitOptions) {
                const chart = this;
                const options = this.options[name] = merge(this.options[name], explicitOptions);
                let elem = this[name];
                if (elem && explicitOptions) {
                    this[name] = elem = elem.destroy()
                }
                if (options && !elem) {
                    elem = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
                        align: options.align,
                        'class': 'highcharts-' + name,
                        zIndex: options.zIndex || 4
                    }).add();
                    elem.update = function(updateOptions, redraw) {
                        chart.applyDescription(name, updateOptions);
                        chart.layOutTitles(redraw)
                    }
                    ;
                    if (!this.styledMode) {
                        elem.css(extend(name === 'title' ? {
                            fontSize: this.options.isStock ? '1em' : '1.2em'
                        } : {}, options.style))
                    }
                    this[name] = elem
                }
            }
            layOutTitles(redraw=!0) {
                const titleOffset = [0, 0, 0]
                    , renderer = this.renderer
                    , spacingBox = this.spacingBox;
                ['title', 'subtitle', 'caption'].forEach(function(key) {
                    const title = this[key]
                        , titleOptions = (this.options[key])
                        , verticalAlign = titleOptions.verticalAlign || 'top'
                        , offset = key === 'title' ? verticalAlign === 'top' ? -3 : 0 : verticalAlign === 'top' ? titleOffset[0] + 2 : 0;
                    if (title) {
                        title.css({
                            width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + 'px'
                        });
                        const baseline = renderer.fontMetrics(title).b
                            , height = Math.round(title.getBBox(titleOptions.useHTML).height);
                        title.align(extend({
                            y: verticalAlign === 'bottom' ? baseline : offset + baseline,
                            height
                        }, titleOptions), !1, 'spacingBox');
                        if (!titleOptions.floating) {
                            if (verticalAlign === 'top') {
                                titleOffset[0] = Math.ceil(titleOffset[0] + height)
                            } else if (verticalAlign === 'bottom') {
                                titleOffset[2] = Math.ceil(titleOffset[2] + height)
                            }
                        }
                    }
                }, this);
                if (titleOffset[0] && (this.options.title.verticalAlign || 'top') === 'top') {
                    titleOffset[0] += this.options.title.margin
                }
                if (titleOffset[2] && this.options.caption.verticalAlign === 'bottom') {
                    titleOffset[2] += this.options.caption.margin
                }
                const requiresDirtyBox = (!this.titleOffset || this.titleOffset.join(',') !== titleOffset.join(','));
                this.titleOffset = titleOffset;
                fireEvent(this, 'afterLayOutTitles');
                if (!this.isDirtyBox && requiresDirtyBox) {
                    this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
                    if (this.hasRendered && redraw && this.isDirtyBox) {
                        this.redraw()
                    }
                }
            }
            getContainerBox() {
                return {
                    width: getStyle(this.renderTo, 'width', !0) || 0,
                    height: getStyle(this.renderTo, 'height', !0) || 0
                }
            }
            getChartSize() {
                const chart = this
                    , optionsChart = chart.options.chart
                    , widthOption = optionsChart.width
                    , heightOption = optionsChart.height
                    , containerBox = chart.getContainerBox();
                chart.chartWidth = Math.max(0, widthOption || containerBox.width || 600);
                chart.chartHeight = Math.max(0, relativeLength(heightOption, chart.chartWidth) || (containerBox.height > 1 ? containerBox.height : 400));
                chart.containerBox = containerBox
            }
            temporaryDisplay(revert) {
                let node = this.renderTo, tempStyle;
                if (!revert) {
                    while (node && node.style) {
                        if (!doc.body.contains(node) && !node.parentNode) {
                            node.hcOrigDetached = !0;
                            doc.body.appendChild(node)
                        }
                        if (getStyle(node, 'display', !1) === 'none' || node.hcOricDetached) {
                            node.hcOrigStyle = {
                                display: node.style.display,
                                height: node.style.height,
                                overflow: node.style.overflow
                            };
                            tempStyle = {
                                display: 'block',
                                overflow: 'hidden'
                            };
                            if (node !== this.renderTo) {
                                tempStyle.height = 0
                            }
                            css(node, tempStyle);
                            if (!node.offsetWidth) {
                                node.style.setProperty('display', 'block', 'important')
                            }
                        }
                        node = node.parentNode;
                        if (node === doc.body) {
                            break
                        }
                    }
                } else {
                    while (node && node.style) {
                        if (node.hcOrigStyle) {
                            css(node, node.hcOrigStyle);
                            delete node.hcOrigStyle
                        }
                        if (node.hcOrigDetached) {
                            doc.body.removeChild(node);
                            node.hcOrigDetached = !1
                        }
                        node = node.parentNode
                    }
                }
            }
            setClassName(className) {
                this.container.className = 'highcharts-container ' + (className || '')
            }
            getContainer() {
                const chart = this
                    , options = chart.options
                    , optionsChart = options.chart
                    , indexAttrName = 'data-highcharts-chart'
                    , containerId = uniqueKey();
                let containerStyle, renderTo = chart.renderTo;
                if (!renderTo) {
                    chart.renderTo = renderTo = optionsChart.renderTo
                }
                if (isString(renderTo)) {
                    chart.renderTo = renderTo = doc.getElementById(renderTo)
                }
                if (!renderTo) {
                    error(13, !0, chart)
                }
                const oldChartIndex = pInt(attr(renderTo, indexAttrName));
                if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
                    charts[oldChartIndex].destroy()
                }
                attr(renderTo, indexAttrName, chart.index);
                renderTo.innerHTML = AST.emptyHTML;
                if (!optionsChart.skipClone && !renderTo.offsetWidth) {
                    chart.temporaryDisplay()
                }
                chart.getChartSize();
                const chartWidth = chart.chartWidth;
                const chartHeight = chart.chartHeight;
                css(renderTo, {
                    overflow: 'hidden'
                });
                if (!chart.styledMode) {
                    containerStyle = extend({
                        position: 'relative',
                        overflow: 'hidden',
                        width: chartWidth + 'px',
                        height: chartHeight + 'px',
                        textAlign: 'left',
                        lineHeight: 'normal',
                        zIndex: 0,
                        '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',
                        userSelect: 'none',
                        'touch-action': 'manipulation',
                        outline: 'none'
                    }, optionsChart.style || {})
                }
                const container = createElement('div', {
                    id: containerId
                }, containerStyle, renderTo);
                chart.container = container;
                chart._cursor = container.style.cursor;
                const Renderer = optionsChart.renderer || !svg ? RendererRegistry.getRendererType(optionsChart.renderer) : SVGRenderer;
                chart.renderer = new Renderer(container,chartWidth,chartHeight,void 0,optionsChart.forExport,options.exporting && options.exporting.allowHTML,chart.styledMode);
                chart.containerBox = chart.getContainerBox();
                setAnimation(void 0, chart);
                chart.setClassName(optionsChart.className);
                if (!chart.styledMode) {
                    chart.renderer.setStyle(optionsChart.style)
                } else {
                    for (const key in options.defs) {
                        this.renderer.definition(options.defs[key])
                    }
                }
                chart.renderer.chartIndex = chart.index;
                fireEvent(this, 'afterGetContainer')
            }
            getMargins(skipAxes) {
                const {spacing, margin, titleOffset} = this;
                this.resetMargins();
                if (titleOffset[0] && !defined(margin[0])) {
                    this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0])
                }
                if (titleOffset[2] && !defined(margin[2])) {
                    this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2])
                }
                if (this.legend && this.legend.display) {
                    this.legend.adjustMargins(margin, spacing)
                }
                fireEvent(this, 'getMargins');
                if (!skipAxes) {
                    this.getAxisMargins()
                }
            }
            getAxisMargins() {
                const chart = this
                    , axisOffset = chart.axisOffset = [0, 0, 0, 0]
                    , colorAxis = chart.colorAxis
                    , margin = chart.margin
                    , getOffset = function(axes) {
                    axes.forEach(function(axis) {
                        if (axis.visible) {
                            axis.getOffset()
                        }
                    })
                };
                if (chart.hasCartesianSeries) {
                    getOffset(chart.axes)
                } else if (colorAxis && colorAxis.length) {
                    getOffset(colorAxis)
                }
                marginNames.forEach(function(m, side) {
                    if (!defined(margin[side])) {
                        chart[m] += axisOffset[side]
                    }
                });
                chart.setChartSize()
            }
            getOptions() {
                return diffObjects(this.userOptions, defaultOptions)
            }
            reflow(e) {
                const chart = this
                    , oldBox = chart.containerBox
                    , containerBox = chart.getContainerBox();
                delete chart.pointer.chartPosition;
                if (!chart.isPrinting && !chart.isResizing && oldBox && containerBox.width) {
                    if (containerBox.width !== oldBox.width || containerBox.height !== oldBox.height) {
                        U.clearTimeout(chart.reflowTimeout);
                        chart.reflowTimeout = syncTimeout(function() {
                            if (chart.container) {
                                chart.setSize(void 0, void 0, !1)
                            }
                        }, e ? 100 : 0)
                    }
                    chart.containerBox = containerBox
                }
            }
            setReflow() {
                const chart = this;
                const runReflow = (e) => {
                        if (chart.options?.chart.reflow && chart.hasLoaded) {
                            chart.reflow(e)
                        }
                    }
                ;
                if (typeof ResizeObserver === 'function') {
                    (new ResizeObserver(runReflow)).observe(chart.renderTo)
                } else {
                    const unbind = addEvent(win, 'resize', runReflow);
                    addEvent(this, 'destroy', unbind)
                }
            }
            setSize(width, height, animation) {
                const chart = this
                    , renderer = chart.renderer;
                chart.isResizing += 1;
                setAnimation(animation, chart);
                const globalAnimation = renderer.globalAnimation;
                chart.oldChartHeight = chart.chartHeight;
                chart.oldChartWidth = chart.chartWidth;
                if (typeof width !== 'undefined') {
                    chart.options.chart.width = width
                }
                if (typeof height !== 'undefined') {
                    chart.options.chart.height = height
                }
                chart.getChartSize();
                if (!chart.styledMode) {
                    (globalAnimation ? animate : css)(chart.container, {
                        width: chart.chartWidth + 'px',
                        height: chart.chartHeight + 'px'
                    }, globalAnimation)
                }
                chart.setChartSize(!0);
                renderer.setSize(chart.chartWidth, chart.chartHeight, globalAnimation);
                chart.axes.forEach(function(axis) {
                    axis.isDirty = !0;
                    axis.setScale()
                });
                chart.isDirtyLegend = !0;
                chart.isDirtyBox = !0;
                chart.layOutTitles();
                chart.getMargins();
                chart.redraw(globalAnimation);
                chart.oldChartHeight = null;
                fireEvent(chart, 'resize');
                setTimeout( () => {
                        if (chart) {
                            fireEvent(chart, 'endResize', void 0, () => {
                                    chart.isResizing -= 1
                                }
                            )
                        }
                    }
                    , animObject(globalAnimation).duration)
            }
            setChartSize(skipAxes) {
                const chart = this
                    , inverted = chart.inverted
                    , renderer = chart.renderer
                    , chartWidth = chart.chartWidth
                    , chartHeight = chart.chartHeight
                    , optionsChart = chart.options.chart
                    , spacing = chart.spacing
                    , clipOffset = chart.clipOffset;
                let plotLeft, plotTop, plotWidth, plotHeight;
                chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
                chart.plotTop = plotTop = Math.round(chart.plotTop);
                chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
                chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
                chart.plotSizeX = inverted ? plotHeight : plotWidth;
                chart.plotSizeY = inverted ? plotWidth : plotHeight;
                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
                chart.spacingBox = renderer.spacingBox = {
                    x: spacing[3],
                    y: spacing[0],
                    width: chartWidth - spacing[3] - spacing[1],
                    height: chartHeight - spacing[0] - spacing[2]
                };
                chart.plotBox = renderer.plotBox = {
                    x: plotLeft,
                    y: plotTop,
                    width: plotWidth,
                    height: plotHeight
                };
                const plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2)
                    , clipX = Math.ceil(Math.max(plotBorderWidth, clipOffset[3]) / 2)
                    , clipY = Math.ceil(Math.max(plotBorderWidth, clipOffset[0]) / 2);
                chart.clipBox = {
                    x: clipX,
                    y: clipY,
                    width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
                    height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
                };
                if (!skipAxes) {
                    chart.axes.forEach(function(axis) {
                        axis.setAxisSize();
                        axis.setAxisTranslation()
                    });
                    renderer.alignElements()
                }
                fireEvent(chart, 'afterSetChartSize', {
                    skipAxes: skipAxes
                })
            }
            resetMargins() {
                fireEvent(this, 'resetMargins');
                const chart = this
                    , chartOptions = chart.options.chart;
                ['margin', 'spacing'].forEach(function splashArrays(target) {
                    const value = chartOptions[target]
                        , values = isObject(value) ? value : [value, value, value, value];
                    ['Top', 'Right', 'Bottom', 'Left'].forEach(function(sideName, side) {
                        chart[target][side] = pick(chartOptions[target + sideName], values[side])
                    })
                });
                marginNames.forEach(function(m, side) {
                    chart[m] = pick(chart.margin[side], chart.spacing[side])
                });
                chart.axisOffset = [0, 0, 0, 0];
                chart.clipOffset = [0, 0, 0, 0]
            }
            drawChartBox() {
                const chart = this
                    , optionsChart = chart.options.chart
                    , renderer = chart.renderer
                    , chartWidth = chart.chartWidth
                    , chartHeight = chart.chartHeight
                    , styledMode = chart.styledMode
                    , plotBGImage = chart.plotBGImage
                    , chartBackgroundColor = optionsChart.backgroundColor
                    , plotBackgroundColor = optionsChart.plotBackgroundColor
                    , plotBackgroundImage = optionsChart.plotBackgroundImage
                    , plotLeft = chart.plotLeft
                    , plotTop = chart.plotTop
                    , plotWidth = chart.plotWidth
                    , plotHeight = chart.plotHeight
                    , plotBox = chart.plotBox
                    , clipRect = chart.clipRect
                    , clipBox = chart.clipBox;
                let chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = 'animate';
                if (!chartBackground) {
                    chart.chartBackground = chartBackground = renderer.rect().addClass('highcharts-background').add();
                    verb = 'attr'
                }
                if (!styledMode) {
                    chartBorderWidth = optionsChart.borderWidth || 0;
                    mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
                    bgAttr = {
                        fill: chartBackgroundColor || 'none'
                    };
                    if (chartBorderWidth || chartBackground['stroke-width']) {
                        bgAttr.stroke = optionsChart.borderColor;
                        bgAttr['stroke-width'] = chartBorderWidth
                    }
                    chartBackground.attr(bgAttr).shadow(optionsChart.shadow)
                } else {
                    chartBorderWidth = mgn = chartBackground.strokeWidth()
                }
                chartBackground[verb]({
                    x: mgn / 2,
                    y: mgn / 2,
                    width: chartWidth - mgn - chartBorderWidth % 2,
                    height: chartHeight - mgn - chartBorderWidth % 2,
                    r: optionsChart.borderRadius
                });
                verb = 'animate';
                if (!plotBackground) {
                    verb = 'attr';
                    chart.plotBackground = plotBackground = renderer.rect().addClass('highcharts-plot-background').add()
                }
                plotBackground[verb](plotBox);
                if (!styledMode) {
                    plotBackground.attr({
                        fill: plotBackgroundColor || 'none'
                    }).shadow(optionsChart.plotShadow);
                    if (plotBackgroundImage) {
                        if (!plotBGImage) {
                            chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add()
                        } else {
                            if (plotBackgroundImage !== plotBGImage.attr('href')) {
                                plotBGImage.attr('href', plotBackgroundImage)
                            }
                            plotBGImage.animate(plotBox)
                        }
                    }
                }
                if (!clipRect) {
                    chart.clipRect = renderer.clipRect(clipBox)
                } else {
                    clipRect.animate({
                        width: clipBox.width,
                        height: clipBox.height
                    })
                }
                verb = 'animate';
                if (!plotBorder) {
                    verb = 'attr';
                    chart.plotBorder = plotBorder = renderer.rect().addClass('highcharts-plot-border').attr({
                        zIndex: 1
                    }).add()
                }
                if (!styledMode) {
                    plotBorder.attr({
                        stroke: optionsChart.plotBorderColor,
                        'stroke-width': optionsChart.plotBorderWidth || 0,
                        fill: 'none'
                    })
                }
                plotBorder[verb](plotBorder.crisp({
                    x: plotLeft,
                    y: plotTop,
                    width: plotWidth,
                    height: plotHeight
                }, -plotBorder.strokeWidth()));
                chart.isDirtyBox = !1;
                fireEvent(this, 'afterDrawChartBox')
            }
            propFromSeries() {
                const chart = this
                    , optionsChart = chart.options.chart
                    , seriesOptions = chart.options.series;
                let i, klass, value;
                ['inverted', 'angular', 'polar'].forEach(function(key) {
                    klass = seriesTypes[optionsChart.type];
                    value = optionsChart[key] || (klass && klass.prototype[key]);
                    i = seriesOptions && seriesOptions.length;
                    while (!value && i--) {
                        klass = seriesTypes[seriesOptions[i].type];
                        if (klass && klass.prototype[key]) {
                            value = !0
                        }
                    }
                    chart[key] = value
                })
            }
            linkSeries(isUpdating) {
                const chart = this
                    , chartSeries = chart.series;
                chartSeries.forEach(function(series) {
                    series.linkedSeries.length = 0
                });
                chartSeries.forEach(function(series) {
                    let linkedTo = series.options.linkedTo;
                    if (isString(linkedTo)) {
                        if (linkedTo === ':previous') {
                            linkedTo = chart.series[series.index - 1]
                        } else {
                            linkedTo = chart.get(linkedTo)
                        }
                        if (linkedTo && linkedTo.linkedParent !== series) {
                            linkedTo.linkedSeries.push(series);
                            series.linkedParent = linkedTo;
                            if (linkedTo.enabledDataSorting) {
                                series.setDataSortingOptions()
                            }
                            series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible)
                        }
                    }
                });
                fireEvent(this, 'afterLinkSeries', {
                    isUpdating
                })
            }
            renderSeries() {
                this.series.forEach(function(serie) {
                    serie.translate();
                    serie.render()
                })
            }
            render() {
                const chart = this
                    , axes = chart.axes
                    , colorAxis = chart.colorAxis
                    , renderer = chart.renderer
                    , renderAxes = function(axes) {
                    axes.forEach(function(axis) {
                        if (axis.visible) {
                            axis.render()
                        }
                    })
                };
                let correction = 0;
                chart.setTitle();
                fireEvent(chart, 'beforeMargins');
                if (chart.getStacks) {
                    chart.getStacks()
                }
                chart.getMargins(!0);
                chart.setChartSize();
                const tempWidth = chart.plotWidth;
                axes.some(function(axis) {
                    if (axis.horiz && axis.visible && axis.options.labels.enabled && axis.series.length) {
                        correction = 21;
                        return !0
                    }
                });
                chart.plotHeight = Math.max(chart.plotHeight - correction, 0);
                const tempHeight = chart.plotHeight;
                axes.forEach(function(axis) {
                    axis.setScale()
                });
                chart.getAxisMargins();
                const redoHorizontal = tempWidth / chart.plotWidth > 1.1;
                const redoVertical = tempHeight / chart.plotHeight > 1.05;
                if (redoHorizontal || redoVertical) {
                    axes.forEach(function(axis) {
                        if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
                            axis.setTickInterval(!0)
                        }
                    });
                    chart.getMargins()
                }
                chart.drawChartBox();
                if (chart.hasCartesianSeries) {
                    renderAxes(axes)
                } else if (colorAxis && colorAxis.length) {
                    renderAxes(colorAxis)
                }
                if (!chart.seriesGroup) {
                    chart.seriesGroup = renderer.g('series-group').attr({
                        zIndex: 3
                    }).shadow(chart.options.chart.seriesGroupShadow).add()
                }
                chart.renderSeries();
                chart.addCredits();
                if (chart.setResponsive) {
                    chart.setResponsive()
                }
                chart.hasRendered = !0
            }
            addCredits(credits) {
                const chart = this
                    , creds = merge(!0, this.options.credits, credits);
                if (creds.enabled && !this.credits) {
                    this.credits = this.renderer.text(creds.text + (this.mapCredits || ''), 0, 0).addClass('highcharts-credits').on('click', function() {
                        if (creds.href) {
                            win.location.href = creds.href
                        }
                    }).attr({
                        align: creds.position.align,
                        zIndex: 8
                    });
                    if (!chart.styledMode) {
                        this.credits.css(creds.style)
                    }
                    this.credits.add().align(creds.position);
                    this.credits.update = function(options) {
                        chart.credits = chart.credits.destroy();
                        chart.addCredits(options)
                    }
                }
            }
            destroy() {
                const chart = this
                    , axes = chart.axes
                    , series = chart.series
                    , container = chart.container
                    , parentNode = container && container.parentNode;
                let i;
                fireEvent(chart, 'destroy');
                if (chart.renderer.forExport) {
                    erase(charts, chart)
                } else {
                    charts[chart.index] = void 0
                }
                H.chartCount--;
                chart.renderTo.removeAttribute('data-highcharts-chart');
                removeEvent(chart);
                i = axes.length;
                while (i--) {
                    axes[i] = axes[i].destroy()
                }
                if (this.scroller && this.scroller.destroy) {
                    this.scroller.destroy()
                }
                i = series.length;
                while (i--) {
                    series[i] = series[i].destroy()
                }
                ['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'].forEach(function(name) {
                    const prop = chart[name];
                    if (prop && prop.destroy) {
                        chart[name] = prop.destroy()
                    }
                });
                if (container) {
                    container.innerHTML = AST.emptyHTML;
                    removeEvent(container);
                    if (parentNode) {
                        discardElement(container)
                    }
                }
                objectEach(chart, function(val, key) {
                    delete chart[key]
                })
            }
            firstRender() {
                const chart = this
                    , options = chart.options;
                chart.getContainer();
                chart.resetMargins();
                chart.setChartSize();
                chart.propFromSeries();
                chart.getAxes();
                const series = isArray(options.series) ? options.series : [];
                options.series = [];
                series.forEach(function(serieOptions) {
                    chart.initSeries(serieOptions)
                });
                chart.linkSeries();
                chart.setSeriesData();
                fireEvent(chart, 'beforeRender');
                chart.render();
                chart.pointer.getChartPosition();
                if (!chart.renderer.imgCount && !chart.hasLoaded) {
                    chart.onload()
                }
                chart.temporaryDisplay(!0)
            }
            onload() {
                this.callbacks.concat([this.callback]).forEach(function(fn) {
                    if (fn && typeof this.index !== 'undefined') {
                        fn.apply(this, [this])
                    }
                }, this);
                fireEvent(this, 'load');
                fireEvent(this, 'render');
                if (defined(this.index)) {
                    this.setReflow()
                }
                this.warnIfA11yModuleNotLoaded();
                this.hasLoaded = !0
            }
            warnIfA11yModuleNotLoaded() {
                const {options, title} = this;
                if (options && !this.accessibility) {
                    this.renderer.boxWrapper.attr({
                        role: 'img',
                        'aria-label': ((title && title.element.textContent) || '').replace(/</g, '&lt;')
                    });
                    if (!(options.accessibility && options.accessibility.enabled === !1)) {
                        error('Highcharts warning: Consider including the ' + '"accessibility.js" module to make your chart more ' + 'usable for people with disabilities. Set the ' + '"accessibility.enabled" option to false to remove this ' + 'warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this)
                    }
                }
            }
            addSeries(options, redraw, animation) {
                const chart = this;
                let series;
                if (options) {
                    redraw = pick(redraw, !0);
                    fireEvent(chart, 'addSeries', {
                        options: options
                    }, function() {
                        series = chart.initSeries(options);
                        chart.isDirtyLegend = !0;
                        chart.linkSeries();
                        if (series.enabledDataSorting) {
                            series.setData(options.data, !1)
                        }
                        fireEvent(chart, 'afterAddSeries', {
                            series: series
                        });
                        if (redraw) {
                            chart.redraw(animation)
                        }
                    })
                }
                return series
            }
            addAxis(options, isX, redraw, animation) {
                return this.createAxis(isX ? 'xAxis' : 'yAxis', {
                    axis: options,
                    redraw: redraw,
                    animation: animation
                })
            }
            addColorAxis(options, redraw, animation) {
                return this.createAxis('colorAxis', {
                    axis: options,
                    redraw: redraw,
                    animation: animation
                })
            }
            createAxis(coll, options) {
                const axis = new Axis(this,options.axis,coll);
                if (pick(options.redraw, !0)) {
                    this.redraw(options.animation)
                }
                return axis
            }
            showLoading(str) {
                const chart = this
                    , options = chart.options
                    , loadingOptions = options.loading
                    , setLoadingSize = function() {
                    if (loadingDiv) {
                        css(loadingDiv, {
                            left: chart.plotLeft + 'px',
                            top: chart.plotTop + 'px',
                            width: chart.plotWidth + 'px',
                            height: chart.plotHeight + 'px'
                        })
                    }
                };
                let loadingDiv = chart.loadingDiv
                    , loadingSpan = chart.loadingSpan;
                if (!loadingDiv) {
                    chart.loadingDiv = loadingDiv = createElement('div', {
                        className: 'highcharts-loading highcharts-loading-hidden'
                    }, null, chart.container)
                }
                if (!loadingSpan) {
                    chart.loadingSpan = loadingSpan = createElement('span', {
                        className: 'highcharts-loading-inner'
                    }, null, loadingDiv);
                    addEvent(chart, 'redraw', setLoadingSize)
                }
                loadingDiv.className = 'highcharts-loading';
                AST.setElementHTML(loadingSpan, pick(str, options.lang.loading, ''));
                if (!chart.styledMode) {
                    css(loadingDiv, extend(loadingOptions.style, {
                        zIndex: 10
                    }));
                    css(loadingSpan, loadingOptions.labelStyle);
                    if (!chart.loadingShown) {
                        css(loadingDiv, {
                            opacity: 0,
                            display: ''
                        });
                        animate(loadingDiv, {
                            opacity: loadingOptions.style.opacity || 0.5
                        }, {
                            duration: loadingOptions.showDuration || 0
                        })
                    }
                }
                chart.loadingShown = !0;
                setLoadingSize()
            }
            hideLoading() {
                const options = this.options
                    , loadingDiv = this.loadingDiv;
                if (loadingDiv) {
                    loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';
                    if (!this.styledMode) {
                        animate(loadingDiv, {
                            opacity: 0
                        }, {
                            duration: options.loading.hideDuration || 100,
                            complete: function() {
                                css(loadingDiv, {
                                    display: 'none'
                                })
                            }
                        })
                    }
                }
                this.loadingShown = !1
            }
            update(options, redraw, oneToOne, animation) {
                const chart = this
                    , adders = {
                    credits: 'addCredits',
                    title: 'setTitle',
                    subtitle: 'setSubtitle',
                    caption: 'setCaption'
                }
                    , isResponsiveOptions = options.isResponsiveOptions
                    , itemsForRemoval = [];
                let updateAllAxes, updateAllSeries, runSetSize;
                fireEvent(chart, 'update', {
                    options: options
                });
                if (!isResponsiveOptions) {
                    chart.setResponsive(!1, !0)
                }
                options = diffObjects(options, chart.options);
                chart.userOptions = merge(chart.userOptions, options);
                const optionsChart = options.chart;
                if (optionsChart) {
                    merge(!0, chart.options.chart, optionsChart);
                    this.setZoomOptions();
                    if ('className'in optionsChart) {
                        chart.setClassName(optionsChart.className)
                    }
                    if ('inverted'in optionsChart || 'polar'in optionsChart || 'type'in optionsChart) {
                        chart.propFromSeries();
                        updateAllAxes = !0
                    }
                    if ('alignTicks'in optionsChart) {
                        updateAllAxes = !0
                    }
                    if ('events'in optionsChart) {
                        registerEventOptions(this, optionsChart)
                    }
                    objectEach(optionsChart, function(val, key) {
                        if (chart.propsRequireUpdateSeries.indexOf('chart.' + key) !== -1) {
                            updateAllSeries = !0
                        }
                        if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
                            chart.isDirtyBox = !0
                        }
                        if (chart.propsRequireReflow.indexOf(key) !== -1) {
                            if (isResponsiveOptions) {
                                chart.isDirtyBox = !0
                            } else {
                                runSetSize = !0
                            }
                        }
                    });
                    if (!chart.styledMode && optionsChart.style) {
                        chart.renderer.setStyle(chart.options.chart.style || {})
                    }
                }
                if (!chart.styledMode && options.colors) {
                    this.options.colors = options.colors
                }
                if (options.time) {
                    if (this.time === defaultTime) {
                        this.time = new Time(options.time)
                    }
                    merge(!0, chart.options.time, options.time)
                }
                objectEach(options, function(val, key) {
                    if (chart[key] && typeof chart[key].update === 'function') {
                        chart[key].update(val, !1)
                    } else if (typeof chart[adders[key]] === 'function') {
                        chart[adders[key]](val)
                    } else if (key !== 'colors' && chart.collectionsWithUpdate.indexOf(key) === -1) {
                        merge(!0, chart.options[key], options[key])
                    }
                    if (key !== 'chart' && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
                        updateAllSeries = !0
                    }
                });
                this.collectionsWithUpdate.forEach(function(coll) {
                    if (options[coll]) {
                        splat(options[coll]).forEach(function(newOptions, i) {
                            const hasId = defined(newOptions.id);
                            let item;
                            if (hasId) {
                                item = chart.get(newOptions.id)
                            }
                            if (!item && chart[coll]) {
                                item = chart[coll][pick(newOptions.index, i)];
                                if (item && ((hasId && defined(item.options.id)) || item.options.isInternal)) {
                                    item = void 0
                                }
                            }
                            if (item && item.coll === coll) {
                                item.update(newOptions, !1);
                                if (oneToOne) {
                                    item.touched = !0
                                }
                            }
                            if (!item && oneToOne && chart.collectionsWithInit[coll]) {
                                chart.collectionsWithInit[coll][0].apply(chart, [newOptions].concat(chart.collectionsWithInit[coll][1] || []).concat([!1])).touched = !0
                            }
                        });
                        if (oneToOne) {
                            chart[coll].forEach(function(item) {
                                if (!item.touched && !item.options.isInternal) {
                                    itemsForRemoval.push(item)
                                } else {
                                    delete item.touched
                                }
                            })
                        }
                    }
                });
                itemsForRemoval.forEach(function(item) {
                    if (item.chart && item.remove) {
                        item.remove(!1)
                    }
                });
                if (updateAllAxes) {
                    chart.axes.forEach(function(axis) {
                        axis.update({}, !1)
                    })
                }
                if (updateAllSeries) {
                    chart.getSeriesOrderByLinks().forEach(function(series) {
                        if (series.chart) {
                            series.update({}, !1)
                        }
                    }, this)
                }
                const newWidth = optionsChart && optionsChart.width;
                const newHeight = optionsChart && (isString(optionsChart.height) ? relativeLength(optionsChart.height, newWidth || chart.chartWidth) : optionsChart.height);
                if (runSetSize || (isNumber(newWidth) && newWidth !== chart.chartWidth) || (isNumber(newHeight) && newHeight !== chart.chartHeight)) {
                    chart.setSize(newWidth, newHeight, animation)
                } else if (pick(redraw, !0)) {
                    chart.redraw(animation)
                }
                fireEvent(chart, 'afterUpdate', {
                    options: options,
                    redraw: redraw,
                    animation: animation
                })
            }
            setSubtitle(options, redraw) {
                this.applyDescription('subtitle', options);
                this.layOutTitles(redraw)
            }
            setCaption(options, redraw) {
                this.applyDescription('caption', options);
                this.layOutTitles(redraw)
            }
            showResetZoom() {
                const chart = this
                    , lang = defaultOptions.lang
                    , btnOptions = chart.zooming.resetButton
                    , theme = btnOptions.theme
                    , alignTo = (btnOptions.relativeTo === 'chart' || btnOptions.relativeTo === 'spacingBox' ? null : 'scrollablePlotBox');
                function zoomOut() {
                    chart.zoomOut()
                }
                fireEvent(this, 'beforeShowResetZoom', null, function() {
                    chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme).attr({
                        align: btnOptions.position.align,
                        title: lang.resetZoomTitle
                    }).addClass('highcharts-reset-zoom').add().align(btnOptions.position, !1, alignTo)
                });
                fireEvent(this, 'afterShowResetZoom')
            }
            zoomOut() {
                fireEvent(this, 'selection', {
                    resetSelection: !0
                }, this.zoom)
            }
            zoom(event) {
                const chart = this
                    , pointer = chart.pointer;
                let displayButton = !1, hasZoomed;
                if (!event || event.resetSelection) {
                    chart.axes.forEach(function(axis) {
                        hasZoomed = axis.zoom()
                    });
                    pointer.initiated = !1
                } else {
                    event.xAxis.concat(event.yAxis).forEach(function(axisData) {
                        const axis = axisData.axis
                            , isXAxis = axis.isXAxis
                            , {hasPinched, mouseDownX, mouseDownY} = pointer;
                        if (pointer[isXAxis ? 'zoomX' : 'zoomY'] && (defined(mouseDownX) && defined(mouseDownY) && chart.isInsidePlot(mouseDownX - chart.plotLeft, mouseDownY - chart.plotTop, {
                            axis,
                            ignoreX: hasPinched,
                            ignoreY: hasPinched
                        })) || !defined(chart.inverted ? mouseDownX : mouseDownY)) {
                            hasZoomed = axis.zoom(axisData.min, axisData.max);
                            if (axis.displayBtn) {
                                displayButton = !0
                            }
                        }
                    })
                }
                const resetZoomButton = chart.resetZoomButton;
                if (displayButton && !resetZoomButton) {
                    chart.showResetZoom()
                } else if (!displayButton && isObject(resetZoomButton)) {
                    chart.resetZoomButton = resetZoomButton.destroy()
                }
                if (hasZoomed) {
                    chart.redraw(pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100))
                }
            }
            pan(e, panning) {
                const chart = this
                    , hoverPoints = chart.hoverPoints
                    , panningOptions = (typeof panning === 'object' ? panning : {
                    enabled: panning,
                    type: 'x'
                })
                    , chartOptions = chart.options.chart;
                if (chartOptions && chartOptions.panning) {
                    chartOptions.panning = panningOptions
                }
                const type = panningOptions.type;
                let doRedraw;
                fireEvent(this, 'pan', {
                    originalEvent: e
                }, function() {
                    if (hoverPoints) {
                        hoverPoints.forEach(function(point) {
                            point.setState()
                        })
                    }
                    let axes = chart.xAxis;
                    if (type === 'xy') {
                        axes = axes.concat(chart.yAxis)
                    } else if (type === 'y') {
                        axes = chart.yAxis
                    }
                    const nextMousePos = {};
                    axes.forEach(function(axis) {
                        if (!axis.options.panningEnabled || axis.options.isInternal) {
                            return
                        }
                        const horiz = axis.horiz
                            , mousePos = e[horiz ? 'chartX' : 'chartY']
                            , mouseDown = horiz ? 'mouseDownX' : 'mouseDownY'
                            , startPos = chart[mouseDown]
                            , halfPointRange = axis.minPointOffset || 0
                            , pointRangeDirection = (axis.reversed && !chart.inverted) || (!axis.reversed && chart.inverted) ? -1 : 1
                            , extremes = axis.getExtremes()
                            , panMin = axis.toValue(startPos - mousePos, !0) + halfPointRange * pointRangeDirection
                            , panMax = axis.toValue(startPos + axis.len - mousePos, !0) - ((halfPointRange * pointRangeDirection) || (axis.isXAxis && axis.pointRangePadding) || 0)
                            , flipped = panMax < panMin
                            , hasVerticalPanning = axis.hasVerticalPanning();
                        let newMin = flipped ? panMax : panMin, newMax = flipped ? panMin : panMax, panningState = axis.panningState, spill;
                        if (hasVerticalPanning && !axis.isXAxis && (!panningState || panningState.isDirty)) {
                            axis.series.forEach(function(series) {
                                const processedData = series.getProcessedData(!0)
                                    , dataExtremes = series.getExtremes(processedData.yData, !0);
                                if (!panningState) {
                                    panningState = {
                                        startMin: Number.MAX_VALUE,
                                        startMax: -Number.MAX_VALUE
                                    }
                                }
                                if (isNumber(dataExtremes.dataMin) && isNumber(dataExtremes.dataMax)) {
                                    panningState.startMin = Math.min(pick(series.options.threshold, Infinity), dataExtremes.dataMin, panningState.startMin);
                                    panningState.startMax = Math.max(pick(series.options.threshold, -Infinity), dataExtremes.dataMax, panningState.startMax)
                                }
                            })
                        }
                        const paddedMin = Math.min(pick(panningState && panningState.startMin, extremes.dataMin), halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding));
                        const paddedMax = Math.max(pick(panningState && panningState.startMax, extremes.dataMax), halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding));
                        axis.panningState = panningState;
                        if (!axis.isOrdinal) {
                            spill = paddedMin - newMin;
                            if (spill > 0) {
                                newMax += spill;
                                newMin = paddedMin
                            }
                            spill = newMax - paddedMax;
                            if (spill > 0) {
                                newMax = paddedMax;
                                newMin -= spill
                            }
                            if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max && newMin >= paddedMin && newMax <= paddedMax) {
                                axis.setExtremes(newMin, newMax, !1, !1, {
                                    trigger: 'pan'
                                });
                                if (!chart.resetZoomButton && newMin !== paddedMin && newMax !== paddedMax && type.match('y')) {
                                    chart.showResetZoom();
                                    axis.displayBtn = !1
                                }
                                doRedraw = !0
                            }
                            nextMousePos[mouseDown] = mousePos
                        }
                    });
                    objectEach(nextMousePos, (pos, down) => {
                            chart[down] = pos
                        }
                    );
                    if (doRedraw) {
                        chart.redraw(!1)
                    }
                    css(chart.container, {
                        cursor: 'move'
                    })
                })
            }
        }
        extend(Chart.prototype, {
            callbacks: [],
            collectionsWithInit: {
                xAxis: [Chart.prototype.addAxis, [!0]],
                yAxis: [Chart.prototype.addAxis, [!1]],
                series: [Chart.prototype.addSeries]
            },
            collectionsWithUpdate: ['xAxis', 'yAxis', 'series'],
            propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth', 'plotShadow', 'shadow'],
            propsRequireReflow: ['margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft'],
            propsRequireUpdateSeries: ['chart.inverted', 'chart.polar', 'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions', 'time', 'tooltip']
        });
        '';
        return Chart
    });
    _registerModule(_modules, 'Extensions/ScrollablePlotArea.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Axis/Axis.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Series/Series.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Utilities.js']], function(A, Axis, Chart, Series, RendererRegistry, U) {
        const {stop} = A;
        const {addEvent, createElement, defined, merge, pick} = U;
        addEvent(Chart, 'afterSetChartSize', function(e) {
            let scrollablePlotArea = this.options.chart.scrollablePlotArea, scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth, scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight, scrollablePixelsX, scrollablePixelsY, corrections;
            if (!this.renderer.forExport) {
                if (scrollableMinWidth) {
                    this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);
                    if (scrollablePixelsX) {
                        this.scrollablePlotBox = (this.renderer.scrollablePlotBox = merge(this.plotBox));
                        this.plotBox.width = this.plotWidth += scrollablePixelsX;
                        if (this.inverted) {
                            this.clipBox.height += scrollablePixelsX
                        } else {
                            this.clipBox.width += scrollablePixelsX
                        }
                        corrections = {
                            1: {
                                name: 'right',
                                value: scrollablePixelsX
                            }
                        }
                    }
                } else if (scrollableMinHeight) {
                    this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);
                    if (defined(scrollablePixelsY)) {
                        this.scrollablePlotBox = (this.renderer.scrollablePlotBox = merge(this.plotBox));
                        this.plotBox.height = this.plotHeight += scrollablePixelsY;
                        if (this.inverted) {
                            this.clipBox.width += scrollablePixelsY
                        } else {
                            this.clipBox.height += scrollablePixelsY
                        }
                        corrections = {
                            2: {
                                name: 'bottom',
                                value: scrollablePixelsY
                            }
                        }
                    }
                }
                if (corrections && !e.skipAxes) {
                    this.axes.forEach(function(axis) {
                        if (corrections[axis.side]) {
                            axis.getPlotLinePath = function() {
                                let marginName = corrections[axis.side].name, correctionValue = corrections[axis.side].value, margin = this[marginName], path;
                                this[marginName] = margin - correctionValue;
                                path = Axis.prototype.getPlotLinePath.apply(this, arguments);
                                this[marginName] = margin;
                                return path
                            }
                        } else {
                            axis.setAxisSize();
                            axis.setAxisTranslation()
                        }
                    })
                }
            }
        });
        addEvent(Chart, 'render', function() {
            if (this.scrollablePixelsX || this.scrollablePixelsY) {
                if (this.setUpScrolling) {
                    this.setUpScrolling()
                }
                this.applyFixed()
            } else if (this.fixedDiv) {
                this.applyFixed()
            }
        });
        Chart.prototype.setUpScrolling = function() {
            const css = {
                WebkitOverflowScrolling: 'touch',
                overflowX: 'hidden',
                overflowY: 'hidden'
            };
            if (this.scrollablePixelsX) {
                css.overflowX = 'auto'
            }
            if (this.scrollablePixelsY) {
                css.overflowY = 'auto'
            }
            this.scrollingParent = createElement('div', {
                className: 'highcharts-scrolling-parent'
            }, {
                position: 'relative'
            }, this.renderTo);
            this.scrollingContainer = createElement('div', {
                'className': 'highcharts-scrolling'
            }, css, this.scrollingParent);
            let lastHoverPoint;
            addEvent(this.scrollingContainer, 'scroll', () => {
                    if (this.pointer) {
                        delete this.pointer.chartPosition;
                        if (this.hoverPoint) {
                            lastHoverPoint = this.hoverPoint
                        }
                        this.pointer.runPointActions(void 0, lastHoverPoint, !0)
                    }
                }
            );
            this.innerContainer = createElement('div', {
                'className': 'highcharts-inner-container'
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null
        }
        ;
        Chart.prototype.moveFixedElements = function() {
            let container = this.container, fixedRenderer = this.fixedRenderer, fixedSelectors = ['.highcharts-breadcrumbs-group', '.highcharts-contextbutton', '.highcharts-credits', '.highcharts-legend', '.highcharts-legend-checkbox', '.highcharts-navigator-series', '.highcharts-navigator-xaxis', '.highcharts-navigator-yaxis', '.highcharts-navigator', '.highcharts-reset-zoom', '.highcharts-drillup-button', '.highcharts-scrollbar', '.highcharts-subtitle', '.highcharts-title'], axisClass;
            if (this.scrollablePixelsX && !this.inverted) {
                axisClass = '.highcharts-yaxis'
            } else if (this.scrollablePixelsX && this.inverted) {
                axisClass = '.highcharts-xaxis'
            } else if (this.scrollablePixelsY && !this.inverted) {
                axisClass = '.highcharts-xaxis'
            } else if (this.scrollablePixelsY && this.inverted) {
                axisClass = '.highcharts-yaxis'
            }
            if (axisClass) {
                fixedSelectors.push(`${axisClass}:not(.highcharts-radial-axis)`, `${axisClass}-labels:not(.highcharts-radial-axis-labels)`)
            }
            fixedSelectors.forEach(function(className) {
                [].forEach.call(container.querySelectorAll(className), function(elem) {
                    (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
                    elem.style.pointerEvents = 'auto'
                })
            })
        }
        ;
        Chart.prototype.applyFixed = function() {
            const firstTime = !this.fixedDiv
                , chartOptions = this.options.chart
                , scrollableOptions = chartOptions.scrollablePlotArea
                , Renderer = RendererRegistry.getRendererType();
            let fixedRenderer, scrollableWidth, scrollableHeight;
            if (firstTime) {
                this.fixedDiv = createElement('div', {
                    className: 'highcharts-fixed'
                }, {
                    position: 'absolute',
                    overflow: 'hidden',
                    pointerEvents: 'none',
                    zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,
                    top: 0
                }, null, !0);
                if (this.scrollingContainer) {
                    this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer)
                }
                this.renderTo.style.overflow = 'visible';
                this.fixedRenderer = fixedRenderer = new Renderer(this.fixedDiv,this.chartWidth,this.chartHeight,this.options.chart.style);
                this.scrollableMask = fixedRenderer.path().attr({
                    fill: this.options.chart.backgroundColor || '#fff',
                    'fill-opacity': pick(scrollableOptions.opacity, 0.85),
                    zIndex: -1
                }).addClass('highcharts-scrollable-mask').add();
                addEvent(this, 'afterShowResetZoom', this.moveFixedElements);
                addEvent(this, 'afterApplyDrilldown', this.moveFixedElements);
                addEvent(this, 'afterLayOutTitles', this.moveFixedElements)
            } else {
                this.fixedRenderer.setSize(this.chartWidth, this.chartHeight)
            }
            if (this.scrollableDirty || firstTime) {
                this.scrollableDirty = !1;
                this.moveFixedElements()
            }
            scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);
            scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);
            stop(this.container);
            this.container.style.width = scrollableWidth + 'px';
            this.container.style.height = scrollableHeight + 'px';
            this.renderer.boxWrapper.attr({
                width: scrollableWidth,
                height: scrollableHeight,
                viewBox: [0, 0, scrollableWidth, scrollableHeight].join(' ')
            });
            this.chartBackground.attr({
                width: scrollableWidth,
                height: scrollableHeight
            });
            this.scrollingContainer.style.height = this.chartHeight + 'px';
            if (firstTime) {
                if (scrollableOptions.scrollPositionX) {
                    this.scrollingContainer.scrollLeft = this.scrollablePixelsX * scrollableOptions.scrollPositionX
                }
                if (scrollableOptions.scrollPositionY) {
                    this.scrollingContainer.scrollTop = this.scrollablePixelsY * scrollableOptions.scrollPositionY
                }
            }
            let axisOffset = this.axisOffset, maskTop = this.plotTop - axisOffset[0] - 1, maskLeft = this.plotLeft - axisOffset[3] - 1, maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1, maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1, maskPlotRight = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), maskPlotBottom = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), d;
            if (this.scrollablePixelsX) {
                d = [['M', 0, maskTop], ['L', this.plotLeft - 1, maskTop], ['L', this.plotLeft - 1, maskBottom], ['L', 0, maskBottom], ['Z'], ['M', maskPlotRight, maskTop], ['L', this.chartWidth, maskTop], ['L', this.chartWidth, maskBottom], ['L', maskPlotRight, maskBottom], ['Z']]
            } else if (this.scrollablePixelsY) {
                d = [['M', maskLeft, 0], ['L', maskLeft, this.plotTop - 1], ['L', maskRight, this.plotTop - 1], ['L', maskRight, 0], ['Z'], ['M', maskLeft, maskPlotBottom], ['L', maskLeft, this.chartHeight], ['L', maskRight, this.chartHeight], ['L', maskRight, maskPlotBottom], ['Z']]
            } else {
                d = [['M', 0, 0]]
            }
            if (this.redrawTrigger !== 'adjustHeight') {
                this.scrollableMask.attr({
                    d
                })
            }
        }
        ;
        addEvent(Axis, 'afterInit', function() {
            this.chart.scrollableDirty = !0
        });
        addEvent(Series, 'show', function() {
            this.chart.scrollableDirty = !0
        });
        ('')
    });
    _registerModule(_modules, 'Core/Axis/Stacking/StackItem.js', [_modules['Core/Templating.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(T, SeriesRegistry, U) {
        const {format} = T;
        const {series: Series} = SeriesRegistry;
        const {destroyObjectProperties, fireEvent, isNumber, pick} = U;
        class StackItem {
            constructor(axis, options, negativeValue, x, stackOption) {
                const inverted = axis.chart.inverted
                    , reversed = axis.reversed;
                this.axis = axis;
                const isNegative = (this.isNegative = !!negativeValue !== !!reversed);
                this.options = options = options || {};
                this.x = x;
                this.total = null;
                this.cumulative = null;
                this.points = {};
                this.hasValidPoints = !1;
                this.stack = stackOption;
                this.leftCliff = 0;
                this.rightCliff = 0;
                this.alignOptions = {
                    align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
                    verticalAlign: options.verticalAlign || (inverted ? 'middle' : isNegative ? 'bottom' : 'top'),
                    y: options.y,
                    x: options.x
                };
                this.textAlign = options.textAlign || (inverted ? (!isNegative ? 'left' : 'right') : 'center')
            }
            destroy() {
                destroyObjectProperties(this, this.axis)
            }
            render(group) {
                const chart = this.axis.chart
                    , options = this.options
                    , formatOption = options.format
                    , str = formatOption ? format(formatOption, this, chart) : options.formatter.call(this);
                if (this.label) {
                    this.label.attr({
                        text: str,
                        visibility: 'hidden'
                    })
                } else {
                    this.label = chart.renderer.label(str, null, void 0, options.shape, void 0, void 0, options.useHTML, !1, 'stack-labels');
                    const attr = {
                        r: options.borderRadius || 0,
                        text: str,
                        padding: pick(options.padding, 5),
                        visibility: 'hidden'
                    };
                    if (!chart.styledMode) {
                        attr.fill = options.backgroundColor;
                        attr.stroke = options.borderColor;
                        attr['stroke-width'] = options.borderWidth;
                        this.label.css(options.style || {})
                    }
                    this.label.attr(attr);
                    if (!this.label.added) {
                        this.label.add(group)
                    }
                }
                this.label.labelrank = chart.plotSizeY;
                fireEvent(this, 'afterRender')
            }
            setOffset(xOffset, width, boxBottom, boxTop, defaultX, xAxis) {
                const {alignOptions, axis, label, options, textAlign} = this
                    , chart = axis.chart
                    , stackBox = this.getStackBox({
                    xOffset,
                    width,
                    boxBottom,
                    boxTop,
                    defaultX,
                    xAxis
                })
                    , {verticalAlign} = alignOptions;
                if (label && stackBox) {
                    const labelBox = label.getBBox()
                        , padding = label.padding;
                    let isJustify = pick(options.overflow, 'justify') === 'justify', visible;
                    alignOptions.x = options.x || 0;
                    alignOptions.y = options.y || 0;
                    const {x, y} = this.adjustStackPosition({
                        labelBox,
                        verticalAlign,
                        textAlign
                    });
                    stackBox.x -= x;
                    stackBox.y -= y;
                    label.align(alignOptions, !1, stackBox);
                    visible = chart.isInsidePlot(label.alignAttr.x + alignOptions.x + x, label.alignAttr.y + alignOptions.y + y);
                    if (!visible) {
                        isJustify = !1
                    }
                    if (isJustify) {
                        Series.prototype.justifyDataLabel.call(axis, label, alignOptions, label.alignAttr, labelBox, stackBox)
                    }
                    label.attr({
                        x: label.alignAttr.x,
                        y: label.alignAttr.y,
                        rotation: options.rotation,
                        rotationOriginX: labelBox.width / 2,
                        rotationOriginY: labelBox.height / 2
                    });
                    if (pick(!isJustify && options.crop, !0)) {
                        visible = isNumber(label.x) && isNumber(label.y) && chart.isInsidePlot(label.x - padding + (label.width || 0), label.y) && chart.isInsidePlot(label.x + padding, label.y)
                    }
                    label[visible ? 'show' : 'hide']()
                }
                fireEvent(this, 'afterSetOffset', {
                    xOffset,
                    width
                })
            }
            adjustStackPosition({labelBox, verticalAlign, textAlign}) {
                const factorMap = {
                    bottom: 0,
                    middle: 1,
                    top: 2,
                    right: 1,
                    center: 0,
                    left: -1
                }
                    , verticalAlignFactor = factorMap[verticalAlign]
                    , textAlignFactor = factorMap[textAlign];
                return {
                    x: labelBox.width / 2 + (labelBox.width / 2) * textAlignFactor,
                    y: (labelBox.height / 2) * verticalAlignFactor
                }
            }
            getStackBox(stackBoxProps) {
                const stackItem = this
                    , axis = this.axis
                    , chart = axis.chart
                    , {boxTop, defaultX, xOffset, width, boxBottom} = stackBoxProps
                    , totalStackValue = axis.stacking.usePercentage ? 100 : pick(boxTop, this.total, 0)
                    , y = axis.toPixels(totalStackValue)
                    , xAxis = stackBoxProps.xAxis || chart.xAxis[0]
                    , x = pick(defaultX, xAxis.translate(this.x)) + xOffset
                    , yZero = axis.toPixels(boxBottom || (isNumber(axis.min) && axis.logarithmic && axis.logarithmic.lin2log(axis.min)) || 0)
                    , height = Math.abs(y - yZero)
                    , inverted = chart.inverted
                    , neg = stackItem.isNegative;
                return inverted ? {
                    x: (neg ? y : y - height) - chart.plotLeft,
                    y: xAxis.height - x - width,
                    width: height,
                    height: width
                } : {
                    x: x + xAxis.transB - chart.plotLeft,
                    y: (neg ? y - height : y) - chart.plotTop,
                    width: width,
                    height: height
                }
            }
        }
        '';
        return StackItem
    });
    _registerModule(_modules, 'Core/Axis/Stacking/StackingAxis.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Axis/Axis.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function(A, Axis, SeriesRegistry, StackItem, U) {
        const {getDeferredAnimation} = A;
        const {series: {prototype: seriesProto}} = SeriesRegistry;
        const {addEvent, correctFloat, defined, destroyObjectProperties, fireEvent, isArray, isNumber, objectEach, pick} = U;
        function chartGetStacks() {
            const chart = this
                , inverted = chart.inverted;
            chart.axes.forEach( (axis) => {
                    if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {
                        axis.stacking.oldStacks = axis.stacking.stacks
                    }
                }
            );
            chart.series.forEach( (series) => {
                    const xAxisOptions = series.xAxis && series.xAxis.options || {};
                    if (series.options.stacking && series.reserveSpace()) {
                        series.stackKey = [series.type, pick(series.options.stack, ''), inverted ? xAxisOptions.top : xAxisOptions.left, inverted ? xAxisOptions.height : xAxisOptions.width].join(',')
                    }
                }
            )
        }
        function onAxisDestroy() {
            const stacking = this.stacking;
            if (stacking) {
                const stacks = stacking.stacks;
                objectEach(stacks, (stack, stackKey) => {
                        destroyObjectProperties(stack);
                        delete stacks[stackKey]
                    }
                );
                stacking.stackTotalGroup?.destroy()
            }
        }
        function onAxisInit() {
            if (!this.stacking) {
                this.stacking = new AxisAdditions(this)
            }
        }
        function seriesGetStackIndicator(stackIndicator, x, index, key) {
            if (!defined(stackIndicator) || stackIndicator.x !== x || (key && stackIndicator.stackKey !== key)) {
                stackIndicator = {
                    x: x,
                    index: 0,
                    key,
                    stackKey: key
                }
            } else {
                stackIndicator.index++
            }
            stackIndicator.key = [index, x, stackIndicator.index].join(',');
            return stackIndicator
        }
        function seriesModifyStacks() {
            const series = this
                , yAxis = series.yAxis
                , stackKey = series.stackKey || ''
                , stacks = yAxis.stacking.stacks
                , processedXData = series.processedXData
                , stacking = series.options.stacking
                , stacker = series[stacking + 'Stacker'];
            let stackIndicator;
            if (stacker) {
                [stackKey, '-' + stackKey].forEach( (key) => {
                        let i = processedXData.length, x, stackItem, pointExtremes;
                        while (i--) {
                            x = processedXData[i];
                            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
                            stackItem = stacks[key]?.[x];
                            pointExtremes = stackItem?.points[stackIndicator.key || ''];
                            if (pointExtremes) {
                                stacker.call(series, pointExtremes, stackItem, i)
                            }
                        }
                    }
                )
            }
        }
        function seriesPercentStacker(pointExtremes, stack, i) {
            const totalFactor = stack.total ? 100 / stack.total : 0;
            pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);
            pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);
            this.stackedYData[i] = pointExtremes[1]
        }
        function seriesSetGroupedPoints(axis) {
            if (this.options.centerInCategory && (this.is('column') || this.is('columnrange')) && !this.options.stacking && this.chart.series.length > 1) {
                seriesProto.setStackedPoints.call(this, axis, 'group')
            } else {
                axis.stacking.resetStacks()
            }
        }
        function seriesSetStackedPoints(axis, stackingParam) {
            const type = stackingParam || this.options.stacking;
            if (!type || !this.reserveSpace() || ({
                group: 'xAxis'
            }[type] || 'yAxis') !== axis.coll) {
                return
            }
            const series = this
                , xData = series.processedXData
                , yData = series.processedYData
                , stackedYData = []
                , yDataLength = yData.length
                , seriesOptions = series.options
                , threshold = seriesOptions.threshold || 0
                , stackThreshold = seriesOptions.startFromThreshold ? threshold : 0
                , stackOption = seriesOptions.stack
                , stackKey = stackingParam ? `${series.type},${type}` : (series.stackKey || '')
                , negKey = '-' + stackKey
                , negStacks = series.negStacks
                , stacking = axis.stacking
                , stacks = stacking.stacks
                , oldStacks = stacking.oldStacks;
            let stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;
            stacking.stacksTouched += 1;
            for (i = 0; i < yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
                pointKey = stackIndicator.key || '';
                isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
                key = isNegative ? negKey : stackKey;
                if (!stacks[key]) {
                    stacks[key] = {}
                }
                if (!stacks[key][x]) {
                    if (oldStacks[key]?.[x]) {
                        stacks[key][x] = oldStacks[key][x];
                        stacks[key][x].total = null
                    } else {
                        stacks[key][x] = new StackItem(axis,axis.options.stackLabels,!!isNegative,x,stackOption)
                    }
                }
                stack = stacks[key][x];
                if (y !== null) {
                    stack.points[pointKey] = stack.points[series.index] = [pick(stack.cumulative, stackThreshold)];
                    if (!defined(stack.cumulative)) {
                        stack.base = pointKey
                    }
                    stack.touched = stacking.stacksTouched;
                    if (stackIndicator.index > 0 && series.singleStacks === !1) {
                        stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0]
                    }
                } else {
                    delete stack.points[pointKey];
                    delete stack.points[series.index]
                }
                let total = stack.total || 0;
                if (type === 'percent') {
                    other = isNegative ? stackKey : negKey;
                    if (negStacks && stacks[other]?.[x]) {
                        other = stacks[other][x];
                        total = other.total = Math.max(other.total || 0, total) + Math.abs(y) || 0
                    } else {
                        total = correctFloat(total + (Math.abs(y) || 0))
                    }
                } else if (type === 'group') {
                    if (isArray(y)) {
                        y = y[0]
                    }
                    if (y !== null) {
                        total++
                    }
                } else {
                    total = correctFloat(total + (y || 0))
                }
                if (type === 'group') {
                    stack.cumulative = (total || 1) - 1
                } else {
                    stack.cumulative = correctFloat(pick(stack.cumulative, stackThreshold) + (y || 0))
                }
                stack.total = total;
                if (y !== null) {
                    stack.points[pointKey].push(stack.cumulative);
                    stackedYData[i] = stack.cumulative;
                    stack.hasValidPoints = !0
                }
            }
            if (type === 'percent') {
                stacking.usePercentage = !0
            }
            if (type !== 'group') {
                this.stackedYData = stackedYData
            }
            stacking.oldStacks = {}
        }
        class AxisAdditions {
            constructor(axis) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = axis
            }
            buildStacks() {
                const stacking = this
                    , axis = stacking.axis
                    , axisSeries = axis.series
                    , isXAxis = axis.coll === 'xAxis'
                    , reversedStacks = axis.options.reversedStacks
                    , len = axisSeries.length;
                let actualSeries, i;
                this.resetStacks();
                stacking.usePercentage = !1;
                i = len;
                while (i--) {
                    actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
                    if (isXAxis) {
                        actualSeries.setGroupedPoints(axis)
                    }
                    actualSeries.setStackedPoints(axis)
                }
                if (!isXAxis) {
                    for (i = 0; i < len; i++) {
                        axisSeries[i].modifyStacks()
                    }
                }
                fireEvent(axis, 'afterBuildStacks')
            }
            cleanStacks() {
                if (this.oldStacks) {
                    this.stacks = this.oldStacks;
                    objectEach(this.stacks, (type) => {
                            objectEach(type, (stack) => {
                                    stack.cumulative = stack.total
                                }
                            )
                        }
                    )
                }
            }
            resetStacks() {
                objectEach(this.stacks, (type) => {
                        objectEach(type, (stack, x) => {
                                if (isNumber(stack.touched) && stack.touched < this.stacksTouched) {
                                    stack.destroy();
                                    delete type[x]
                                } else {
                                    stack.total = null;
                                    stack.cumulative = null
                                }
                            }
                        )
                    }
                )
            }
            renderStackTotals() {
                const stacking = this
                    , axis = stacking.axis
                    , chart = axis.chart
                    , renderer = chart.renderer
                    , stacks = stacking.stacks
                    , stackLabelsAnim = axis.options.stackLabels?.animation
                    , animationConfig = getDeferredAnimation(chart, stackLabelsAnim || !1)
                    , stackTotalGroup = stacking.stackTotalGroup = (stacking.stackTotalGroup || renderer.g('stack-labels').attr({
                    zIndex: 6,
                    opacity: 0
                }).add());
                stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
                objectEach(stacks, (type) => {
                        objectEach(type, (stack) => {
                                stack.render(stackTotalGroup)
                            }
                        )
                    }
                );
                stackTotalGroup.animate({
                    opacity: 1
                }, animationConfig)
            }
        }
        var StackingAxis;
        (function(StackingAxis) {
                const composedMembers = [];
                function compose(AxisClass, ChartClass, SeriesClass) {
                    if (U.pushUnique(composedMembers, AxisClass)) {
                        addEvent(AxisClass, 'init', onAxisInit);
                        addEvent(AxisClass, 'destroy', onAxisDestroy)
                    }
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.getStacks = chartGetStacks
                    }
                    if (U.pushUnique(composedMembers, SeriesClass)) {
                        const seriesProto = SeriesClass.prototype;
                        seriesProto.getStackIndicator = seriesGetStackIndicator;
                        seriesProto.modifyStacks = seriesModifyStacks;
                        seriesProto.percentStacker = seriesPercentStacker;
                        seriesProto.setGroupedPoints = seriesSetGroupedPoints;
                        seriesProto.setStackedPoints = seriesSetStackedPoints
                    }
                }
                StackingAxis.compose = compose
            }
        )(StackingAxis || (StackingAxis = {}));
        return StackingAxis
    });
    _registerModule(_modules, 'Series/Line/LineSeries.js', [_modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Series, SeriesRegistry, U) {
        const {defined, merge, isObject} = U;
        class LineSeries extends Series {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            drawGraph() {
                const series = this
                    , options = this.options
                    , graphPath = (this.gappedPath || this.getGraphPath).call(this)
                    , styledMode = this.chart.styledMode;
                let props = [['graph', 'highcharts-graph']];
                if (!styledMode) {
                    props[0].push((options.lineColor || this.color || "#cccccc"), options.dashStyle)
                }
                props = series.getZonesGraphs(props);
                props.forEach(function(prop, i) {
                    const graphKey = prop[0];
                    let attribs, graph = series[graphKey];
                    const verb = graph ? 'animate' : 'attr';
                    if (graph) {
                        graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
                        graph.animate({
                            d: graphPath
                        })
                    } else if (graphPath.length) {
                        series[graphKey] = graph = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({
                            zIndex: 1
                        }).add(series.group)
                    }
                    if (graph && !styledMode) {
                        attribs = {
                            'stroke': prop[2],
                            'stroke-width': options.lineWidth || 0,
                            'fill': (series.fillGraph && series.color) || 'none'
                        };
                        if (prop[3]) {
                            attribs.dashstyle = prop[3]
                        } else if (options.linecap !== 'square') {
                            attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round'
                        }
                        graph[verb](attribs).shadow((i < 2) && options.shadow && merge({
                            filterUnits: 'userSpaceOnUse'
                        }, isObject(options.shadow) ? options.shadow : {}))
                    }
                    if (graph) {
                        graph.startX = graphPath.xMap;
                        graph.isArea = graphPath.isArea
                    }
                })
            }
            getGraphPath(points, nullsAsZeroes, connectCliffs) {
                const series = this
                    , options = series.options
                    , graphPath = []
                    , xMap = [];
                let gap, step = options.step;
                points = points || series.points;
                const reversed = points.reversed;
                if (reversed) {
                    points.reverse()
                }
                step = {
                    right: 1,
                    center: 2
                }[step] || (step && 3);
                if (step && reversed) {
                    step = 4 - step
                }
                points = this.getValidPoints(points, !1, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
                points.forEach(function(point, i) {
                    const plotX = point.plotX
                        , plotY = point.plotY
                        , lastPoint = points[i - 1]
                        , isNull = point.isNull || typeof plotY !== 'number';
                    let pathToPoint;
                    if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
                        gap = !0
                    }
                    if (isNull && !defined(nullsAsZeroes) && i > 0) {
                        gap = !options.connectNulls
                    } else if (isNull && !nullsAsZeroes) {
                        gap = !0
                    } else {
                        if (i === 0 || gap) {
                            pathToPoint = [['M', point.plotX, point.plotY]]
                        } else if (series.getPointSpline) {
                            pathToPoint = [series.getPointSpline(points, point, i)]
                        } else if (step) {
                            if (step === 1) {
                                pathToPoint = [['L', lastPoint.plotX, plotY]]
                            } else if (step === 2) {
                                pathToPoint = [['L', (lastPoint.plotX + plotX) / 2, lastPoint.plotY], ['L', (lastPoint.plotX + plotX) / 2, plotY]]
                            } else {
                                pathToPoint = [['L', plotX, lastPoint.plotY]]
                            }
                            pathToPoint.push(['L', plotX, plotY])
                        } else {
                            pathToPoint = [['L', plotX, plotY]]
                        }
                        xMap.push(point.x);
                        if (step) {
                            xMap.push(point.x);
                            if (step === 2) {
                                xMap.push(point.x)
                            }
                        }
                        graphPath.push.apply(graphPath, pathToPoint);
                        gap = !1
                    }
                });
                graphPath.xMap = xMap;
                series.graphPath = graphPath;
                return graphPath
            }
            getZonesGraphs(props) {
                this.zones.forEach(function(zone, i) {
                    const propset = ['zone-graph-' + i, 'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || '')];
                    if (!this.chart.styledMode) {
                        propset.push((zone.color || this.color), (zone.dashStyle || this.options.dashStyle))
                    }
                    props.push(propset)
                }, this);
                return props
            }
        }
        LineSeries.defaultOptions = merge(Series.defaultOptions, {
            legendSymbol: 'lineMarker'
        });
        SeriesRegistry.registerSeriesType('line', LineSeries);
        '';
        return LineSeries
    });
    _registerModule(_modules, 'Series/Area/AreaSeries.js', [_modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Color, SeriesRegistry, U) {
        const {parse: color} = Color;
        const {seriesTypes: {line: LineSeries}} = SeriesRegistry;
        const {extend, merge, objectEach, pick} = U;
        class AreaSeries extends LineSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            drawGraph() {
                this.areaPath = [];
                super.drawGraph.apply(this);
                const series = this
                    , areaPath = this.areaPath
                    , options = this.options
                    , zones = this.zones
                    , props = [['area', 'highcharts-area', this.color, options.fillColor]];
                zones.forEach(function(zone, i) {
                    props.push(['zone-area-' + i, 'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className, zone.color || series.color, zone.fillColor || options.fillColor])
                });
                props.forEach(function(prop) {
                    const areaKey = prop[0]
                        , attribs = {};
                    let area = series[areaKey];
                    const verb = area ? 'animate' : 'attr';
                    if (area) {
                        area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
                        area.animate({
                            d: areaPath
                        })
                    } else {
                        attribs.zIndex = 0;
                        area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);
                        area.isArea = !0
                    }
                    if (!series.chart.styledMode) {
                        if (prop[3]) {
                            attribs.fill = prop[3]
                        } else {
                            attribs.fill = prop[2];
                            attribs['fill-opacity'] = pick(options.fillOpacity, 0.75)
                        }
                    }
                    area[verb](attribs);
                    area.startX = areaPath.xMap;
                    area.shiftUnit = options.step ? 2 : 1
                })
            }
            getGraphPath(points) {
                const getGraphPath = LineSeries.prototype.getGraphPath
                    , options = this.options
                    , stacking = options.stacking
                    , yAxis = this.yAxis
                    , bottomPoints = []
                    , graphPoints = []
                    , seriesIndex = this.index
                    , stacks = yAxis.stacking.stacks[this.stackKey]
                    , threshold = options.threshold
                    , translatedThreshold = Math.round(yAxis.getThreshold(options.threshold))
                    , connectNulls = pick(options.connectNulls, stacking === 'percent')
                    , addDummyPoints = function(i, otherI, side) {
                    const point = points[i]
                        , stackedValues = stacking && stacks[point.x].points[seriesIndex]
                        , nullVal = point[side + 'Null'] || 0
                        , cliffVal = point[side + 'Cliff'] || 0;
                    let top, bottom, isNull = !0;
                    if (cliffVal || nullVal) {
                        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
                        bottom = stackedValues[0] + cliffVal;
                        isNull = !!nullVal
                    } else if (!stacking && points[otherI] && points[otherI].isNull) {
                        top = bottom = threshold
                    }
                    if (typeof top !== 'undefined') {
                        graphPoints.push({
                            plotX: plotX,
                            plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
                            isNull: isNull,
                            isCliff: !0
                        });
                        bottomPoints.push({
                            plotX: plotX,
                            plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
                            doCurve: !1
                        })
                    }
                };
                let plotX, isNull, yBottom;
                points = points || this.points;
                if (stacking) {
                    points = this.getStackPoints(points)
                }
                for (let i = 0, iEnd = points.length; i < iEnd; ++i) {
                    if (!stacking) {
                        points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0
                    }
                    isNull = points[i].isNull;
                    plotX = pick(points[i].rectPlotX, points[i].plotX);
                    yBottom = stacking ? pick(points[i].yBottom, translatedThreshold) : translatedThreshold;
                    if (!isNull || connectNulls) {
                        if (!connectNulls) {
                            addDummyPoints(i, i - 1, 'left')
                        }
                        if (!(isNull && !stacking && connectNulls)) {
                            graphPoints.push(points[i]);
                            bottomPoints.push({
                                x: i,
                                plotX: plotX,
                                plotY: yBottom
                            })
                        }
                        if (!connectNulls) {
                            addDummyPoints(i, i + 1, 'right')
                        }
                    }
                }
                const topPath = getGraphPath.call(this, graphPoints, !0, !0);
                bottomPoints.reversed = !0;
                const bottomPath = getGraphPath.call(this, bottomPoints, !0, !0);
                const firstBottomPoint = bottomPath[0];
                if (firstBottomPoint && firstBottomPoint[0] === 'M') {
                    bottomPath[0] = ['L', firstBottomPoint[1], firstBottomPoint[2]]
                }
                const areaPath = topPath.concat(bottomPath);
                if (areaPath.length) {
                    areaPath.push(['Z'])
                }
                const graphPath = getGraphPath.call(this, graphPoints, !1, connectNulls);
                areaPath.xMap = topPath.xMap;
                this.areaPath = areaPath;
                return graphPath
            }
            getStackPoints(points) {
                const series = this
                    , segment = []
                    , keys = []
                    , xAxis = this.xAxis
                    , yAxis = this.yAxis
                    , stack = yAxis.stacking.stacks[this.stackKey]
                    , pointMap = {}
                    , yAxisSeries = yAxis.series
                    , seriesLength = yAxisSeries.length
                    , upOrDown = yAxis.options.reversedStacks ? 1 : -1
                    , seriesIndex = yAxisSeries.indexOf(series);
                points = points || this.points;
                if (this.options.stacking) {
                    for (let i = 0; i < points.length; i++) {
                        points[i].leftNull = points[i].rightNull = void 0;
                        pointMap[points[i].x] = points[i]
                    }
                    objectEach(stack, function(stackX, x) {
                        if (stackX.total !== null) {
                            keys.push(x)
                        }
                    });
                    keys.sort(function(a, b) {
                        return a - b
                    });
                    const visibleSeries = yAxisSeries.map( (s) => s.visible);
                    keys.forEach(function(x, idx) {
                        let y = 0, stackPoint, stackedValues;
                        if (pointMap[x] && !pointMap[x].isNull) {
                            segment.push(pointMap[x]);
                            [-1, 1].forEach(function(direction) {
                                const nullName = direction === 1 ? 'rightNull' : 'leftNull'
                                    , cliffName = direction === 1 ? 'rightCliff' : 'leftCliff'
                                    , otherStack = stack[keys[idx + direction]];
                                let cliff = 0;
                                if (otherStack) {
                                    let i = seriesIndex;
                                    while (i >= 0 && i < seriesLength) {
                                        const si = yAxisSeries[i].index;
                                        stackPoint = otherStack.points[si];
                                        if (!stackPoint) {
                                            if (si === series.index) {
                                                pointMap[x][nullName] = !0
                                            } else if (visibleSeries[i]) {
                                                stackedValues = stack[x].points[si];
                                                if (stackedValues) {
                                                    cliff -= (stackedValues[1] - stackedValues[0])
                                                }
                                            }
                                        }
                                        i += upOrDown
                                    }
                                }
                                pointMap[x][cliffName] = cliff
                            })
                        } else {
                            let i = seriesIndex;
                            while (i >= 0 && i < seriesLength) {
                                const si = yAxisSeries[i].index;
                                stackPoint = stack[x].points[si];
                                if (stackPoint) {
                                    y = stackPoint[1];
                                    break
                                }
                                i += upOrDown
                            }
                            y = pick(y, 0);
                            y = yAxis.translate(y, 0, 1, 0, 1);
                            segment.push({
                                isNull: !0,
                                plotX: xAxis.translate(x, 0, 0, 0, 1),
                                x: x,
                                plotY: y,
                                yBottom: y
                            })
                        }
                    })
                }
                return segment
            }
        }
        AreaSeries.defaultOptions = merge(LineSeries.defaultOptions, {
            threshold: 0,
            legendSymbol: 'rectangle'
        });
        extend(AreaSeries.prototype, {
            singleStacks: !1
        });
        SeriesRegistry.registerSeriesType('area', AreaSeries);
        '';
        return AreaSeries
    });
    _registerModule(_modules, 'Series/Spline/SplineSeries.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(SeriesRegistry, U) {
        const {line: LineSeries} = SeriesRegistry.seriesTypes;
        const {merge, pick} = U;
        class SplineSeries extends LineSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            getPointSpline(points, point, i) {
                const smoothing = 1.5
                    , denom = smoothing + 1
                    , plotX = point.plotX || 0
                    , plotY = point.plotY || 0
                    , lastPoint = points[i - 1]
                    , nextPoint = points[i + 1];
                let leftContX, leftContY, rightContX, rightContY;
                function doCurve(otherPoint) {
                    return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== !1 && !point.isCliff
                }
                if (doCurve(lastPoint) && doCurve(nextPoint)) {
                    const lastX = lastPoint.plotX || 0
                        , lastY = lastPoint.plotY || 0
                        , nextX = nextPoint.plotX || 0
                        , nextY = nextPoint.plotY || 0;
                    let correction = 0;
                    leftContX = (smoothing * plotX + lastX) / denom;
                    leftContY = (smoothing * plotY + lastY) / denom;
                    rightContX = (smoothing * plotX + nextX) / denom;
                    rightContY = (smoothing * plotY + nextY) / denom;
                    if (rightContX !== leftContX) {
                        correction = (((rightContY - leftContY) * (rightContX - plotX)) / (rightContX - leftContX) + plotY - rightContY)
                    }
                    leftContY += correction;
                    rightContY += correction;
                    if (leftContY > lastY && leftContY > plotY) {
                        leftContY = Math.max(lastY, plotY);
                        rightContY = 2 * plotY - leftContY
                    } else if (leftContY < lastY && leftContY < plotY) {
                        leftContY = Math.min(lastY, plotY);
                        rightContY = 2 * plotY - leftContY
                    }
                    if (rightContY > nextY && rightContY > plotY) {
                        rightContY = Math.max(nextY, plotY);
                        leftContY = 2 * plotY - rightContY
                    } else if (rightContY < nextY && rightContY < plotY) {
                        rightContY = Math.min(nextY, plotY);
                        leftContY = 2 * plotY - rightContY
                    }
                    point.rightContX = rightContX;
                    point.rightContY = rightContY;
                    point.controlPoints = {
                        low: [leftContX, leftContY],
                        high: [rightContX, rightContY]
                    }
                }
                const ret = ['C', pick(lastPoint.rightContX, lastPoint.plotX, 0), pick(lastPoint.rightContY, lastPoint.plotY, 0), pick(leftContX, plotX, 0), pick(leftContY, plotY, 0), plotX, plotY];
                lastPoint.rightContX = lastPoint.rightContY = void 0;
                return ret
            }
        }
        SplineSeries.defaultOptions = merge(LineSeries.defaultOptions);
        SeriesRegistry.registerSeriesType('spline', SplineSeries);
        '';
        return SplineSeries
    });
    _registerModule(_modules, 'Series/AreaSpline/AreaSplineSeries.js', [_modules['Series/Spline/SplineSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(SplineSeries, SeriesRegistry, U) {
        const {area: AreaSeries, area: {prototype: areaProto}} = SeriesRegistry.seriesTypes;
        const {extend, merge} = U;
        class AreaSplineSeries extends SplineSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.points = void 0;
                this.options = void 0
            }
        }
        AreaSplineSeries.defaultOptions = merge(SplineSeries.defaultOptions, AreaSeries.defaultOptions);
        extend(AreaSplineSeries.prototype, {
            getGraphPath: areaProto.getGraphPath,
            getStackPoints: areaProto.getStackPoints,
            drawGraph: areaProto.drawGraph
        });
        SeriesRegistry.registerSeriesType('areaspline', AreaSplineSeries);
        '';
        return AreaSplineSeries
    });
    _registerModule(_modules, 'Series/Column/ColumnSeriesDefaults.js', [], function() {
        const ColumnSeriesDefaults = {
            borderRadius: 3,
            centerInCategory: !1,
            groupPadding: 0.2,
            marker: null,
            pointPadding: 0.1,
            minPointLength: 0,
            cropThreshold: 50,
            pointRange: null,
            states: {
                hover: {
                    halo: !1,
                    brightness: 0.1
                },
                select: {
                    color: "#cccccc",
                    borderColor: "#000000"
                }
            },
            dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                y: void 0
            },
            startFromThreshold: !0,
            stickyTracking: !1,
            tooltip: {
                distance: 6
            },
            threshold: 0,
            borderColor: "#ffffff"
        };
        '';
        return ColumnSeriesDefaults
    });
    _registerModule(_modules, 'Series/Column/ColumnSeries.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Color/Color.js'], _modules['Series/Column/ColumnSeriesDefaults.js'], _modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(A, Color, ColumnSeriesDefaults, H, Series, SeriesRegistry, U) {
        const {animObject} = A;
        const {parse: color} = Color;
        const {hasTouch, noop} = H;
        const {clamp, defined, extend, fireEvent, isArray, isNumber, merge, pick, objectEach, relativeLength} = U;
        class ColumnSeries extends Series {
            constructor() {
                super(...arguments);
                this.borderWidth = void 0;
                this.data = void 0;
                this.group = void 0;
                this.options = void 0;
                this.points = void 0
            }
            animate(init) {
                const series = this
                    , yAxis = this.yAxis
                    , yAxisPos = yAxis.pos
                    , options = series.options
                    , inverted = this.chart.inverted
                    , attr = {}
                    , translateProp = inverted ? 'translateX' : 'translateY';
                let translateStart, translatedThreshold;
                if (init) {
                    attr.scaleY = 0.001;
                    translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxisPos, yAxisPos + yAxis.len);
                    if (inverted) {
                        attr.translateX = translatedThreshold - yAxis.len
                    } else {
                        attr.translateY = translatedThreshold
                    }
                    if (series.clipBox) {
                        series.setClip()
                    }
                    series.group.attr(attr)
                } else {
                    translateStart = Number(series.group.attr(translateProp));
                    series.group.animate({
                        scaleY: 1
                    }, extend(animObject(series.options.animation), {
                        step: function(val, fx) {
                            if (series.group) {
                                attr[translateProp] = translateStart + fx.pos * (yAxisPos - translateStart);
                                series.group.attr(attr)
                            }
                        }
                    }))
                }
            }
            init(chart, options) {
                super.init.apply(this, arguments);
                const series = this;
                chart = series.chart;
                if (chart.hasRendered) {
                    chart.series.forEach(function(otherSeries) {
                        if (otherSeries.type === series.type) {
                            otherSeries.isDirty = !0
                        }
                    })
                }
            }
            getColumnMetrics() {
                const series = this
                    , options = series.options
                    , xAxis = series.xAxis
                    , yAxis = series.yAxis
                    , reversedStacks = xAxis.options.reversedStacks
                    , reverseStacks = (xAxis.reversed && !reversedStacks) || (!xAxis.reversed && reversedStacks)
                    , stackGroups = {};
                let stackKey, columnCount = 0;
                if (options.grouping === !1) {
                    columnCount = 1
                } else {
                    series.chart.series.forEach(function(otherSeries) {
                        const otherYAxis = otherSeries.yAxis
                            , otherOptions = otherSeries.options;
                        let columnIndex;
                        if (otherSeries.type === series.type && otherSeries.reserveSpace() && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
                            if (otherOptions.stacking && otherOptions.stacking !== 'group') {
                                stackKey = otherSeries.stackKey;
                                if (typeof stackGroups[stackKey] === 'undefined') {
                                    stackGroups[stackKey] = columnCount++
                                }
                                columnIndex = stackGroups[stackKey]
                            } else if (otherOptions.grouping !== !1) {
                                columnIndex = columnCount++
                            }
                            otherSeries.columnIndex = columnIndex
                        }
                    })
                }
                const categoryWidth = Math.min(Math.abs(xAxis.transA) * ((!xAxis.brokenAxis?.hasBreaks && xAxis.ordinal?.slope) || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), xAxis.len)
                    , groupPadding = categoryWidth * options.groupPadding
                    , groupWidth = categoryWidth - 2 * groupPadding
                    , pointOffsetWidth = groupWidth / (columnCount || 1)
                    , pointWidth = Math.min(options.maxPointWidth || xAxis.len, pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding)))
                    , pointPadding = (pointOffsetWidth - pointWidth) / 2
                    , colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0)
                    , pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - (categoryWidth / 2)) * (reverseStacks ? -1 : 1);
                series.columnMetrics = {
                    width: pointWidth,
                    offset: pointXOffset,
                    paddedWidth: pointOffsetWidth,
                    columnCount
                };
                return series.columnMetrics
            }
            crispCol(x, y, w, h) {
                const chart = this.chart
                    , borderWidth = this.borderWidth
                    , xCrisp = -(borderWidth % 2 ? 0.5 : 0);
                let right, yCrisp = borderWidth % 2 ? 0.5 : 1;
                if (this.options.crisp) {
                    right = Math.round(x + w) + xCrisp;
                    x = Math.round(x) + xCrisp;
                    w = right - x
                }
                const bottom = Math.round(y + h) + yCrisp
                    , fromTop = Math.abs(y) <= 0.5 && bottom > 0.5;
                y = Math.round(y) + yCrisp;
                h = bottom - y;
                if (fromTop && h) {
                    y -= 1;
                    h += 1
                }
                return {
                    x: x,
                    y: y,
                    width: w,
                    height: h
                }
            }
            adjustForMissingColumns(x, pointWidth, point, metrics) {
                if (!point.isNull && metrics.columnCount > 1) {
                    const visibleSeries = this.xAxis.series.filter( (s) => s.visible).map( (s) => s.index);
                    let indexInCategory = 0
                        , totalInCategory = 0;
                    objectEach(this.xAxis.stacking?.stacks, (stack) => {
                            if (typeof point.x === 'number') {
                                const stackItem = stack[point.x.toString()];
                                if (stackItem) {
                                    const pointValues = stackItem.points[this.index];
                                    if (isArray(pointValues)) {
                                        const seriesIndexes = Object.keys(stackItem.points).filter( (pointKey) => !pointKey.match(',') && stackItem.points[pointKey] && stackItem.points[pointKey].length > 1).map(parseFloat).filter( (index) => visibleSeries.indexOf(index) !== -1).sort( (a, b) => b - a);
                                        indexInCategory = seriesIndexes.indexOf(this.index);
                                        totalInCategory = seriesIndexes.length
                                    }
                                }
                            }
                        }
                    );
                    const boxWidth = (totalInCategory - 1) * metrics.paddedWidth + pointWidth;
                    x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory * metrics.paddedWidth
                }
                return x
            }
            translate() {
                const series = this
                    , chart = series.chart
                    , options = series.options
                    , dense = series.dense = series.closestPointRange * series.xAxis.transA < 2
                    , borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1)
                    , xAxis = series.xAxis
                    , yAxis = series.yAxis
                    , threshold = options.threshold
                    , minPointLength = pick(options.minPointLength, 5)
                    , metrics = series.getColumnMetrics()
                    , seriesPointWidth = metrics.width
                    , seriesXOffset = series.pointXOffset = metrics.offset
                    , dataMin = series.dataMin
                    , dataMax = series.dataMax;
                let seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth)
                    , translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold);
                if (chart.inverted) {
                    translatedThreshold -= 0.5
                }
                if (options.pointPadding) {
                    seriesBarW = Math.ceil(seriesBarW)
                }
                Series.prototype.translate.apply(series);
                series.points.forEach(function(point) {
                    const yBottom = pick(point.yBottom, translatedThreshold)
                        , safeDistance = 999 + Math.abs(yBottom)
                        , plotX = point.plotX || 0
                        , plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance)
                        , stackBox = point.stackBox;
                    let up, barY = Math.min(plotY, yBottom), barH = Math.max(plotY, yBottom) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
                    if (minPointLength && Math.abs(barH) < minPointLength) {
                        barH = minPointLength;
                        up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
                        if (isNumber(threshold) && isNumber(dataMax) && point.y === threshold && dataMax <= threshold && (yAxis.min || 0) < threshold && (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
                            up = !up;
                            point.negative = !point.negative
                        }
                        barY = (Math.abs(barY - translatedThreshold) > minPointLength ? yBottom - minPointLength : translatedThreshold - (up ? minPointLength : 0))
                    }
                    if (defined(point.options.pointWidth)) {
                        pointWidth = barW = Math.ceil(point.options.pointWidth);
                        barX -= Math.round((pointWidth - seriesPointWidth) / 2)
                    }
                    if (options.centerInCategory && !options.stacking) {
                        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics)
                    }
                    point.barX = barX;
                    point.pointWidth = pointWidth;
                    point.tooltipPos = chart.inverted ? [clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft), xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2, barH] : [xAxis.left - chart.plotLeft + barX + barW / 2, clamp(plotY + yAxis.pos - chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop), barH];
                    point.shapeType = series.pointClass.prototype.shapeType || 'roundedRect';
                    point.shapeArgs = series.crispCol(barX, point.isNull ? translatedThreshold : barY, barW, point.isNull ? 0 : barH)
                });
                fireEvent(this, 'afterColumnTranslate')
            }
            drawGraph() {
                this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data')
            }
            pointAttribs(point, state) {
                const options = this.options
                    , p2o = this.pointAttrToOptions || {}
                    , strokeOption = p2o.stroke || 'borderColor'
                    , strokeWidthOption = p2o['stroke-width'] || 'borderWidth';
                let stateOptions, zone, brightness, fill = (point && point.color) || this.color, stroke = ((point && point[strokeOption]) || options[strokeOption] || fill), dashstyle = (point && point.options.dashStyle) || options.dashStyle, strokeWidth = (point && point[strokeWidthOption]) || options[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = pick(point && point.opacity, options.opacity, 1);
                if (point && this.zones.length) {
                    zone = point.getZone();
                    fill = (point.options.color || (zone && (zone.color || point.nonZonedColor)) || this.color);
                    if (zone) {
                        stroke = zone.borderColor || stroke;
                        dashstyle = zone.dashStyle || dashstyle;
                        strokeWidth = zone.borderWidth || strokeWidth
                    }
                }
                if (state && point) {
                    stateOptions = merge(options.states[state], point.options.states && point.options.states[state] || {});
                    brightness = stateOptions.brightness;
                    fill = stateOptions.color || (typeof brightness !== 'undefined' && color(fill).brighten(stateOptions.brightness).get()) || fill;
                    stroke = stateOptions[strokeOption] || stroke;
                    strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
                    dashstyle = stateOptions.dashStyle || dashstyle;
                    opacity = pick(stateOptions.opacity, opacity)
                }
                const ret = {
                    fill: fill,
                    stroke: stroke,
                    'stroke-width': strokeWidth,
                    opacity: opacity
                };
                if (dashstyle) {
                    ret.dashstyle = dashstyle
                }
                return ret
            }
            drawPoints(points=this.points) {
                const series = this
                    , chart = this.chart
                    , options = series.options
                    , renderer = chart.renderer
                    , animationLimit = options.animationLimit || 250;
                let shapeArgs;
                points.forEach(function(point) {
                    const plotY = point.plotY;
                    let graphic = point.graphic
                        , hasGraphic = !!graphic
                        , verb = graphic && chart.pointCount < animationLimit ? 'animate' : 'attr';
                    if (isNumber(plotY) && point.y !== null) {
                        shapeArgs = point.shapeArgs;
                        if (graphic && point.hasNewShapeType()) {
                            graphic = graphic.destroy()
                        }
                        if (series.enabledDataSorting) {
                            point.startXPos = series.xAxis.reversed ? -(shapeArgs ? (shapeArgs.width || 0) : 0) : series.xAxis.width
                        }
                        if (!graphic) {
                            point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
                            if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
                                graphic.attr({
                                    x: point.startXPos
                                });
                                hasGraphic = !0;
                                verb = 'animate'
                            }
                        }
                        if (graphic && hasGraphic) {
                            graphic[verb](merge(shapeArgs))
                        }
                        if (!chart.styledMode) {
                            graphic[verb](series.pointAttribs(point, (point.selected && 'select'))).shadow(point.allowShadow !== !1 && options.shadow)
                        }
                        if (graphic) {
                            graphic.addClass(point.getClassName(), !0);
                            graphic.attr({
                                visibility: point.visible ? 'inherit' : 'hidden'
                            })
                        }
                    } else if (graphic) {
                        point.graphic = graphic.destroy()
                    }
                })
            }
            drawTracker(points=this.points) {
                const series = this
                    , chart = series.chart
                    , pointer = chart.pointer
                    , onMouseOver = function(e) {
                    const point = pointer.getPointFromEvent(e);
                    if (typeof point !== 'undefined' && series.options.enableMouseTracking) {
                        pointer.isDirectTouch = !0;
                        point.onMouseOver(e)
                    }
                };
                let dataLabels;
                points.forEach(function(point) {
                    dataLabels = (isArray(point.dataLabels) ? point.dataLabels : (point.dataLabel ? [point.dataLabel] : []));
                    if (point.graphic) {
                        point.graphic.element.point = point
                    }
                    dataLabels.forEach(function(dataLabel) {
                        if (dataLabel.div) {
                            dataLabel.div.point = point
                        } else {
                            dataLabel.element.point = point
                        }
                    })
                });
                if (!series._hasTracking) {
                    series.trackerGroups.forEach(function(key) {
                        if (series[key]) {
                            series[key].addClass('highcharts-tracker').on('mouseover', onMouseOver).on('mouseout', function(e) {
                                pointer.onTrackerMouseOut(e)
                            });
                            if (hasTouch) {
                                series[key].on('touchstart', onMouseOver)
                            }
                            if (!chart.styledMode && series.options.cursor) {
                                series[key].css({
                                    cursor: series.options.cursor
                                })
                            }
                        }
                    });
                    series._hasTracking = !0
                }
                fireEvent(this, 'afterDrawTracker')
            }
            remove() {
                const series = this
                    , chart = series.chart;
                if (chart.hasRendered) {
                    chart.series.forEach(function(otherSeries) {
                        if (otherSeries.type === series.type) {
                            otherSeries.isDirty = !0
                        }
                    })
                }
                Series.prototype.remove.apply(series, arguments)
            }
        }
        ColumnSeries.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);
        extend(ColumnSeries.prototype, {
            directTouch: !0,
            getSymbol: noop,
            negStacks: !0,
            trackerGroups: ['group', 'dataLabelsGroup']
        });
        SeriesRegistry.registerSeriesType('column', ColumnSeries);
        '';
        return ColumnSeries
    });
    _registerModule(_modules, 'Core/Series/DataLabel.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Templating.js'], _modules['Core/Utilities.js']], function(A, F, U) {
        const {getDeferredAnimation} = A;
        const {format} = F;
        const {defined, extend, fireEvent, isArray, isString, merge, objectEach, pick, pInt, splat} = U;
        var DataLabel;
        (function(DataLabel) {
                const composedMembers = [];
                function hasDataLabels() {
                    return splat(this.options.dataLabels || {}).some( (o) => o?.enabled)
                }
                function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
                    const series = this
                        , chart = this.chart
                        , inverted = this.isCartesian && chart.inverted
                        , enabledDataSorting = this.enabledDataSorting
                        , plotX = point.plotX
                        , plotY = point.plotY
                        , rotation = options.rotation
                        , align = options.align
                        , isInsidePlot = defined(plotX) && defined(plotY) && chart.isInsidePlot(plotX, Math.round(plotY), {
                            inverted,
                            paneCoordinates: !0,
                            series
                        })
                        , setStartPos = (alignOptions) => {
                            if (enabledDataSorting && series.xAxis && !justify) {
                                series.setDataLabelStartPos(point, dataLabel, isNew, isInsidePlot, alignOptions)
                            }
                        }
                    ;
                    let baseline, rotCorr, alignAttr, justify = pick(options.overflow, (enabledDataSorting ? 'none' : 'justify')) === 'justify', visible = this.visible && point.visible !== !1 && defined(plotX) && (point.series.forceDL || (enabledDataSorting && !justify) || isInsidePlot || (pick(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
                        inverted,
                        paneCoordinates: !0,
                        series
                    })));
                    const pos = point.pos();
                    if (visible && pos) {
                        if (rotation) {
                            dataLabel.attr({
                                align
                            })
                        }
                        let bBox = dataLabel.getBBox(!0)
                            , bBoxCorrection = [0, 0];
                        baseline = chart.renderer.fontMetrics(dataLabel).b;
                        alignTo = extend({
                            x: pos[0],
                            y: Math.round(pos[1]),
                            width: 0,
                            height: 0
                        }, alignTo);
                        extend(options, {
                            width: bBox.width,
                            height: bBox.height
                        });
                        if (rotation) {
                            justify = !1;
                            rotCorr = chart.renderer.rotCorr(baseline, rotation);
                            alignAttr = {
                                x: (alignTo.x + (options.x || 0) + alignTo.width / 2 + rotCorr.x),
                                y: (alignTo.y + (options.y || 0) + {
                                    top: 0,
                                    middle: 0.5,
                                    bottom: 1
                                }[options.verticalAlign] * alignTo.height)
                            };
                            bBoxCorrection = [bBox.x - Number(dataLabel.attr('x')), bBox.y - Number(dataLabel.attr('y'))];
                            setStartPos(alignAttr);
                            dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
                        } else {
                            setStartPos(alignTo);
                            dataLabel.align(options, void 0, alignTo);
                            alignAttr = dataLabel.alignAttr
                        }
                        if (justify && alignTo.height >= 0) {
                            this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew)
                        } else if (pick(options.crop, !0)) {
                            let {x, y} = alignAttr;
                            x += bBoxCorrection[0];
                            y += bBoxCorrection[1];
                            visible = chart.isInsidePlot(x, y, {
                                paneCoordinates: !0,
                                series
                            }) && chart.isInsidePlot(x + bBox.width, y + bBox.height, {
                                paneCoordinates: !0,
                                series
                            })
                        }
                        if (options.shape && !rotation) {
                            dataLabel[isNew ? 'attr' : 'animate']({
                                anchorX: pos[0],
                                anchorY: pos[1]
                            })
                        }
                    }
                    if (isNew && enabledDataSorting) {
                        dataLabel.placed = !1
                    }
                    if (!visible && (!enabledDataSorting || justify)) {
                        dataLabel.hide();
                        dataLabel.placed = !1
                    } else {
                        dataLabel.show()
                    }
                }
                function applyFilter(point, options) {
                    const filter = options.filter;
                    if (filter) {
                        const op = filter.operator;
                        const prop = point[filter.property];
                        const val = filter.value;
                        if ((op === '>' && prop > val) || (op === '<' && prop < val) || (op === '>=' && prop >= val) || (op === '<=' && prop <= val) || (op === '==' && prop == val) || (op === '===' && prop === val)) {
                            return !0
                        }
                        return !1
                    }
                    return !0
                }
                function compose(SeriesClass) {
                    if (U.pushUnique(composedMembers, SeriesClass)) {
                        const seriesProto = SeriesClass.prototype;
                        seriesProto.initDataLabelsGroup = initDataLabelsGroup;
                        seriesProto.initDataLabels = initDataLabels;
                        seriesProto.alignDataLabel = alignDataLabel;
                        seriesProto.drawDataLabels = drawDataLabels;
                        seriesProto.justifyDataLabel = justifyDataLabel;
                        seriesProto.setDataLabelStartPos = setDataLabelStartPos;
                        seriesProto.hasDataLabels = hasDataLabels
                    }
                }
                DataLabel.compose = compose;
                function initDataLabelsGroup() {
                    return this.plotGroup('dataLabelsGroup', 'data-labels', this.hasRendered ? 'inherit' : 'hidden', this.options.dataLabels.zIndex || 6)
                }
                function initDataLabels(animationConfig) {
                    const series = this
                        , hasRendered = series.hasRendered || 0;
                    const dataLabelsGroup = this.initDataLabelsGroup().attr({
                        opacity: +hasRendered
                    });
                    if (!hasRendered && dataLabelsGroup) {
                        if (series.visible) {
                            dataLabelsGroup.show()
                        }
                        if (series.options.animation) {
                            dataLabelsGroup.animate({
                                opacity: 1
                            }, animationConfig)
                        } else {
                            dataLabelsGroup.attr({
                                opacity: 1
                            })
                        }
                    }
                    return dataLabelsGroup
                }
                function drawDataLabels(points) {
                    points = points || this.points;
                    const series = this
                        , chart = series.chart
                        , seriesOptions = series.options
                        , renderer = chart.renderer
                        , {backgroundColor, plotBackgroundColor} = chart.options.chart
                        , plotOptions = chart.options.plotOptions
                        , contrastColor = renderer.getContrast((isString(plotBackgroundColor) && plotBackgroundColor) || (isString(backgroundColor) && backgroundColor) || "#000000");
                    let seriesDlOptions = seriesOptions.dataLabels, pointOptions, dataLabelsGroup;
                    seriesDlOptions = mergeArrays(mergeArrays(plotOptions?.series?.dataLabels, plotOptions?.[series.type]?.dataLabels), seriesDlOptions);
                    const {animation, defer} = splat(seriesDlOptions)[0]
                        , animationConfig = defer ? getDeferredAnimation(chart, animation, series) : {
                        defer: 0,
                        duration: 0
                    };
                    fireEvent(this, 'drawDataLabels');
                    if (series.hasDataLabels?.()) {
                        dataLabelsGroup = this.initDataLabels(animationConfig);
                        points.forEach( (point) => {
                                const dataLabels = point.dataLabels || [];
                                pointOptions = splat(mergeArrays(seriesDlOptions, point.dlOptions || point.options?.dataLabels));
                                pointOptions.forEach( (labelOptions, i) => {
                                        const labelEnabled = (labelOptions.enabled && point.visible && (!point.isNull || point.dataLabelOnNull) && applyFilter(point, labelOptions))
                                            , style = labelOptions.style || {}
                                            , labelDistance = labelOptions.distance;
                                        let labelConfig, formatString, labelText, rotation, attr = {}, dataLabel = dataLabels[i], isNew = !dataLabel;
                                        if (labelEnabled) {
                                            formatString = pick(labelOptions[point.formatPrefix + 'Format'], labelOptions.format);
                                            labelConfig = point.getLabelConfig();
                                            labelText = defined(formatString) ? format(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + 'Formatter'] || labelOptions.formatter).call(labelConfig, labelOptions);
                                            rotation = labelOptions.rotation;
                                            if (!chart.styledMode) {
                                                style.color = pick(labelOptions.color, style.color, isString(series.color) ? series.color : void 0, "#000000");
                                                if (style.color === 'contrast') {
                                                    point.contrastColor = renderer.getContrast((point.color || series.color));
                                                    style.color = ((!defined(labelDistance) && labelOptions.inside) || pInt(labelDistance || 0) < 0 || seriesOptions.stacking) ? point.contrastColor : contrastColor
                                                } else {
                                                    delete point.contrastColor
                                                }
                                                if (seriesOptions.cursor) {
                                                    style.cursor = seriesOptions.cursor
                                                }
                                            }
                                            attr = {
                                                r: labelOptions.borderRadius || 0,
                                                rotation,
                                                padding: labelOptions.padding,
                                                zIndex: 1
                                            };
                                            if (!chart.styledMode) {
                                                const {backgroundColor, borderColor} = labelOptions;
                                                attr.fill = backgroundColor === 'auto' ? point.color : backgroundColor;
                                                attr.stroke = borderColor === 'auto' ? point.color : borderColor;
                                                attr['stroke-width'] = labelOptions.borderWidth
                                            }
                                            objectEach(attr, (val, name) => {
                                                    if (typeof val === 'undefined') {
                                                        delete attr[name]
                                                    }
                                                }
                                            )
                                        }
                                        if (dataLabel && (!labelEnabled || !defined(labelText) || !!dataLabel.div !== !!labelOptions.useHTML || ((!dataLabel.rotation || !labelOptions.rotation) && dataLabel.rotation !== labelOptions.rotation))) {
                                            dataLabel = void 0;
                                            isNew = !0
                                        }
                                        if (labelEnabled && defined(labelText)) {
                                            if (!dataLabel) {
                                                dataLabel = rotation ? renderer.text(labelText, 0, 0, labelOptions.useHTML).addClass('highcharts-data-label') : renderer.label(labelText, 0, 0, labelOptions.shape, void 0, void 0, labelOptions.useHTML, void 0, 'data-label');
                                                if (dataLabel) {
                                                    dataLabel.addClass(' highcharts-data-label-color-' + point.colorIndex + ' ' + (labelOptions.className || '') + (labelOptions.useHTML ? ' highcharts-tracker' : ''))
                                                }
                                            } else {
                                                attr.text = labelText
                                            }
                                            if (dataLabel) {
                                                dataLabel.options = labelOptions;
                                                dataLabel.attr(attr);
                                                if (!chart.styledMode) {
                                                    dataLabel.css(style).shadow(labelOptions.shadow)
                                                }
                                                const textPathOptions = labelOptions[point.formatPrefix + 'TextPath'] || labelOptions.textPath;
                                                if (textPathOptions && !labelOptions.useHTML) {
                                                    dataLabel.setTextPath(point.getDataLabelPath?.(dataLabel) || point.graphic, textPathOptions);
                                                    if (point.dataLabelPath && !textPathOptions.enabled) {
                                                        point.dataLabelPath = (point.dataLabelPath.destroy())
                                                    }
                                                }
                                                if (!dataLabel.added) {
                                                    dataLabel.add(dataLabelsGroup)
                                                }
                                                series.alignDataLabel(point, dataLabel, labelOptions, void 0, isNew);
                                                dataLabel.isActive = !0;
                                                if (dataLabels[i] && dataLabels[i] !== dataLabel) {
                                                    dataLabels[i].destroy()
                                                }
                                                dataLabels[i] = dataLabel
                                            }
                                        }
                                    }
                                );
                                let j = dataLabels.length;
                                while (j--) {
                                    if (!dataLabels[j] || !dataLabels[j].isActive) {
                                        dataLabels[j]?.destroy();
                                        dataLabels.splice(j, 1)
                                    } else {
                                        dataLabels[j].isActive = !1
                                    }
                                }
                                point.dataLabel = dataLabels[0];
                                point.dataLabels = dataLabels
                            }
                        )
                    }
                    fireEvent(this, 'afterDrawDataLabels')
                }
                function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
                    const chart = this.chart
                        , align = options.align
                        , verticalAlign = options.verticalAlign
                        , padding = dataLabel.box ? 0 : (dataLabel.padding || 0);
                    let {x=0, y=0} = options, off, justified;
                    off = (alignAttr.x || 0) + padding;
                    if (off < 0) {
                        if (align === 'right' && x >= 0) {
                            options.align = 'left';
                            options.inside = !0
                        } else {
                            x -= off
                        }
                        justified = !0
                    }
                    off = (alignAttr.x || 0) + bBox.width - padding;
                    if (off > chart.plotWidth) {
                        if (align === 'left' && x <= 0) {
                            options.align = 'right';
                            options.inside = !0
                        } else {
                            x += chart.plotWidth - off
                        }
                        justified = !0
                    }
                    off = alignAttr.y + padding;
                    if (off < 0) {
                        if (verticalAlign === 'bottom' && y >= 0) {
                            options.verticalAlign = 'top';
                            options.inside = !0
                        } else {
                            y -= off
                        }
                        justified = !0
                    }
                    off = (alignAttr.y || 0) + bBox.height - padding;
                    if (off > chart.plotHeight) {
                        if (verticalAlign === 'top' && y <= 0) {
                            options.verticalAlign = 'bottom';
                            options.inside = !0
                        } else {
                            y += chart.plotHeight - off
                        }
                        justified = !0
                    }
                    if (justified) {
                        options.x = x;
                        options.y = y;
                        dataLabel.placed = !isNew;
                        dataLabel.align(options, void 0, alignTo)
                    }
                    return justified
                }
                function mergeArrays(one, two) {
                    let res = [], i;
                    if (isArray(one) && !isArray(two)) {
                        res = one.map(function(el) {
                            return merge(el, two)
                        })
                    } else if (isArray(two) && !isArray(one)) {
                        res = two.map(function(el) {
                            return merge(one, el)
                        })
                    } else if (!isArray(one) && !isArray(two)) {
                        res = merge(one, two)
                    } else if (isArray(one) && isArray(two)) {
                        i = Math.max(one.length, two.length);
                        while (i--) {
                            res[i] = merge(one[i], two[i])
                        }
                    }
                    return res
                }
                function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
                    const chart = this.chart
                        , inverted = chart.inverted
                        , xAxis = this.xAxis
                        , reversed = xAxis.reversed
                        , labelCenter = ((inverted ? dataLabel.height : dataLabel.width) || 0) / 2
                        , pointWidth = point.pointWidth
                        , halfWidth = pointWidth ? pointWidth / 2 : 0;
                    dataLabel.startXPos = inverted ? alignOptions.x : (reversed ? -labelCenter - halfWidth : xAxis.width - labelCenter + halfWidth);
                    dataLabel.startYPos = inverted ? (reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth) : alignOptions.y;
                    if (!isInside) {
                        dataLabel.attr({
                            opacity: 1
                        }).animate({
                            opacity: 0
                        }, void 0, dataLabel.hide)
                    } else if (dataLabel.visibility === 'hidden') {
                        dataLabel.show();
                        dataLabel.attr({
                            opacity: 0
                        }).animate({
                            opacity: 1
                        })
                    }
                    if (!chart.hasRendered) {
                        return
                    }
                    if (isNew) {
                        dataLabel.attr({
                            x: dataLabel.startXPos,
                            y: dataLabel.startYPos
                        })
                    }
                    dataLabel.placed = !0
                }
            }
        )(DataLabel || (DataLabel = {}));
        '';
        return DataLabel
    });
    _registerModule(_modules, 'Series/Column/ColumnDataLabel.js', [_modules['Core/Series/DataLabel.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(DataLabel, SeriesRegistry, U) {
        const {series: Series} = SeriesRegistry;
        const {merge, pick} = U;
        var ColumnDataLabel;
        (function(ColumnDataLabel) {
                const composedMembers = [];
                function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
                    const inverted = this.chart.inverted
                        , series = point.series
                        , xLen = (series.xAxis ? series.xAxis.len : this.chart.plotSizeX) || 0
                        , yLen = (series.yAxis ? series.yAxis.len : this.chart.plotSizeY) || 0
                        , dlBox = point.dlBox || point.shapeArgs
                        , below = pick(point.below, point.plotY > pick(this.translatedThreshold, yLen))
                        , inside = pick(options.inside, !!this.options.stacking);
                    if (dlBox) {
                        alignTo = merge(dlBox);
                        if (!(options.overflow === 'allow' && options.crop === !1)) {
                            if (alignTo.y < 0) {
                                alignTo.height += alignTo.y;
                                alignTo.y = 0
                            }
                            const overshoot = alignTo.y + alignTo.height - yLen;
                            if (overshoot > 0 && overshoot < alignTo.height) {
                                alignTo.height -= overshoot
                            }
                        }
                        if (inverted) {
                            alignTo = {
                                x: yLen - alignTo.y - alignTo.height,
                                y: xLen - alignTo.x - alignTo.width,
                                width: alignTo.height,
                                height: alignTo.width
                            }
                        }
                        if (!inside) {
                            if (inverted) {
                                alignTo.x += below ? 0 : alignTo.width;
                                alignTo.width = 0
                            } else {
                                alignTo.y += below ? alignTo.height : 0;
                                alignTo.height = 0
                            }
                        }
                    }
                    options.align = pick(options.align, !inverted || inside ? 'center' : below ? 'right' : 'left');
                    options.verticalAlign = pick(options.verticalAlign, inverted || inside ? 'middle' : below ? 'top' : 'bottom');
                    Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
                    if (options.inside && point.contrastColor) {
                        dataLabel.css({
                            color: point.contrastColor
                        })
                    }
                }
                function compose(ColumnSeriesClass) {
                    DataLabel.compose(Series);
                    if (U.pushUnique(composedMembers, ColumnSeriesClass)) {
                        ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel
                    }
                }
                ColumnDataLabel.compose = compose
            }
        )(ColumnDataLabel || (ColumnDataLabel = {}));
        return ColumnDataLabel
    });
    _registerModule(_modules, 'Series/Bar/BarSeries.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(ColumnSeries, SeriesRegistry, U) {
        const {extend, merge} = U;
        class BarSeries extends ColumnSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
        }
        BarSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {});
        extend(BarSeries.prototype, {
            inverted: !0
        });
        SeriesRegistry.registerSeriesType('bar', BarSeries);
        '';
        return BarSeries
    });
    _registerModule(_modules, 'Series/Scatter/ScatterSeriesDefaults.js', [], function() {
        const ScatterSeriesDefaults = {
            lineWidth: 0,
            findNearestPointBy: 'xy',
            jitter: {
                x: 0,
                y: 0
            },
            marker: {
                enabled: !0
            },
            tooltip: {
                headerFormat: '<span style="color:{point.color}">\u25CF</span> ' + '<span style="font-size: 0.8em"> {series.name}</span><br/>',
                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
            }
        };
        '';
        return ScatterSeriesDefaults
    });
    _registerModule(_modules, 'Series/Scatter/ScatterSeries.js', [_modules['Series/Scatter/ScatterSeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(ScatterSeriesDefaults, SeriesRegistry, U) {
        const {column: ColumnSeries, line: LineSeries} = SeriesRegistry.seriesTypes;
        const {addEvent, extend, merge} = U;
        class ScatterSeries extends LineSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            applyJitter() {
                const series = this
                    , jitter = this.options.jitter
                    , len = this.points.length;
                function unrandom(seed) {
                    const rand = Math.sin(seed) * 10000;
                    return rand - Math.floor(rand)
                }
                if (jitter) {
                    this.points.forEach(function(point, i) {
                        ['x', 'y'].forEach(function(dim, j) {
                            let axis, plotProp = 'plot' + dim.toUpperCase(), min, max, translatedJitter;
                            if (jitter[dim] && !point.isNull) {
                                axis = series[dim + 'Axis'];
                                translatedJitter = jitter[dim] * axis.transA;
                                if (axis && !axis.isLog) {
                                    min = Math.max(0, point[plotProp] - translatedJitter);
                                    max = Math.min(axis.len, point[plotProp] + translatedJitter);
                                    point[plotProp] = min + (max - min) * unrandom(i + j * len);
                                    if (dim === 'x') {
                                        point.clientX = point.plotX
                                    }
                                }
                            }
                        })
                    })
                }
            }
            drawGraph() {
                if (this.options.lineWidth) {
                    super.drawGraph()
                } else if (this.graph) {
                    this.graph = this.graph.destroy()
                }
            }
        }
        ScatterSeries.defaultOptions = merge(LineSeries.defaultOptions, ScatterSeriesDefaults);
        extend(ScatterSeries.prototype, {
            drawTracker: ColumnSeries.prototype.drawTracker,
            sorted: !1,
            requireSorting: !1,
            noSharedTooltip: !0,
            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
            takeOrdinalPosition: !1
        });
        addEvent(ScatterSeries, 'afterTranslate', function() {
            this.applyJitter()
        });
        SeriesRegistry.registerSeriesType('scatter', ScatterSeries);
        return ScatterSeries
    });
    _registerModule(_modules, 'Series/CenteredUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Core/Utilities.js']], function(H, Series, U) {
        const {deg2rad} = H;
        const {fireEvent, isNumber, pick, relativeLength} = U;
        var CenteredUtilities;
        (function(CenteredUtilities) {
                function getCenter() {
                    const options = this.options
                        , chart = this.chart
                        , slicingRoom = 2 * (options.slicedOffset || 0)
                        , plotWidth = chart.plotWidth - 2 * slicingRoom
                        , plotHeight = chart.plotHeight - 2 * slicingRoom
                        , centerOption = options.center
                        , smallestSize = Math.min(plotWidth, plotHeight)
                        , thickness = options.thickness;
                    let handleSlicingRoom, size = options.size, innerSize = options.innerSize || 0, i, value;
                    if (typeof size === 'string') {
                        size = parseFloat(size)
                    }
                    if (typeof innerSize === 'string') {
                        innerSize = parseFloat(innerSize)
                    }
                    const positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), pick(size && size < 0 ? void 0 : options.size, '100%'), pick(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, '0%')];
                    if (chart.angular && !(this instanceof Series)) {
                        positions[3] = 0
                    }
                    for (i = 0; i < 4; ++i) {
                        value = positions[i];
                        handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));
                        positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0)
                    }
                    if (positions[3] > positions[2]) {
                        positions[3] = positions[2]
                    }
                    if (isNumber(thickness) && thickness * 2 < positions[2] && thickness > 0) {
                        positions[3] = positions[2] - thickness * 2
                    }
                    fireEvent(this, 'afterGetCenter', {
                        positions
                    });
                    return positions
                }
                CenteredUtilities.getCenter = getCenter;
                function getStartAndEndRadians(start, end) {
                    const startAngle = isNumber(start) ? start : 0
                        , endAngle = ((isNumber(end) && end > startAngle && (end - startAngle) < 360) ? end : startAngle + 360)
                        , correction = -90;
                    return {
                        start: deg2rad * (startAngle + correction),
                        end: deg2rad * (endAngle + correction)
                    }
                }
                CenteredUtilities.getStartAndEndRadians = getStartAndEndRadians
            }
        )(CenteredUtilities || (CenteredUtilities = {}));
        '';
        return CenteredUtilities
    });
    _registerModule(_modules, 'Series/Pie/PiePoint.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function(A, Point, U) {
        const {setAnimation} = A;
        const {addEvent, defined, extend, isNumber, isString, pick, relativeLength} = U;
        class PiePoint extends Point {
            constructor() {
                super(...arguments);
                this.half = 0;
                this.options = void 0;
                this.series = void 0
            }
            getConnectorPath(dataLabel) {
                const labelPosition = dataLabel.dataLabelPosition
                    , options = (dataLabel.options || {})
                    , connectorShape = options.connectorShape
                    , shapeFunc = (this.connectorShapes[connectorShape] || connectorShape);
                return labelPosition && shapeFunc.call(this, {
                    ...labelPosition.computed,
                    alignment: labelPosition.alignment
                }, labelPosition.connectorPosition, options) || []
            }
            getTranslate() {
                return this.sliced && this.slicedTranslation || {
                    translateX: 0,
                    translateY: 0
                }
            }
            haloPath(size) {
                const shapeArgs = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
                    innerR: shapeArgs.r - 1,
                    start: shapeArgs.start,
                    end: shapeArgs.end,
                    borderRadius: shapeArgs.borderRadius
                })
            }
            init() {
                super.init.apply(this, arguments);
                this.name = pick(this.name, 'Slice');
                const toggleSlice = (e) => {
                        this.slice(e.type === 'select')
                    }
                ;
                addEvent(this, 'select', toggleSlice);
                addEvent(this, 'unselect', toggleSlice);
                return this
            }
            isValid() {
                return isNumber(this.y) && this.y >= 0
            }
            setVisible(vis, redraw) {
                const series = this.series
                    , chart = series.chart
                    , ignoreHiddenPoint = series.options.ignoreHiddenPoint;
                redraw = pick(redraw, ignoreHiddenPoint);
                if (vis !== this.visible) {
                    this.visible = this.options.visible = vis = typeof vis === 'undefined' ? !this.visible : vis;
                    series.options.data[series.data.indexOf(this)] = this.options;
                    ['graphic', 'dataLabel', 'connector'].forEach( (key) => {
                            if (this[key]) {
                                this[key][vis ? 'show' : 'hide'](vis)
                            }
                        }
                    );
                    if (this.legendItem) {
                        chart.legend.colorizeItem(this, vis)
                    }
                    if (!vis && this.state === 'hover') {
                        this.setState('')
                    }
                    if (ignoreHiddenPoint) {
                        series.isDirty = !0
                    }
                    if (redraw) {
                        chart.redraw()
                    }
                }
            }
            slice(sliced, redraw, animation) {
                const series = this.series
                    , chart = series.chart;
                setAnimation(animation, chart);
                redraw = pick(redraw, !0);
                this.sliced = this.options.sliced = sliced = defined(sliced) ? sliced : !this.sliced;
                series.options.data[series.data.indexOf(this)] = this.options;
                if (this.graphic) {
                    this.graphic.animate(this.getTranslate())
                }
            }
        }
        extend(PiePoint.prototype, {
            connectorShapes: {
                fixedOffset: function(labelPosition, connectorPosition, options) {
                    const breakAt = connectorPosition.breakAt
                        , touchingSliceAt = connectorPosition.touchingSliceAt
                        , lineSegment = options.softConnector ? ['C', labelPosition.x + (labelPosition.alignment === 'left' ? -5 : 5), labelPosition.y, 2 * breakAt.x - touchingSliceAt.x, 2 * breakAt.y - touchingSliceAt.y, breakAt.x, breakAt.y] : ['L', breakAt.x, breakAt.y];
                    return ([['M', labelPosition.x, labelPosition.y], lineSegment, ['L', touchingSliceAt.x, touchingSliceAt.y]])
                },
                straight: function(labelPosition, connectorPosition) {
                    const touchingSliceAt = connectorPosition.touchingSliceAt;
                    return [['M', labelPosition.x, labelPosition.y], ['L', touchingSliceAt.x, touchingSliceAt.y]]
                },
                crookedLine: function(labelPosition, connectorPosition, options) {
                    const {breakAt, touchingSliceAt} = connectorPosition
                        , {series} = this
                        , [cx,cy,diameter] = series.center
                        , r = diameter / 2
                        , {plotLeft, plotWidth} = series.chart
                        , leftAligned = labelPosition.alignment === 'left'
                        , {x, y} = labelPosition;
                    let crookX = breakAt.x;
                    if (options.crookDistance) {
                        const crookDistance = relativeLength(options.crookDistance, 1);
                        crookX = leftAligned ? cx + r + (plotWidth + plotLeft - cx - r) * (1 - crookDistance) : plotLeft + (cx - r) * crookDistance
                    } else {
                        crookX = cx + (cy - y) * Math.tan((this.angle || 0) - Math.PI / 2)
                    }
                    const path = [['M', x, y]];
                    if (leftAligned ? (crookX <= x && crookX >= breakAt.x) : (crookX >= x && crookX <= breakAt.x)) {
                        path.push(['L', crookX, y])
                    }
                    path.push(['L', breakAt.x, breakAt.y], ['L', touchingSliceAt.x, touchingSliceAt.y]);
                    return path
                }
            }
        });
        return PiePoint
    });
    _registerModule(_modules, 'Series/Pie/PieSeriesDefaults.js', [], function() {
        const PieSeriesDefaults = {
            borderRadius: 3,
            center: [null, null],
            clip: !1,
            colorByPoint: !0,
            dataLabels: {
                connectorPadding: 5,
                connectorShape: 'crookedLine',
                crookDistance: void 0,
                distance: 30,
                enabled: !0,
                formatter: function() {
                    return this.point.isNull ? void 0 : this.point.name
                },
                softConnector: !0,
                x: 0
            },
            fillColor: void 0,
            ignoreHiddenPoint: !0,
            inactiveOtherPoints: !0,
            legendType: 'point',
            marker: null,
            size: null,
            showInLegend: !1,
            slicedOffset: 10,
            stickyTracking: !1,
            tooltip: {
                followPointer: !0
            },
            borderColor: "#ffffff",
            borderWidth: 1,
            lineWidth: void 0,
            states: {
                hover: {
                    brightness: 0.1
                }
            }
        };
        '';
        return PieSeriesDefaults
    });
    _registerModule(_modules, 'Series/Pie/PieSeries.js', [_modules['Series/CenteredUtilities.js'], _modules['Series/Column/ColumnSeries.js'], _modules['Core/Globals.js'], _modules['Series/Pie/PiePoint.js'], _modules['Series/Pie/PieSeriesDefaults.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Renderer/SVG/Symbols.js'], _modules['Core/Utilities.js']], function(CU, ColumnSeries, H, PiePoint, PieSeriesDefaults, Series, SeriesRegistry, Symbols, U) {
        const {getStartAndEndRadians} = CU;
        const {noop} = H;
        const {clamp, extend, fireEvent, merge, pick, relativeLength, splat} = U;
        class PieSeries extends Series {
            constructor() {
                super(...arguments);
                this.center = void 0;
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            animate(init) {
                const series = this
                    , points = series.points
                    , startAngleRad = series.startAngleRad;
                if (!init) {
                    points.forEach(function(point) {
                        const graphic = point.graphic
                            , args = point.shapeArgs;
                        if (graphic && args) {
                            graphic.attr({
                                r: pick(point.startR, (series.center && series.center[3] / 2)),
                                start: startAngleRad,
                                end: startAngleRad
                            });
                            graphic.animate({
                                r: args.r,
                                start: args.start,
                                end: args.end
                            }, series.options.animation)
                        }
                    })
                }
            }
            drawEmpty() {
                const start = this.startAngleRad
                    , end = this.endAngleRad
                    , options = this.options;
                let centerX, centerY;
                if (this.total === 0 && this.center) {
                    centerX = this.center[0];
                    centerY = this.center[1];
                    if (!this.graph) {
                        this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start, end).addClass('highcharts-empty-series').add(this.group)
                    }
                    this.graph.attr({
                        d: Symbols.arc(centerX, centerY, this.center[2] / 2, 0, {
                            start,
                            end,
                            innerR: this.center[3] / 2
                        })
                    });
                    if (!this.chart.styledMode) {
                        this.graph.attr({
                            'stroke-width': options.borderWidth,
                            fill: options.fillColor || 'none',
                            stroke: options.color || "#cccccc"
                        })
                    }
                } else if (this.graph) {
                    this.graph = this.graph.destroy()
                }
            }
            drawPoints() {
                const renderer = this.chart.renderer;
                this.points.forEach(function(point) {
                    if (point.graphic && point.hasNewShapeType()) {
                        point.graphic = point.graphic.destroy()
                    }
                    if (!point.graphic) {
                        point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
                        point.delayedRendering = !0
                    }
                })
            }
            generatePoints() {
                super.generatePoints();
                this.updateTotals()
            }
            getX(y, left, point, dataLabel) {
                const center = this.center
                    , radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2
                    , labelPosition = dataLabel.dataLabelPosition
                    , distance = labelPosition?.distance || 0;
                const angle = Math.asin(clamp((y - center[1]) / (radius + distance), -1, 1));
                const x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + distance)) + (distance > 0 ? (left ? -1 : 1) * (dataLabel.padding || 0) : 0);
                return x
            }
            hasData() {
                return !!this.processedXData.length
            }
            redrawPoints() {
                const series = this
                    , chart = series.chart;
                let groupTranslation, graphic, pointAttr, shapeArgs;
                this.drawEmpty();
                if (series.group && !chart.styledMode) {
                    series.group.shadow(series.options.shadow)
                }
                series.points.forEach(function(point) {
                    const animateTo = {};
                    graphic = point.graphic;
                    if (!point.isNull && graphic) {
                        shapeArgs = point.shapeArgs;
                        groupTranslation = point.getTranslate();
                        if (!chart.styledMode) {
                            pointAttr = series.pointAttribs(point, (point.selected && 'select'))
                        }
                        if (!point.delayedRendering) {
                            graphic.setRadialReference(series.center);
                            if (!chart.styledMode) {
                                merge(!0, animateTo, pointAttr)
                            }
                            merge(!0, animateTo, shapeArgs, groupTranslation);
                            graphic.animate(animateTo)
                        } else {
                            graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
                            if (!chart.styledMode) {
                                graphic.attr(pointAttr).attr({
                                    'stroke-linejoin': 'round'
                                })
                            }
                            point.delayedRendering = !1
                        }
                        graphic.attr({
                            visibility: point.visible ? 'inherit' : 'hidden'
                        });
                        graphic.addClass(point.getClassName(), !0)
                    } else if (graphic) {
                        point.graphic = graphic.destroy()
                    }
                })
            }
            sortByAngle(points, sign) {
                points.sort(function(a, b) {
                    return ((typeof a.angle !== 'undefined') && (b.angle - a.angle) * sign)
                })
            }
            translate(positions) {
                fireEvent(this, 'translate');
                this.generatePoints();
                const series = this
                    , precision = 1000
                    , options = series.options
                    , slicedOffset = options.slicedOffset
                    , radians = getStartAndEndRadians(options.startAngle, options.endAngle)
                    , startAngleRad = series.startAngleRad = radians.start
                    , endAngleRad = series.endAngleRad = radians.end
                    , circ = endAngleRad - startAngleRad
                    , points = series.points
                    , ignoreHiddenPoint = options.ignoreHiddenPoint
                    , len = points.length;
                let start, end, angle, radiusX, radiusY, i, point, cumulative = 0;
                if (!positions) {
                    series.center = positions = series.getCenter()
                }
                for (i = 0; i < len; i++) {
                    point = points[i];
                    start = startAngleRad + (cumulative * circ);
                    if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
                        cumulative += point.percentage / 100
                    }
                    end = startAngleRad + (cumulative * circ);
                    const shapeArgs = {
                        x: positions[0],
                        y: positions[1],
                        r: positions[2] / 2,
                        innerR: positions[3] / 2,
                        start: Math.round(start * precision) / precision,
                        end: Math.round(end * precision) / precision
                    };
                    point.shapeType = 'arc';
                    point.shapeArgs = shapeArgs;
                    angle = (end + start) / 2;
                    if (angle > 1.5 * Math.PI) {
                        angle -= 2 * Math.PI
                    } else if (angle < -Math.PI / 2) {
                        angle += 2 * Math.PI
                    }
                    point.slicedTranslation = {
                        translateX: Math.round(Math.cos(angle) * slicedOffset),
                        translateY: Math.round(Math.sin(angle) * slicedOffset)
                    };
                    radiusX = Math.cos(angle) * positions[2] / 2;
                    radiusY = Math.sin(angle) * positions[2] / 2;
                    point.tooltipPos = [positions[0] + radiusX * 0.7, positions[1] + radiusY * 0.7];
                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
                    point.angle = angle
                }
                fireEvent(series, 'afterTranslate')
            }
            updateTotals() {
                const points = this.points
                    , len = points.length
                    , ignoreHiddenPoint = this.options.ignoreHiddenPoint;
                let i, point, total = 0;
                for (i = 0; i < len; i++) {
                    point = points[i];
                    if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
                        total += point.y
                    }
                }
                this.total = total;
                for (i = 0; i < len; i++) {
                    point = points[i];
                    point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
                    point.total = total
                }
            }
        }
        PieSeries.defaultOptions = merge(Series.defaultOptions, PieSeriesDefaults);
        extend(PieSeries.prototype, {
            axisTypes: [],
            directTouch: !0,
            drawGraph: void 0,
            drawTracker: ColumnSeries.prototype.drawTracker,
            getCenter: CU.getCenter,
            getSymbol: noop,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointAttribs: ColumnSeries.prototype.pointAttribs,
            pointClass: PiePoint,
            requireSorting: !1,
            searchPoint: noop,
            trackerGroups: ['group', 'dataLabelsGroup']
        });
        SeriesRegistry.registerSeriesType('pie', PieSeries);
        return PieSeries
    });
    _registerModule(_modules, 'Series/Pie/PieDataLabel.js', [_modules['Core/Series/DataLabel.js'], _modules['Core/Globals.js'], _modules['Core/Renderer/RendererUtilities.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(DataLabel, H, R, SeriesRegistry, U) {
        const {noop} = H;
        const {distribute} = R;
        const {series: Series} = SeriesRegistry;
        const {arrayMax, clamp, defined, pick, relativeLength} = U;
        var ColumnDataLabel;
        (function(ColumnDataLabel) {
                const composedMembers = [];
                const dataLabelPositioners = {
                    radialDistributionY: function(point, dataLabel) {
                        return (dataLabel.dataLabelPosition?.top || 0) + point.distributeBox.pos
                    },
                    radialDistributionX: function(series, point, y, naturalY, dataLabel) {
                        const pos = dataLabel.dataLabelPosition;
                        return series.getX(y < (pos?.top || 0) + 2 || y > (pos?.bottom || 0) - 2 ? naturalY : y, point.half, point, dataLabel)
                    },
                    justify: function(point, dataLabel, radius, seriesCenter) {
                        return seriesCenter[0] + (point.half ? -1 : 1) * (radius + (dataLabel.dataLabelPosition?.distance || 0))
                    },
                    alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
                        const dataLabelWidth = dataLabel.getBBox().width;
                        return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft
                    },
                    alignToConnectors: function(points, half, plotWidth, plotLeft) {
                        let maxDataLabelWidth = 0, dataLabelWidth;
                        points.forEach(function(point) {
                            dataLabelWidth = point.dataLabel.getBBox().width;
                            if (dataLabelWidth > maxDataLabelWidth) {
                                maxDataLabelWidth = dataLabelWidth
                            }
                        });
                        return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft
                    }
                };
                function compose(PieSeriesClass) {
                    DataLabel.compose(Series);
                    if (U.pushUnique(composedMembers, PieSeriesClass)) {
                        const pieProto = PieSeriesClass.prototype;
                        pieProto.dataLabelPositioners = dataLabelPositioners;
                        pieProto.alignDataLabel = noop;
                        pieProto.drawDataLabels = drawDataLabels;
                        pieProto.getDataLabelPosition = getDataLabelPosition;
                        pieProto.placeDataLabels = placeDataLabels;
                        pieProto.verifyDataLabelOverflow = verifyDataLabelOverflow
                    }
                }
                ColumnDataLabel.compose = compose;
                function getDataLabelPosition(point, distance) {
                    const {center, options} = this
                        , r = center[2] / 2
                        , angle = point.angle || 0
                        , cosAngle = Math.cos(angle)
                        , sinAngle = Math.sin(angle)
                        , x = center[0] + cosAngle * r
                        , y = center[1] + sinAngle * r
                        , finalConnectorOffset = Math.min((options.slicedOffset || 0) + (options.borderWidth || 0), distance / 5);
                    return {
                        natural: {
                            x: x + cosAngle * distance,
                            y: y + sinAngle * distance
                        },
                        computed: {},
                        alignment: distance < 0 ? 'center' : point.half ? 'right' : 'left',
                        connectorPosition: {
                            breakAt: {
                                x: x + cosAngle * finalConnectorOffset,
                                y: y + sinAngle * finalConnectorOffset
                            },
                            touchingSliceAt: {
                                x,
                                y
                            }
                        },
                        distance
                    }
                }
                function drawDataLabels() {
                    const series = this
                        , points = series.points
                        , chart = series.chart
                        , plotWidth = chart.plotWidth
                        , plotHeight = chart.plotHeight
                        , plotLeft = chart.plotLeft
                        , maxWidth = Math.round(chart.chartWidth / 3)
                        , seriesCenter = series.center
                        , radius = seriesCenter[2] / 2
                        , centerY = seriesCenter[1]
                        , halves = [[], []]
                        , overflow = [0, 0, 0, 0]
                        , dataLabelPositioners = series.dataLabelPositioners;
                    let connector, dataLabelWidth, labelHeight, maxLabelDistance = 0;
                    if (!series.visible || !series.hasDataLabels?.()) {
                        return
                    }
                    points.forEach( (point) => {
                            (point.dataLabels || []).forEach( (dataLabel) => {
                                    if (dataLabel.shortened) {
                                        dataLabel.attr({
                                            width: 'auto'
                                        }).css({
                                            width: 'auto',
                                            textOverflow: 'clip'
                                        });
                                        dataLabel.shortened = !1
                                    }
                                }
                            )
                        }
                    );
                    Series.prototype.drawDataLabels.apply(series);
                    points.forEach( (point) => {
                            (point.dataLabels || []).forEach( (dataLabel, i) => {
                                    const r = seriesCenter[2] / 2
                                        , dataLabelOptions = dataLabel.options
                                        , distance = relativeLength(dataLabelOptions?.distance || 0, r);
                                    if (i === 0) {
                                        halves[point.half].push(point)
                                    }
                                    if (!defined(dataLabelOptions?.style?.width)) {
                                        if (dataLabel.getBBox().width > maxWidth) {
                                            dataLabel.css({
                                                width: Math.round(maxWidth * 0.7) + 'px'
                                            });
                                            dataLabel.shortened = !0
                                        }
                                    }
                                    dataLabel.dataLabelPosition = this.getDataLabelPosition(point, distance);
                                    maxLabelDistance = Math.max(maxLabelDistance, distance)
                                }
                            )
                        }
                    );
                    halves.forEach( (points, halfIdx) => {
                            const length = points.length
                                , positions = [];
                            let top, bottom, size = 0, distributionLength;
                            if (!length) {
                                return
                            }
                            series.sortByAngle(points, halfIdx - 0.5);
                            if (maxLabelDistance > 0) {
                                top = Math.max(0, centerY - radius - maxLabelDistance);
                                bottom = Math.min(centerY + radius + maxLabelDistance, chart.plotHeight);
                                points.forEach( (point) => {
                                        (point.dataLabels || []).forEach( (dataLabel, i) => {
                                                const labelPosition = dataLabel.dataLabelPosition;
                                                if (labelPosition && labelPosition.distance > 0) {
                                                    labelPosition.top = Math.max(0, centerY - radius - labelPosition.distance);
                                                    labelPosition.bottom = Math.min(centerY + radius + labelPosition.distance, chart.plotHeight);
                                                    size = dataLabel.getBBox().height || 21;
                                                    point.distributeBox = {
                                                        target: ((dataLabel.dataLabelPosition?.natural.y || 0) - labelPosition.top + size / 2),
                                                        size,
                                                        rank: point.y
                                                    };
                                                    positions.push(point.distributeBox)
                                                }
                                            }
                                        )
                                    }
                                );
                                distributionLength = bottom + size - top;
                                distribute(positions, distributionLength, distributionLength / 5)
                            }
                            points.forEach( (point) => {
                                    (point.dataLabels || []).forEach( (dataLabel) => {
                                            const dataLabelOptions = (dataLabel.options || {})
                                                , distributeBox = point.distributeBox
                                                , labelPosition = dataLabel.dataLabelPosition
                                                , naturalY = labelPosition?.natural.y || 0
                                                , connectorPadding = dataLabelOptions.connectorPadding || 0;
                                            let x = 0
                                                , y = naturalY
                                                , visibility = 'inherit';
                                            if (labelPosition) {
                                                if (positions && defined(distributeBox) && labelPosition.distance > 0) {
                                                    if (typeof distributeBox.pos === 'undefined') {
                                                        visibility = 'hidden'
                                                    } else {
                                                        labelHeight = distributeBox.size;
                                                        y = dataLabelPositioners.radialDistributionY(point, dataLabel)
                                                    }
                                                }
                                                if (dataLabelOptions.justify) {
                                                    x = dataLabelPositioners.justify(point, dataLabel, radius, seriesCenter)
                                                } else {
                                                    switch (dataLabelOptions.alignTo) {
                                                        case 'connectors':
                                                            x = dataLabelPositioners.alignToConnectors(points, halfIdx, plotWidth, plotLeft);
                                                            break;
                                                        case 'plotEdges':
                                                            x = dataLabelPositioners.alignToPlotEdges(dataLabel, halfIdx, plotWidth, plotLeft);
                                                            break;
                                                        default:
                                                            x = dataLabelPositioners.radialDistributionX(series, point, y, naturalY, dataLabel)
                                                    }
                                                }
                                                labelPosition.attribs = {
                                                    visibility,
                                                    align: labelPosition.alignment
                                                };
                                                labelPosition.posAttribs = {
                                                    x: x + (dataLabelOptions.x || 0) + ({
                                                        left: connectorPadding,
                                                        right: -connectorPadding
                                                    }[labelPosition.alignment] || 0),
                                                    y: y + (dataLabelOptions.y || 0) - dataLabel.getBBox().height / 2
                                                };
                                                labelPosition.computed.x = x;
                                                labelPosition.computed.y = y;
                                                if (pick(dataLabelOptions.crop, !0)) {
                                                    dataLabelWidth = dataLabel.getBBox().width;
                                                    let sideOverflow;
                                                    if (x - dataLabelWidth < connectorPadding && halfIdx === 1) {
                                                        sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
                                                        overflow[3] = Math.max(sideOverflow, overflow[3])
                                                    } else if (x + dataLabelWidth > plotWidth - connectorPadding && halfIdx === 0) {
                                                        sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
                                                        overflow[1] = Math.max(sideOverflow, overflow[1])
                                                    }
                                                    if (y - labelHeight / 2 < 0) {
                                                        overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0])
                                                    } else if (y + labelHeight / 2 > plotHeight) {
                                                        overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2])
                                                    }
                                                    labelPosition.sideOverflow = sideOverflow
                                                }
                                            }
                                        }
                                    )
                                }
                            )
                        }
                    );
                    if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
                        this.placeDataLabels();
                        this.points.forEach( (point) => {
                                (point.dataLabels || []).forEach( (dataLabel) => {
                                        const {connectorColor, connectorWidth=1} = (dataLabel.options || {})
                                            , labelPosition = dataLabel.dataLabelPosition;
                                        if (connectorWidth) {
                                            let isNew;
                                            connector = dataLabel.connector;
                                            if (labelPosition && labelPosition.distance > 0) {
                                                isNew = !connector;
                                                if (!connector) {
                                                    dataLabel.connector = connector = chart.renderer.path().addClass('highcharts-data-label-connector ' + ' highcharts-color-' + point.colorIndex + (point.className ? ' ' + point.className : '')).add(series.dataLabelsGroup)
                                                }
                                                if (!chart.styledMode) {
                                                    connector.attr({
                                                        'stroke-width': connectorWidth,
                                                        'stroke': (connectorColor || point.color || "#666666")
                                                    })
                                                }
                                                connector[isNew ? 'attr' : 'animate']({
                                                    d: point.getConnectorPath(dataLabel)
                                                });
                                                connector.attr({
                                                    visibility: labelPosition.attribs?.visibility
                                                })
                                            } else if (connector) {
                                                dataLabel.connector = connector.destroy()
                                            }
                                        }
                                    }
                                )
                            }
                        )
                    }
                }
                function placeDataLabels() {
                    this.points.forEach( (point) => {
                            (point.dataLabels || []).forEach( (dataLabel) => {
                                    const labelPosition = dataLabel.dataLabelPosition;
                                    if (labelPosition) {
                                        if (labelPosition.sideOverflow) {
                                            dataLabel.css({
                                                width: (Math.max(dataLabel.getBBox().width - labelPosition.sideOverflow, 0)) + 'px',
                                                textOverflow: ((dataLabel.options?.style || {}).textOverflow || 'ellipsis')
                                            });
                                            dataLabel.shortened = !0
                                        }
                                        dataLabel.attr(labelPosition.attribs);
                                        dataLabel[dataLabel.moved ? 'animate' : 'attr'](labelPosition.posAttribs);
                                        dataLabel.moved = !0
                                    } else if (dataLabel) {
                                        dataLabel.attr({
                                            y: -9999
                                        })
                                    }
                                }
                            );
                            delete point.distributeBox
                        }
                        , this)
                }
                function verifyDataLabelOverflow(overflow) {
                    let center = this.center
                        , options = this.options
                        , centerOption = options.center
                        , minSize = options.minSize || 80
                        , newSize = minSize
                        , ret = options.size !== null;
                    if (!ret) {
                        if (centerOption[0] !== null) {
                            newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize)
                        } else {
                            newSize = Math.max(center[2] - overflow[1] - overflow[3], minSize);
                            center[0] += (overflow[3] - overflow[1]) / 2
                        }
                        if (centerOption[1] !== null) {
                            newSize = clamp(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]))
                        } else {
                            newSize = clamp(newSize, minSize, center[2] - overflow[0] - overflow[2]);
                            center[1] += (overflow[0] - overflow[2]) / 2
                        }
                        if (newSize < center[2]) {
                            center[2] = newSize;
                            center[3] = Math.min(options.thickness ? Math.max(0, newSize - options.thickness * 2) : Math.max(0, relativeLength(options.innerSize || 0, newSize)), newSize);
                            this.translate(center);
                            if (this.drawDataLabels) {
                                this.drawDataLabels()
                            }
                        } else {
                            ret = !0
                        }
                    }
                    return ret
                }
            }
        )(ColumnDataLabel || (ColumnDataLabel = {}));
        return ColumnDataLabel
    });
    _registerModule(_modules, 'Extensions/OverlappingDataLabels.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, fireEvent, isNumber, objectEach, pick, pushUnique} = U;
        const composedMembers = [];
        function chartHideOverlappingLabels(labels) {
            const chart = this
                , len = labels.length
                , ren = chart.renderer
                , isIntersectRect = (box1, box2) => !(box2.x >= box1.x + box1.width || box2.x + box2.width <= box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y)
                , getAbsoluteBox = (label) => {
                    const padding = label.box ? 0 : (label.padding || 0);
                    let pos, parent, bBox, lineHeightCorrection = 0, xOffset = 0, boxWidth, alignValue;
                    if (label && (!label.alignAttr || label.placed)) {
                        pos = label.alignAttr || {
                            x: label.attr('x'),
                            y: label.attr('y')
                        };
                        parent = label.parentGroup;
                        if (!label.width) {
                            bBox = label.getBBox();
                            label.width = bBox.width;
                            label.height = bBox.height;
                            lineHeightCorrection = ren.fontMetrics(label.element).h
                        }
                        boxWidth = label.width - 2 * padding;
                        alignValue = {
                            left: '0',
                            center: '0.5',
                            right: '1'
                        }[label.alignValue];
                        if (alignValue) {
                            xOffset = +alignValue * boxWidth
                        } else if (isNumber(label.x) && Math.round(label.x) !== label.translateX) {
                            xOffset = label.x - (label.translateX || 0)
                        }
                        return {
                            x: pos.x + (parent.translateX || 0) + padding - (xOffset || 0),
                            y: pos.y + (parent.translateY || 0) + padding - lineHeightCorrection,
                            width: label.width - 2 * padding,
                            height: (label.height || 0) - 2 * padding
                        }
                    }
                }
            ;
            let label, label1, label2, box1, box2, isLabelAffected = !1;
            for (let i = 0; i < len; i++) {
                label = labels[i];
                if (label) {
                    label.oldOpacity = label.opacity;
                    label.newOpacity = 1;
                    label.absoluteBox = getAbsoluteBox(label)
                }
            }
            labels.sort( (a, b) => (b.labelrank || 0) - (a.labelrank || 0));
            for (let i = 0; i < len; ++i) {
                label1 = labels[i];
                box1 = label1 && label1.absoluteBox;
                for (let j = i + 1; j < len; ++j) {
                    label2 = labels[j];
                    box2 = label2 && label2.absoluteBox;
                    if (box1 && box2 && label1 !== label2 && label1.newOpacity !== 0 && label2.newOpacity !== 0 && label1.visibility !== 'hidden' && label2.visibility !== 'hidden') {
                        if (isIntersectRect(box1, box2)) {
                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0
                        }
                    }
                }
            }
            for (const label of labels) {
                if (hideOrShow(label, chart)) {
                    isLabelAffected = !0
                }
            }
            if (isLabelAffected) {
                fireEvent(chart, 'afterHideAllOverlappingLabels')
            }
        }
        function compose(ChartClass) {
            if (pushUnique(composedMembers, ChartClass)) {
                const chartProto = ChartClass.prototype;
                chartProto.hideOverlappingLabels = chartHideOverlappingLabels;
                addEvent(ChartClass, 'render', onChartRender)
            }
        }
        function hideOrShow(label, chart) {
            let complete, newOpacity, isLabelAffected = !1;
            if (label) {
                newOpacity = label.newOpacity;
                if (label.oldOpacity !== newOpacity) {
                    if (label.alignAttr && label.placed) {
                        label[newOpacity ? 'removeClass' : 'addClass']('highcharts-data-label-hidden');
                        complete = function() {
                            if (!chart.styledMode) {
                                label.css({
                                    pointerEvents: newOpacity ? 'auto' : 'none'
                                })
                            }
                        }
                        ;
                        isLabelAffected = !0;
                        label.alignAttr.opacity = newOpacity;
                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
                        fireEvent(chart, 'afterHideOverlappingLabel')
                    } else {
                        label.attr({
                            opacity: newOpacity
                        })
                    }
                }
                label.isOld = !0
            }
            return isLabelAffected
        }
        function onChartRender() {
            const chart = this;
            let labels = [];
            for (const collector of (chart.labelCollectors || [])) {
                labels = labels.concat(collector())
            }
            for (const yAxis of (chart.yAxis || [])) {
                if (yAxis.stacking && yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
                    objectEach(yAxis.stacking.stacks, (stack) => {
                            objectEach(stack, (stackItem) => {
                                    if (stackItem.label) {
                                        labels.push(stackItem.label)
                                    }
                                }
                            )
                        }
                    )
                }
            }
            for (const series of (chart.series || [])) {
                if (series.visible && series.hasDataLabels?.()) {
                    const push = (points) => {
                            for (const point of points) {
                                if (point.visible) {
                                    (point.dataLabels || []).forEach( (label) => {
                                            const options = label.options || {};
                                            label.labelrank = pick(options.labelrank, point.labelrank, point.shapeArgs?.height);
                                            if (options.allowOverlap ?? Number(options.distance) > 0) {
                                                label.oldOpacity = label.opacity;
                                                label.newOpacity = 1;
                                                hideOrShow(label, chart)
                                            } else {
                                                labels.push(label)
                                            }
                                        }
                                    )
                                }
                            }
                        }
                    ;
                    push(series.nodes || []);
                    push(series.points)
                }
            }
            this.hideOverlappingLabels(labels)
        }
        const OverlappingDataLabels = {
            compose
        };
        return OverlappingDataLabels
    });
    _registerModule(_modules, 'Extensions/BorderRadius.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(D, G, U) {
        const {defaultOptions} = D;
        const {noop} = G;
        const {addEvent, extend, isObject, merge, pushUnique, relativeLength} = U;
        const composedMembers = [];
        const defaultBorderRadiusOptions = {
            radius: 0,
            scope: 'stack',
            where: void 0
        };
        let oldArc = noop;
        let oldRoundedRect = noop;
        function applyBorderRadius(path, i, r) {
            const a = path[i];
            let b = path[i + 1];
            if (b[0] === 'Z') {
                b = path[0]
            }
            let line, arc, fromLineToArc;
            if ((a[0] === 'M' || a[0] === 'L') && b[0] === 'A') {
                line = a;
                arc = b;
                fromLineToArc = !0
            } else if (a[0] === 'A' && (b[0] === 'M' || b[0] === 'L')) {
                line = b;
                arc = a
            }
            if (line && arc && arc.params) {
                const bigR = arc[1]
                    , clockwise = arc[5]
                    , params = arc.params
                    , {start, end, cx, cy} = params;
                const relativeR = clockwise ? (bigR - r) : (bigR + r)
                    , angleOfBorderRadius = relativeR ? Math.asin(r / relativeR) : 0
                    , angleOffset = clockwise ? angleOfBorderRadius : -angleOfBorderRadius
                    , distanceBigCenterToStartArc = (Math.cos(angleOfBorderRadius) * relativeR);
                if (fromLineToArc) {
                    params.start = start + angleOffset;
                    line[1] = cx + distanceBigCenterToStartArc * Math.cos(start);
                    line[2] = cy + distanceBigCenterToStartArc * Math.sin(start);
                    path.splice(i + 1, 0, ['A', r, r, 0, 0, 1, cx + bigR * Math.cos(params.start), cy + bigR * Math.sin(params.start)])
                } else {
                    params.end = end - angleOffset;
                    arc[6] = cx + bigR * Math.cos(params.end);
                    arc[7] = cy + bigR * Math.sin(params.end);
                    path.splice(i + 1, 0, ['A', r, r, 0, 0, 1, cx + distanceBigCenterToStartArc * Math.cos(end), cy + distanceBigCenterToStartArc * Math.sin(end)])
                }
                arc[4] = Math.abs(params.end - params.start) < Math.PI ? 0 : 1
            }
        }
        function arc(x, y, w, h, options={}) {
            const path = oldArc(x, y, w, h, options)
                , {innerR=0, r=w, start=0, end=0} = options;
            if (options.open || !options.borderRadius) {
                return path
            }
            const alpha = end - start
                , sinHalfAlpha = Math.sin(alpha / 2)
                , borderRadius = Math.max(Math.min(relativeLength(options.borderRadius || 0, r - innerR), (r - innerR) / 2, (r * sinHalfAlpha) / (1 + sinHalfAlpha)), 0)
                , innerBorderRadius = Math.min(borderRadius, 2 * (alpha / Math.PI) * innerR);
            let i = path.length - 1;
            while (i--) {
                applyBorderRadius(path, i, i > 1 ? innerBorderRadius : borderRadius)
            }
            return path
        }
        function seriesOnAfterColumnTranslate() {
            if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
                const {options, yAxis} = this
                    , percent = options.stacking === 'percent'
                    , seriesDefault = defaultOptions.plotOptions?.[this.type]?.borderRadius
                    , borderRadius = optionsToObject(options.borderRadius, isObject(seriesDefault) ? seriesDefault : {})
                    , reversed = yAxis.options.reversed;
                for (const point of this.points) {
                    const {shapeArgs} = point;
                    if (point.shapeType === 'roundedRect' && shapeArgs) {
                        const {width=0, height=0, y=0} = shapeArgs;
                        let brBoxY = y
                            , brBoxHeight = height;
                        if (borderRadius.scope === 'stack' && point.stackTotal) {
                            const stackEnd = yAxis.translate(percent ? 100 : point.stackTotal, !1, !0, !1, !0)
                                , stackThreshold = yAxis.translate(options.threshold || 0, !1, !0, !1, !0)
                                , box = this.crispCol(0, Math.min(stackEnd, stackThreshold), 0, Math.abs(stackEnd - stackThreshold));
                            brBoxY = box.y;
                            brBoxHeight = box.height
                        }
                        const flip = (point.negative ? -1 : 1) * (reversed ? -1 : 1) === -1;
                        let where = borderRadius.where;
                        if (!where && this.is('waterfall') && Math.abs((point.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth) {
                            where = 'all'
                        }
                        if (!where) {
                            where = 'end'
                        }
                        const r = Math.min(relativeLength(borderRadius.radius, width), width / 2, where === 'all' ? height / 2 : Infinity) || 0;
                        if (where === 'end') {
                            if (flip) {
                                brBoxY -= r;
                                brBoxHeight += r
                            } else {
                                brBoxHeight += r
                            }
                        }
                        extend(shapeArgs, {
                            brBoxHeight,
                            brBoxY,
                            r
                        })
                    }
                }
            }
        }
        function compose(SeriesClass, PieSeriesClass, SVGElementClass, SVGRendererClass) {
            if (pushUnique(composedMembers, SeriesClass)) {
                addEvent(SeriesClass, 'afterColumnTranslate', seriesOnAfterColumnTranslate, {
                    order: 9
                })
            }
            if (pushUnique(composedMembers, PieSeriesClass)) {
                addEvent(PieSeriesClass, 'afterTranslate', pieSeriesOnAfterTranslate)
            }
            if (pushUnique(composedMembers, SVGElementClass)) {
                SVGElementClass.symbolCustomAttribs.push('borderRadius', 'brBoxHeight', 'brBoxY')
            }
            if (pushUnique(composedMembers, SVGRendererClass)) {
                const symbols = SVGRendererClass.prototype.symbols;
                oldArc = symbols.arc;
                oldRoundedRect = symbols.roundedRect;
                symbols.arc = arc;
                symbols.roundedRect = roundedRect
            }
        }
        function optionsToObject(options, seriesBROptions) {
            if (!isObject(options)) {
                options = {
                    radius: options || 0
                }
            }
            return merge(defaultBorderRadiusOptions, seriesBROptions, options)
        }
        function pieSeriesOnAfterTranslate() {
            const borderRadius = optionsToObject(this.options.borderRadius);
            for (const point of this.points) {
                const shapeArgs = point.shapeArgs;
                if (shapeArgs) {
                    shapeArgs.borderRadius = relativeLength(borderRadius.radius, (shapeArgs.r || 0) - ((shapeArgs.innerR) || 0))
                }
            }
        }
        function roundedRect(x, y, width, height, options={}) {
            const path = oldRoundedRect(x, y, width, height, options)
                , {r=0, brBoxHeight=height, brBoxY=y} = options
                , brOffsetTop = y - brBoxY
                , brOffsetBtm = (brBoxY + brBoxHeight) - (y + height)
                , rTop = (brOffsetTop - r) > -0.1 ? 0 : r
                , rBtm = (brOffsetBtm - r) > -0.1 ? 0 : r
                , cutTop = Math.max(rTop && brOffsetTop, 0)
                , cutBtm = Math.max(rBtm && brOffsetBtm, 0);
            const a = [x + rTop, y]
                , b = [x + width - rTop, y]
                , c = [x + width, y + rTop]
                , d = [x + width, y + height - rBtm]
                , e = [x + width - rBtm, y + height]
                , f = [x + rBtm, y + height]
                , g = [x, y + height - rBtm]
                , h = [x, y + rTop];
            const applyPythagoras = (r, altitude) => Math.sqrt(Math.pow(r, 2) - Math.pow(altitude, 2));
            if (cutTop) {
                const base = applyPythagoras(rTop, rTop - cutTop);
                a[0] -= base;
                b[0] += base;
                c[1] = h[1] = y + rTop - cutTop
            }
            if (height < rTop - cutTop) {
                const base = applyPythagoras(rTop, rTop - cutTop - height);
                c[0] = d[0] = x + width - rTop + base;
                e[0] = Math.min(c[0], e[0]);
                f[0] = Math.max(d[0], f[0]);
                g[0] = h[0] = x + rTop - base;
                c[1] = h[1] = y + height
            }
            if (cutBtm) {
                const base = applyPythagoras(rBtm, rBtm - cutBtm);
                e[0] += base;
                f[0] -= base;
                d[1] = g[1] = y + height - rBtm + cutBtm
            }
            if (height < rBtm - cutBtm) {
                const base = applyPythagoras(rBtm, rBtm - cutBtm - height);
                c[0] = d[0] = x + width - rBtm + base;
                b[0] = Math.min(c[0], b[0]);
                a[0] = Math.max(d[0], a[0]);
                g[0] = h[0] = x + rBtm - base;
                d[1] = g[1] = y
            }
            path.length = 0;
            path.push(['M', ...a], ['L', ...b], ['A', rTop, rTop, 0, 0, 1, ...c], ['L', ...d], ['A', rBtm, rBtm, 0, 0, 1, ...e], ['L', ...f], ['A', rBtm, rBtm, 0, 0, 1, ...g], ['L', ...h], ['A', rTop, rTop, 0, 0, 1, ...a], ['Z']);
            return path
        }
        const BorderRadius = {
            compose,
            optionsToObject
        };
        ('');
        return BorderRadius
    });
    _registerModule(_modules, 'Core/Responsive.js', [_modules['Core/Utilities.js']], function(U) {
        const {diffObjects, extend, find, isArray, isObject, merge, objectEach, pick, splat, uniqueKey} = U;
        var Responsive;
        (function(Responsive) {
                const composedMembers = [];
                function compose(ChartClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        extend(ChartClass.prototype, {
                            matchResponsiveRule,
                            setResponsive
                        })
                    }
                    return ChartClass
                }
                Responsive.compose = compose;
                function matchResponsiveRule(rule, matches) {
                    const condition = rule.condition
                        , fn = condition.callback || function() {
                            return (this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) && this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) && this.chartWidth >= pick(condition.minWidth, 0) && this.chartHeight >= pick(condition.minHeight, 0))
                        }
                    ;
                    if (fn.call(this)) {
                        matches.push(rule._id)
                    }
                }
                function setResponsive(redraw, reset) {
                    const options = this.options.responsive
                        , currentResponsive = this.currentResponsive;
                    let ruleIds = [], undoOptions;
                    if (!reset && options && options.rules) {
                        options.rules.forEach( (rule) => {
                                if (typeof rule._id === 'undefined') {
                                    rule._id = uniqueKey()
                                }
                                this.matchResponsiveRule(rule, ruleIds)
                            }
                            , this)
                    }
                    const mergedOptions = merge(...ruleIds.map( (ruleId) => find((options || {}).rules || [], (rule) => (rule._id === ruleId))).map( (rule) => (rule && rule.chartOptions)));
                    mergedOptions.isResponsiveOptions = !0;
                    ruleIds = (ruleIds.toString() || void 0);
                    const currentRuleIds = (currentResponsive && currentResponsive.ruleIds);
                    if (ruleIds !== currentRuleIds) {
                        if (currentResponsive) {
                            this.update(currentResponsive.undoOptions, redraw, !0)
                        }
                        if (ruleIds) {
                            undoOptions = diffObjects(mergedOptions, this.options, !0, this.collectionsWithUpdate);
                            undoOptions.isResponsiveOptions = !0;
                            this.currentResponsive = {
                                ruleIds: ruleIds,
                                mergedOptions: mergedOptions,
                                undoOptions: undoOptions
                            };
                            this.update(mergedOptions, redraw, !0)
                        } else {
                            this.currentResponsive = void 0
                        }
                    }
                }
            }
        )(Responsive || (Responsive = {}));
        ('');
        ('');
        return Responsive
    });
    _registerModule(_modules, 'masters/highcharts.src.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Core/Defaults.js'], _modules['Core/Animation/Fx.js'], _modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Renderer/HTML/AST.js'], _modules['Core/Templating.js'], _modules['Core/Renderer/RendererUtilities.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Renderer/HTML/HTMLElement.js'], _modules['Core/Renderer/HTML/HTMLRenderer.js'], _modules['Core/Axis/Axis.js'], _modules['Core/Axis/DateTimeAxis.js'], _modules['Core/Axis/LogarithmicAxis.js'], _modules['Core/Axis/PlotLineOrBand/PlotLineOrBand.js'], _modules['Core/Axis/Tick.js'], _modules['Core/Tooltip.js'], _modules['Core/Series/Point.js'], _modules['Core/Pointer.js'], _modules['Core/Legend/Legend.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Axis/Stacking/StackingAxis.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/Column/ColumnSeries.js'], _modules['Series/Column/ColumnDataLabel.js'], _modules['Series/Pie/PieSeries.js'], _modules['Series/Pie/PieDataLabel.js'], _modules['Core/Series/DataLabel.js'], _modules['Extensions/OverlappingDataLabels.js'], _modules['Extensions/BorderRadius.js'], _modules['Core/Responsive.js'], _modules['Core/Color/Color.js'], _modules['Core/Time.js']], function(Highcharts, Utilities, Defaults, Fx, Animation, AST, Templating, RendererUtilities, SVGElement, SVGRenderer, HTMLElement, HTMLRenderer, Axis, DateTimeAxis, LogarithmicAxis, PlotLineOrBand, Tick, Tooltip, Point, Pointer, Legend, Chart, StackingAxis, StackItem, Series, SeriesRegistry, ColumnSeries, ColumnDataLabel, PieSeries, PieDataLabel, DataLabel, OverlappingDataLabels, BorderRadius, Responsive, Color, Time) {
        const G = Highcharts;
        G.animate = Animation.animate;
        G.animObject = Animation.animObject;
        G.getDeferredAnimation = Animation.getDeferredAnimation;
        G.setAnimation = Animation.setAnimation;
        G.stop = Animation.stop;
        G.timers = Fx.timers;
        G.AST = AST;
        G.Axis = Axis;
        G.Chart = Chart;
        G.chart = Chart.chart;
        G.Fx = Fx;
        G.Legend = Legend;
        G.PlotLineOrBand = PlotLineOrBand;
        G.Point = Point;
        G.Pointer = Pointer;
        G.Series = Series;
        G.StackItem = StackItem;
        G.SVGElement = SVGElement;
        G.SVGRenderer = SVGRenderer;
        G.Templating = Templating;
        G.Tick = Tick;
        G.Time = Time;
        G.Tooltip = Tooltip;
        G.Color = Color;
        G.color = Color.parse;
        HTMLRenderer.compose(SVGRenderer);
        HTMLElement.compose(SVGElement);
        Pointer.compose(Chart);
        Legend.compose(Chart);
        G.defaultOptions = Defaults.defaultOptions;
        G.getOptions = Defaults.getOptions;
        G.time = Defaults.defaultTime;
        G.setOptions = Defaults.setOptions;
        G.dateFormat = Templating.dateFormat;
        G.format = Templating.format;
        G.numberFormat = Templating.numberFormat;
        Utilities.extend(G, Utilities);
        G.distribute = RendererUtilities.distribute;
        G.seriesType = SeriesRegistry.seriesType;
        ColumnDataLabel.compose(ColumnSeries);
        BorderRadius.compose(Series, PieSeries, SVGElement, SVGRenderer);
        DataLabel.compose(Series);
        DateTimeAxis.compose(Axis);
        LogarithmicAxis.compose(Axis);
        OverlappingDataLabels.compose(Chart);
        PieDataLabel.compose(PieSeries);
        PlotLineOrBand.compose(Axis);
        Responsive.compose(Chart);
        StackingAxis.compose(Axis, Chart, Series);
        Tooltip.compose(Pointer);
        return G
    });
    _modules['masters/highcharts.src.js']._modules = _modules;
    return _modules['masters/highcharts.src.js']
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * 3D features for Highcharts JS
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/highcharts-3d', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Core/Math3D.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {deg2rad} = H;
        const {pick} = U;
        function rotate3D(x, y, z, angles) {
            return {
                x: angles.cosB * x - angles.sinB * z,
                y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,
                z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z
            }
        }
        function perspective(points, chart, insidePlotArea, useInvertedPersp) {
            const options3d = chart.options.chart.options3d
                , inverted = pick(useInvertedPersp, insidePlotArea ? chart.inverted : !1)
                , origin = {
                x: chart.plotWidth / 2,
                y: chart.plotHeight / 2,
                z: options3d.depth / 2,
                vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)
            }
                , scale = chart.scale3d || 1
                , beta = deg2rad * options3d.beta * (inverted ? -1 : 1)
                , alpha = deg2rad * options3d.alpha * (inverted ? -1 : 1)
                , angles = {
                cosA: Math.cos(alpha),
                cosB: Math.cos(-beta),
                sinA: Math.sin(alpha),
                sinB: Math.sin(-beta)
            };
            if (!insidePlotArea) {
                origin.x += chart.plotLeft;
                origin.y += chart.plotTop
            }
            return points.map(function(point) {
                const rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles)
                    , coordinate = perspective3D(rotated, origin, origin.vd);
                coordinate.x = coordinate.x * scale + origin.x;
                coordinate.y = coordinate.y * scale + origin.y;
                coordinate.z = rotated.z * scale + origin.z;
                return {
                    x: (inverted ? coordinate.y : coordinate.x),
                    y: (inverted ? coordinate.x : coordinate.y),
                    z: coordinate.z
                }
            })
        }
        function perspective3D(coordinate, origin, distance) {
            const projection = ((distance > 0) && (distance < Number.POSITIVE_INFINITY)) ? distance / (coordinate.z + origin.z + distance) : 1;
            return {
                x: coordinate.x * projection,
                y: coordinate.y * projection
            }
        }
        function pointCameraDistance(coordinates, chart) {
            const options3d = chart.options.chart.options3d
                , cameraPosition = {
                x: chart.plotWidth / 2,
                y: chart.plotHeight / 2,
                z: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0) + options3d.depth
            }
                , distance = Math.sqrt(Math.pow(cameraPosition.x - pick(coordinates.plotX, coordinates.x), 2) + Math.pow(cameraPosition.y - pick(coordinates.plotY, coordinates.y), 2) + Math.pow(cameraPosition.z - pick(coordinates.plotZ, coordinates.z), 2));
            return distance
        }
        function shapeArea(vertexes) {
            let area = 0, i, j;
            for (i = 0; i < vertexes.length; i++) {
                j = (i + 1) % vertexes.length;
                area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y
            }
            return area / 2
        }
        function shapeArea3D(vertexes, chart, insidePlotArea) {
            return shapeArea(perspective(vertexes, chart, insidePlotArea))
        }
        const Math3D = {
            perspective,
            perspective3D,
            pointCameraDistance,
            shapeArea,
            shapeArea3D
        };
        return Math3D
    });
    _registerModule(_modules, 'Core/Chart/Chart3D.js', [_modules['Core/Color/Color.js'], _modules['Core/Defaults.js'], _modules['Core/Math3D.js'], _modules['Core/Utilities.js']], function(Color, D, Math3D, U) {
        const {parse: color} = Color;
        const {defaultOptions: genericDefaultOptions} = D;
        const {perspective, shapeArea3D} = Math3D;
        const {addEvent, isArray, merge, pick, wrap} = U;
        var Chart3D;
        (function(Chart3D) {
                Chart3D.defaultOptions = {
                    chart: {
                        options3d: {
                            enabled: !1,
                            alpha: 0,
                            beta: 0,
                            depth: 100,
                            fitToPlot: !0,
                            viewDistance: 25,
                            axisLabelPosition: null,
                            frame: {
                                visible: 'default',
                                size: 1,
                                bottom: {},
                                top: {},
                                left: {},
                                right: {},
                                back: {},
                                front: {}
                            }
                        }
                    }
                };
                function compose(ChartClass, FxClass) {
                    const chartProto = ChartClass.prototype;
                    const fxProto = FxClass.prototype;
                    chartProto.is3d = function() {
                        return Boolean(this.options.chart.options3d && this.options.chart.options3d.enabled)
                    }
                    ;
                    chartProto.propsRequireDirtyBox.push('chart.options3d');
                    chartProto.propsRequireUpdateSeries.push('chart.options3d');
                    fxProto.matrixSetter = function() {
                        let interpolated;
                        if (this.pos < 1 && (isArray(this.start) || isArray(this.end))) {
                            const start = (this.start || [1, 0, 0, 1, 0, 0])
                                , end = this.end || [1, 0, 0, 1, 0, 0];
                            interpolated = [];
                            for (let i = 0; i < 6; i++) {
                                interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i])
                            }
                        } else {
                            interpolated = this.end
                        }
                        this.elem.attr(this.prop, interpolated, null, !0)
                    }
                    ;
                    merge(!0, genericDefaultOptions, Chart3D.defaultOptions);
                    addEvent(ChartClass, 'init', onInit);
                    addEvent(ChartClass, 'addSeries', onAddSeries);
                    addEvent(ChartClass, 'afterDrawChartBox', onAfterDrawChartBox);
                    addEvent(ChartClass, 'afterGetContainer', onAfterGetContainer);
                    addEvent(ChartClass, 'afterInit', onAfterInit);
                    addEvent(ChartClass, 'afterSetChartSize', onAfterSetChartSize);
                    addEvent(ChartClass, 'beforeRedraw', onBeforeRedraw);
                    addEvent(ChartClass, 'beforeRender', onBeforeRender);
                    wrap(chartProto, 'isInsidePlot', wrapIsInsidePlot);
                    wrap(chartProto, 'renderSeries', wrapRenderSeries);
                    wrap(chartProto, 'setClassName', wrapSetClassName)
                }
                Chart3D.compose = compose;
                function onAddSeries(e) {
                    if (this.is3d()) {
                        if (e.options.type === 'scatter') {
                            e.options.type = 'scatter3d'
                        }
                    }
                }
                function onAfterDrawChartBox() {
                    if (this.chart3d && this.is3d()) {
                        const chart = this
                            , renderer = chart.renderer
                            , options3d = chart.options.chart.options3d
                            , frame = chart.chart3d.get3dFrame()
                            , xm = chart.plotLeft
                            , xp = chart.plotLeft + chart.plotWidth
                            , ym = chart.plotTop
                            , yp = chart.plotTop + chart.plotHeight
                            , zm = 0
                            , zp = options3d.depth
                            , xmm = xm - (frame.left.visible ? frame.left.size : 0)
                            , xpp = xp + (frame.right.visible ? frame.right.size : 0)
                            , ymm = ym - (frame.top.visible ? frame.top.size : 0)
                            , ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0)
                            , zmm = zm - (frame.front.visible ? frame.front.size : 0)
                            , zpp = zp + (frame.back.visible ? frame.back.size : 0)
                            , verb = chart.hasRendered ? 'animate' : 'attr';
                        chart.chart3d.frame3d = frame;
                        if (!chart.frameShapes) {
                            chart.frameShapes = {
                                bottom: renderer.polyhedron().add(),
                                top: renderer.polyhedron().add(),
                                left: renderer.polyhedron().add(),
                                right: renderer.polyhedron().add(),
                                back: renderer.polyhedron().add(),
                                front: renderer.polyhedron().add()
                            }
                        }
                        chart.frameShapes.bottom[verb]({
                            'class': 'highcharts-3d-frame highcharts-3d-frame-bottom',
                            zIndex: frame.bottom.frontFacing ? -1000 : 1000,
                            faces: [{
                                fill: color(frame.bottom.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }],
                                enabled: frame.bottom.visible
                            }, {
                                fill: color(frame.bottom.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.bottom.visible
                            }, {
                                fill: color(frame.bottom.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.bottom.visible && !frame.left.visible
                            }, {
                                fill: color(frame.bottom.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }],
                                enabled: frame.bottom.visible && !frame.right.visible
                            }, {
                                fill: color(frame.bottom.color).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.bottom.visible && !frame.front.visible
                            }, {
                                fill: color(frame.bottom.color).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }],
                                enabled: frame.bottom.visible && !frame.back.visible
                            }]
                        });
                        chart.frameShapes.top[verb]({
                            'class': 'highcharts-3d-frame highcharts-3d-frame-top',
                            zIndex: frame.top.frontFacing ? -1000 : 1000,
                            faces: [{
                                fill: color(frame.top.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }],
                                enabled: frame.top.visible
                            }, {
                                fill: color(frame.top.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.top.visible
                            }, {
                                fill: color(frame.top.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.top.visible && !frame.left.visible
                            }, {
                                fill: color(frame.top.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }],
                                enabled: frame.top.visible && !frame.right.visible
                            }, {
                                fill: color(frame.top.color).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }],
                                enabled: frame.top.visible && !frame.front.visible
                            }, {
                                fill: color(frame.top.color).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.top.visible && !frame.back.visible
                            }]
                        });
                        chart.frameShapes.left[verb]({
                            'class': 'highcharts-3d-frame highcharts-3d-frame-left',
                            zIndex: frame.left.frontFacing ? -1000 : 1000,
                            faces: [{
                                fill: color(frame.left.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }],
                                enabled: frame.left.visible && !frame.bottom.visible
                            }, {
                                fill: color(frame.left.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }],
                                enabled: frame.left.visible && !frame.top.visible
                            }, {
                                fill: color(frame.left.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }],
                                enabled: frame.left.visible
                            }, {
                                fill: color(frame.left.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }],
                                enabled: frame.left.visible
                            }, {
                                fill: color(frame.left.color).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.left.visible && !frame.front.visible
                            }, {
                                fill: color(frame.left.color).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.left.visible && !frame.back.visible
                            }]
                        });
                        chart.frameShapes.right[verb]({
                            'class': 'highcharts-3d-frame highcharts-3d-frame-right',
                            zIndex: frame.right.frontFacing ? -1000 : 1000,
                            faces: [{
                                fill: color(frame.right.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }],
                                enabled: frame.right.visible && !frame.bottom.visible
                            }, {
                                fill: color(frame.right.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }],
                                enabled: frame.right.visible && !frame.top.visible
                            }, {
                                fill: color(frame.right.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.right.visible
                            }, {
                                fill: color(frame.right.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }],
                                enabled: frame.right.visible
                            }, {
                                fill: color(frame.right.color).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }],
                                enabled: frame.right.visible && !frame.front.visible
                            }, {
                                fill: color(frame.right.color).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }],
                                enabled: frame.right.visible && !frame.back.visible
                            }]
                        });
                        chart.frameShapes.back[verb]({
                            'class': 'highcharts-3d-frame highcharts-3d-frame-back',
                            zIndex: frame.back.frontFacing ? -1000 : 1000,
                            faces: [{
                                fill: color(frame.back.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }],
                                enabled: frame.back.visible && !frame.bottom.visible
                            }, {
                                fill: color(frame.back.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.back.visible && !frame.top.visible
                            }, {
                                fill: color(frame.back.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }],
                                enabled: frame.back.visible && !frame.left.visible
                            }, {
                                fill: color(frame.back.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }],
                                enabled: frame.back.visible && !frame.right.visible
                            }, {
                                fill: color(frame.back.color).get(),
                                vertexes: [{
                                    x: xm,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zp
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zp
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zp
                                }],
                                enabled: frame.back.visible
                            }, {
                                fill: color(frame.back.color).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zpp
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zpp
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zpp
                                }],
                                enabled: frame.back.visible
                            }]
                        });
                        chart.frameShapes.front[verb]({
                            'class': 'highcharts-3d-frame highcharts-3d-frame-front',
                            zIndex: frame.front.frontFacing ? -1000 : 1000,
                            faces: [{
                                fill: color(frame.front.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.front.visible && !frame.bottom.visible
                            }, {
                                fill: color(frame.front.color).brighten(0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }],
                                enabled: frame.front.visible && !frame.top.visible
                            }, {
                                fill: color(frame.front.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }],
                                enabled: frame.front.visible && !frame.left.visible
                            }, {
                                fill: color(frame.front.color).brighten(-0.1).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.front.visible && !frame.right.visible
                            }, {
                                fill: color(frame.front.color).get(),
                                vertexes: [{
                                    x: xp,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: ym,
                                    z: zm
                                }, {
                                    x: xm,
                                    y: yp,
                                    z: zm
                                }, {
                                    x: xp,
                                    y: yp,
                                    z: zm
                                }],
                                enabled: frame.front.visible
                            }, {
                                fill: color(frame.front.color).get(),
                                vertexes: [{
                                    x: xpp,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ypp,
                                    z: zmm
                                }, {
                                    x: xmm,
                                    y: ymm,
                                    z: zmm
                                }, {
                                    x: xpp,
                                    y: ymm,
                                    z: zmm
                                }],
                                enabled: frame.front.visible
                            }]
                        })
                    }
                }
                function onAfterGetContainer() {
                    if (this.styledMode) {
                        [{
                            name: 'darker',
                            slope: 0.6
                        }, {
                            name: 'brighter',
                            slope: 1.4
                        }].forEach(function(cfg) {
                            this.renderer.definition({
                                tagName: 'filter',
                                attributes: {
                                    id: 'highcharts-' + cfg.name
                                },
                                children: [{
                                    tagName: 'feComponentTransfer',
                                    children: [{
                                        tagName: 'feFuncR',
                                        attributes: {
                                            type: 'linear',
                                            slope: cfg.slope
                                        }
                                    }, {
                                        tagName: 'feFuncG',
                                        attributes: {
                                            type: 'linear',
                                            slope: cfg.slope
                                        }
                                    }, {
                                        tagName: 'feFuncB',
                                        attributes: {
                                            type: 'linear',
                                            slope: cfg.slope
                                        }
                                    }]
                                }]
                            })
                        }, this)
                    }
                }
                function onAfterInit() {
                    const options = this.options;
                    if (this.is3d()) {
                        (options.series || []).forEach(function(s) {
                            const type = (s.type || options.chart.type || options.chart.defaultSeriesType);
                            if (type === 'scatter') {
                                s.type = 'scatter3d'
                            }
                        })
                    }
                }
                function onAfterSetChartSize() {
                    const chart = this
                        , options3d = chart.options.chart.options3d;
                    if (chart.chart3d && chart.is3d()) {
                        if (options3d) {
                            options3d.alpha = options3d.alpha % 360 + (options3d.alpha >= 0 ? 0 : 360);
                            options3d.beta = options3d.beta % 360 + (options3d.beta >= 0 ? 0 : 360)
                        }
                        const inverted = chart.inverted
                            , clipBox = chart.clipBox
                            , margin = chart.margin
                            , x = inverted ? 'y' : 'x'
                            , y = inverted ? 'x' : 'y'
                            , w = inverted ? 'height' : 'width'
                            , h = inverted ? 'width' : 'height';
                        clipBox[x] = -(margin[3] || 0);
                        clipBox[y] = -(margin[0] || 0);
                        clipBox[w] = (chart.chartWidth + (margin[3] || 0) + (margin[1] || 0));
                        clipBox[h] = (chart.chartHeight + (margin[0] || 0) + (margin[2] || 0));
                        chart.scale3d = 1;
                        if (options3d.fitToPlot === !0) {
                            chart.scale3d = chart.chart3d.getScale(options3d.depth)
                        }
                        chart.chart3d.frame3d = chart.chart3d.get3dFrame()
                    }
                }
                function onBeforeRedraw() {
                    if (this.is3d()) {
                        this.isDirtyBox = !0
                    }
                }
                function onBeforeRender() {
                    if (this.chart3d && this.is3d()) {
                        this.chart3d.frame3d = this.chart3d.get3dFrame()
                    }
                }
                function onInit() {
                    if (!this.chart3d) {
                        this.chart3d = new Additions(this)
                    }
                }
                function wrapIsInsidePlot(proceed) {
                    return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1))
                }
                function wrapRenderSeries(proceed) {
                    let series, i = this.series.length;
                    if (this.is3d()) {
                        while (i--) {
                            series = this.series[i];
                            series.translate();
                            series.render()
                        }
                    } else {
                        proceed.call(this)
                    }
                }
                function wrapSetClassName(proceed) {
                    proceed.apply(this, [].slice.call(arguments, 1));
                    if (this.is3d()) {
                        this.container.className += ' highcharts-3d-chart'
                    }
                }
                class Additions {
                    constructor(chart) {
                        this.frame3d = void 0;
                        this.chart = chart
                    }
                    get3dFrame() {
                        const chart = this.chart
                            , options3d = chart.options.chart.options3d
                            , frameOptions = options3d.frame
                            , xm = chart.plotLeft
                            , xp = chart.plotLeft + chart.plotWidth
                            , ym = chart.plotTop
                            , yp = chart.plotTop + chart.plotHeight
                            , zm = 0
                            , zp = options3d.depth
                            , faceOrientation = function(vertexes) {
                            const area = shapeArea3D(vertexes, chart);
                            if (area > 0.5) {
                                return 1
                            }
                            if (area < -0.5) {
                                return -1
                            }
                            return 0
                        }
                            , bottomOrientation = faceOrientation([{
                            x: xm,
                            y: yp,
                            z: zp
                        }, {
                            x: xp,
                            y: yp,
                            z: zp
                        }, {
                            x: xp,
                            y: yp,
                            z: zm
                        }, {
                            x: xm,
                            y: yp,
                            z: zm
                        }])
                            , topOrientation = faceOrientation([{
                            x: xm,
                            y: ym,
                            z: zm
                        }, {
                            x: xp,
                            y: ym,
                            z: zm
                        }, {
                            x: xp,
                            y: ym,
                            z: zp
                        }, {
                            x: xm,
                            y: ym,
                            z: zp
                        }])
                            , leftOrientation = faceOrientation([{
                            x: xm,
                            y: ym,
                            z: zm
                        }, {
                            x: xm,
                            y: ym,
                            z: zp
                        }, {
                            x: xm,
                            y: yp,
                            z: zp
                        }, {
                            x: xm,
                            y: yp,
                            z: zm
                        }])
                            , rightOrientation = faceOrientation([{
                            x: xp,
                            y: ym,
                            z: zp
                        }, {
                            x: xp,
                            y: ym,
                            z: zm
                        }, {
                            x: xp,
                            y: yp,
                            z: zm
                        }, {
                            x: xp,
                            y: yp,
                            z: zp
                        }])
                            , frontOrientation = faceOrientation([{
                            x: xm,
                            y: yp,
                            z: zm
                        }, {
                            x: xp,
                            y: yp,
                            z: zm
                        }, {
                            x: xp,
                            y: ym,
                            z: zm
                        }, {
                            x: xm,
                            y: ym,
                            z: zm
                        }])
                            , backOrientation = faceOrientation([{
                            x: xm,
                            y: ym,
                            z: zp
                        }, {
                            x: xp,
                            y: ym,
                            z: zp
                        }, {
                            x: xp,
                            y: yp,
                            z: zp
                        }, {
                            x: xm,
                            y: yp,
                            z: zp
                        }])
                            , defaultShowFront = !1
                            , defaultShowBack = !0;
                        let defaultShowBottom = !1
                            , defaultShowTop = !1
                            , defaultShowLeft = !1
                            , defaultShowRight = !1;
                        [].concat(chart.xAxis, chart.yAxis, chart.zAxis).forEach(function(axis) {
                            if (axis) {
                                if (axis.horiz) {
                                    if (axis.opposite) {
                                        defaultShowTop = !0
                                    } else {
                                        defaultShowBottom = !0
                                    }
                                } else {
                                    if (axis.opposite) {
                                        defaultShowRight = !0
                                    } else {
                                        defaultShowLeft = !0
                                    }
                                }
                            }
                        });
                        const getFaceOptions = function(sources, faceOrientation, defaultVisible) {
                            const faceAttrs = ['size', 'color', 'visible']
                                , options = {};
                            for (let i = 0; i < faceAttrs.length; i++) {
                                const attr = faceAttrs[i];
                                for (let j = 0; j < sources.length; j++) {
                                    if (typeof sources[j] === 'object') {
                                        const val = sources[j][attr];
                                        if (typeof val !== 'undefined' && val !== null) {
                                            options[attr] = val;
                                            break
                                        }
                                    }
                                }
                            }
                            let isVisible = defaultVisible;
                            if (options.visible === !0 || options.visible === !1) {
                                isVisible = options.visible
                            } else if (options.visible === 'auto') {
                                isVisible = faceOrientation > 0
                            }
                            return {
                                size: pick(options.size, 1),
                                color: pick(options.color, 'none'),
                                frontFacing: faceOrientation > 0,
                                visible: isVisible
                            }
                        };
                        const ret = {
                            axes: {},
                            bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),
                            top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),
                            left: getFaceOptions([frameOptions.left, frameOptions.right, frameOptions.side, frameOptions], leftOrientation, defaultShowLeft),
                            right: getFaceOptions([frameOptions.right, frameOptions.left, frameOptions.side, frameOptions], rightOrientation, defaultShowRight),
                            back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),
                            front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)
                        };
                        if (options3d.axisLabelPosition === 'auto') {
                            const isValidEdge = function(face1, face2) {
                                return ((face1.visible !== face2.visible) || (face1.visible && face2.visible && (face1.frontFacing !== face2.frontFacing)))
                            };
                            const yEdges = [];
                            if (isValidEdge(ret.left, ret.front)) {
                                yEdges.push({
                                    y: (ym + yp) / 2,
                                    x: xm,
                                    z: zm,
                                    xDir: {
                                        x: 1,
                                        y: 0,
                                        z: 0
                                    }
                                })
                            }
                            if (isValidEdge(ret.left, ret.back)) {
                                yEdges.push({
                                    y: (ym + yp) / 2,
                                    x: xm,
                                    z: zp,
                                    xDir: {
                                        x: 0,
                                        y: 0,
                                        z: -1
                                    }
                                })
                            }
                            if (isValidEdge(ret.right, ret.front)) {
                                yEdges.push({
                                    y: (ym + yp) / 2,
                                    x: xp,
                                    z: zm,
                                    xDir: {
                                        x: 0,
                                        y: 0,
                                        z: 1
                                    }
                                })
                            }
                            if (isValidEdge(ret.right, ret.back)) {
                                yEdges.push({
                                    y: (ym + yp) / 2,
                                    x: xp,
                                    z: zp,
                                    xDir: {
                                        x: -1,
                                        y: 0,
                                        z: 0
                                    }
                                })
                            }
                            const xBottomEdges = [];
                            if (isValidEdge(ret.bottom, ret.front)) {
                                xBottomEdges.push({
                                    x: (xm + xp) / 2,
                                    y: yp,
                                    z: zm,
                                    xDir: {
                                        x: 1,
                                        y: 0,
                                        z: 0
                                    }
                                })
                            }
                            if (isValidEdge(ret.bottom, ret.back)) {
                                xBottomEdges.push({
                                    x: (xm + xp) / 2,
                                    y: yp,
                                    z: zp,
                                    xDir: {
                                        x: -1,
                                        y: 0,
                                        z: 0
                                    }
                                })
                            }
                            const xTopEdges = [];
                            if (isValidEdge(ret.top, ret.front)) {
                                xTopEdges.push({
                                    x: (xm + xp) / 2,
                                    y: ym,
                                    z: zm,
                                    xDir: {
                                        x: 1,
                                        y: 0,
                                        z: 0
                                    }
                                })
                            }
                            if (isValidEdge(ret.top, ret.back)) {
                                xTopEdges.push({
                                    x: (xm + xp) / 2,
                                    y: ym,
                                    z: zp,
                                    xDir: {
                                        x: -1,
                                        y: 0,
                                        z: 0
                                    }
                                })
                            }
                            const zBottomEdges = [];
                            if (isValidEdge(ret.bottom, ret.left)) {
                                zBottomEdges.push({
                                    z: (zm + zp) / 2,
                                    y: yp,
                                    x: xm,
                                    xDir: {
                                        x: 0,
                                        y: 0,
                                        z: -1
                                    }
                                })
                            }
                            if (isValidEdge(ret.bottom, ret.right)) {
                                zBottomEdges.push({
                                    z: (zm + zp) / 2,
                                    y: yp,
                                    x: xp,
                                    xDir: {
                                        x: 0,
                                        y: 0,
                                        z: 1
                                    }
                                })
                            }
                            const zTopEdges = [];
                            if (isValidEdge(ret.top, ret.left)) {
                                zTopEdges.push({
                                    z: (zm + zp) / 2,
                                    y: ym,
                                    x: xm,
                                    xDir: {
                                        x: 0,
                                        y: 0,
                                        z: -1
                                    }
                                })
                            }
                            if (isValidEdge(ret.top, ret.right)) {
                                zTopEdges.push({
                                    z: (zm + zp) / 2,
                                    y: ym,
                                    x: xp,
                                    xDir: {
                                        x: 0,
                                        y: 0,
                                        z: 1
                                    }
                                })
                            }
                            const pickEdge = function(edges, axis, mult) {
                                if (edges.length === 0) {
                                    return null
                                }
                                if (edges.length === 1) {
                                    return edges[0]
                                }
                                const projections = perspective(edges, chart, !1);
                                let best = 0;
                                for (let i = 1; i < projections.length; i++) {
                                    if (mult * projections[i][axis] > mult * projections[best][axis]) {
                                        best = i
                                    } else if ((mult * projections[i][axis] === mult * projections[best][axis]) && (projections[i].z < projections[best].z)) {
                                        best = i
                                    }
                                }
                                return edges[best]
                            };
                            ret.axes = {
                                y: {
                                    'left': pickEdge(yEdges, 'x', -1),
                                    'right': pickEdge(yEdges, 'x', +1)
                                },
                                x: {
                                    'top': pickEdge(xTopEdges, 'y', -1),
                                    'bottom': pickEdge(xBottomEdges, 'y', +1)
                                },
                                z: {
                                    'top': pickEdge(zTopEdges, 'y', -1),
                                    'bottom': pickEdge(zBottomEdges, 'y', +1)
                                }
                            }
                        } else {
                            ret.axes = {
                                y: {
                                    'left': {
                                        x: xm,
                                        z: zm,
                                        xDir: {
                                            x: 1,
                                            y: 0,
                                            z: 0
                                        }
                                    },
                                    'right': {
                                        x: xp,
                                        z: zm,
                                        xDir: {
                                            x: 0,
                                            y: 0,
                                            z: 1
                                        }
                                    }
                                },
                                x: {
                                    'top': {
                                        y: ym,
                                        z: zm,
                                        xDir: {
                                            x: 1,
                                            y: 0,
                                            z: 0
                                        }
                                    },
                                    'bottom': {
                                        y: yp,
                                        z: zm,
                                        xDir: {
                                            x: 1,
                                            y: 0,
                                            z: 0
                                        }
                                    }
                                },
                                z: {
                                    'top': {
                                        x: defaultShowLeft ? xp : xm,
                                        y: ym,
                                        xDir: defaultShowLeft ? {
                                            x: 0,
                                            y: 0,
                                            z: 1
                                        } : {
                                            x: 0,
                                            y: 0,
                                            z: -1
                                        }
                                    },
                                    'bottom': {
                                        x: defaultShowLeft ? xp : xm,
                                        y: yp,
                                        xDir: defaultShowLeft ? {
                                            x: 0,
                                            y: 0,
                                            z: 1
                                        } : {
                                            x: 0,
                                            y: 0,
                                            z: -1
                                        }
                                    }
                                }
                            }
                        }
                        return ret
                    }
                    getScale(depth) {
                        const chart = this.chart
                            , plotLeft = chart.plotLeft
                            , plotRight = chart.plotWidth + plotLeft
                            , plotTop = chart.plotTop
                            , plotBottom = chart.plotHeight + plotTop
                            , originX = plotLeft + chart.plotWidth / 2
                            , originY = plotTop + chart.plotHeight / 2
                            , bbox3d = {
                            minX: Number.MAX_VALUE,
                            maxX: -Number.MAX_VALUE,
                            minY: Number.MAX_VALUE,
                            maxY: -Number.MAX_VALUE
                        };
                        let corners, scale = 1;
                        corners = [{
                            x: plotLeft,
                            y: plotTop,
                            z: 0
                        }, {
                            x: plotLeft,
                            y: plotTop,
                            z: depth
                        }];
                        [0, 1].forEach(function(i) {
                            corners.push({
                                x: plotRight,
                                y: corners[i].y,
                                z: corners[i].z
                            })
                        });
                        [0, 1, 2, 3].forEach(function(i) {
                            corners.push({
                                x: corners[i].x,
                                y: plotBottom,
                                z: corners[i].z
                            })
                        });
                        corners = perspective(corners, chart, !1);
                        corners.forEach(function(corner) {
                            bbox3d.minX = Math.min(bbox3d.minX, corner.x);
                            bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);
                            bbox3d.minY = Math.min(bbox3d.minY, corner.y);
                            bbox3d.maxY = Math.max(bbox3d.maxY, corner.y)
                        });
                        if (plotLeft > bbox3d.minX) {
                            scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1)
                        }
                        if (plotRight < bbox3d.maxX) {
                            scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX))
                        }
                        if (plotTop > bbox3d.minY) {
                            if (bbox3d.minY < 0) {
                                scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY))
                            } else {
                                scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1)
                            }
                        }
                        if (plotBottom < bbox3d.maxY) {
                            scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)))
                        }
                        return scale
                    }
                }
                Chart3D.Additions = Additions
            }
        )(Chart3D || (Chart3D = {}));
        '';
        return Chart3D
    });
    _registerModule(_modules, 'Series/Area3D/Area3DSeries.js', [_modules['Core/Math3D.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Math3D, SeriesRegistry, U) {
        const {perspective} = Math3D;
        const {seriesTypes: {line: {prototype: lineProto}}} = SeriesRegistry;
        const {wrap} = U;
        const composedMembers = [];
        function compose(AreaSeriesClass) {
            if (U.pushUnique(composedMembers, AreaSeriesClass)) {
                wrap(AreaSeriesClass.prototype, 'getGraphPath', wrapAreaSeriesGetGraphPath)
            }
        }
        function wrapAreaSeriesGetGraphPath(proceed) {
            const series = this
                , svgPath = proceed.apply(series, [].slice.call(arguments, 1));
            if (!series.chart.is3d()) {
                return svgPath
            }
            const getGraphPath = lineProto.getGraphPath
                , options = series.options
                , translatedThreshold = Math.round(series.yAxis.getThreshold(options.threshold));
            let bottomPoints = [];
            if (series.rawPointsX) {
                for (let i = 0; i < series.points.length; i++) {
                    bottomPoints.push({
                        x: series.rawPointsX[i],
                        y: options.stacking ? series.points[i].yBottom : translatedThreshold,
                        z: series.zPadding
                    })
                }
            }
            const options3d = series.chart.options.chart.options3d;
            bottomPoints = perspective(bottomPoints, series.chart, !0).map( (point) => ({
                plotX: point.x,
                plotY: point.y,
                plotZ: point.z
            }));
            if (series.group && options3d && options3d.depth && options3d.beta) {
                if (series.markerGroup) {
                    series.markerGroup.add(series.group);
                    series.markerGroup.attr({
                        translateX: 0,
                        translateY: 0
                    })
                }
                series.group.attr({
                    zIndex: Math.max(1, (options3d.beta > 270 || options3d.beta < 90) ? options3d.depth - Math.round(series.zPadding || 0) : Math.round(series.zPadding || 0))
                })
            }
            bottomPoints.reversed = !0;
            const bottomPath = getGraphPath.call(series, bottomPoints, !0, !0);
            if (bottomPath[0] && bottomPath[0][0] === 'M') {
                bottomPath[0] = ['L', bottomPath[0][1], bottomPath[0][2]]
            }
            if (series.areaPath) {
                const areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath);
                areaPath.xMap = series.areaPath.xMap;
                series.areaPath = areaPath
            }
            return svgPath
        }
        const Area3DSeries = {
            compose
        };
        return Area3DSeries
    });
    _registerModule(_modules, 'Core/Axis/Axis3DDefaults.js', [], function() {
        const Axis3DDefaults = {
            labels: {
                position3d: 'offset',
                skew3d: !1
            },
            title: {
                position3d: null,
                skew3d: null
            }
        };
        return Axis3DDefaults
    });
    _registerModule(_modules, 'Core/Axis/Tick3DComposition.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, extend, wrap} = U;
        const composedMembers = [];
        function compose(TickClass) {
            if (U.pushUnique(composedMembers, TickClass)) {
                addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);
                wrap(TickClass.prototype, 'getMarkPath', wrapTickGetMarkPath)
            }
        }
        function onTickAfterGetLabelPosition(e) {
            const axis3D = this.axis.axis3D;
            if (axis3D) {
                extend(e.pos, axis3D.fix3dPosition(e.pos))
            }
        }
        function wrapTickGetMarkPath(proceed) {
            const axis3D = this.axis.axis3D
                , path = proceed.apply(this, [].slice.call(arguments, 1));
            if (axis3D) {
                const start = path[0];
                const end = path[1];
                if (start[0] === 'M' && end[0] === 'L') {
                    const pArr = [axis3D.fix3dPosition({
                        x: start[1],
                        y: start[2],
                        z: 0
                    }), axis3D.fix3dPosition({
                        x: end[1],
                        y: end[2],
                        z: 0
                    })];
                    return this.axis.chart.renderer.toLineSegments(pArr)
                }
            }
            return path
        }
        const Tick3DAdditions = {
            compose
        };
        return Tick3DAdditions
    });
    _registerModule(_modules, 'Core/Axis/Axis3DComposition.js', [_modules['Core/Axis/Axis3DDefaults.js'], _modules['Core/Globals.js'], _modules['Core/Math3D.js'], _modules['Core/Axis/Tick3DComposition.js'], _modules['Core/Utilities.js']], function(Axis3DDefaults, H, Math3D, Tick3D, U) {
        const {deg2rad} = H;
        const {perspective, perspective3D, shapeArea} = Math3D;
        const {addEvent, merge, pick, wrap} = U;
        const composedMembers = [];
        function onAxisAfterSetOptions() {
            const axis = this
                , chart = axis.chart
                , options = axis.options;
            if (chart.is3d && chart.is3d() && axis.coll !== 'colorAxis') {
                options.tickWidth = pick(options.tickWidth, 0);
                options.gridLineWidth = pick(options.gridLineWidth, 1)
            }
        }
        function onAxisDrawCrosshair(e) {
            const axis = this;
            if (axis.chart.is3d() && axis.coll !== 'colorAxis') {
                if (e.point) {
                    e.point.crosshairPos = axis.isXAxis ? e.point.axisXpos : axis.len - e.point.axisYpos
                }
            }
        }
        function onAxisInit() {
            const axis = this;
            if (!axis.axis3D) {
                axis.axis3D = new Axis3DAdditions(axis)
            }
        }
        function wrapAxisGetLinePath(proceed) {
            const axis = this;
            if (!axis.chart.is3d() || axis.coll === 'colorAxis') {
                return proceed.apply(axis, [].slice.call(arguments, 1))
            }
            return []
        }
        function wrapAxisGetPlotBandPath(proceed) {
            if (!this.chart.is3d() || this.coll === 'colorAxis') {
                return proceed.apply(this, [].slice.call(arguments, 1))
            }
            const args = arguments
                , from = args[1]
                , to = args[2]
                , path = []
                , fromPath = this.getPlotLinePath({
                value: from
            })
                , toPath = this.getPlotLinePath({
                value: to
            });
            if (fromPath && toPath) {
                for (let i = 0; i < fromPath.length; i += 2) {
                    const fromStartSeg = fromPath[i]
                        , fromEndSeg = fromPath[i + 1]
                        , toStartSeg = toPath[i]
                        , toEndSeg = toPath[i + 1];
                    if (fromStartSeg[0] === 'M' && fromEndSeg[0] === 'L' && toStartSeg[0] === 'M' && toEndSeg[0] === 'L') {
                        path.push(fromStartSeg, fromEndSeg, toEndSeg, ['L', toStartSeg[1], toStartSeg[2]], ['Z'])
                    }
                }
            }
            return path
        }
        function wrapAxisGetPlotLinePath(proceed) {
            const axis = this
                , axis3D = axis.axis3D
                , chart = axis.chart
                , path = proceed.apply(axis, [].slice.call(arguments, 1));
            if (axis.coll === 'colorAxis' || !chart.chart3d || !chart.is3d()) {
                return path
            }
            if (path === null) {
                return path
            }
            const options3d = chart.options.chart.options3d
                , d = axis.isZAxis ? chart.plotWidth : options3d.depth
                , frame = chart.chart3d.frame3d
                , startSegment = path[0]
                , endSegment = path[1];
            let pArr, pathSegments = [];
            if (startSegment[0] === 'M' && endSegment[0] === 'L') {
                pArr = [axis3D.swapZ({
                    x: startSegment[1],
                    y: startSegment[2],
                    z: 0
                }), axis3D.swapZ({
                    x: startSegment[1],
                    y: startSegment[2],
                    z: d
                }), axis3D.swapZ({
                    x: endSegment[1],
                    y: endSegment[2],
                    z: 0
                }), axis3D.swapZ({
                    x: endSegment[1],
                    y: endSegment[2],
                    z: d
                })];
                if (!this.horiz) {
                    if (frame.front.visible) {
                        pathSegments.push(pArr[0], pArr[2])
                    }
                    if (frame.back.visible) {
                        pathSegments.push(pArr[1], pArr[3])
                    }
                    if (frame.left.visible) {
                        pathSegments.push(pArr[0], pArr[1])
                    }
                    if (frame.right.visible) {
                        pathSegments.push(pArr[2], pArr[3])
                    }
                } else if (this.isZAxis) {
                    if (frame.left.visible) {
                        pathSegments.push(pArr[0], pArr[2])
                    }
                    if (frame.right.visible) {
                        pathSegments.push(pArr[1], pArr[3])
                    }
                    if (frame.top.visible) {
                        pathSegments.push(pArr[0], pArr[1])
                    }
                    if (frame.bottom.visible) {
                        pathSegments.push(pArr[2], pArr[3])
                    }
                } else {
                    if (frame.front.visible) {
                        pathSegments.push(pArr[0], pArr[2])
                    }
                    if (frame.back.visible) {
                        pathSegments.push(pArr[1], pArr[3])
                    }
                    if (frame.top.visible) {
                        pathSegments.push(pArr[0], pArr[1])
                    }
                    if (frame.bottom.visible) {
                        pathSegments.push(pArr[2], pArr[3])
                    }
                }
                pathSegments = perspective(pathSegments, this.chart, !1)
            }
            return chart.renderer.toLineSegments(pathSegments)
        }
        function wrapAxisGetSlotWidth(proceed, tick) {
            const axis = this
                , chart = axis.chart
                , ticks = axis.ticks
                , gridGroup = axis.gridGroup;
            if (axis.categories && chart.frameShapes && chart.is3d() && gridGroup && tick && tick.label) {
                const firstGridLine = (gridGroup.element.childNodes[0].getBBox())
                    , frame3DLeft = chart.frameShapes.left.getBBox()
                    , options3d = chart.options.chart.options3d
                    , origin = {
                    x: chart.plotWidth / 2,
                    y: chart.plotHeight / 2,
                    z: options3d.depth / 2,
                    vd: (pick(options3d.depth, 1) * pick(options3d.viewDistance, 0))
                }
                    , tickId = tick.pos
                    , prevTick = ticks[tickId - 1]
                    , nextTick = ticks[tickId + 1];
                let labelPos, prevLabelPos, nextLabelPos;
                if (tickId !== 0 && prevTick && prevTick.label && prevTick.label.xy) {
                    prevLabelPos = perspective3D({
                        x: prevTick.label.xy.x,
                        y: prevTick.label.xy.y,
                        z: null
                    }, origin, origin.vd)
                }
                if (nextTick && nextTick.label && nextTick.label.xy) {
                    nextLabelPos = perspective3D({
                        x: nextTick.label.xy.x,
                        y: nextTick.label.xy.y,
                        z: null
                    }, origin, origin.vd)
                }
                labelPos = {
                    x: tick.label.xy.x,
                    y: tick.label.xy.y,
                    z: null
                };
                labelPos = perspective3D(labelPos, origin, origin.vd);
                return Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x)
            }
            return proceed.apply(axis, [].slice.call(arguments, 1))
        }
        function wrapAxisGetTitlePosition(proceed) {
            const pos = proceed.apply(this, [].slice.call(arguments, 1));
            return this.axis3D ? this.axis3D.fix3dPosition(pos, !0) : pos
        }
        class Axis3DAdditions {
            static compose(AxisClass, TickClass) {
                Tick3D.compose(TickClass);
                if (U.pushUnique(composedMembers, AxisClass)) {
                    merge(!0, AxisClass.defaultOptions, Axis3DDefaults);
                    AxisClass.keepProps.push('axis3D');
                    addEvent(AxisClass, 'init', onAxisInit);
                    addEvent(AxisClass, 'afterSetOptions', onAxisAfterSetOptions);
                    addEvent(AxisClass, 'drawCrosshair', onAxisDrawCrosshair);
                    const axisProto = AxisClass.prototype;
                    wrap(axisProto, 'getLinePath', wrapAxisGetLinePath);
                    wrap(axisProto, 'getPlotBandPath', wrapAxisGetPlotBandPath);
                    wrap(axisProto, 'getPlotLinePath', wrapAxisGetPlotLinePath);
                    wrap(axisProto, 'getSlotWidth', wrapAxisGetSlotWidth);
                    wrap(axisProto, 'getTitlePosition', wrapAxisGetTitlePosition)
                }
            }
            constructor(axis) {
                this.axis = axis
            }
            fix3dPosition(pos, isTitle) {
                const axis3D = this;
                const axis = axis3D.axis;
                const chart = axis.chart;
                if (axis.coll === 'colorAxis' || !chart.chart3d || !chart.is3d()) {
                    return pos
                }
                const alpha = deg2rad * chart.options.chart.options3d.alpha
                    , beta = deg2rad * chart.options.chart.options3d.beta
                    , positionMode = pick(isTitle && axis.options.title.position3d, axis.options.labels.position3d)
                    , skew = pick(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d)
                    , frame = chart.chart3d.frame3d
                    , plotLeft = chart.plotLeft
                    , plotRight = chart.plotWidth + plotLeft
                    , plotTop = chart.plotTop
                    , plotBottom = chart.plotHeight + plotTop;
                let offsetX = 0, offsetY = 0, vecX, vecY = {
                    x: 0,
                    y: 1,
                    z: 0
                }, reverseFlap = !1;
                pos = axis.axis3D.swapZ({
                    x: pos.x,
                    y: pos.y,
                    z: 0
                });
                if (axis.isZAxis) {
                    if (axis.opposite) {
                        if (frame.axes.z.top === null) {
                            return {}
                        }
                        offsetY = pos.y - plotTop;
                        pos.x = frame.axes.z.top.x;
                        pos.y = frame.axes.z.top.y;
                        vecX = frame.axes.z.top.xDir;
                        reverseFlap = !frame.top.frontFacing
                    } else {
                        if (frame.axes.z.bottom === null) {
                            return {}
                        }
                        offsetY = pos.y - plotBottom;
                        pos.x = frame.axes.z.bottom.x;
                        pos.y = frame.axes.z.bottom.y;
                        vecX = frame.axes.z.bottom.xDir;
                        reverseFlap = !frame.bottom.frontFacing
                    }
                } else if (axis.horiz) {
                    if (axis.opposite) {
                        if (frame.axes.x.top === null) {
                            return {}
                        }
                        offsetY = pos.y - plotTop;
                        pos.y = frame.axes.x.top.y;
                        pos.z = frame.axes.x.top.z;
                        vecX = frame.axes.x.top.xDir;
                        reverseFlap = !frame.top.frontFacing
                    } else {
                        if (frame.axes.x.bottom === null) {
                            return {}
                        }
                        offsetY = pos.y - plotBottom;
                        pos.y = frame.axes.x.bottom.y;
                        pos.z = frame.axes.x.bottom.z;
                        vecX = frame.axes.x.bottom.xDir;
                        reverseFlap = !frame.bottom.frontFacing
                    }
                } else {
                    if (axis.opposite) {
                        if (frame.axes.y.right === null) {
                            return {}
                        }
                        offsetX = pos.x - plotRight;
                        pos.x = frame.axes.y.right.x;
                        pos.z = frame.axes.y.right.z;
                        vecX = frame.axes.y.right.xDir;
                        vecX = {
                            x: vecX.z,
                            y: vecX.y,
                            z: -vecX.x
                        }
                    } else {
                        if (frame.axes.y.left === null) {
                            return {}
                        }
                        offsetX = pos.x - plotLeft;
                        pos.x = frame.axes.y.left.x;
                        pos.z = frame.axes.y.left.z;
                        vecX = frame.axes.y.left.xDir
                    }
                }
                if (positionMode === 'chart') {} else if (positionMode === 'flap') {
                    if (!axis.horiz) {
                        vecX = {
                            x: Math.cos(beta),
                            y: 0,
                            z: Math.sin(beta)
                        }
                    } else {
                        let sin = Math.sin(alpha);
                        const cos = Math.cos(alpha);
                        if (axis.opposite) {
                            sin = -sin
                        }
                        if (reverseFlap) {
                            sin = -sin
                        }
                        vecY = {
                            x: vecX.z * sin,
                            y: cos,
                            z: -vecX.x * sin
                        }
                    }
                } else if (positionMode === 'ortho') {
                    if (!axis.horiz) {
                        vecX = {
                            x: Math.cos(beta),
                            y: 0,
                            z: Math.sin(beta)
                        }
                    } else {
                        const sina = Math.sin(alpha);
                        const cosa = Math.cos(alpha);
                        const sinb = Math.sin(beta);
                        const cosb = Math.cos(beta);
                        const vecZ = {
                            x: sinb * cosa,
                            y: -sina,
                            z: -cosa * cosb
                        };
                        vecY = {
                            x: vecX.y * vecZ.z - vecX.z * vecZ.y,
                            y: vecX.z * vecZ.x - vecX.x * vecZ.z,
                            z: vecX.x * vecZ.y - vecX.y * vecZ.x
                        };
                        let scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);
                        if (reverseFlap) {
                            scale = -scale
                        }
                        vecY = {
                            x: scale * vecY.x,
                            y: scale * vecY.y,
                            z: scale * vecY.z
                        }
                    }
                } else {
                    if (!axis.horiz) {
                        vecX = {
                            x: Math.cos(beta),
                            y: 0,
                            z: Math.sin(beta)
                        }
                    } else {
                        vecY = {
                            x: Math.sin(beta) * Math.sin(alpha),
                            y: Math.cos(alpha),
                            z: -Math.cos(beta) * Math.sin(alpha)
                        }
                    }
                }
                pos.x += offsetX * vecX.x + offsetY * vecY.x;
                pos.y += offsetX * vecX.y + offsetY * vecY.y;
                pos.z += offsetX * vecX.z + offsetY * vecY.z;
                const projected = perspective([pos], axis.chart)[0];
                if (skew) {
                    const isMirrored = shapeArea(perspective([pos, {
                        x: pos.x + vecX.x,
                        y: pos.y + vecX.y,
                        z: pos.z + vecX.z
                    }, {
                        x: pos.x + vecY.x,
                        y: pos.y + vecY.y,
                        z: pos.z + vecY.z
                    }], axis.chart)) < 0;
                    if (isMirrored) {
                        vecX = {
                            x: -vecX.x,
                            y: -vecX.y,
                            z: -vecX.z
                        }
                    }
                    const pointsProjected = perspective([{
                        x: pos.x,
                        y: pos.y,
                        z: pos.z
                    }, {
                        x: pos.x + vecX.x,
                        y: pos.y + vecX.y,
                        z: pos.z + vecX.z
                    }, {
                        x: pos.x + vecY.x,
                        y: pos.y + vecY.y,
                        z: pos.z + vecY.z
                    }], axis.chart);
                    projected.matrix = [pointsProjected[1].x - pointsProjected[0].x, pointsProjected[1].y - pointsProjected[0].y, pointsProjected[2].x - pointsProjected[0].x, pointsProjected[2].y - pointsProjected[0].y, projected.x, projected.y];
                    projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];
                    projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3]
                }
                return projected
            }
            swapZ(p, insidePlotArea) {
                const axis = this.axis;
                if (axis.isZAxis) {
                    const plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;
                    return {
                        x: plotLeft + p.z,
                        y: p.y,
                        z: p.x - plotLeft
                    }
                }
                return p
            }
        }
        return Axis3DAdditions
    });
    _registerModule(_modules, 'Core/Series/Series3D.js', [_modules['Core/Math3D.js'], _modules['Core/Series/Series.js'], _modules['Core/Utilities.js']], function(Math3D, Series, U) {
        const {perspective} = Math3D;
        const {addEvent, extend, merge, pick, pushUnique, isNumber} = U;
        const composedMembers = [];
        class Series3D extends Series {
            static compose(SeriesClass) {
                if (pushUnique(composedMembers, SeriesClass)) {
                    addEvent(SeriesClass, 'afterTranslate', function() {
                        if (this.chart.is3d()) {
                            this.translate3dPoints()
                        }
                    });
                    extend(SeriesClass.prototype, {
                        translate3dPoints: Series3D.prototype.translate3dPoints
                    })
                }
            }
            translate3dPoints() {
                const series = this
                    , seriesOptions = series.options
                    , chart = series.chart
                    , zAxis = pick(series.zAxis, chart.options.zAxis[0])
                    , rawPoints = []
                    , rawPointsX = []
                    , stack = seriesOptions.stacking ? (isNumber(seriesOptions.stack) ? seriesOptions.stack : 0) : series.index || 0;
                let rawPoint, projectedPoint, zValue, i;
                series.zPadding = stack * (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));
                for (i = 0; i < series.data.length; i++) {
                    rawPoint = series.data[i];
                    if (zAxis && zAxis.translate) {
                        zValue = zAxis.logarithmic && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z;
                        rawPoint.plotZ = zAxis.translate(zValue);
                        rawPoint.isInside = rawPoint.isInside ? (zValue >= zAxis.min && zValue <= zAxis.max) : !1
                    } else {
                        rawPoint.plotZ = series.zPadding
                    }
                    rawPoint.axisXpos = rawPoint.plotX;
                    rawPoint.axisYpos = rawPoint.plotY;
                    rawPoint.axisZpos = rawPoint.plotZ;
                    rawPoints.push({
                        x: rawPoint.plotX,
                        y: rawPoint.plotY,
                        z: rawPoint.plotZ
                    });
                    rawPointsX.push(rawPoint.plotX || 0)
                }
                series.rawPointsX = rawPointsX;
                const projectedPoints = perspective(rawPoints, chart, !0);
                for (i = 0; i < series.data.length; i++) {
                    rawPoint = series.data[i];
                    projectedPoint = projectedPoints[i];
                    rawPoint.plotX = projectedPoint.x;
                    rawPoint.plotY = projectedPoint.y;
                    rawPoint.plotZ = projectedPoint.z
                }
            }
        }
        Series3D.defaultOptions = merge(Series.defaultOptions);
        return Series3D
    });
    _registerModule(_modules, 'Core/Renderer/SVG/SVGElement3D.js', [_modules['Core/Color/Color.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Utilities.js']], function(Color, RendererRegistry, U) {
        const {parse: color} = Color;
        const {Element: SVGElement} = RendererRegistry.getRendererType().prototype;
        const {defined, pick} = U;
        class SVGElement3D extends SVGElement {
            constructor() {
                super(...arguments);
                this.parts = ['front', 'top', 'side'];
                this.pathType = 'cuboid'
            }
            initArgs(args) {
                const elem3d = this
                    , renderer = elem3d.renderer
                    , paths = renderer[elem3d.pathType + 'Path'](args)
                    , zIndexes = paths.zIndexes;
                for (const part of elem3d.parts) {
                    const attribs = {
                        'class': 'highcharts-3d-' + part,
                        zIndex: zIndexes[part] || 0
                    };
                    if (renderer.styledMode) {
                        if (part === 'top') {
                            attribs.filter = 'url(#highcharts-brighter)'
                        } else if (part === 'side') {
                            attribs.filter = 'url(#highcharts-darker)'
                        }
                    }
                    elem3d[part] = renderer.path(paths[part]).attr(attribs).add(elem3d)
                }
                elem3d.attr({
                    'stroke-linejoin': 'round',
                    zIndex: zIndexes.group
                });
                elem3d.forcedSides = paths.forcedSides
            }
            singleSetterForParts(prop, val, values, verb, duration, complete) {
                const elem3d = this
                    , newAttr = {}
                    , optionsToApply = [null, null, (verb || 'attr'), duration, complete]
                    , hasZIndexes = values && values.zIndexes;
                if (!values) {
                    newAttr[prop] = val;
                    optionsToApply[0] = newAttr
                } else {
                    if (hasZIndexes && hasZIndexes.group) {
                        elem3d.attr({
                            zIndex: hasZIndexes.group
                        })
                    }
                    for (const part of Object.keys(values)) {
                        newAttr[part] = {};
                        newAttr[part][prop] = values[part];
                        if (hasZIndexes) {
                            newAttr[part].zIndex = values.zIndexes[part] || 0
                        }
                    }
                    optionsToApply[1] = newAttr
                }
                return this.processParts.apply(elem3d, optionsToApply)
            }
            processParts(props, partsProps, verb, duration, complete) {
                const elem3d = this;
                for (const part of elem3d.parts) {
                    if (partsProps) {
                        props = pick(partsProps[part], !1)
                    }
                    if (props !== !1) {
                        elem3d[part][verb](props, duration, complete)
                    }
                }
                return elem3d
            }
            destroy() {
                this.processParts(null, null, 'destroy');
                return super.destroy()
            }
            attr(args, val, complete, continueAnimation) {
                if (typeof args === 'string' && typeof val !== 'undefined') {
                    const key = args;
                    args = {};
                    args[key] = val
                }
                if (args.shapeArgs || defined(args.x)) {
                    return this.singleSetterForParts('d', null, this.renderer[this.pathType + 'Path'](args.shapeArgs || args))
                }
                return super.attr(args, void 0, complete, continueAnimation)
            }
            animate(args, duration, complete) {
                if (defined(args.x) && defined(args.y)) {
                    const paths = this.renderer[this.pathType + 'Path'](args)
                        , forcedSides = paths.forcedSides;
                    this.singleSetterForParts('d', null, paths, 'animate', duration, complete);
                    this.attr({
                        zIndex: paths.zIndexes.group
                    });
                    if (forcedSides !== this.forcedSides) {
                        this.forcedSides = forcedSides;
                        if (!this.renderer.styledMode) {
                            this.fillSetter(this.fill)
                        }
                    }
                } else {
                    super.animate(args, duration, complete)
                }
                return this
            }
            fillSetter(fill) {
                const elem3d = this;
                elem3d.forcedSides = elem3d.forcedSides || [];
                elem3d.singleSetterForParts('fill', null, {
                    front: fill,
                    top: color(fill).brighten(elem3d.forcedSides.indexOf('top') >= 0 ? 0 : 0.1).get(),
                    side: color(fill).brighten(elem3d.forcedSides.indexOf('side') >= 0 ? 0 : -0.1).get()
                });
                elem3d.color = elem3d.fill = fill;
                return elem3d
            }
        }
        SVGElement3D.types = {
            base: SVGElement3D,
            cuboid: SVGElement3D
        };
        return SVGElement3D
    });
    _registerModule(_modules, 'Core/Renderer/SVG/SVGRenderer3D.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Math3D.js'], _modules['Core/Renderer/SVG/SVGElement3D.js'], _modules['Core/Utilities.js']], function(A, Color, H, Math3D, SVGElement3D, U) {
        const {animObject} = A;
        const {parse: color} = Color;
        const {charts, deg2rad} = H;
        const {perspective, shapeArea} = Math3D;
        const {defined, extend, merge, pick, pushUnique} = U;
        const composedMembers = []
            , cos = Math.cos
            , sin = Math.sin
            , PI = Math.PI
            , dFactor = (4 * (Math.sqrt(2) - 1) / 3) / (PI / 2);
        function curveTo(cx, cy, rx, ry, start, end, dx, dy) {
            const arcAngle = end - start;
            let result = [];
            if ((end > start) && (end - start > Math.PI / 2 + 0.0001)) {
                result = result.concat(curveTo(cx, cy, rx, ry, start, start + (Math.PI / 2), dx, dy));
                result = result.concat(curveTo(cx, cy, rx, ry, start + (Math.PI / 2), end, dx, dy));
                return result
            }
            if ((end < start) && (start - end > Math.PI / 2 + 0.0001)) {
                result = result.concat(curveTo(cx, cy, rx, ry, start, start - (Math.PI / 2), dx, dy));
                result = result.concat(curveTo(cx, cy, rx, ry, start - (Math.PI / 2), end, dx, dy));
                return result
            }
            return [['C', cx + (rx * Math.cos(start)) - ((rx * dFactor * arcAngle) * Math.sin(start)) + dx, cy + (ry * Math.sin(start)) + ((ry * dFactor * arcAngle) * Math.cos(start)) + dy, cx + (rx * Math.cos(end)) + ((rx * dFactor * arcAngle) * Math.sin(end)) + dx, cy + (ry * Math.sin(end)) - ((ry * dFactor * arcAngle) * Math.cos(end)) + dy, cx + (rx * Math.cos(end)) + dx, cy + (ry * Math.sin(end)) + dy]]
        }
        var SVGRenderer3D;
        (function(SVGRenderer3D) {
                function compose(SVGRendererClass) {
                    if (pushUnique(composedMembers, SVGRendererClass)) {
                        extend(SVGRendererClass.prototype, {
                            Element3D: SVGElement3D,
                            arc3d,
                            arc3dPath,
                            cuboid,
                            cuboidPath,
                            element3d,
                            face3d,
                            polyhedron,
                            toLinePath,
                            toLineSegments
                        })
                    }
                }
                SVGRenderer3D.compose = compose;
                function toLinePath(points, closed) {
                    const result = [];
                    for (const point of points) {
                        result.push(['L', point.x, point.y])
                    }
                    if (points.length) {
                        result[0][0] = 'M';
                        if (closed) {
                            result.push(['Z'])
                        }
                    }
                    return result
                }
                function toLineSegments(points) {
                    const result = [];
                    let m = !0;
                    for (const point of points) {
                        result.push(m ? ['M', point.x, point.y] : ['L', point.x, point.y]);
                        m = !m
                    }
                    return result
                }
                function face3d(args) {
                    const renderer = this
                        , elementProto = renderer.Element.prototype
                        , ret = renderer.createElement('path');
                    ret.vertexes = [];
                    ret.insidePlotArea = !1;
                    ret.enabled = !0;
                    ret.attr = function(hash) {
                        if (typeof hash === 'object' && (defined(hash.enabled) || defined(hash.vertexes) || defined(hash.insidePlotArea))) {
                            this.enabled = pick(hash.enabled, this.enabled);
                            this.vertexes = pick(hash.vertexes, this.vertexes);
                            this.insidePlotArea = pick(hash.insidePlotArea, this.insidePlotArea);
                            delete hash.enabled;
                            delete hash.vertexes;
                            delete hash.insidePlotArea;
                            const chart = charts[renderer.chartIndex]
                                , vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea)
                                , path = renderer.toLinePath(vertexes2d, !0)
                                , area = shapeArea(vertexes2d);
                            hash.d = path;
                            hash.visibility = (this.enabled && area > 0) ? 'inherit' : 'hidden'
                        }
                        return elementProto.attr.apply(this, arguments)
                    }
                    ;
                    ret.animate = function(params) {
                        if (typeof params === 'object' && (defined(params.enabled) || defined(params.vertexes) || defined(params.insidePlotArea))) {
                            this.enabled = pick(params.enabled, this.enabled);
                            this.vertexes = pick(params.vertexes, this.vertexes);
                            this.insidePlotArea = pick(params.insidePlotArea, this.insidePlotArea);
                            delete params.enabled;
                            delete params.vertexes;
                            delete params.insidePlotArea;
                            const chart = charts[renderer.chartIndex]
                                , vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea)
                                , path = renderer.toLinePath(vertexes2d, !0)
                                , area = shapeArea(vertexes2d)
                                , visibility = (this.enabled && area > 0) ? 'visible' : 'hidden';
                            params.d = path;
                            this.attr('visibility', visibility)
                        }
                        return elementProto.animate.apply(this, arguments)
                    }
                    ;
                    return ret.attr(args)
                }
                function polyhedron(args) {
                    const renderer = this
                        , elementProto = renderer.Element.prototype
                        , result = renderer.g()
                        , destroy = result.destroy;
                    if (!this.styledMode) {
                        result.attr({
                            'stroke-linejoin': 'round'
                        })
                    }
                    result.faces = [];
                    result.destroy = function() {
                        for (let i = 0; i < result.faces.length; i++) {
                            result.faces[i].destroy()
                        }
                        return destroy.call(this)
                    }
                    ;
                    result.attr = function(hash, val, complete, continueAnimation) {
                        if (typeof hash === 'object' && defined(hash.faces)) {
                            while (result.faces.length > hash.faces.length) {
                                result.faces.pop().destroy()
                            }
                            while (result.faces.length < hash.faces.length) {
                                result.faces.push(renderer.face3d().add(result))
                            }
                            for (let i = 0; i < hash.faces.length; i++) {
                                if (renderer.styledMode) {
                                    delete hash.faces[i].fill
                                }
                                result.faces[i].attr(hash.faces[i], null, complete, continueAnimation)
                            }
                            delete hash.faces
                        }
                        return elementProto.attr.apply(this, arguments)
                    }
                    ;
                    result.animate = function(params, duration, complete) {
                        if (params && params.faces) {
                            while (result.faces.length > params.faces.length) {
                                result.faces.pop().destroy()
                            }
                            while (result.faces.length < params.faces.length) {
                                result.faces.push(renderer.face3d().add(result))
                            }
                            for (let i = 0; i < params.faces.length; i++) {
                                result.faces[i].animate(params.faces[i], duration, complete)
                            }
                            delete params.faces
                        }
                        return elementProto.animate.apply(this, arguments)
                    }
                    ;
                    return result.attr(args)
                }
                function element3d(type, shapeArgs) {
                    const elem3d = new SVGElement3D.types[type]();
                    elem3d.init(this, 'g');
                    elem3d.initArgs(shapeArgs);
                    return elem3d
                }
                function cuboid(shapeArgs) {
                    return this.element3d('cuboid', shapeArgs)
                }
                function cuboidPath(shapeArgs) {
                    const x = shapeArgs.x || 0
                        , y = shapeArgs.y || 0
                        , z = shapeArgs.z || 0
                        , h = shapeArgs.height || 0
                        , w = shapeArgs.width || 0
                        , d = shapeArgs.depth || 0
                        , chart = charts[this.chartIndex]
                        , options3d = chart.options.chart.options3d
                        , alpha = options3d.alpha
                        , incrementX = 1000000
                        , incrementY = 10
                        , incrementZ = 100
                        , forcedSides = [];
                    let shape, zIndex = 0, pArr = [{
                        x: x,
                        y: y,
                        z: z
                    }, {
                        x: x + w,
                        y: y,
                        z: z
                    }, {
                        x: x + w,
                        y: y + h,
                        z: z
                    }, {
                        x: x,
                        y: y + h,
                        z: z
                    }, {
                        x: x,
                        y: y + h,
                        z: z + d
                    }, {
                        x: x + w,
                        y: y + h,
                        z: z + d
                    }, {
                        x: x + w,
                        y: y,
                        z: z + d
                    }, {
                        x: x,
                        y: y,
                        z: z + d
                    }];
                    pArr = perspective(pArr, chart, shapeArgs.insidePlotArea);
                    const mapSidePath = (i) => {
                            if (h === 0 && i > 1 && i < 6) {
                                return {
                                    x: pArr[i].x,
                                    y: pArr[i].y + 10,
                                    z: pArr[i].z
                                }
                            }
                            if (pArr[0].x === pArr[7].x && i >= 4) {
                                return {
                                    x: pArr[i].x + 10,
                                    y: pArr[i].y,
                                    z: pArr[i].z
                                }
                            }
                            if (d === 0 && i < 2 || i > 5) {
                                return {
                                    x: pArr[i].x,
                                    y: pArr[i].y,
                                    z: pArr[i].z + 10
                                }
                            }
                            return pArr[i]
                        }
                        , mapPath = (i) => (pArr[i])
                        , pickShape = (verticesIndex1, verticesIndex2, side) => {
                            const face1 = verticesIndex1.map(mapPath)
                                , face2 = verticesIndex2.map(mapPath)
                                , dummyFace1 = verticesIndex1.map(mapSidePath)
                                , dummyFace2 = verticesIndex2.map(mapSidePath);
                            let ret = [[], -1];
                            if (shapeArea(face1) < 0) {
                                ret = [face1, 0]
                            } else if (shapeArea(face2) < 0) {
                                ret = [face2, 1]
                            } else if (side) {
                                forcedSides.push(side);
                                if (shapeArea(dummyFace1) < 0) {
                                    ret = [face1, 0]
                                } else if (shapeArea(dummyFace2) < 0) {
                                    ret = [face2, 1]
                                } else {
                                    ret = [face1, 0]
                                }
                            }
                            return ret
                        }
                    ;
                    const front = [3, 2, 1, 0]
                        , back = [7, 6, 5, 4];
                    shape = pickShape(front, back, 'front');
                    const path1 = shape[0]
                        , isFront = shape[1];
                    const top = [1, 6, 7, 0]
                        , bottom = [4, 5, 2, 3];
                    shape = pickShape(top, bottom, 'top');
                    const path2 = shape[0]
                        , isTop = shape[1];
                    const right = [1, 2, 5, 6]
                        , left = [0, 7, 4, 3];
                    shape = pickShape(right, left, 'side');
                    const path3 = shape[0]
                        , isRight = shape[1];
                    if (isRight === 1) {
                        zIndex += incrementX * (chart.plotWidth - x)
                    } else if (!isRight) {
                        zIndex += incrementX * x
                    }
                    zIndex += incrementY * (!isTop || (alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5) ? chart.plotHeight - y : 10 + y);
                    if (isFront === 1) {
                        zIndex += incrementZ * (z)
                    } else if (!isFront) {
                        zIndex += incrementZ * (1000 - z)
                    }
                    return {
                        front: this.toLinePath(path1, !0),
                        top: this.toLinePath(path2, !0),
                        side: this.toLinePath(path3, !0),
                        zIndexes: {
                            group: Math.round(zIndex)
                        },
                        forcedSides: forcedSides,
                        isFront: isFront,
                        isTop: isTop
                    }
                }
                function arc3d(attribs) {
                    const renderer = this
                        , wrapper = renderer.g()
                        , elementProto = renderer.Element.prototype
                        , customAttribs = ['x', 'y', 'r', 'innerR', 'start', 'end', 'depth'];
                    function suckOutCustom(params) {
                        const ca = {};
                        let hasCA = !1, key;
                        params = merge(params);
                        for (key in params) {
                            if (customAttribs.indexOf(key) !== -1) {
                                ca[key] = params[key];
                                delete params[key];
                                hasCA = !0
                            }
                        }
                        return hasCA ? [ca, params] : !1
                    }
                    attribs = merge(attribs);
                    attribs.alpha = (attribs.alpha || 0) * deg2rad;
                    attribs.beta = (attribs.beta || 0) * deg2rad;
                    wrapper.top = renderer.path();
                    wrapper.side1 = renderer.path();
                    wrapper.side2 = renderer.path();
                    wrapper.inn = renderer.path();
                    wrapper.out = renderer.path();
                    wrapper.onAdd = function() {
                        const parent = wrapper.parentGroup
                            , className = wrapper.attr('class');
                        wrapper.top.add(wrapper);
                        for (const face of ['out', 'inn', 'side1', 'side2']) {
                            wrapper[face].attr({
                                'class': className + ' highcharts-3d-side'
                            }).add(parent)
                        }
                    }
                    ;
                    for (const fn of ['addClass', 'removeClass']) {
                        wrapper[fn] = function() {
                            const args = arguments;
                            for (const face of ['top', 'out', 'inn', 'side1', 'side2']) {
                                wrapper[face][fn].apply(wrapper[face], args)
                            }
                        }
                    }
                    wrapper.setPaths = function(attribs) {
                        const paths = wrapper.renderer.arc3dPath(attribs)
                            , zIndex = paths.zTop * 100;
                        wrapper.attribs = attribs;
                        wrapper.top.attr({
                            d: paths.top,
                            zIndex: paths.zTop
                        });
                        wrapper.inn.attr({
                            d: paths.inn,
                            zIndex: paths.zInn
                        });
                        wrapper.out.attr({
                            d: paths.out,
                            zIndex: paths.zOut
                        });
                        wrapper.side1.attr({
                            d: paths.side1,
                            zIndex: paths.zSide1
                        });
                        wrapper.side2.attr({
                            d: paths.side2,
                            zIndex: paths.zSide2
                        });
                        wrapper.zIndex = zIndex;
                        wrapper.attr({
                            zIndex: zIndex
                        });
                        if (attribs.center) {
                            wrapper.top.setRadialReference(attribs.center);
                            delete attribs.center
                        }
                    }
                    ;
                    wrapper.setPaths(attribs);
                    wrapper.fillSetter = function(value) {
                        const darker = color(value).brighten(-0.1).get();
                        this.fill = value;
                        this.side1.attr({
                            fill: darker
                        });
                        this.side2.attr({
                            fill: darker
                        });
                        this.inn.attr({
                            fill: darker
                        });
                        this.out.attr({
                            fill: darker
                        });
                        this.top.attr({
                            fill: value
                        });
                        return this
                    }
                    ;
                    for (const setter of ['opacity', 'translateX', 'translateY', 'visibility']) {
                        wrapper[setter + 'Setter'] = function(value, key) {
                            wrapper[key] = value;
                            for (const el of ['out', 'inn', 'side1', 'side2', 'top']) {
                                wrapper[el].attr(key, value)
                            }
                        }
                    }
                    wrapper.attr = function(params) {
                        let ca, paramArr;
                        if (typeof params === 'object') {
                            paramArr = suckOutCustom(params);
                            if (paramArr) {
                                ca = paramArr[0];
                                arguments[0] = paramArr[1];
                                extend(wrapper.attribs, ca);
                                wrapper.setPaths(wrapper.attribs)
                            }
                        }
                        return elementProto.attr.apply(wrapper, arguments)
                    }
                    ;
                    wrapper.animate = function(params, animation, complete) {
                        const from = this.attribs
                            , randomProp = ('data-' + Math.random().toString(26).substring(2, 9));
                        let paramArr, to;
                        delete params.center;
                        delete params.z;
                        delete params.alpha;
                        delete params.beta;
                        const anim = animObject(pick(animation, this.renderer.globalAnimation));
                        if (anim.duration) {
                            paramArr = suckOutCustom(params);
                            wrapper[randomProp] = 0;
                            params[randomProp] = 1;
                            wrapper[randomProp + 'Setter'] = H.noop;
                            if (paramArr) {
                                to = paramArr[0];
                                anim.step = function(a, fx) {
                                    const interpolate = (key) => (from[key] + (pick(to[key], from[key]) - from[key]) * fx.pos);
                                    if (fx.prop === randomProp) {
                                        fx.elem.setPaths(merge(from, {
                                            x: interpolate('x'),
                                            y: interpolate('y'),
                                            r: interpolate('r'),
                                            innerR: interpolate('innerR'),
                                            start: interpolate('start'),
                                            end: interpolate('end'),
                                            depth: interpolate('depth')
                                        }))
                                    }
                                }
                            }
                            animation = anim
                        }
                        return elementProto.animate.call(this, params, animation, complete)
                    }
                    ;
                    wrapper.destroy = function() {
                        this.top.destroy();
                        this.out.destroy();
                        this.inn.destroy();
                        this.side1.destroy();
                        this.side2.destroy();
                        return elementProto.destroy.call(this)
                    }
                    ;
                    wrapper.hide = function() {
                        this.top.hide();
                        this.out.hide();
                        this.inn.hide();
                        this.side1.hide();
                        this.side2.hide()
                    }
                    ;
                    wrapper.show = function(inherit) {
                        this.top.show(inherit);
                        this.out.show(inherit);
                        this.inn.show(inherit);
                        this.side1.show(inherit);
                        this.side2.show(inherit)
                    }
                    ;
                    return wrapper
                }
                function arc3dPath(shapeArgs) {
                    const cx = shapeArgs.x || 0
                        , cy = shapeArgs.y || 0
                        , start = shapeArgs.start || 0
                        , end = (shapeArgs.end || 0) - 0.00001
                        , r = shapeArgs.r || 0
                        , ir = shapeArgs.innerR || 0
                        , d = shapeArgs.depth || 0
                        , alpha = shapeArgs.alpha || 0
                        , beta = shapeArgs.beta || 0;
                    const cs = Math.cos(start)
                        , ss = Math.sin(start)
                        , ce = Math.cos(end)
                        , se = Math.sin(end)
                        , rx = r * Math.cos(beta)
                        , ry = r * Math.cos(alpha)
                        , irx = ir * Math.cos(beta)
                        , iry = ir * Math.cos(alpha)
                        , dx = d * Math.sin(beta)
                        , dy = d * Math.sin(alpha);
                    let top = [['M', cx + (rx * cs), cy + (ry * ss)]];
                    top = top.concat(curveTo(cx, cy, rx, ry, start, end, 0, 0));
                    top.push(['L', cx + (irx * ce), cy + (iry * se)]);
                    top = top.concat(curveTo(cx, cy, irx, iry, end, start, 0, 0));
                    top.push(['Z']);
                    const b = (beta > 0 ? Math.PI / 2 : 0)
                        , a = (alpha > 0 ? 0 : Math.PI / 2);
                    const start2 = start > -b ? start : (end > -b ? -b : start)
                        , end2 = end < PI - a ? end : (start < PI - a ? PI - a : end)
                        , midEnd = 2 * PI - a;
                    let out = [['M', cx + (rx * cos(start2)), cy + (ry * sin(start2))]];
                    out = out.concat(curveTo(cx, cy, rx, ry, start2, end2, 0, 0));
                    if (end > midEnd && start < midEnd) {
                        out.push(['L', cx + (rx * cos(end2)) + dx, cy + (ry * sin(end2)) + dy]);
                        out = out.concat(curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy));
                        out.push(['L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))]);
                        out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end, 0, 0));
                        out.push(['L', cx + (rx * cos(end)) + dx, cy + (ry * sin(end)) + dy]);
                        out = out.concat(curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));
                        out.push(['L', cx + (rx * cos(midEnd)), cy + (ry * sin(midEnd))]);
                        out = out.concat(curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0))
                    } else if (end > PI - a && start < PI - a) {
                        out.push(['L', cx + (rx * Math.cos(end2)) + dx, cy + (ry * Math.sin(end2)) + dy]);
                        out = out.concat(curveTo(cx, cy, rx, ry, end2, end, dx, dy));
                        out.push(['L', cx + (rx * Math.cos(end)), cy + (ry * Math.sin(end))]);
                        out = out.concat(curveTo(cx, cy, rx, ry, end, end2, 0, 0))
                    }
                    out.push(['L', cx + (rx * Math.cos(end2)) + dx, cy + (ry * Math.sin(end2)) + dy]);
                    out = out.concat(curveTo(cx, cy, rx, ry, end2, start2, dx, dy));
                    out.push(['Z']);
                    let inn = [['M', cx + (irx * cs), cy + (iry * ss)]];
                    inn = inn.concat(curveTo(cx, cy, irx, iry, start, end, 0, 0));
                    inn.push(['L', cx + (irx * Math.cos(end)) + dx, cy + (iry * Math.sin(end)) + dy]);
                    inn = inn.concat(curveTo(cx, cy, irx, iry, end, start, dx, dy));
                    inn.push(['Z']);
                    const side1 = [['M', cx + (rx * cs), cy + (ry * ss)], ['L', cx + (rx * cs) + dx, cy + (ry * ss) + dy], ['L', cx + (irx * cs) + dx, cy + (iry * ss) + dy], ['L', cx + (irx * cs), cy + (iry * ss)], ['Z']];
                    const side2 = [['M', cx + (rx * ce), cy + (ry * se)], ['L', cx + (rx * ce) + dx, cy + (ry * se) + dy], ['L', cx + (irx * ce) + dx, cy + (iry * se) + dy], ['L', cx + (irx * ce), cy + (iry * se)], ['Z']];
                    const angleCorr = Math.atan2(dy, -dx);
                    let angleEnd = Math.abs(end + angleCorr)
                        , angleStart = Math.abs(start + angleCorr)
                        , angleMid = Math.abs((start + end) / 2 + angleCorr);
                    function toZeroPIRange(angle) {
                        angle = angle % (2 * Math.PI);
                        if (angle > Math.PI) {
                            angle = 2 * Math.PI - angle
                        }
                        return angle
                    }
                    angleEnd = toZeroPIRange(angleEnd);
                    angleStart = toZeroPIRange(angleStart);
                    angleMid = toZeroPIRange(angleMid);
                    const incPrecision = 1e5
                        , a1 = angleMid * incPrecision
                        , a2 = angleStart * incPrecision
                        , a3 = angleEnd * incPrecision;
                    return {
                        top: top,
                        zTop: Math.PI * incPrecision + 1,
                        out: out,
                        zOut: Math.max(a1, a2, a3),
                        inn: inn,
                        zInn: Math.max(a1, a2, a3),
                        side1: side1,
                        zSide1: a3 * 0.99,
                        side2: side2,
                        zSide2: a2 * 0.99
                    }
                }
            }
        )(SVGRenderer3D || (SVGRenderer3D = {}));
        return SVGRenderer3D
    });
    _registerModule(_modules, 'Core/Axis/ZAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Utilities.js']], function(Axis, U) {
        const {addEvent, merge, pick, splat} = U;
        const composedMembers = [];
        function chartAddZAxis(options) {
            return new ZAxis(this,options)
        }
        function onChartAfterGetAxes() {
            const zAxisOptions = this.options.zAxis = splat(this.options.zAxis || {});
            if (!this.is3d()) {
                return
            }
            this.zAxis = [];
            zAxisOptions.forEach( (axisOptions, i) => {
                    this.addZAxis(axisOptions).setScale()
                }
            )
        }
        class ZAxis extends Axis {
            constructor() {
                super(...arguments);
                this.isZAxis = !0
            }
            static compose(ChartClass) {
                if (U.pushUnique(composedMembers, ChartClass)) {
                    addEvent(ChartClass, 'afterGetAxes', onChartAfterGetAxes);
                    const chartProto = ChartClass.prototype;
                    chartProto.addZAxis = chartAddZAxis;
                    chartProto.collectionsWithInit.zAxis = [chartProto.addZAxis];
                    chartProto.collectionsWithUpdate.push('zAxis')
                }
            }
            init(chart, userOptions) {
                this.isZAxis = !0;
                super.init(chart, userOptions, 'zAxis')
            }
            getSeriesExtremes() {
                const chart = this.chart;
                this.hasVisibleSeries = !1;
                this.dataMin = this.dataMax = this.ignoreMinPadding = (this.ignoreMaxPadding = void 0);
                if (this.stacking) {
                    this.stacking.buildStacks()
                }
                this.series.forEach( (series) => {
                        if (series.reserveSpace()) {
                            let threshold = series.options.threshold;
                            this.hasVisibleSeries = !0;
                            if (this.positiveValuesOnly && threshold <= 0) {
                                threshold = void 0
                            }
                            const zData = series.zData;
                            if (zData.length) {
                                this.dataMin = Math.min(pick(this.dataMin, zData[0]), Math.min.apply(null, zData));
                                this.dataMax = Math.max(pick(this.dataMax, zData[0]), Math.max.apply(null, zData))
                            }
                        }
                    }
                )
            }
            setAxisSize() {
                const chart = this.chart;
                super.setAxisSize();
                this.width = this.len = (chart.options.chart.options3d && chart.options.chart.options3d.depth) || 0;
                this.right = chart.chartWidth - this.width - this.left
            }
            setOptions(userOptions) {
                userOptions = merge({
                    offset: 0,
                    lineWidth: 0
                }, userOptions);
                super.setOptions(userOptions)
            }
        }
        return ZAxis
    });
    _registerModule(_modules, 'Series/Column3D/Column3DComposition.js', [_modules['Core/Math3D.js'], _modules['Core/Utilities.js']], function(Math3D, U) {
        const {perspective} = Math3D;
        const {addEvent, extend, pick, pushUnique, wrap} = U;
        const composedMembers = [];
        function columnSeriesTranslate3dShapes() {
            const series = this
                , chart = series.chart
                , seriesOptions = series.options
                , depth = seriesOptions.depth
                , stack = seriesOptions.stacking ? (seriesOptions.stack || 0) : series.index;
            let z = stack * (depth + (seriesOptions.groupZPadding || 1)), borderCrisp = series.borderWidth % 2 ? 0.5 : 0, point2dPos;
            if (chart.inverted && !series.yAxis.reversed) {
                borderCrisp *= -1
            }
            if (seriesOptions.grouping !== !1) {
                z = 0
            }
            z += (seriesOptions.groupZPadding || 1);
            for (const point of series.data) {
                point.outside3dPlot = null;
                if (point.y !== null) {
                    const shapeArgs = extend({
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }, point.shapeArgs || {})
                        , dimensions = [['x', 'width'], ['y', 'height']]
                        , tooltipPos = point.tooltipPos;
                    let borderlessBase;
                    for (const d of dimensions) {
                        borderlessBase = shapeArgs[d[0]] - borderCrisp;
                        if (borderlessBase < 0) {
                            shapeArgs[d[1]] += shapeArgs[d[0]] + borderCrisp;
                            shapeArgs[d[0]] = -borderCrisp;
                            borderlessBase = 0
                        }
                        if ((borderlessBase + shapeArgs[d[1]] > series[d[0] + 'Axis'].len) && shapeArgs[d[1]] !== 0) {
                            shapeArgs[d[1]] = series[d[0] + 'Axis'].len - shapeArgs[d[0]]
                        }
                        if (shapeArgs[d[1]] !== 0 && (shapeArgs[d[0]] >= series[d[0] + 'Axis'].len || shapeArgs[d[0]] + shapeArgs[d[1]] <= borderCrisp)) {
                            for (const key in shapeArgs) {
                                shapeArgs[key] = key === 'y' ? -9999 : 0
                            }
                            point.outside3dPlot = !0
                        }
                    }
                    if (point.shapeType === 'roundedRect') {
                        point.shapeType = 'cuboid'
                    }
                    point.shapeArgs = extend(shapeArgs, {
                        z,
                        depth,
                        insidePlotArea: !0
                    });
                    point2dPos = {
                        x: shapeArgs.x + shapeArgs.width / 2,
                        y: shapeArgs.y,
                        z: z + depth / 2
                    };
                    if (chart.inverted) {
                        point2dPos.x = shapeArgs.height;
                        point2dPos.y = point.clientX || 0
                    }
                    point.plot3d = perspective([point2dPos], chart, !0, !1)[0];
                    if (tooltipPos) {
                        const translatedTTPos = perspective([{
                            x: tooltipPos[0],
                            y: tooltipPos[1],
                            z: z + depth / 2
                        }], chart, !0, !1)[0];
                        point.tooltipPos = [translatedTTPos.x, translatedTTPos.y]
                    }
                }
            }
            series.z = z
        }
        function compose(SeriesClass, StackItemClass) {
            if (pushUnique(composedMembers, SeriesClass)) {
                const seriesProto = SeriesClass.prototype;
                wrap(seriesProto, 'alignDataLabel', wrapSeriesAlignDataLabel);
                wrap(seriesProto, 'justifyDataLabel', wrapSeriesJustifyDataLabel)
            }
            if (pushUnique(composedMembers, StackItemClass)) {
                const stackItemProto = StackItemClass.prototype;
                wrap(stackItemProto, 'getStackBox', wrapStackItemGetStackBox)
            }
            const {column: ColumnSeriesClass, columnRange: ColumnRangeSeriesClass} = SeriesClass.types;
            if (ColumnSeriesClass && pushUnique(composedMembers, ColumnSeriesClass)) {
                const columnSeriesProto = ColumnSeriesClass.prototype
                    , columnPointProto = columnSeriesProto.pointClass.prototype;
                columnSeriesProto.translate3dPoints = () => void 0;
                columnSeriesProto.translate3dShapes = columnSeriesTranslate3dShapes;
                addEvent(columnSeriesProto, 'afterInit', onColumnSeriesAfterInit);
                wrap(columnPointProto, 'hasNewShapeType', wrapColumnPointHasNewShapeType);
                wrap(columnSeriesProto, 'animate', wrapColumnSeriesAnimate);
                wrap(columnSeriesProto, 'plotGroup', wrapColumnSeriesPlotGroup);
                wrap(columnSeriesProto, 'pointAttribs', wrapColumnSeriesPointAttribs);
                wrap(columnSeriesProto, 'setState', wrapColumnSeriesSetState);
                wrap(columnSeriesProto, 'setVisible', wrapColumnSeriesSetVisible);
                wrap(columnSeriesProto, 'translate', wrapColumnSeriesTranslate)
            }
            if (ColumnRangeSeriesClass && pushUnique(composedMembers, ColumnRangeSeriesClass)) {
                const columnRangeSeriesProto = ColumnRangeSeriesClass.prototype
                    , columnRangePointProto = columnRangeSeriesProto.pointClass.prototype;
                wrap(columnRangePointProto, 'hasNewShapeType', wrapColumnPointHasNewShapeType);
                wrap(columnRangeSeriesProto, 'plotGroup', wrapColumnSeriesPlotGroup);
                wrap(columnRangeSeriesProto, 'pointAttribs', wrapColumnSeriesPointAttribs);
                wrap(columnRangeSeriesProto, 'setState', wrapColumnSeriesSetState);
                wrap(columnRangeSeriesProto, 'setVisible', wrapColumnSeriesSetVisible)
            }
        }
        function retrieveStacks(chart, stacking) {
            const series = chart.series
                , stacks = {
                totalStacks: 0
            };
            let stackNumber, i = 1;
            series.forEach(function(s) {
                stackNumber = pick(s.options.stack, (stacking ? 0 : series.length - 1 - s.index));
                if (!stacks[stackNumber]) {
                    stacks[stackNumber] = {
                        series: [s],
                        position: i
                    };
                    i++
                } else {
                    stacks[stackNumber].series.push(s)
                }
            });
            stacks.totalStacks = i + 1;
            return stacks
        }
        function onColumnSeriesAfterInit() {
            if (this.chart.is3d()) {
                const series = this
                    , seriesOptions = series.options
                    , grouping = seriesOptions.grouping
                    , stacking = seriesOptions.stacking
                    , reversedStacks = series.yAxis.options.reversedStacks;
                let z = 0;
                if (!(typeof grouping !== 'undefined' && !grouping)) {
                    const stacks = retrieveStacks(this.chart, stacking)
                        , stack = seriesOptions.stack || 0;
                    let i;
                    for (i = 0; i < stacks[stack].series.length; i++) {
                        if (stacks[stack].series[i] === this) {
                            break
                        }
                    }
                    z = (10 * (stacks.totalStacks - stacks[stack].position)) + (reversedStacks ? i : -i);
                    if (!this.xAxis.reversed) {
                        z = (stacks.totalStacks * 10) - z
                    }
                }
                seriesOptions.depth = seriesOptions.depth || 25;
                series.z = series.z || 0;
                seriesOptions.zIndex = z
            }
        }
        function wrapColumnPointHasNewShapeType(proceed, ...args) {
            return this.series.chart.is3d() ? this.graphic && this.graphic.element.nodeName !== 'g' : proceed.apply(this, args)
        }
        function wrapColumnSeriesAnimate(proceed) {
            if (!this.chart.is3d()) {
                proceed.apply(this, [].slice.call(arguments, 1))
            } else {
                const args = arguments
                    , init = args[1]
                    , yAxis = this.yAxis
                    , series = this
                    , reversed = this.yAxis.reversed;
                if (init) {
                    for (const point of series.data) {
                        if (point.y !== null) {
                            point.height = point.shapeArgs.height;
                            point.shapey = point.shapeArgs.y;
                            point.shapeArgs.height = 1;
                            if (!reversed) {
                                if (point.stackY) {
                                    point.shapeArgs.y = point.plotY + yAxis.translate(point.stackY)
                                } else {
                                    point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height)
                                }
                            }
                        }
                    }
                } else {
                    for (const point of series.data) {
                        if (point.y !== null) {
                            point.shapeArgs.height = point.height;
                            point.shapeArgs.y = point.shapey;
                            if (point.graphic) {
                                point.graphic[point.outside3dPlot ? 'attr' : 'animate'](point.shapeArgs, series.options.animation)
                            }
                        }
                    }
                    this.drawDataLabels()
                }
            }
        }
        function wrapColumnSeriesPlotGroup(proceed, prop, _name, _visibility, _zIndex, parent) {
            if (prop !== 'dataLabelsGroup' && prop !== 'markerGroup') {
                if (this.chart.is3d()) {
                    if (this[prop]) {
                        delete this[prop]
                    }
                    if (parent) {
                        if (!this.chart.columnGroup) {
                            this.chart.columnGroup = this.chart.renderer.g('columnGroup').add(parent)
                        }
                        this[prop] = this.chart.columnGroup;
                        this.chart.columnGroup.attr(this.getPlotBox());
                        this[prop].survive = !0;
                        if (prop === 'group') {
                            arguments[3] = 'visible'
                        }
                    }
                }
            }
            return proceed.apply(this, Array.prototype.slice.call(arguments, 1))
        }
        function wrapColumnSeriesPointAttribs(proceed) {
            const attr = proceed.apply(this, [].slice.call(arguments, 1));
            if (this.chart.is3d && this.chart.is3d()) {
                attr.stroke = this.options.edgeColor || attr.fill;
                attr['stroke-width'] = pick(this.options.edgeWidth, 1)
            }
            return attr
        }
        function wrapColumnSeriesSetState(proceed, state, inherit) {
            const is3d = this.chart.is3d && this.chart.is3d();
            if (is3d) {
                this.options.inactiveOtherPoints = !0
            }
            proceed.call(this, state, inherit);
            if (is3d) {
                this.options.inactiveOtherPoints = !1
            }
        }
        function wrapColumnSeriesSetVisible(proceed, vis) {
            const series = this;
            if (series.chart.is3d()) {
                for (const point of series.data) {
                    point.visible = point.options.visible = vis = typeof vis === 'undefined' ? !pick(series.visible, point.visible) : vis;
                    series.options.data[series.data.indexOf(point)] = point.options;
                    if (point.graphic) {
                        point.graphic.attr({
                            visibility: vis ? 'visible' : 'hidden'
                        })
                    }
                }
            }
            proceed.apply(this, Array.prototype.slice.call(arguments, 1))
        }
        function wrapColumnSeriesTranslate(proceed) {
            proceed.apply(this, [].slice.call(arguments, 1));
            if (this.chart.is3d()) {
                this.translate3dShapes()
            }
        }
        function wrapSeriesAlignDataLabel(proceed, point, _dataLabel, options, alignTo) {
            const chart = this.chart;
            options.outside3dPlot = point.outside3dPlot;
            if (chart.is3d() && this.is('column')) {
                const series = this
                    , seriesOptions = series.options
                    , inside = pick(options.inside, !!series.options.stacking)
                    , options3d = chart.options.chart.options3d
                    , xOffset = point.pointWidth / 2 || 0;
                let dLPosition = {
                    x: alignTo.x + xOffset,
                    y: alignTo.y,
                    z: series.z + seriesOptions.depth / 2
                };
                if (chart.inverted) {
                    if (inside) {
                        alignTo.width = 0;
                        dLPosition.x += point.shapeArgs.height / 2
                    }
                    if (options3d.alpha >= 90 && options3d.alpha <= 270) {
                        dLPosition.y += point.shapeArgs.width
                    }
                }
                dLPosition = perspective([dLPosition], chart, !0, !1)[0];
                alignTo.x = dLPosition.x - xOffset;
                alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y
            }
            proceed.apply(this, [].slice.call(arguments, 1))
        }
        function wrapSeriesJustifyDataLabel(proceed) {
            return (!(arguments[2].outside3dPlot) ? proceed.apply(this, [].slice.call(arguments, 1)) : !1)
        }
        function wrapStackItemGetStackBox(proceed, stackBoxProps) {
            const stackBox = proceed.apply(this, [].slice.call(arguments, 1));
            const stackItem = this
                , chart = this.axis.chart
                , {width: xWidth} = stackBoxProps;
            if (chart.is3d() && stackItem.base) {
                const baseSeriesInd = +(stackItem.base).split(',')[0];
                const columnSeries = chart.series[baseSeriesInd];
                const options3d = chart.options.chart.options3d;
                if (columnSeries && columnSeries.type === 'column') {
                    let dLPosition = {
                        x: stackBox.x + (chart.inverted ? stackBox.height : xWidth / 2),
                        y: stackBox.y,
                        z: columnSeries.options.depth / 2
                    };
                    if (chart.inverted) {
                        stackBox.width = 0;
                        if (options3d.alpha >= 90 && options3d.alpha <= 270) {
                            dLPosition.y += xWidth
                        }
                    }
                    dLPosition = perspective([dLPosition], chart, !0, !1)[0];
                    stackBox.x = dLPosition.x - xWidth / 2;
                    stackBox.y = dLPosition.y
                }
            }
            return stackBox
        }
        const Column3DComposition = {
            compose
        };
        '';
        return Column3DComposition
    });
    _registerModule(_modules, 'Series/Pie3D/Pie3DPoint.js', [_modules['Core/Series/SeriesRegistry.js']], function(SeriesRegistry) {
        const {pie: {prototype: {pointClass: PiePoint}}} = SeriesRegistry.seriesTypes;
        class Pie3DPoint extends PiePoint {
            constructor() {
                super(...arguments);
                this.series = void 0
            }
            haloPath() {
                return this.series?.chart.is3d() ? [] : super.haloPath.apply(this, arguments)
            }
        }
        return Pie3DPoint
    });
    _registerModule(_modules, 'Series/Pie3D/Pie3DSeries.js', [_modules['Core/Globals.js'], _modules['Series/Pie3D/Pie3DPoint.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(H, Pie3DPoint, SeriesRegistry, U) {
        const {deg2rad} = H;
        const {pie: PieSeries} = SeriesRegistry.seriesTypes;
        const {extend, pick, pushUnique} = U;
        const composedMembers = [];
        class Pie3DSeries extends PieSeries {
            static compose(SeriesClass) {
                if (pushUnique(composedMembers, SeriesClass)) {
                    SeriesClass.types.pie = Pie3DSeries
                }
            }
            addPoint() {
                super.addPoint.apply(this, arguments);
                if (this.chart.is3d()) {
                    this.update(this.userOptions, !0)
                }
            }
            animate(init) {
                if (!this.chart.is3d()) {
                    super.animate.apply(this, arguments)
                } else {
                    const center = this.center
                        , group = this.group
                        , markerGroup = this.markerGroup;
                    let animation = this.options.animation, attribs;
                    if (animation === !0) {
                        animation = {}
                    }
                    if (init) {
                        group.oldtranslateX = pick(group.oldtranslateX, group.translateX);
                        group.oldtranslateY = pick(group.oldtranslateY, group.translateY);
                        attribs = {
                            translateX: center[0],
                            translateY: center[1],
                            scaleX: 0.001,
                            scaleY: 0.001
                        };
                        group.attr(attribs);
                        if (markerGroup) {
                            markerGroup.attrSetters = group.attrSetters;
                            markerGroup.attr(attribs)
                        }
                    } else {
                        attribs = {
                            translateX: group.oldtranslateX,
                            translateY: group.oldtranslateY,
                            scaleX: 1,
                            scaleY: 1
                        };
                        group.animate(attribs, animation);
                        if (markerGroup) {
                            markerGroup.animate(attribs, animation)
                        }
                    }
                }
            }
            getDataLabelPosition(point, distance) {
                const labelPosition = super.getDataLabelPosition(point, distance);
                if (this.chart.is3d()) {
                    const options3d = this.chart.options.chart.options3d
                        , shapeArgs = point.shapeArgs
                        , r = shapeArgs.r
                        , a1 = ((shapeArgs.alpha || options3d?.alpha) * deg2rad)
                        , b1 = ((shapeArgs.beta || options3d?.beta) * deg2rad)
                        , a2 = (shapeArgs.start + shapeArgs.end) / 2
                        , connectorPosition = labelPosition.connectorPosition
                        , yOffset = (-r * (1 - Math.cos(a1)) * Math.sin(a2))
                        , xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2);
                    for (const coordinates of [labelPosition?.natural, connectorPosition.breakAt, connectorPosition.touchingSliceAt]) {
                        coordinates.x += xOffset;
                        coordinates.y += yOffset
                    }
                }
                return labelPosition
            }
            pointAttribs(point) {
                const attr = super.pointAttribs.apply(this, arguments)
                    , options = this.options;
                if (this.chart.is3d() && !this.chart.styledMode) {
                    attr.stroke = options.edgeColor || point.color || this.color;
                    attr['stroke-width'] = pick(options.edgeWidth, 1)
                }
                return attr
            }
            translate() {
                super.translate.apply(this, arguments);
                if (!this.chart.is3d()) {
                    return
                }
                const series = this
                    , seriesOptions = series.options
                    , depth = seriesOptions.depth || 0
                    , options3d = series.chart.options.chart.options3d
                    , alpha = options3d.alpha
                    , beta = options3d.beta;
                let z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;
                z += depth / 2;
                if (seriesOptions.grouping !== !1) {
                    z = 0
                }
                for (const point of series.data) {
                    const shapeArgs = point.shapeArgs;
                    point.shapeType = 'arc3d';
                    shapeArgs.z = z;
                    shapeArgs.depth = depth * 0.75;
                    shapeArgs.alpha = alpha;
                    shapeArgs.beta = beta;
                    shapeArgs.center = series.center;
                    const angle = (shapeArgs.end + shapeArgs.start) / 2;
                    point.slicedTranslation = {
                        translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad)),
                        translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad))
                    }
                }
            }
            drawTracker() {
                super.drawTracker.apply(this, arguments);
                if (!this.chart.is3d()) {
                    return
                }
                for (const point of this.points) {
                    if (point.graphic) {
                        for (const face of ['out', 'inn', 'side1', 'side2']) {
                            if (point.graphic) {
                                point.graphic[face].element.point = point
                            }
                        }
                    }
                }
            }
        }
        extend(Pie3DSeries.prototype, {
            pointClass: Pie3DPoint
        });
        '';
        return Pie3DSeries
    });
    _registerModule(_modules, 'Series/Scatter3D/Scatter3DPoint.js', [_modules['Series/Scatter/ScatterSeries.js'], _modules['Core/Utilities.js']], function(ScatterSeries, U) {
        const {pointClass: ScatterPoint} = ScatterSeries.prototype;
        const {defined} = U;
        class Scatter3DPoint extends ScatterPoint {
            constructor() {
                super(...arguments);
                this.options = void 0;
                this.series = void 0
            }
            applyOptions() {
                super.applyOptions.apply(this, arguments);
                if (!defined(this.z)) {
                    this.z = 0
                }
                return this
            }
        }
        return Scatter3DPoint
    });
    _registerModule(_modules, 'Series/Scatter3D/Scatter3DSeriesDefaults.js', [], function() {
        const Scatter3DSeriesDefaults = {
            tooltip: {
                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>'
            }
        };
        '';
        return Scatter3DSeriesDefaults
    });
    _registerModule(_modules, 'Series/Scatter3D/Scatter3DSeries.js', [_modules['Core/Math3D.js'], _modules['Series/Scatter3D/Scatter3DPoint.js'], _modules['Series/Scatter3D/Scatter3DSeriesDefaults.js'], _modules['Series/Scatter/ScatterSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Math3D, Scatter3DPoint, Scatter3DSeriesDefaults, ScatterSeries, SeriesRegistry, U) {
        const {pointCameraDistance} = Math3D;
        const {extend, merge} = U;
        class Scatter3DSeries extends ScatterSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            pointAttribs(point) {
                const attribs = super.pointAttribs.apply(this, arguments);
                if (this.chart.is3d() && point) {
                    attribs.zIndex = pointCameraDistance(point, this.chart)
                }
                return attribs
            }
        }
        Scatter3DSeries.defaultOptions = merge(ScatterSeries.defaultOptions, Scatter3DSeriesDefaults);
        extend(Scatter3DSeries.prototype, {
            axisTypes: ['xAxis', 'yAxis', 'zAxis'],
            directTouch: !0,
            parallelArrays: ['x', 'y', 'z'],
            pointArrayMap: ['x', 'y', 'z'],
            pointClass: Scatter3DPoint
        });
        SeriesRegistry.registerSeriesType('scatter3d', Scatter3DSeries);
        return Scatter3DSeries
    });
    _registerModule(_modules, 'masters/highcharts-3d.src.js', [_modules['Core/Globals.js'], _modules['Core/Chart/Chart3D.js'], _modules['Series/Area3D/Area3DSeries.js'], _modules['Core/Axis/Axis3DComposition.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Series/Series3D.js'], _modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Renderer/SVG/SVGRenderer3D.js'], _modules['Core/Axis/ZAxis.js'], _modules['Series/Column3D/Column3DComposition.js'], _modules['Series/Pie3D/Pie3DSeries.js']], function(Highcharts, Chart3D, Area3DSeries, Axis3DComposition, RendererRegistry, Series3D, StackItem, SVGRenderer3D, ZAxis, Column3DComposition, Pie3DSeries) {
        const G = Highcharts;
        Area3DSeries.compose(G.seriesTypes.area);
        Axis3DComposition.compose(G.Axis, G.Tick);
        Chart3D.compose(G.Chart, G.Fx);
        Column3DComposition.compose(G.Series, StackItem);
        Pie3DSeries.compose(G.Series);
        Series3D.compose(G.Series);
        SVGRenderer3D.compose(RendererRegistry.getRendererType());
        ZAxis.compose(G.Chart)
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * (c) 2009-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/highcharts-more', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Extensions/Pane.js', [_modules['Core/Chart/Chart.js'], _modules['Series/CenteredUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Pointer.js'], _modules['Core/Utilities.js']], function(Chart, CU, H, Pointer, U) {
        const {addEvent, correctFloat, defined, extend, merge, pick, splat} = U;
        Chart.prototype.collectionsWithUpdate.push('pane');
        class Pane {
            constructor(options, chart) {
                this.background = void 0;
                this.center = void 0;
                this.chart = void 0;
                this.options = void 0;
                this.coll = 'pane';
                this.defaultOptions = {
                    center: ['50%', '50%'],
                    size: '85%',
                    innerSize: '0%',
                    startAngle: 0
                };
                this.defaultBackgroundOptions = {
                    shape: 'circle',
                    borderWidth: 1,
                    borderColor: "#cccccc",
                    backgroundColor: {
                        linearGradient: {
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: 1
                        },
                        stops: [[0, "#ffffff"], [1, "#e6e6e6"]]
                    },
                    from: -Number.MAX_VALUE,
                    innerRadius: 0,
                    to: Number.MAX_VALUE,
                    outerRadius: '105%'
                };
                this.init(options, chart)
            }
            init(options, chart) {
                this.chart = chart;
                this.background = [];
                chart.pane.push(this);
                this.setOptions(options)
            }
            setOptions(options) {
                this.options = options = merge(this.defaultOptions, this.chart.angular ? {
                    background: {}
                } : void 0, options)
            }
            render() {
                let options = this.options, backgroundOption = this.options.background, renderer = this.chart.renderer, len, i;
                if (!this.group) {
                    this.group = renderer.g('pane-group').attr({
                        zIndex: options.zIndex || 0
                    }).add()
                }
                this.updateCenter();
                if (backgroundOption) {
                    backgroundOption = splat(backgroundOption);
                    len = Math.max(backgroundOption.length, this.background.length || 0);
                    for (i = 0; i < len; i++) {
                        if (backgroundOption[i] && this.axis) {
                            this.renderBackground(merge(this.defaultBackgroundOptions, backgroundOption[i]), i)
                        } else if (this.background[i]) {
                            this.background[i] = this.background[i].destroy();
                            this.background.splice(i, 1)
                        }
                    }
                }
            }
            renderBackground(backgroundOptions, i) {
                let method = 'animate'
                    , attribs = {
                    'class': 'highcharts-pane ' + (backgroundOptions.className || '')
                };
                if (!this.chart.styledMode) {
                    extend(attribs, {
                        'fill': backgroundOptions.backgroundColor,
                        'stroke': backgroundOptions.borderColor,
                        'stroke-width': backgroundOptions.borderWidth
                    })
                }
                if (!this.background[i]) {
                    this.background[i] = this.chart.renderer.path().add(this.group);
                    method = 'attr'
                }
                this.background[i][method]({
                    'd': this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
                }).attr(attribs)
            }
            updateCenter(axis) {
                this.center = (axis || this.axis || {}).center = CU.getCenter.call(this)
            }
            update(options, redraw) {
                merge(!0, this.options, options);
                this.setOptions(this.options);
                this.render();
                this.chart.axes.forEach(function(axis) {
                    if (axis.pane === this) {
                        axis.pane = null;
                        axis.update({}, redraw)
                    }
                }, this)
            }
        }
        function isInsidePane(x, y, center, startAngle, endAngle) {
            let insideSlice = !0;
            const cx = center[0]
                , cy = center[1];
            const distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
            if (defined(startAngle) && defined(endAngle)) {
                const angle = Math.atan2(correctFloat(y - cy, 8), correctFloat(x - cx, 8));
                if (endAngle !== startAngle) {
                    if (startAngle > endAngle) {
                        insideSlice = (angle >= startAngle && angle <= Math.PI) || (angle <= endAngle && angle >= -Math.PI)
                    } else {
                        insideSlice = angle >= startAngle && angle <= correctFloat(endAngle, 8)
                    }
                }
            }
            return distance <= Math.ceil(center[2] / 2) && insideSlice
        }
        Chart.prototype.getHoverPane = function(eventArgs) {
            const chart = this;
            let hoverPane;
            if (eventArgs) {
                chart.pane.forEach( (pane) => {
                        const x = eventArgs.chartX - chart.plotLeft
                            , y = eventArgs.chartY - chart.plotTop;
                        if (isInsidePane(x, y, pane.center)) {
                            hoverPane = pane
                        }
                    }
                )
            }
            return hoverPane
        }
        ;
        addEvent(Chart, 'afterIsInsidePlot', function(e) {
            const chart = this;
            if (chart.polar) {
                if (e.options.inverted) {
                    [e.x,e.y] = [e.y, e.x]
                }
                e.isInsidePlot = chart.pane.some( (pane) => isInsidePane(e.x, e.y, pane.center, pane.axis && pane.axis.normalizedStartAngleRad, pane.axis && pane.axis.normalizedEndAngleRad))
            }
        });
        addEvent(Pointer, 'beforeGetHoverData', function(eventArgs) {
            const chart = this.chart;
            if (chart.polar) {
                chart.hoverPane = chart.getHoverPane(eventArgs);
                eventArgs.filter = function(s) {
                    return (s.visible && !(!eventArgs.shared && s.directTouch) && pick(s.options.enableMouseTracking, !0) && (!chart.hoverPane || s.xAxis.pane === chart.hoverPane))
                }
            } else {
                chart.hoverPane = void 0
            }
        });
        addEvent(Pointer, 'afterGetHoverData', function(eventArgs) {
            const chart = this.chart;
            if (eventArgs.hoverPoint && eventArgs.hoverPoint.plotX && eventArgs.hoverPoint.plotY && chart.hoverPane && !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {
                eventArgs.hoverPoint = void 0
            }
        });
        H.Pane = Pane;
        return Pane
    });
    _registerModule(_modules, 'Series/AreaRange/AreaRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(SeriesRegistry, U) {
        const {area: {prototype: {pointClass: AreaPoint, pointClass: {prototype: areaProto}}}} = SeriesRegistry.seriesTypes;
        const {defined, isNumber, merge} = U;
        class AreaRangePoint extends AreaPoint {
            constructor() {
                super(...arguments);
                this.high = void 0;
                this.low = void 0;
                this.options = void 0;
                this.plotX = void 0;
                this.series = void 0
            }
            setState() {
                const prevState = this.state
                    , series = this.series
                    , isPolar = series.chart.polar
                    , seriesOptionsMarker = series.options.marker
                    , seriesDefaultSymbol = series.symbol;
                if (!defined(this.plotHigh)) {
                    this.plotHigh = series.yAxis.toPixels(this.high, !0)
                }
                if (!defined(this.plotLow)) {
                    this.plotLow = this.plotY = series.yAxis.toPixels(this.low, !0)
                }
                series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
                series.stateMarkerGraphic = series.upperStateMarkerGraphic;
                this.graphic = this.graphics && this.graphics[1];
                this.plotY = this.plotHigh;
                if (isPolar && isNumber(this.plotHighX)) {
                    this.plotX = this.plotHighX
                }
                areaProto.setState.apply(this, arguments);
                this.state = prevState;
                this.plotY = this.plotLow;
                this.graphic = this.graphics && this.graphics[0];
                if (isPolar && isNumber(this.plotLowX)) {
                    this.plotX = this.plotLowX
                }
                series.upperStateMarkerGraphic = series.stateMarkerGraphic;
                series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
                series.lowerStateMarkerGraphic = void 0;
                const originalSettings = series.modifyMarkerSettings();
                areaProto.setState.apply(this, arguments);
                series.restoreMarkerSettings(originalSettings)
            }
            haloPath() {
                const isPolar = this.series.chart.polar;
                let path = [];
                this.plotY = this.plotLow;
                if (isPolar && isNumber(this.plotLowX)) {
                    this.plotX = this.plotLowX
                }
                if (this.isInside) {
                    path = areaProto.haloPath.apply(this, arguments)
                }
                this.plotY = this.plotHigh;
                if (isPolar && isNumber(this.plotHighX)) {
                    this.plotX = this.plotHighX
                }
                if (this.isTopInside) {
                    path = path.concat(areaProto.haloPath.apply(this, arguments))
                }
                return path
            }
            isValid() {
                return isNumber(this.low) && isNumber(this.high)
            }
        }
        return AreaRangePoint
    });
    _registerModule(_modules, 'Series/AreaRange/AreaRangeSeries.js', [_modules['Series/AreaRange/AreaRangePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(AreaRangePoint, H, SeriesRegistry, U) {
        const {noop} = H;
        const {area: AreaSeries, area: {prototype: areaProto}, column: {prototype: columnProto}} = SeriesRegistry.seriesTypes;
        const {addEvent, defined, extend, isArray, isNumber, pick, merge} = U;
        const areaRangeSeriesOptions = {
            lineWidth: 1,
            threshold: null,
            tooltip: {
                pointFormat: '<span style="color:{series.color}">\u25CF</span> ' + '{series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
            },
            trackByArea: !0,
            dataLabels: {
                align: void 0,
                verticalAlign: void 0,
                xLow: 0,
                xHigh: 0,
                yLow: 0,
                yHigh: 0
            }
        };
        class AreaRangeSeries extends AreaSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0;
                this.lowerStateMarkerGraphic = void 0;
                this.xAxis = void 0
            }
            toYData(point) {
                return [point.low, point.high]
            }
            highToXY(point) {
                const chart = this.chart
                    , xy = this.xAxis.postTranslate(point.rectPlotX || 0, this.yAxis.len - (point.plotHigh || 0));
                point.plotHighX = xy.x - chart.plotLeft;
                point.plotHigh = xy.y - chart.plotTop;
                point.plotLowX = point.plotX
            }
            getGraphPath(points) {
                const highPoints = []
                    , highAreaPoints = []
                    , getGraphPath = areaProto.getGraphPath
                    , options = this.options
                    , polar = this.chart.polar
                    , connectEnds = polar && options.connectEnds !== !1
                    , connectNulls = options.connectNulls;
                let i, point, pointShim, step = options.step;
                points = points || this.points;
                i = points.length;
                while (i--) {
                    point = points[i];
                    const highAreaPoint = polar ? {
                        plotX: point.rectPlotX,
                        plotY: point.yBottom,
                        doCurve: !1
                    } : {
                        plotX: point.plotX,
                        plotY: point.plotY,
                        doCurve: !1
                    };
                    if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
                        highAreaPoints.push(highAreaPoint)
                    }
                    pointShim = {
                        polarPlotY: point.polarPlotY,
                        rectPlotX: point.rectPlotX,
                        yBottom: point.yBottom,
                        plotX: pick(point.plotHighX, point.plotX),
                        plotY: point.plotHigh,
                        isNull: point.isNull
                    };
                    highAreaPoints.push(pointShim);
                    highPoints.push(pointShim);
                    if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
                        highAreaPoints.push(highAreaPoint)
                    }
                }
                const lowerPath = getGraphPath.call(this, points);
                if (step) {
                    if (step === !0) {
                        step = 'left'
                    }
                    options.step = {
                        left: 'right',
                        center: 'center',
                        right: 'left'
                    }[step]
                }
                const higherPath = getGraphPath.call(this, highPoints);
                const higherAreaPath = getGraphPath.call(this, highAreaPoints);
                options.step = step;
                const linePath = [].concat(lowerPath, higherPath);
                if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === 'M') {
                    higherAreaPath[0] = ['L', higherAreaPath[0][1], higherAreaPath[0][2]]
                }
                this.graphPath = linePath;
                this.areaPath = lowerPath.concat(higherAreaPath);
                linePath.isArea = !0;
                linePath.xMap = lowerPath.xMap;
                this.areaPath.xMap = lowerPath.xMap;
                return linePath
            }
            drawDataLabels() {
                const data = this.points
                    , length = data.length
                    , originalDataLabels = []
                    , dataLabelOptions = this.options.dataLabels
                    , inverted = this.chart.inverted;
                let i, point, up, upperDataLabelOptions, lowerDataLabelOptions;
                if (dataLabelOptions) {
                    if (isArray(dataLabelOptions)) {
                        upperDataLabelOptions = dataLabelOptions[0] || {
                            enabled: !1
                        };
                        lowerDataLabelOptions = dataLabelOptions[1] || {
                            enabled: !1
                        }
                    } else {
                        upperDataLabelOptions = extend({}, dataLabelOptions);
                        upperDataLabelOptions.x = dataLabelOptions.xHigh;
                        upperDataLabelOptions.y = dataLabelOptions.yHigh;
                        lowerDataLabelOptions = extend({}, dataLabelOptions);
                        lowerDataLabelOptions.x = dataLabelOptions.xLow;
                        lowerDataLabelOptions.y = dataLabelOptions.yLow
                    }
                    if (upperDataLabelOptions.enabled || this.hasDataLabels?.()) {
                        i = length;
                        while (i--) {
                            point = data[i];
                            if (point) {
                                const {plotHigh=0, plotLow=0} = point;
                                up = upperDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
                                point.y = point.high;
                                point._plotY = point.plotY;
                                point.plotY = plotHigh;
                                originalDataLabels[i] = point.dataLabel;
                                point.dataLabel = point.dataLabelUpper;
                                point.below = up;
                                if (inverted) {
                                    if (!upperDataLabelOptions.align) {
                                        upperDataLabelOptions.align = up ? 'right' : 'left'
                                    }
                                } else {
                                    if (!upperDataLabelOptions.verticalAlign) {
                                        upperDataLabelOptions.verticalAlign = up ? 'top' : 'bottom'
                                    }
                                }
                            }
                        }
                        this.options.dataLabels = upperDataLabelOptions;
                        if (areaProto.drawDataLabels) {
                            areaProto.drawDataLabels.apply(this, arguments)
                        }
                        i = length;
                        while (i--) {
                            point = data[i];
                            if (point) {
                                point.dataLabelUpper = point.dataLabel;
                                point.dataLabel = originalDataLabels[i];
                                delete point.dataLabels;
                                point.y = point.low;
                                point.plotY = point._plotY
                            }
                        }
                    }
                    if (lowerDataLabelOptions.enabled || this.hasDataLabels?.()) {
                        i = length;
                        while (i--) {
                            point = data[i];
                            if (point) {
                                const {plotHigh=0, plotLow=0} = point;
                                up = lowerDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
                                point.below = !up;
                                if (inverted) {
                                    if (!lowerDataLabelOptions.align) {
                                        lowerDataLabelOptions.align = up ? 'left' : 'right'
                                    }
                                } else {
                                    if (!lowerDataLabelOptions.verticalAlign) {
                                        lowerDataLabelOptions.verticalAlign = up ? 'bottom' : 'top'
                                    }
                                }
                            }
                        }
                        this.options.dataLabels = lowerDataLabelOptions;
                        if (areaProto.drawDataLabels) {
                            areaProto.drawDataLabels.apply(this, arguments)
                        }
                    }
                    if (upperDataLabelOptions.enabled) {
                        i = length;
                        while (i--) {
                            point = data[i];
                            if (point) {
                                point.dataLabels = [point.dataLabelUpper, point.dataLabel].filter(function(label) {
                                    return !!label
                                })
                            }
                        }
                    }
                    this.options.dataLabels = dataLabelOptions
                }
            }
            alignDataLabel() {
                columnProto.alignDataLabel.apply(this, arguments)
            }
            modifyMarkerSettings() {
                const series = this
                    , originalMarkerSettings = {
                    marker: series.options.marker,
                    symbol: series.symbol
                };
                if (series.options.lowMarker) {
                    const {options: {marker, lowMarker}} = series;
                    series.options.marker = merge(marker, lowMarker);
                    if (lowMarker.symbol) {
                        series.symbol = lowMarker.symbol
                    }
                }
                return originalMarkerSettings
            }
            restoreMarkerSettings(originalSettings) {
                const series = this;
                series.options.marker = originalSettings.marker;
                series.symbol = originalSettings.symbol
            }
            drawPoints() {
                const series = this
                    , pointLength = series.points.length;
                let i, point;
                const originalSettings = series.modifyMarkerSettings();
                areaProto.drawPoints.apply(series, arguments);
                series.restoreMarkerSettings(originalSettings);
                i = 0;
                while (i < pointLength) {
                    point = series.points[i];
                    point.graphics = point.graphics || [];
                    point.origProps = {
                        plotY: point.plotY,
                        plotX: point.plotX,
                        isInside: point.isInside,
                        negative: point.negative,
                        zone: point.zone,
                        y: point.y
                    };
                    if (point.graphic || point.graphics[0]) {
                        point.graphics[0] = point.graphic
                    }
                    point.graphic = point.graphics[1];
                    point.plotY = point.plotHigh;
                    if (defined(point.plotHighX)) {
                        point.plotX = point.plotHighX
                    }
                    point.y = pick(point.high, point.origProps.y);
                    point.negative = point.y < (series.options.threshold || 0);
                    if (series.zones.length) {
                        point.zone = point.getZone()
                    }
                    if (!series.chart.polar) {
                        point.isInside = point.isTopInside = (typeof point.plotY !== 'undefined' && point.plotY >= 0 && point.plotY <= series.yAxis.len && point.plotX >= 0 && point.plotX <= series.xAxis.len)
                    }
                    i++
                }
                areaProto.drawPoints.apply(series, arguments);
                i = 0;
                while (i < pointLength) {
                    point = series.points[i];
                    point.graphics = point.graphics || [];
                    if (point.graphic || point.graphics[1]) {
                        point.graphics[1] = point.graphic
                    }
                    point.graphic = point.graphics[0];
                    if (point.origProps) {
                        extend(point, point.origProps);
                        delete point.origProps
                    }
                    i++
                }
            }
            hasMarkerChanged(options, oldOptions) {
                const series = this
                    , lowMarker = options.lowMarker
                    , oldMarker = oldOptions.lowMarker || {};
                return (lowMarker && (lowMarker.enabled === !1 || oldMarker.symbol !== lowMarker.symbol || oldMarker.height !== lowMarker.height || oldMarker.width !== lowMarker.width)) || super.hasMarkerChanged(options, oldOptions)
            }
        }
        AreaRangeSeries.defaultOptions = merge(AreaSeries.defaultOptions, areaRangeSeriesOptions);
        addEvent(AreaRangeSeries, 'afterTranslate', function() {
            if (this.pointArrayMap.join(',') === 'low,high') {
                this.points.forEach( (point) => {
                        const high = point.high
                            , plotY = point.plotY;
                        if (point.isNull) {
                            point.plotY = void 0
                        } else {
                            point.plotLow = plotY;
                            point.plotHigh = isNumber(high) ? this.yAxis.translate(this.dataModify ? this.dataModify.modifyValue(high) : high, !1, !0, void 0, !0) : void 0;
                            if (this.dataModify) {
                                point.yBottom = point.plotHigh
                            }
                        }
                    }
                )
            }
        }, {
            order: 0
        });
        addEvent(AreaRangeSeries, 'afterTranslate', function() {
            const inverted = this.chart.inverted;
            this.points.forEach( (point) => {
                    if (this.chart.polar) {
                        this.highToXY(point);
                        point.plotLow = point.plotY;
                        point.tooltipPos = [((point.plotHighX || 0) + (point.plotLowX || 0)) / 2, ((point.plotHigh || 0) + (point.plotLow || 0)) / 2]
                    } else {
                        const tooltipPos = point.pos(!1, point.plotLow)
                            , posHigh = point.pos(!1, point.plotHigh);
                        if (tooltipPos && posHigh) {
                            tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;
                            tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2
                        }
                        point.tooltipPos = tooltipPos
                    }
                }
            )
        }, {
            order: 3
        });
        extend(AreaRangeSeries.prototype, {
            deferTranslatePolar: !0,
            pointArrayMap: ['low', 'high'],
            pointClass: AreaRangePoint,
            pointValKey: 'low',
            setStackedPoints: noop
        });
        SeriesRegistry.registerSeriesType('arearange', AreaRangeSeries);
        '';
        return AreaRangeSeries
    });
    _registerModule(_modules, 'Series/AreaSplineRange/AreaSplineRangeSeries.js', [_modules['Series/AreaRange/AreaRangeSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(AreaRangeSeries, SeriesRegistry, U) {
        const {spline: {prototype: splineProto}} = SeriesRegistry.seriesTypes;
        const {merge, extend} = U;
        class AreaSplineRangeSeries extends AreaRangeSeries {
            constructor() {
                super(...arguments);
                this.options = void 0;
                this.data = void 0;
                this.points = void 0
            }
        }
        AreaSplineRangeSeries.defaultOptions = merge(AreaRangeSeries.defaultOptions);
        extend(AreaSplineRangeSeries.prototype, {
            getPointSpline: splineProto.getPointSpline
        });
        SeriesRegistry.registerSeriesType('areasplinerange', AreaSplineRangeSeries);
        '';
        return AreaSplineRangeSeries
    });
    _registerModule(_modules, 'Series/BoxPlot/BoxPlotSeriesDefaults.js', [], function() {
        const BoxPlotSeriesDefaults = {
            threshold: null,
            tooltip: {
                pointFormat: '<span style="color:{point.color}">\u25CF</span> <b>' + '{series.name}</b><br/>' + 'Maximum: {point.high}<br/>' + 'Upper quartile: {point.q3}<br/>' + 'Median: {point.median}<br/>' + 'Lower quartile: {point.q1}<br/>' + 'Minimum: {point.low}<br/>'
            },
            whiskerLength: '50%',
            fillColor: "#ffffff",
            lineWidth: 1,
            medianWidth: 2,
            whiskerWidth: 2
        };
        '';
        return BoxPlotSeriesDefaults
    });
    _registerModule(_modules, 'Series/BoxPlot/BoxPlotSeries.js', [_modules['Series/BoxPlot/BoxPlotSeriesDefaults.js'], _modules['Series/Column/ColumnSeries.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(BoxPlotSeriesDefaults, ColumnSeries, H, SeriesRegistry, U) {
        const {noop} = H;
        const {extend, merge, pick} = U;
        class BoxPlotSeries extends ColumnSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            pointAttribs() {
                return {}
            }
            translate() {
                const series = this
                    , yAxis = series.yAxis
                    , pointArrayMap = series.pointArrayMap;
                super.translate.apply(series);
                series.points.forEach(function(point) {
                    pointArrayMap.forEach(function(key) {
                        if (point[key] !== null) {
                            point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1)
                        }
                    });
                    point.plotHigh = point.highPlot
                })
            }
            drawPoints() {
                const series = this
                    , points = series.points
                    , options = series.options
                    , chart = series.chart
                    , renderer = chart.renderer
                    , doQuartiles = series.doQuartiles !== !1
                    , whiskerLength = series.options.whiskerLength;
                let q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, crispCorr, crispX = 0, boxPath, graphic, width, left, right, halfWidth, pointWiskerLength;
                for (const point of points) {
                    graphic = point.graphic;
                    const verb = graphic ? 'animate' : 'attr'
                        , shapeArgs = point.shapeArgs
                        , boxAttr = {}
                        , stemAttr = {}
                        , whiskersAttr = {}
                        , medianAttr = {}
                        , color = point.color || series.color;
                    if (typeof point.plotY !== 'undefined') {
                        width = Math.round(shapeArgs.width);
                        left = Math.floor(shapeArgs.x);
                        right = left + width;
                        halfWidth = Math.round(width / 2);
                        q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
                        q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
                        highPlot = Math.floor(point.highPlot);
                        lowPlot = Math.floor(point.lowPlot);
                        if (!graphic) {
                            point.graphic = graphic = renderer.g('point').add(series.group);
                            point.stem = renderer.path().addClass('highcharts-boxplot-stem').add(graphic);
                            if (whiskerLength) {
                                point.whiskers = renderer.path().addClass('highcharts-boxplot-whisker').add(graphic)
                            }
                            if (doQuartiles) {
                                point.box = renderer.path(boxPath).addClass('highcharts-boxplot-box').add(graphic)
                            }
                            point.medianShape = renderer.path(medianPath).addClass('highcharts-boxplot-median').add(graphic)
                        }
                        if (!chart.styledMode) {
                            stemAttr.stroke = point.stemColor || options.stemColor || color;
                            stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);
                            stemAttr.dashstyle = (point.stemDashStyle || options.stemDashStyle || options.dashStyle);
                            point.stem.attr(stemAttr);
                            if (whiskerLength) {
                                whiskersAttr.stroke = (point.whiskerColor || options.whiskerColor || color);
                                whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);
                                whiskersAttr.dashstyle = (point.whiskerDashStyle || options.whiskerDashStyle || options.dashStyle);
                                point.whiskers.attr(whiskersAttr)
                            }
                            if (doQuartiles) {
                                boxAttr.fill = (point.fillColor || options.fillColor || color);
                                boxAttr.stroke = options.lineColor || color;
                                boxAttr['stroke-width'] = options.lineWidth || 0;
                                boxAttr.dashstyle = (point.boxDashStyle || options.boxDashStyle || options.dashStyle);
                                point.box.attr(boxAttr)
                            }
                            medianAttr.stroke = (point.medianColor || options.medianColor || color);
                            medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);
                            medianAttr.dashstyle = (point.medianDashStyle || options.medianDashStyle || options.dashStyle);
                            point.medianShape.attr(medianAttr)
                        }
                        let d;
                        crispCorr = (point.stem.strokeWidth() % 2) / 2;
                        crispX = left + halfWidth + crispCorr;
                        d = [['M', crispX, q3Plot], ['L', crispX, highPlot], ['M', crispX, q1Plot], ['L', crispX, lowPlot]];
                        point.stem[verb]({
                            d
                        });
                        if (doQuartiles) {
                            crispCorr = (point.box.strokeWidth() % 2) / 2;
                            q1Plot = Math.floor(q1Plot) + crispCorr;
                            q3Plot = Math.floor(q3Plot) + crispCorr;
                            left += crispCorr;
                            right += crispCorr;
                            d = [['M', left, q3Plot], ['L', left, q1Plot], ['L', right, q1Plot], ['L', right, q3Plot], ['L', left, q3Plot], ['Z']];
                            point.box[verb]({
                                d
                            })
                        }
                        if (whiskerLength) {
                            crispCorr = (point.whiskers.strokeWidth() % 2) / 2;
                            highPlot = highPlot + crispCorr;
                            lowPlot = lowPlot + crispCorr;
                            pointWiskerLength = (/%$/).test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
                            d = [['M', crispX - pointWiskerLength, highPlot], ['L', crispX + pointWiskerLength, highPlot], ['M', crispX - pointWiskerLength, lowPlot], ['L', crispX + pointWiskerLength, lowPlot]];
                            point.whiskers[verb]({
                                d
                            })
                        }
                        medianPlot = Math.round(point.medianPlot);
                        crispCorr = (point.medianShape.strokeWidth() % 2) / 2;
                        medianPlot = medianPlot + crispCorr;
                        d = [['M', left, medianPlot], ['L', right, medianPlot]];
                        point.medianShape[verb]({
                            d
                        })
                    }
                }
            }
            toYData(point) {
                return [point.low, point.q1, point.median, point.q3, point.high]
            }
        }
        BoxPlotSeries.defaultOptions = merge(ColumnSeries.defaultOptions, BoxPlotSeriesDefaults);
        extend(BoxPlotSeries.prototype, {
            pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],
            pointValKey: 'high',
            drawDataLabels: noop,
            setStackedPoints: noop
        });
        SeriesRegistry.registerSeriesType('boxplot', BoxPlotSeries);
        return BoxPlotSeries
    });
    _registerModule(_modules, 'Series/Bubble/BubbleLegendDefaults.js', [], function() {
        const BubbleLegendDefaults = {
            borderColor: void 0,
            borderWidth: 2,
            className: void 0,
            color: void 0,
            connectorClassName: void 0,
            connectorColor: void 0,
            connectorDistance: 60,
            connectorWidth: 1,
            enabled: !1,
            labels: {
                className: void 0,
                allowOverlap: !1,
                format: '',
                formatter: void 0,
                align: 'right',
                style: {
                    fontSize: '0.9em',
                    color: "#000000"
                },
                x: 0,
                y: 0
            },
            maxSize: 60,
            minSize: 10,
            legendIndex: 0,
            ranges: {
                value: void 0,
                borderColor: void 0,
                color: void 0,
                connectorColor: void 0
            },
            sizeBy: 'area',
            sizeByAbsoluteValue: !1,
            zIndex: 1,
            zThreshold: 0
        };
        return BubbleLegendDefaults
    });
    _registerModule(_modules, 'Series/Bubble/BubbleLegendItem.js', [_modules['Core/Color/Color.js'], _modules['Core/Templating.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(Color, F, H, U) {
        const {parse: color} = Color;
        const {noop} = H;
        const {arrayMax, arrayMin, isNumber, merge, pick, stableSort} = U;
        class BubbleLegendItem {
            constructor(options, legend) {
                this.chart = void 0;
                this.legend = void 0;
                this.maxLabel = void 0;
                this.movementX = void 0;
                this.ranges = void 0;
                this.selected = void 0;
                this.visible = void 0;
                this.symbols = void 0;
                this.options = void 0;
                this.setState = noop;
                this.init(options, legend)
            }
            init(options, legend) {
                this.options = options;
                this.visible = !0;
                this.chart = legend.chart;
                this.legend = legend
            }
            addToLegend(items) {
                items.splice(this.options.legendIndex, 0, this)
            }
            drawLegendSymbol(legend) {
                const chart = this.chart
                    , itemDistance = pick(legend.options.itemDistance, 20)
                    , legendItem = this.legendItem || {}
                    , options = this.options
                    , ranges = options.ranges
                    , connectorDistance = options.connectorDistance;
                let connectorSpace;
                if (!ranges || !ranges.length || !isNumber(ranges[0].value)) {
                    legend.options.bubbleLegend.autoRanges = !0;
                    return
                }
                stableSort(ranges, function(a, b) {
                    return b.value - a.value
                });
                this.ranges = ranges;
                this.setOptions();
                this.render();
                const maxLabel = this.getMaxLabelSize()
                    , radius = this.ranges[0].radius
                    , size = radius * 2;
                connectorSpace = connectorDistance - radius + maxLabel.width;
                connectorSpace = connectorSpace > 0 ? connectorSpace : 0;
                this.maxLabel = maxLabel;
                this.movementX = options.labels.align === 'left' ? connectorSpace : 0;
                legendItem.labelWidth = size + connectorSpace + itemDistance;
                legendItem.labelHeight = size + maxLabel.height / 2
            }
            setOptions() {
                const ranges = this.ranges
                    , options = this.options
                    , series = this.chart.series[options.seriesIndex]
                    , baseline = this.legend.baseline
                    , bubbleAttribs = {
                    zIndex: options.zIndex,
                    'stroke-width': options.borderWidth
                }
                    , connectorAttribs = {
                    zIndex: options.zIndex,
                    'stroke-width': options.connectorWidth
                }
                    , labelAttribs = {
                    align: (this.legend.options.rtl || options.labels.align === 'left') ? 'right' : 'left',
                    zIndex: options.zIndex
                }
                    , fillOpacity = series.options.marker.fillOpacity
                    , styledMode = this.chart.styledMode;
                ranges.forEach(function(range, i) {
                    if (!styledMode) {
                        bubbleAttribs.stroke = pick(range.borderColor, options.borderColor, series.color);
                        bubbleAttribs.fill = pick(range.color, options.color, fillOpacity !== 1 ? color(series.color).setOpacity(fillOpacity).get('rgba') : series.color);
                        connectorAttribs.stroke = pick(range.connectorColor, options.connectorColor, series.color)
                    }
                    ranges[i].radius = this.getRangeRadius(range.value);
                    ranges[i] = merge(ranges[i], {
                        center: (ranges[0].radius - ranges[i].radius + baseline)
                    });
                    if (!styledMode) {
                        merge(!0, ranges[i], {
                            bubbleAttribs: merge(bubbleAttribs),
                            connectorAttribs: merge(connectorAttribs),
                            labelAttribs: labelAttribs
                        })
                    }
                }, this)
            }
            getRangeRadius(value) {
                const options = this.options
                    , seriesIndex = this.options.seriesIndex
                    , bubbleSeries = this.chart.series[seriesIndex]
                    , zMax = options.ranges[0].value
                    , zMin = options.ranges[options.ranges.length - 1].value
                    , minSize = options.minSize
                    , maxSize = options.maxSize;
                return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value)
            }
            render() {
                const legendItem = this.legendItem || {}
                    , renderer = this.chart.renderer
                    , zThreshold = this.options.zThreshold;
                if (!this.symbols) {
                    this.symbols = {
                        connectors: [],
                        bubbleItems: [],
                        labels: []
                    }
                }
                legendItem.symbol = renderer.g('bubble-legend');
                legendItem.label = renderer.g('bubble-legend-item').css(this.legend.itemStyle || {});
                legendItem.symbol.translateX = 0;
                legendItem.symbol.translateY = 0;
                legendItem.symbol.add(legendItem.label);
                legendItem.label.add(legendItem.group);
                for (const range of this.ranges) {
                    if (range.value >= zThreshold) {
                        this.renderRange(range)
                    }
                }
                this.hideOverlappingLabels()
            }
            renderRange(range) {
                const mainRange = this.ranges[0]
                    , legend = this.legend
                    , options = this.options
                    , labelsOptions = options.labels
                    , chart = this.chart
                    , bubbleSeries = chart.series[options.seriesIndex]
                    , renderer = chart.renderer
                    , symbols = this.symbols
                    , labels = symbols.labels
                    , elementCenter = range.center
                    , absoluteRadius = Math.abs(range.radius)
                    , connectorDistance = options.connectorDistance || 0
                    , labelsAlign = labelsOptions.align
                    , rtl = legend.options.rtl
                    , borderWidth = options.borderWidth
                    , connectorWidth = options.connectorWidth
                    , posX = mainRange.radius || 0
                    , posY = elementCenter - absoluteRadius - borderWidth / 2 + connectorWidth / 2
                    , crispMovement = (posY % 1 ? 1 : 0.5) - (connectorWidth % 2 ? 0 : 0.5)
                    , styledMode = renderer.styledMode;
                let connectorLength = rtl || labelsAlign === 'left' ? -connectorDistance : connectorDistance;
                if (labelsAlign === 'center') {
                    connectorLength = 0;
                    options.connectorDistance = 0;
                    range.labelAttribs.align = 'center'
                }
                symbols.bubbleItems.push(renderer.circle(posX, elementCenter + crispMovement, absoluteRadius).attr(styledMode ? {} : range.bubbleAttribs).addClass((styledMode ? 'highcharts-color-' + bubbleSeries.colorIndex + ' ' : '') + 'highcharts-bubble-legend-symbol ' + (options.className || '')).add(this.legendItem.symbol));
                symbols.connectors.push(renderer.path(renderer.crispLine([['M', posX, posY], ['L', posX + connectorLength, posY]], options.connectorWidth)).attr((styledMode ? {} : range.connectorAttribs)).addClass((styledMode ? 'highcharts-color-' + this.options.seriesIndex + ' ' : '') + 'highcharts-bubble-legend-connectors ' + (options.connectorClassName || '')).add(this.legendItem.symbol));
                const label = renderer.text(this.formatLabel(range)).attr((styledMode ? {} : range.labelAttribs)).css(styledMode ? {} : labelsOptions.style).addClass('highcharts-bubble-legend-labels ' + (options.labels.className || '')).add(this.legendItem.symbol);
                const position = {
                    x: posX + connectorLength + options.labels.x,
                    y: posY + options.labels.y + label.getBBox().height * 0.4
                };
                label.attr(position);
                labels.push(label);
                label.placed = !0;
                label.alignAttr = position
            }
            getMaxLabelSize() {
                const labels = this.symbols.labels;
                let maxLabel, labelSize;
                labels.forEach(function(label) {
                    labelSize = label.getBBox(!0);
                    if (maxLabel) {
                        maxLabel = labelSize.width > maxLabel.width ? labelSize : maxLabel
                    } else {
                        maxLabel = labelSize
                    }
                });
                return maxLabel || {}
            }
            formatLabel(range) {
                const options = this.options
                    , formatter = options.labels.formatter
                    , format = options.labels.format;
                const {numberFormatter} = this.chart;
                return format ? F.format(format, range) : formatter ? formatter.call(range) : numberFormatter(range.value, 1)
            }
            hideOverlappingLabels() {
                const chart = this.chart
                    , allowOverlap = this.options.labels.allowOverlap
                    , symbols = this.symbols;
                if (!allowOverlap && symbols) {
                    chart.hideOverlappingLabels(symbols.labels);
                    symbols.labels.forEach(function(label, index) {
                        if (!label.newOpacity) {
                            symbols.connectors[index].hide()
                        } else if (label.newOpacity !== label.oldOpacity) {
                            symbols.connectors[index].show()
                        }
                    })
                }
            }
            getRanges() {
                const bubbleLegend = this.legend.bubbleLegend
                    , series = bubbleLegend.chart.series
                    , rangesOptions = bubbleLegend.options.ranges;
                let ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;
                series.forEach(function(s) {
                    if (s.isBubble && !s.ignoreSeries) {
                        zData = s.zData.filter(isNumber);
                        if (zData.length) {
                            minZ = pick(s.options.zMin, Math.min(minZ, Math.max(arrayMin(zData), s.options.displayNegative === !1 ? s.options.zThreshold : -Number.MAX_VALUE)));
                            maxZ = pick(s.options.zMax, Math.max(maxZ, arrayMax(zData)))
                        }
                    }
                });
                if (minZ === maxZ) {
                    ranges = [{
                        value: maxZ
                    }]
                } else {
                    ranges = [{
                        value: minZ
                    }, {
                        value: (minZ + maxZ) / 2
                    }, {
                        value: maxZ,
                        autoRanges: !0
                    }]
                }
                if (rangesOptions.length && rangesOptions[0].radius) {
                    ranges.reverse()
                }
                ranges.forEach(function(range, i) {
                    if (rangesOptions && rangesOptions[i]) {
                        ranges[i] = merge(rangesOptions[i], range)
                    }
                });
                return ranges
            }
            predictBubbleSizes() {
                const chart = this.chart
                    , legendOptions = chart.legend.options
                    , floating = legendOptions.floating
                    , horizontal = legendOptions.layout === 'horizontal'
                    , lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0
                    , plotSizeX = chart.plotSizeX
                    , plotSizeY = chart.plotSizeY
                    , bubbleSeries = chart.series[this.options.seriesIndex]
                    , pxSizes = bubbleSeries.getPxExtremes()
                    , minSize = Math.ceil(pxSizes.minPxSize)
                    , maxPxSize = Math.ceil(pxSizes.maxPxSize)
                    , plotSize = Math.min(plotSizeY, plotSizeX);
                let calculatedSize, maxSize = bubbleSeries.options.maxSize;
                if (floating || !(/%$/.test(maxSize))) {
                    calculatedSize = maxPxSize
                } else {
                    maxSize = parseFloat(maxSize);
                    calculatedSize = ((plotSize + lastLineHeight) * maxSize / 100) / (maxSize / 100 + 1);
                    if ((horizontal && plotSizeY - calculatedSize >= plotSizeX) || (!horizontal && plotSizeX - calculatedSize >= plotSizeY)) {
                        calculatedSize = maxPxSize
                    }
                }
                return [minSize, Math.ceil(calculatedSize)]
            }
            updateRanges(min, max) {
                const bubbleLegendOptions = this.legend.options.bubbleLegend;
                bubbleLegendOptions.minSize = min;
                bubbleLegendOptions.maxSize = max;
                bubbleLegendOptions.ranges = this.getRanges()
            }
            correctSizes() {
                const legend = this.legend
                    , chart = this.chart
                    , bubbleSeries = chart.series[this.options.seriesIndex]
                    , pxSizes = bubbleSeries.getPxExtremes()
                    , bubbleSeriesSize = pxSizes.maxPxSize
                    , bubbleLegendSize = this.options.maxSize;
                if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) > 1) {
                    this.updateRanges(this.options.minSize, pxSizes.maxPxSize);
                    legend.render()
                }
            }
        }
        '';
        return BubbleLegendItem
    });
    _registerModule(_modules, 'Series/Bubble/BubbleLegendComposition.js', [_modules['Series/Bubble/BubbleLegendDefaults.js'], _modules['Series/Bubble/BubbleLegendItem.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function(BubbleLegendDefaults, BubbleLegendItem, D, U) {
        const {setOptions} = D;
        const {addEvent, objectEach, wrap} = U;
        const composedMembers = [];
        function chartDrawChartBox(proceed, options, callback) {
            const chart = this
                , legend = chart.legend
                , bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;
            let bubbleLegendOptions, bubbleSizes, legendItem;
            if (legend && legend.options.enabled && legend.bubbleLegend && legend.options.bubbleLegend.autoRanges && bubbleSeries) {
                bubbleLegendOptions = legend.bubbleLegend.options;
                bubbleSizes = legend.bubbleLegend.predictBubbleSizes();
                legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);
                if (!bubbleLegendOptions.placed) {
                    legend.group.placed = !1;
                    legend.allItems.forEach( (item) => {
                            legendItem = item.legendItem || {};
                            if (legendItem.group) {
                                legendItem.group.translateY = void 0
                            }
                        }
                    )
                }
                legend.render();
                chart.getMargins();
                chart.axes.forEach(function(axis) {
                    if (axis.visible) {
                        axis.render()
                    }
                    if (!bubbleLegendOptions.placed) {
                        axis.setScale();
                        axis.updateNames();
                        objectEach(axis.ticks, function(tick) {
                            tick.isNew = !0;
                            tick.isNewLabel = !0
                        })
                    }
                });
                bubbleLegendOptions.placed = !0;
                chart.getMargins();
                proceed.call(chart, options, callback);
                legend.bubbleLegend.correctSizes();
                retranslateItems(legend, getLinesHeights(legend))
            } else {
                proceed.call(chart, options, callback);
                if (legend && legend.options.enabled && legend.bubbleLegend) {
                    legend.render();
                    retranslateItems(legend, getLinesHeights(legend))
                }
            }
        }
        function compose(ChartClass, LegendClass, SeriesClass) {
            if (U.pushUnique(composedMembers, ChartClass)) {
                setOptions({
                    legend: {
                        bubbleLegend: BubbleLegendDefaults
                    }
                });
                wrap(ChartClass.prototype, 'drawChartBox', chartDrawChartBox)
            }
            if (U.pushUnique(composedMembers, LegendClass)) {
                addEvent(LegendClass, 'afterGetAllItems', onLegendAfterGetAllItems)
            }
            if (U.pushUnique(composedMembers, SeriesClass)) {
                addEvent(SeriesClass, 'legendItemClick', onSeriesLegendItemClick)
            }
        }
        function getVisibleBubbleSeriesIndex(chart) {
            const series = chart.series;
            let i = 0;
            while (i < series.length) {
                if (series[i] && series[i].isBubble && series[i].visible && series[i].zData.length) {
                    return i
                }
                i++
            }
            return -1
        }
        function getLinesHeights(legend) {
            const items = legend.allItems
                , lines = []
                , length = items.length;
            let lastLine, legendItem, legendItem2, i = 0, j = 0;
            for (i = 0; i < length; i++) {
                legendItem = items[i].legendItem || {};
                legendItem2 = (items[i + 1] || {}).legendItem || {};
                if (legendItem.labelHeight) {
                    items[i].itemHeight = legendItem.labelHeight
                }
                if (items[i] === items[length - 1] || legendItem.y !== legendItem2.y) {
                    lines.push({
                        height: 0
                    });
                    lastLine = lines[lines.length - 1];
                    for (j; j <= i; j++) {
                        if (items[j].itemHeight > lastLine.height) {
                            lastLine.height = items[j].itemHeight
                        }
                    }
                    lastLine.step = i
                }
            }
            return lines
        }
        function onLegendAfterGetAllItems(e) {
            const legend = this
                , bubbleLegend = legend.bubbleLegend
                , legendOptions = legend.options
                , options = legendOptions.bubbleLegend
                , bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);
            if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {
                if (options.ranges.length) {
                    options.autoRanges = !!options.ranges[0].autoRanges
                }
                legend.destroyItem(bubbleLegend)
            }
            if (bubbleSeriesIndex >= 0 && legendOptions.enabled && options.enabled) {
                options.seriesIndex = bubbleSeriesIndex;
                legend.bubbleLegend = new BubbleLegendItem(options,legend);
                legend.bubbleLegend.addToLegend(e.allItems)
            }
        }
        function onSeriesLegendItemClick(e) {
            if (e.defaultPrevented) {
                return !1
            }
            const series = this
                , chart = series.chart
                , visible = series.visible
                , legend = series.chart.legend;
            let status;
            if (legend && legend.bubbleLegend) {
                series.visible = !visible;
                series.ignoreSeries = visible;
                status = getVisibleBubbleSeriesIndex(chart) >= 0;
                if (legend.bubbleLegend.visible !== status) {
                    legend.update({
                        bubbleLegend: {
                            enabled: status
                        }
                    });
                    legend.bubbleLegend.visible = status
                }
                series.visible = visible
            }
        }
        function retranslateItems(legend, lines) {
            const items = legend.allItems
                , rtl = legend.options.rtl;
            let orgTranslateX, orgTranslateY, movementX, legendItem, actualLine = 0;
            items.forEach( (item, index) => {
                    legendItem = item.legendItem || {};
                    if (!legendItem.group) {
                        return
                    }
                    orgTranslateX = legendItem.group.translateX || 0;
                    orgTranslateY = legendItem.y || 0;
                    movementX = item.movementX;
                    if (movementX || (rtl && item.ranges)) {
                        movementX = rtl ? orgTranslateX - item.options.maxSize / 2 : orgTranslateX + movementX;
                        legendItem.group.attr({
                            translateX: movementX
                        })
                    }
                    if (index > lines[actualLine].step) {
                        actualLine++
                    }
                    legendItem.group.attr({
                        translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)
                    });
                    legendItem.y = orgTranslateY + lines[actualLine].height / 2
                }
            )
        }
        const BubbleLegendComposition = {
            compose
        };
        return BubbleLegendComposition
    });
    _registerModule(_modules, 'Series/Bubble/BubblePoint.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Point, SeriesRegistry, U) {
        const {seriesTypes: {scatter: {prototype: {pointClass: ScatterPoint}}}} = SeriesRegistry;
        const {extend} = U;
        class BubblePoint extends ScatterPoint {
            constructor() {
                super(...arguments);
                this.options = void 0;
                this.series = void 0
            }
            haloPath(size) {
                return Point.prototype.haloPath.call(this, size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size)
            }
        }
        extend(BubblePoint.prototype, {
            ttBelow: !1
        });
        return BubblePoint
    });
    _registerModule(_modules, 'Series/Bubble/BubbleSeries.js', [_modules['Series/Bubble/BubbleLegendComposition.js'], _modules['Series/Bubble/BubblePoint.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(BubbleLegendComposition, BubblePoint, Color, H, SeriesRegistry, U) {
        const {parse: color} = Color;
        const {noop} = H;
        const {series: Series, seriesTypes: {column: {prototype: columnProto}, scatter: ScatterSeries}} = SeriesRegistry;
        const {addEvent, arrayMax, arrayMin, clamp, extend, isNumber, merge, pick} = U;
        const composedMembers = [];
        function axisBeforePadding() {
            const axisLength = this.len
                , chart = this.chart
                , isXAxis = this.isXAxis
                , dataKey = isXAxis ? 'xData' : 'yData'
                , min = this.min
                , range = this.max - min;
            let pxMin = 0, pxMax = axisLength, transA = axisLength / range, hasActiveSeries;
            this.series.forEach( (series) => {
                    if (series.bubblePadding && series.reserveSpace()) {
                        this.allowZoomOutside = !0;
                        hasActiveSeries = !0;
                        const data = series[dataKey];
                        if (isXAxis) {
                            (series.onPoint || series).getRadii(0, 0, series);
                            if (series.onPoint) {
                                series.radii = series.onPoint.radii
                            }
                        }
                        if (range > 0) {
                            let i = data.length;
                            while (i--) {
                                if (isNumber(data[i]) && this.dataMin <= data[i] && data[i] <= this.max) {
                                    const radius = series.radii && series.radii[i] || 0;
                                    pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);
                                    pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax)
                                }
                            }
                        }
                    }
                }
            );
            if (hasActiveSeries && range > 0 && !this.logarithmic) {
                pxMax -= axisLength;
                transA *= (axisLength + Math.max(0, pxMin) - Math.min(pxMax, axisLength)) / axisLength;
                [['min', 'userMin', pxMin], ['max', 'userMax', pxMax]].forEach( (keys) => {
                        if (typeof pick(this.options[keys[0]], this[keys[1]]) === 'undefined') {
                            this[keys[0]] += keys[2] / transA
                        }
                    }
                )
            }
        }
        class BubbleSeries extends ScatterSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.maxPxSize = void 0;
                this.minPxSize = void 0;
                this.options = void 0;
                this.points = void 0;
                this.radii = void 0;
                this.yData = void 0;
                this.zData = void 0
            }
            static compose(AxisClass, ChartClass, LegendClass, SeriesClass) {
                BubbleLegendComposition.compose(ChartClass, LegendClass, SeriesClass);
                if (U.pushUnique(composedMembers, AxisClass)) {
                    AxisClass.prototype.beforePadding = axisBeforePadding
                }
            }
            animate(init) {
                if (!init && this.points.length < this.options.animationLimit) {
                    this.points.forEach(function(point) {
                        const {graphic} = point;
                        if (graphic && graphic.width) {
                            if (!this.hasRendered) {
                                graphic.attr({
                                    x: point.plotX,
                                    y: point.plotY,
                                    width: 1,
                                    height: 1
                                })
                            }
                            graphic.animate(this.markerAttribs(point), this.options.animation)
                        }
                    }, this)
                }
            }
            getRadii() {
                const zData = this.zData
                    , yData = this.yData
                    , radii = [];
                let len, i, value, zExtremes = this.chart.bubbleZExtremes;
                const {minPxSize, maxPxSize} = this.getPxExtremes();
                if (!zExtremes) {
                    let zMin = Number.MAX_VALUE;
                    let zMax = -Number.MAX_VALUE;
                    let valid;
                    this.chart.series.forEach( (otherSeries) => {
                            if (otherSeries.bubblePadding && otherSeries.reserveSpace()) {
                                const zExtremes = (otherSeries.onPoint || otherSeries).getZExtremes();
                                if (zExtremes) {
                                    zMin = Math.min(pick(zMin, zExtremes.zMin), zExtremes.zMin);
                                    zMax = Math.max(pick(zMax, zExtremes.zMax), zExtremes.zMax);
                                    valid = !0
                                }
                            }
                        }
                    );
                    if (valid) {
                        zExtremes = {
                            zMin,
                            zMax
                        };
                        this.chart.bubbleZExtremes = zExtremes
                    } else {
                        zExtremes = {
                            zMin: 0,
                            zMax: 0
                        }
                    }
                }
                for (i = 0,
                         len = zData.length; i < len; i++) {
                    value = zData[i];
                    radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]))
                }
                this.radii = radii
            }
            getRadius(zMin, zMax, minSize, maxSize, value, yValue) {
                const options = this.options
                    , sizeByArea = options.sizeBy !== 'width'
                    , zThreshold = options.zThreshold;
                let zRange = zMax - zMin
                    , pos = 0.5;
                if (yValue === null || value === null) {
                    return null
                }
                if (isNumber(value)) {
                    if (options.sizeByAbsoluteValue) {
                        value = Math.abs(value - zThreshold);
                        zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
                        zMin = 0
                    }
                    if (value < zMin) {
                        return minSize / 2 - 1
                    }
                    if (zRange > 0) {
                        pos = (value - zMin) / zRange
                    }
                }
                if (sizeByArea && pos >= 0) {
                    pos = Math.sqrt(pos)
                }
                return Math.ceil(minSize + pos * (maxSize - minSize)) / 2
            }
            hasData() {
                return !!this.processedXData.length
            }
            pointAttribs(point, state) {
                const markerOptions = this.options.marker
                    , fillOpacity = markerOptions.fillOpacity
                    , attr = Series.prototype.pointAttribs.call(this, point, state);
                if (fillOpacity !== 1) {
                    attr.fill = color(attr.fill).setOpacity(fillOpacity).get('rgba')
                }
                return attr
            }
            translate() {
                super.translate.call(this);
                this.getRadii();
                this.translateBubble()
            }
            translateBubble() {
                const {data, options, radii} = this
                    , {minPxSize} = this.getPxExtremes();
                let i = data.length;
                while (i--) {
                    const point = data[i];
                    const radius = radii ? radii[i] : 0;
                    if (this.zoneAxis === 'z') {
                        point.negative = (point.z || 0) < (options.zThreshold || 0)
                    }
                    if (isNumber(radius) && radius >= minPxSize / 2) {
                        point.marker = extend(point.marker, {
                            radius,
                            width: 2 * radius,
                            height: 2 * radius
                        });
                        point.dlBox = {
                            x: point.plotX - radius,
                            y: point.plotY - radius,
                            width: 2 * radius,
                            height: 2 * radius
                        }
                    } else {
                        point.shapeArgs = point.plotY = point.dlBox = void 0;
                        point.isInside = !1
                    }
                }
            }
            getPxExtremes() {
                const smallestSize = Math.min(this.chart.plotWidth, this.chart.plotHeight);
                const getPxSize = (length) => {
                        let isPercent;
                        if (typeof length === 'string') {
                            isPercent = /%$/.test(length);
                            length = parseInt(length, 10)
                        }
                        return isPercent ? smallestSize * length / 100 : length
                    }
                ;
                const minPxSize = getPxSize(pick(this.options.minSize, 8));
                const maxPxSize = Math.max(getPxSize(pick(this.options.maxSize, '20%')), minPxSize);
                return {
                    minPxSize,
                    maxPxSize
                }
            }
            getZExtremes() {
                const options = this.options
                    , zData = (this.zData || []).filter(isNumber);
                if (zData.length) {
                    const zMin = pick(options.zMin, clamp(arrayMin(zData), options.displayNegative === !1 ? (options.zThreshold || 0) : -Number.MAX_VALUE, Number.MAX_VALUE));
                    const zMax = pick(options.zMax, arrayMax(zData));
                    if (isNumber(zMin) && isNumber(zMax)) {
                        return {
                            zMin,
                            zMax
                        }
                    }
                }
            }
        }
        BubbleSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {
            dataLabels: {
                formatter: function() {
                    const {numberFormatter} = this.series.chart;
                    const {z} = this.point;
                    return isNumber(z) ? numberFormatter(z, -1) : ''
                },
                inside: !0,
                verticalAlign: 'middle'
            },
            animationLimit: 250,
            marker: {
                lineColor: null,
                lineWidth: 1,
                fillOpacity: 0.5,
                radius: null,
                states: {
                    hover: {
                        radiusPlus: 0
                    }
                },
                symbol: 'circle'
            },
            minSize: 8,
            maxSize: '20%',
            softThreshold: !1,
            states: {
                hover: {
                    halo: {
                        size: 5
                    }
                }
            },
            tooltip: {
                pointFormat: '({point.x}, {point.y}), Size: {point.z}'
            },
            turboThreshold: 0,
            zThreshold: 0,
            zoneAxis: 'z'
        });
        extend(BubbleSeries.prototype, {
            alignDataLabel: columnProto.alignDataLabel,
            applyZones: noop,
            bubblePadding: !0,
            isBubble: !0,
            pointArrayMap: ['y', 'z'],
            pointClass: BubblePoint,
            parallelArrays: ['x', 'y', 'z'],
            trackerGroups: ['group', 'dataLabelsGroup'],
            specialGroup: 'group',
            zoneAxis: 'z'
        });
        addEvent(BubbleSeries, 'updatedData', (e) => {
                delete e.target.chart.bubbleZExtremes
            }
        );
        addEvent(BubbleSeries, 'remove', (e) => {
                delete e.target.chart.bubbleZExtremes
            }
        );
        SeriesRegistry.registerSeriesType('bubble', BubbleSeries);
        '';
        '';
        return BubbleSeries
    });
    _registerModule(_modules, 'Series/ColumnRange/ColumnRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(SeriesRegistry, U) {
        const {seriesTypes: {column: {prototype: {pointClass: {prototype: columnProto}}}, arearange: {prototype: {pointClass: AreaRangePoint}}}} = SeriesRegistry;
        const {extend, isNumber} = U;
        class ColumnRangePoint extends AreaRangePoint {
            constructor() {
                super(...arguments);
                this.options = void 0;
                this.series = void 0
            }
            isValid() {
                return isNumber(this.low)
            }
        }
        extend(ColumnRangePoint.prototype, {
            setState: columnProto.setState
        });
        return ColumnRangePoint
    });
    _registerModule(_modules, 'Series/ColumnRange/ColumnRangeSeries.js', [_modules['Series/ColumnRange/ColumnRangePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(ColumnRangePoint, H, SeriesRegistry, U) {
        const {noop} = H;
        const {seriesTypes: {arearange: AreaRangeSeries, column: ColumnSeries, column: {prototype: columnProto}}} = SeriesRegistry;
        const {addEvent, clamp, extend, isNumber, merge, pick} = U;
        const columnRangeOptions = {
            borderRadius: {
                where: 'all'
            },
            pointRange: null,
            marker: null,
            states: {
                hover: {
                    halo: !1
                }
            }
        };
        class ColumnRangeSeries extends AreaRangeSeries {
            setOptions() {
                merge(!0, arguments[0], {
                    stacking: void 0
                });
                return AreaRangeSeries.prototype.setOptions.apply(this, arguments)
            }
            translate() {
                return columnProto.translate.apply(this)
            }
            pointAttribs() {
                return columnProto.pointAttribs.apply(this, arguments)
            }
            translate3dPoints() {
                return columnProto.translate3dPoints.apply(this, arguments)
            }
            translate3dShapes() {
                return columnProto.translate3dShapes.apply(this, arguments)
            }
            afterColumnTranslate() {
                const yAxis = this.yAxis
                    , xAxis = this.xAxis
                    , startAngleRad = xAxis.startAngleRad
                    , chart = this.chart
                    , isRadial = this.xAxis.isRadial
                    , safeDistance = Math.max(chart.chartWidth, chart.chartHeight) + 999;
                let height, heightDifference, start, plotHigh, y;
                function safeBounds(pixelPos) {
                    return clamp(pixelPos, -safeDistance, safeDistance)
                }
                this.points.forEach( (point) => {
                        const shapeArgs = point.shapeArgs || {}
                            , minPointLength = this.options.minPointLength
                            , plotY = point.plotY
                            , plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);
                        if (isNumber(plotHigh) && isNumber(plotY)) {
                            point.plotHigh = safeBounds(plotHigh);
                            point.plotLow = safeBounds(plotY);
                            y = point.plotHigh;
                            height = pick(point.rectPlotY, point.plotY) - point.plotHigh;
                            if (Math.abs(height) < minPointLength) {
                                heightDifference = (minPointLength - height);
                                height += heightDifference;
                                y -= heightDifference / 2
                            } else if (height < 0) {
                                height *= -1;
                                y -= height
                            }
                            if (isRadial && this.polar) {
                                start = point.barX + startAngleRad;
                                point.shapeType = 'arc';
                                point.shapeArgs = this.polar.arc(y + height, y, start, start + point.pointWidth)
                            } else {
                                shapeArgs.height = height;
                                shapeArgs.y = y;
                                const {x=0, width=0} = shapeArgs;
                                point.shapeArgs = merge(point.shapeArgs, this.crispCol(x, y, width, height));
                                point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2, xAxis.len + xAxis.pos - chart.plotTop - x - width / 2, height] : [xAxis.left - chart.plotLeft + x + width / 2, yAxis.pos - chart.plotTop + y + height / 2, height]
                            }
                        }
                    }
                )
            }
        }
        ColumnRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, AreaRangeSeries.defaultOptions, columnRangeOptions);
        addEvent(ColumnRangeSeries, 'afterColumnTranslate', function() {
            ColumnRangeSeries.prototype.afterColumnTranslate.apply(this)
        }, {
            order: 5
        });
        extend(ColumnRangeSeries.prototype, {
            directTouch: !0,
            pointClass: ColumnRangePoint,
            trackerGroups: ['group', 'dataLabelsGroup'],
            adjustForMissingColumns: columnProto.adjustForMissingColumns,
            animate: columnProto.animate,
            crispCol: columnProto.crispCol,
            drawGraph: noop,
            drawPoints: columnProto.drawPoints,
            getSymbol: noop,
            drawTracker: columnProto.drawTracker,
            getColumnMetrics: columnProto.getColumnMetrics
        });
        SeriesRegistry.registerSeriesType('columnrange', ColumnRangeSeries);
        '';
        return ColumnRangeSeries
    });
    _registerModule(_modules, 'Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js', [], function() {
        const ColumnPyramidSeriesDefaults = {};
        '';
        return ColumnPyramidSeriesDefaults
    });
    _registerModule(_modules, 'Series/ColumnPyramid/ColumnPyramidSeries.js', [_modules['Series/ColumnPyramid/ColumnPyramidSeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(ColumnPyramidSeriesDefaults, SeriesRegistry, U) {
        const {column: ColumnSeries} = SeriesRegistry.seriesTypes;
        const {clamp, merge, pick} = U;
        class ColumnPyramidSeries extends ColumnSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            translate() {
                const series = this
                    , chart = series.chart
                    , options = series.options
                    , dense = series.dense = series.closestPointRange * series.xAxis.transA < 2
                    , borderWidth = series.borderWidth = pick(options.borderWidth, dense ? 0 : 1)
                    , yAxis = series.yAxis
                    , threshold = options.threshold
                    , minPointLength = pick(options.minPointLength, 5)
                    , metrics = series.getColumnMetrics()
                    , pointWidth = metrics.width
                    , pointXOffset = series.pointXOffset = metrics.offset;
                let translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold)
                    , seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth);
                if (chart.inverted) {
                    translatedThreshold -= 0.5
                }
                if (options.pointPadding) {
                    seriesBarW = Math.ceil(seriesBarW)
                }
                super.translate();
                for (const point of series.points) {
                    const yBottom = pick(point.yBottom, translatedThreshold)
                        , safeDistance = 999 + Math.abs(yBottom)
                        , plotY = clamp(point.plotY, -safeDistance, yAxis.len + safeDistance)
                        , barW = seriesBarW / 2
                        , barY = Math.min(plotY, yBottom)
                        , barH = Math.max(plotY, yBottom) - barY;
                    let barX = point.plotX + pointXOffset, stackTotal, stackHeight, topPointY, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;
                    if (options.centerInCategory) {
                        barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics)
                    }
                    point.barX = barX;
                    point.pointWidth = pointWidth;
                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW, barH] : [barX + barW, plotY + yAxis.pos - chart.plotTop, barH];
                    stackTotal = threshold + (point.total || point.y);
                    if (options.stacking === 'percent') {
                        stackTotal = threshold + (point.y < 0) ? -100 : 100
                    }
                    topPointY = yAxis.toPixels((stackTotal), !0);
                    stackHeight = chart.plotHeight - topPointY - (chart.plotHeight - translatedThreshold);
                    topXwidth = stackHeight ? (barW * (barY - topPointY)) / stackHeight : 0;
                    bottomXwidth = stackHeight ? (barW * (barY + barH - topPointY)) / stackHeight : 0;
                    x1 = barX - topXwidth + barW;
                    x2 = barX + topXwidth + barW;
                    x3 = barX + bottomXwidth + barW;
                    x4 = barX - bottomXwidth + barW;
                    y1 = barY - minPointLength;
                    y2 = barY + barH;
                    if (point.y < 0) {
                        y1 = barY;
                        y2 = barY + barH + minPointLength
                    }
                    if (chart.inverted) {
                        invBarPos = yAxis.width - barY;
                        stackHeight = topPointY - (yAxis.width - translatedThreshold);
                        topXwidth = (barW * (topPointY - invBarPos)) / stackHeight;
                        bottomXwidth = (barW * (topPointY - (invBarPos - barH))) / stackHeight;
                        x1 = barX + barW + topXwidth;
                        x2 = x1 - 2 * topXwidth;
                        x3 = barX - bottomXwidth + barW;
                        x4 = barX + bottomXwidth + barW;
                        y1 = barY;
                        y2 = barY + barH - minPointLength;
                        if (point.y < 0) {
                            y2 = barY + barH + minPointLength
                        }
                    }
                    point.shapeType = 'path';
                    point.shapeArgs = {
                        x: x1,
                        y: y1,
                        width: x2 - x1,
                        height: barH,
                        d: [['M', x1, y1], ['L', x2, y1], ['L', x3, y2], ['L', x4, y2], ['Z']]
                    }
                }
            }
        }
        ColumnPyramidSeries.defaultOptions = merge(ColumnSeries.defaultOptions, ColumnPyramidSeriesDefaults);
        SeriesRegistry.registerSeriesType('columnpyramid', ColumnPyramidSeries);
        return ColumnPyramidSeries
    });
    _registerModule(_modules, 'Series/ErrorBar/ErrorBarSeriesDefaults.js', [], function() {
        const ErrorBarSeriesDefaults = {
            color: "#000000",
            grouping: !1,
            linkedTo: ':previous',
            tooltip: {
                pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
            },
            whiskerWidth: null
        };
        '';
        return ErrorBarSeriesDefaults
    });
    _registerModule(_modules, 'Series/ErrorBar/ErrorBarSeries.js', [_modules['Series/BoxPlot/BoxPlotSeries.js'], _modules['Series/Column/ColumnSeries.js'], _modules['Series/ErrorBar/ErrorBarSeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(BoxPlotSeries, ColumnSeries, ErrorBarSeriesDefaults, SeriesRegistry, U) {
        const {arearange: AreaRangeSeries} = SeriesRegistry.seriesTypes;
        const {addEvent, merge, extend} = U;
        class ErrorBarSeries extends BoxPlotSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            getColumnMetrics() {
                const series = this;
                return ((series.linkedParent && series.linkedParent.columnMetrics) || ColumnSeries.prototype.getColumnMetrics.call(series))
            }
            drawDataLabels() {
                const series = this
                    , valKey = series.pointValKey;
                if (AreaRangeSeries) {
                    AreaRangeSeries.prototype.drawDataLabels.call(series);
                    for (const point of series.data) {
                        point.y = point[valKey]
                    }
                }
            }
            toYData(point) {
                return [point.low, point.high]
            }
        }
        ErrorBarSeries.defaultOptions = merge(BoxPlotSeries.defaultOptions, ErrorBarSeriesDefaults);
        addEvent(ErrorBarSeries, 'afterTranslate', function() {
            for (const point of this.points) {
                point.plotLow = point.plotY
            }
        }, {
            order: 0
        });
        extend(ErrorBarSeries.prototype, {
            pointArrayMap: ['low', 'high'],
            pointValKey: 'high',
            doQuartiles: !1
        });
        SeriesRegistry.registerSeriesType('errorbar', ErrorBarSeries);
        return ErrorBarSeries
    });
    _registerModule(_modules, 'Series/Gauge/GaugePoint.js', [_modules['Core/Series/SeriesRegistry.js']], function(SeriesRegistry) {
        const {series: {prototype: {pointClass: Point}}} = SeriesRegistry;
        class GaugePoint extends Point {
            constructor() {
                super(...arguments);
                this.options = void 0;
                this.series = void 0;
                this.shapeArgs = void 0
            }
            setState(state) {
                this.state = state
            }
        }
        return GaugePoint
    });
    _registerModule(_modules, 'Series/Gauge/GaugeSeries.js', [_modules['Series/Gauge/GaugePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(GaugePoint, H, SeriesRegistry, U) {
        const {noop} = H;
        const {series: Series, seriesTypes: {column: ColumnSeries}} = SeriesRegistry;
        const {clamp, isNumber, extend, merge, pick, pInt, defined} = U;
        class GaugeSeries extends Series {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.points = void 0;
                this.options = void 0;
                this.yAxis = void 0
            }
            translate() {
                const series = this
                    , yAxis = series.yAxis
                    , options = series.options
                    , center = yAxis.center;
                series.generatePoints();
                series.points.forEach( (point) => {
                        const dialOptions = merge(options.dial, point.dial)
                            , radius = (pInt(dialOptions.radius) * center[2]) / 200
                            , baseLength = (pInt(dialOptions.baseLength) * radius) / 100
                            , rearLength = (pInt(dialOptions.rearLength) * radius) / 100
                            , baseWidth = dialOptions.baseWidth
                            , topWidth = dialOptions.topWidth;
                        let overshoot = options.overshoot
                            , rotation = yAxis.startAngleRad + yAxis.translate(point.y, void 0, void 0, void 0, !0);
                        if (isNumber(overshoot) || options.wrap === !1) {
                            overshoot = isNumber(overshoot) ? (overshoot / 180 * Math.PI) : 0;
                            rotation = clamp(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot)
                        }
                        rotation = rotation * 180 / Math.PI;
                        point.shapeType = 'path';
                        const d = dialOptions.path || [['M', -rearLength, -baseWidth / 2], ['L', baseLength, -baseWidth / 2], ['L', radius, -topWidth / 2], ['L', radius, topWidth / 2], ['L', baseLength, baseWidth / 2], ['L', -rearLength, baseWidth / 2], ['Z']];
                        point.shapeArgs = {
                            d,
                            translateX: center[0],
                            translateY: center[1],
                            rotation: rotation
                        };
                        point.plotX = center[0];
                        point.plotY = center[1];
                        if (defined(point.y) && yAxis.max - yAxis.min) {
                            point.percentage = (point.y - yAxis.min) / (yAxis.max - yAxis.min) * 100
                        }
                    }
                )
            }
            drawPoints() {
                const series = this
                    , chart = series.chart
                    , center = series.yAxis.center
                    , pivot = series.pivot
                    , options = series.options
                    , pivotOptions = options.pivot
                    , renderer = chart.renderer;
                series.points.forEach( (point) => {
                        const graphic = point.graphic
                            , shapeArgs = point.shapeArgs
                            , d = shapeArgs.d
                            , dialOptions = merge(options.dial, point.dial);
                        if (graphic) {
                            graphic.animate(shapeArgs);
                            shapeArgs.d = d
                        } else {
                            point.graphic = renderer[point.shapeType](shapeArgs).addClass('highcharts-dial').add(series.group)
                        }
                        if (!chart.styledMode) {
                            point.graphic[graphic ? 'animate' : 'attr']({
                                stroke: dialOptions.borderColor,
                                'stroke-width': dialOptions.borderWidth,
                                fill: dialOptions.backgroundColor
                            })
                        }
                    }
                );
                if (pivot) {
                    pivot.animate({
                        translateX: center[0],
                        translateY: center[1]
                    })
                } else if (pivotOptions) {
                    series.pivot = renderer.circle(0, 0, pivotOptions.radius).attr({
                        zIndex: 2
                    }).addClass('highcharts-pivot').translate(center[0], center[1]).add(series.group);
                    if (!chart.styledMode) {
                        series.pivot.attr({
                            fill: pivotOptions.backgroundColor,
                            stroke: pivotOptions.borderColor,
                            'stroke-width': pivotOptions.borderWidth
                        })
                    }
                }
            }
            animate(init) {
                const series = this;
                if (!init) {
                    series.points.forEach( (point) => {
                            const graphic = point.graphic;
                            if (graphic) {
                                graphic.attr({
                                    rotation: series.yAxis.startAngleRad * 180 / Math.PI
                                });
                                graphic.animate({
                                    rotation: point.shapeArgs.rotation
                                }, series.options.animation)
                            }
                        }
                    )
                }
            }
            render() {
                this.group = this.plotGroup('group', 'series', this.visible ? 'inherit' : 'hidden', this.options.zIndex, this.chart.seriesGroup);
                Series.prototype.render.call(this);
                this.group.clip(this.chart.clipRect)
            }
            setData(data, redraw) {
                Series.prototype.setData.call(this, data, !1);
                this.processData();
                this.generatePoints();
                if (pick(redraw, !0)) {
                    this.chart.redraw()
                }
            }
            hasData() {
                return !!this.points.length
            }
        }
        GaugeSeries.defaultOptions = merge(Series.defaultOptions, {
            dataLabels: {
                borderColor: "#cccccc",
                borderRadius: 3,
                borderWidth: 1,
                crop: !1,
                defer: !1,
                enabled: !0,
                verticalAlign: 'top',
                y: 15,
                zIndex: 2
            },
            dial: {
                backgroundColor: "#000000",
                baseLength: '70%',
                baseWidth: 3,
                borderColor: "#cccccc",
                borderWidth: 0,
                radius: '80%',
                rearLength: '10%',
                topWidth: 1
            },
            pivot: {
                radius: 5,
                borderWidth: 0,
                borderColor: "#cccccc",
                backgroundColor: "#000000"
            },
            tooltip: {
                headerFormat: ''
            },
            showInLegend: !1
        });
        extend(GaugeSeries.prototype, {
            angular: !0,
            directTouch: !0,
            drawGraph: noop,
            drawTracker: ColumnSeries.prototype.drawTracker,
            fixedBox: !0,
            forceDL: !0,
            noSharedTooltip: !0,
            pointClass: GaugePoint,
            trackerGroups: ['group', 'dataLabelsGroup']
        });
        SeriesRegistry.registerSeriesType('gauge', GaugeSeries);
        '';
        return GaugeSeries
    });
    _registerModule(_modules, 'Series/DragNodesComposition.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent} = U;
        const composedMembers = [];
        function compose(ChartClass) {
            if (U.pushUnique(composedMembers, ChartClass)) {
                addEvent(ChartClass, 'load', onChartLoad)
            }
        }
        function onChartLoad() {
            const chart = this;
            let mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder;
            if (chart.container) {
                mousedownUnbinder = addEvent(chart.container, 'mousedown', (event) => {
                        const point = chart.hoverPoint;
                        if (point && point.series && point.series.hasDraggableNodes && point.series.options.draggable) {
                            point.series.onMouseDown(point, event);
                            mousemoveUnbinder = addEvent(chart.container, 'mousemove', (e) => (point && point.series && point.series.onMouseMove(point, e)));
                            mouseupUnbinder = addEvent(chart.container.ownerDocument, 'mouseup', (e) => {
                                    mousemoveUnbinder();
                                    mouseupUnbinder();
                                    return point && point.series && point.series.onMouseUp(point, e)
                                }
                            )
                        }
                    }
                )
            }
            addEvent(chart, 'destroy', function() {
                mousedownUnbinder()
            })
        }
        function onMouseDown(point, event) {
            const normalizedEvent = this.chart.pointer.normalize(event);
            point.fixedPosition = {
                chartX: normalizedEvent.chartX,
                chartY: normalizedEvent.chartY,
                plotX: point.plotX,
                plotY: point.plotY
            };
            point.inDragMode = !0
        }
        function onMouseMove(point, event) {
            if (point.fixedPosition && point.inDragMode) {
                const series = this
                    , chart = series.chart
                    , normalizedEvent = chart.pointer.normalize(event)
                    , diffX = point.fixedPosition.chartX - normalizedEvent.chartX
                    , diffY = point.fixedPosition.chartY - normalizedEvent.chartY
                    , graphLayoutsLookup = chart.graphLayoutsLookup;
                let newPlotX, newPlotY;
                if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
                    newPlotX = point.fixedPosition.plotX - diffX;
                    newPlotY = point.fixedPosition.plotY - diffY;
                    if (chart.isInsidePlot(newPlotX, newPlotY)) {
                        point.plotX = newPlotX;
                        point.plotY = newPlotY;
                        point.hasDragged = !0;
                        this.redrawHalo(point);
                        graphLayoutsLookup.forEach( (layout) => {
                                layout.restartSimulation()
                            }
                        )
                    }
                }
            }
        }
        function onMouseUp(point, _event) {
            if (point.fixedPosition) {
                if (point.hasDragged) {
                    if (this.layout.enableSimulation) {
                        this.layout.start()
                    } else {
                        this.chart.redraw()
                    }
                }
                point.inDragMode = point.hasDragged = !1;
                if (!this.options.fixedDraggable) {
                    delete point.fixedPosition
                }
            }
        }
        function redrawHalo(point) {
            if (point && this.halo) {
                this.halo.attr({
                    d: point.haloPath(this.options.states.hover.halo.size)
                })
            }
        }
        const DragNodesComposition = {
            compose,
            onMouseDown,
            onMouseMove,
            onMouseUp,
            redrawHalo
        };
        return DragNodesComposition
    });
    _registerModule(_modules, 'Series/GraphLayoutComposition.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Utilities.js']], function(A, U) {
        const {setAnimation} = A;
        const {addEvent} = U;
        const composedMembers = [];
        const integrations = {};
        const layouts = {};
        function compose(ChartClass) {
            if (U.pushUnique(composedMembers, ChartClass)) {
                addEvent(ChartClass, 'afterPrint', onChartAfterPrint);
                addEvent(ChartClass, 'beforePrint', onChartBeforePrint);
                addEvent(ChartClass, 'predraw', onChartPredraw);
                addEvent(ChartClass, 'render', onChartRender)
            }
        }
        function onChartAfterPrint() {
            if (this.graphLayoutsLookup) {
                this.graphLayoutsLookup.forEach( (layout) => {
                        layout.updateSimulation()
                    }
                );
                this.redraw()
            }
        }
        function onChartBeforePrint() {
            if (this.graphLayoutsLookup) {
                this.graphLayoutsLookup.forEach( (layout) => {
                        layout.updateSimulation(!1)
                    }
                );
                this.redraw()
            }
        }
        function onChartPredraw() {
            if (this.graphLayoutsLookup) {
                this.graphLayoutsLookup.forEach( (layout) => {
                        layout.stop()
                    }
                )
            }
        }
        function onChartRender() {
            let systemsStable, afterRender = !1;
            const layoutStep = (layout) => {
                    if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable() && !layout.enableSimulation) {
                        if (layout.beforeStep) {
                            layout.beforeStep()
                        }
                        layout.step();
                        systemsStable = !1;
                        afterRender = !0
                    }
                }
            ;
            if (this.graphLayoutsLookup) {
                setAnimation(!1, this);
                this.graphLayoutsLookup.forEach( (layout) => layout.start());
                while (!systemsStable) {
                    systemsStable = !0;
                    this.graphLayoutsLookup.forEach(layoutStep)
                }
                if (afterRender) {
                    this.series.forEach( (series) => {
                            if (series && series.layout) {
                                series.render()
                            }
                        }
                    )
                }
            }
        }
        const GraphLayoutComposition = {
            compose,
            integrations,
            layouts
        };
        return GraphLayoutComposition
    });
    _registerModule(_modules, 'Series/PackedBubble/PackedBubblePoint.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js']], function(Chart, Point, SeriesRegistry) {
        const {seriesTypes: {bubble: {prototype: {pointClass: BubblePoint}}}} = SeriesRegistry;
        class PackedBubblePoint extends BubblePoint {
            constructor() {
                super(...arguments);
                this.degree = NaN;
                this.mass = NaN;
                this.radius = NaN;
                this.options = void 0;
                this.series = void 0;
                this.value = null
            }
            destroy() {
                if (this.series.layout) {
                    this.series.layout.removeElementFromCollection(this, this.series.layout.nodes)
                }
                return Point.prototype.destroy.apply(this, arguments)
            }
            firePointEvent() {
                const point = this
                    , series = this.series
                    , seriesOptions = series.options;
                if (this.isParentNode && seriesOptions.parentNode) {
                    const temp = seriesOptions.allowPointSelect;
                    seriesOptions.allowPointSelect = (seriesOptions.parentNode.allowPointSelect);
                    Point.prototype.firePointEvent.apply(this, arguments);
                    seriesOptions.allowPointSelect = temp
                } else {
                    Point.prototype.firePointEvent.apply(this, arguments)
                }
            }
            select() {
                const point = this
                    , series = this.series
                    , chart = series.chart;
                if (point.isParentNode) {
                    chart.getSelectedPoints = chart.getSelectedParentNodes;
                    Point.prototype.select.apply(this, arguments);
                    chart.getSelectedPoints = Chart.prototype.getSelectedPoints
                } else {
                    Point.prototype.select.apply(this, arguments)
                }
            }
        }
        return PackedBubblePoint
    });
    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleSeriesDefaults.js', [_modules['Core/Utilities.js']], function(U) {
        const {isNumber} = U;
        const PackedBubbleSeriesDefaults = {
            minSize: '10%',
            maxSize: '50%',
            sizeBy: 'area',
            zoneAxis: 'y',
            crisp: !1,
            tooltip: {
                pointFormat: 'Value: {point.value}'
            },
            draggable: !0,
            useSimulation: !0,
            parentNode: {
                allowPointSelect: !1
            },
            dataLabels: {
                formatter: function() {
                    const {numberFormatter} = this.series.chart;
                    const {value} = this.point;
                    return isNumber(value) ? numberFormatter(value, -1) : ''
                },
                parentNodeFormatter: function() {
                    return this.name
                },
                parentNodeTextPath: {
                    enabled: !0
                },
                padding: 0,
                style: {
                    transition: 'opacity 2000ms'
                }
            },
            layoutAlgorithm: {
                initialPositions: 'circle',
                initialPositionRadius: 20,
                bubblePadding: 5,
                parentNodeLimit: !1,
                seriesInteraction: !0,
                dragBetweenSeries: !1,
                parentNodeOptions: {
                    maxIterations: 400,
                    gravitationalConstant: 0.03,
                    maxSpeed: 50,
                    initialPositionRadius: 100,
                    seriesInteraction: !0,
                    marker: {
                        fillColor: null,
                        fillOpacity: 1,
                        lineWidth: null,
                        lineColor: null,
                        symbol: 'circle'
                    }
                },
                enableSimulation: !0,
                type: 'packedbubble',
                integration: 'packedbubble',
                maxIterations: 1000,
                splitSeries: !1,
                maxSpeed: 5,
                gravitationalConstant: 0.01,
                friction: -0.981
            }
        };
        '';
        return PackedBubbleSeriesDefaults
    });
    _registerModule(_modules, 'Series/Networkgraph/VerletIntegration.js', [], function() {
        function attractive(link, force, distanceXY) {
            const massFactor = link.getMass()
                , translatedX = -distanceXY.x * force * this.diffTemperature
                , translatedY = -distanceXY.y * force * this.diffTemperature;
            if (!link.fromNode.fixedPosition) {
                link.fromNode.plotX -= translatedX * massFactor.fromNode / link.fromNode.degree;
                link.fromNode.plotY -= translatedY * massFactor.fromNode / link.fromNode.degree
            }
            if (!link.toNode.fixedPosition) {
                link.toNode.plotX += translatedX * massFactor.toNode / link.toNode.degree;
                link.toNode.plotY += translatedY * massFactor.toNode / link.toNode.degree
            }
        }
        function attractiveForceFunction(d, k) {
            return (k - d) / d
        }
        function barycenter() {
            let gravitationalConstant = this.options.gravitationalConstant
                , xFactor = this.barycenter.xFactor
                , yFactor = this.barycenter.yFactor;
            xFactor = (xFactor - (this.box.left + this.box.width) / 2) * gravitationalConstant;
            yFactor = (yFactor - (this.box.top + this.box.height) / 2) * gravitationalConstant;
            this.nodes.forEach(function(node) {
                if (!node.fixedPosition) {
                    node.plotX -= xFactor / node.mass / node.degree;
                    node.plotY -= yFactor / node.mass / node.degree
                }
            })
        }
        function getK(layout) {
            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5)
        }
        function integrate(layout, node) {
            let friction = -layout.options.friction
                , maxSpeed = layout.options.maxSpeed
                , prevX = node.prevX
                , prevY = node.prevY
                , diffX = ((node.plotX + node.dispX - prevX) * friction)
                , diffY = ((node.plotY + node.dispY - prevY) * friction)
                , abs = Math.abs
                , signX = abs(diffX) / (diffX || 1)
                , signY = abs(diffY) / (diffY || 1);
            diffX = signX * Math.min(maxSpeed, Math.abs(diffX));
            diffY = signY * Math.min(maxSpeed, Math.abs(diffY));
            node.prevX = node.plotX + node.dispX;
            node.prevY = node.plotY + node.dispY;
            node.plotX += diffX;
            node.plotY += diffY;
            node.temperature = layout.vectorLength({
                x: diffX,
                y: diffY
            })
        }
        function repulsive(node, force, distanceXY) {
            const factor = force * this.diffTemperature / node.mass / node.degree;
            if (!node.fixedPosition) {
                node.plotX += distanceXY.x * factor;
                node.plotY += distanceXY.y * factor
            }
        }
        function repulsiveForceFunction(d, k) {
            return (k - d) / d * (k > d ? 1 : 0)
        }
        const VerletIntegration = {
            attractive,
            attractiveForceFunction,
            barycenter,
            getK,
            integrate,
            repulsive,
            repulsiveForceFunction
        };
        return VerletIntegration
    });
    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleIntegration.js', [_modules['Core/Globals.js'], _modules['Series/Networkgraph/VerletIntegration.js']], function(H, VerletIntegration) {
        const {noop} = H;
        function barycenter() {
            const layout = this
                , gravitationalConstant = layout.options.gravitationalConstant
                , box = layout.box
                , nodes = layout.nodes;
            let centerX, centerY;
            for (const node of nodes) {
                if (layout.options.splitSeries && !node.isParentNode) {
                    centerX = node.series.parentNode.plotX;
                    centerY = node.series.parentNode.plotY
                } else {
                    centerX = box.width / 2;
                    centerY = box.height / 2
                }
                if (!node.fixedPosition) {
                    node.plotX -= (node.plotX - centerX) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
                    node.plotY -= (node.plotY - centerY) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length))
                }
            }
        }
        function repulsive(node, force, distanceXY, repNode) {
            const factor = (force * this.diffTemperature / node.mass / node.degree)
                , x = distanceXY.x * factor
                , y = distanceXY.y * factor;
            if (!node.fixedPosition) {
                node.plotX += x;
                node.plotY += y
            }
            if (!repNode.fixedPosition) {
                repNode.plotX -= x;
                repNode.plotY -= y
            }
        }
        function repulsiveForceFunction(d, k, node, repNode) {
            return Math.min(d, (node.marker.radius + repNode.marker.radius) / 2)
        }
        const PackedBubbleIntegration = {
            barycenter,
            getK: noop,
            integrate: VerletIntegration.integrate,
            repulsive,
            repulsiveForceFunction
        };
        return PackedBubbleIntegration
    });
    _registerModule(_modules, 'Series/Networkgraph/EulerIntegration.js', [], function() {
        function attractive(link, force, distanceXY, distanceR) {
            const massFactor = link.getMass()
                , translatedX = (distanceXY.x / distanceR) * force
                , translatedY = (distanceXY.y / distanceR) * force;
            if (!link.fromNode.fixedPosition) {
                link.fromNode.dispX -= translatedX * massFactor.fromNode / link.fromNode.degree;
                link.fromNode.dispY -= translatedY * massFactor.fromNode / link.fromNode.degree
            }
            if (!link.toNode.fixedPosition) {
                link.toNode.dispX += translatedX * massFactor.toNode / link.toNode.degree;
                link.toNode.dispY += translatedY * massFactor.toNode / link.toNode.degree
            }
        }
        function attractiveForceFunction(d, k) {
            return d * d / k
        }
        function barycenter() {
            const gravitationalConstant = this.options.gravitationalConstant
                , xFactor = this.barycenter.xFactor
                , yFactor = this.barycenter.yFactor;
            this.nodes.forEach(function(node) {
                if (!node.fixedPosition) {
                    const degree = node.getDegree()
                        , phi = degree * (1 + degree / 2);
                    node.dispX += ((xFactor - node.plotX) * gravitationalConstant * phi / node.degree);
                    node.dispY += ((yFactor - node.plotY) * gravitationalConstant * phi / node.degree)
                }
            })
        }
        function getK(layout) {
            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3)
        }
        function integrate(layout, node) {
            let distanceR;
            node.dispX += node.dispX * layout.options.friction;
            node.dispY += node.dispY * layout.options.friction;
            distanceR = node.temperature = layout.vectorLength({
                x: node.dispX,
                y: node.dispY
            });
            if (distanceR !== 0) {
                node.plotX += (node.dispX / distanceR * Math.min(Math.abs(node.dispX), layout.temperature));
                node.plotY += (node.dispY / distanceR * Math.min(Math.abs(node.dispY), layout.temperature))
            }
        }
        function repulsive(node, force, distanceXY, distanceR) {
            node.dispX += (distanceXY.x / distanceR) * force / node.degree;
            node.dispY += (distanceXY.y / distanceR) * force / node.degree
        }
        function repulsiveForceFunction(d, k) {
            return k * k / d
        }
        const EulerIntegration = {
            attractive,
            attractiveForceFunction,
            barycenter,
            getK,
            integrate,
            repulsive,
            repulsiveForceFunction
        };
        return EulerIntegration
    });
    _registerModule(_modules, 'Series/Networkgraph/QuadTreeNode.js', [], function() {
        class QuadTreeNode {
            constructor(box) {
                this.body = !1;
                this.isEmpty = !1;
                this.isInternal = !1;
                this.nodes = [];
                this.box = box;
                this.boxSize = Math.min(box.width, box.height)
            }
            divideBox() {
                const halfWidth = this.box.width / 2
                    , halfHeight = this.box.height / 2;
                this.nodes[0] = new QuadTreeNode({
                    left: this.box.left,
                    top: this.box.top,
                    width: halfWidth,
                    height: halfHeight
                });
                this.nodes[1] = new QuadTreeNode({
                    left: this.box.left + halfWidth,
                    top: this.box.top,
                    width: halfWidth,
                    height: halfHeight
                });
                this.nodes[2] = new QuadTreeNode({
                    left: this.box.left + halfWidth,
                    top: this.box.top + halfHeight,
                    width: halfWidth,
                    height: halfHeight
                });
                this.nodes[3] = new QuadTreeNode({
                    left: this.box.left,
                    top: this.box.top + halfHeight,
                    width: halfWidth,
                    height: halfHeight
                })
            }
            getBoxPosition(point) {
                const left = point.plotX < this.box.left + this.box.width / 2
                    , top = point.plotY < this.box.top + this.box.height / 2;
                let index;
                if (left) {
                    if (top) {
                        index = 0
                    } else {
                        index = 3
                    }
                } else {
                    if (top) {
                        index = 1
                    } else {
                        index = 2
                    }
                }
                return index
            }
            insert(point, depth) {
                let newQuadTreeNode;
                if (this.isInternal) {
                    this.nodes[this.getBoxPosition(point)].insert(point, depth - 1)
                } else {
                    this.isEmpty = !1;
                    if (!this.body) {
                        this.isInternal = !1;
                        this.body = point
                    } else {
                        if (depth) {
                            this.isInternal = !0;
                            this.divideBox();
                            if (this.body !== !0) {
                                this.nodes[this.getBoxPosition(this.body)].insert(this.body, depth - 1);
                                this.body = !0
                            }
                            this.nodes[this.getBoxPosition(point)].insert(point, depth - 1)
                        } else {
                            newQuadTreeNode = new QuadTreeNode({
                                top: point.plotX || NaN,
                                left: point.plotY || NaN,
                                width: 0.1,
                                height: 0.1
                            });
                            newQuadTreeNode.body = point;
                            newQuadTreeNode.isInternal = !1;
                            this.nodes.push(newQuadTreeNode)
                        }
                    }
                }
            }
            updateMassAndCenter() {
                let mass = 0
                    , plotX = 0
                    , plotY = 0;
                if (this.isInternal) {
                    for (const pointMass of this.nodes) {
                        if (!pointMass.isEmpty) {
                            mass += pointMass.mass;
                            plotX += pointMass.plotX * pointMass.mass;
                            plotY += pointMass.plotY * pointMass.mass
                        }
                    }
                    plotX /= mass;
                    plotY /= mass
                } else if (this.body) {
                    mass = this.body.mass;
                    plotX = this.body.plotX;
                    plotY = this.body.plotY
                }
                this.mass = mass;
                this.plotX = plotX;
                this.plotY = plotY
            }
        }
        return QuadTreeNode
    });
    _registerModule(_modules, 'Series/Networkgraph/QuadTree.js', [_modules['Series/Networkgraph/QuadTreeNode.js']], function(QuadTreeNode) {
        class QuadTree {
            constructor(x, y, width, height) {
                this.box = {
                    left: x,
                    top: y,
                    width: width,
                    height: height
                };
                this.maxDepth = 25;
                this.root = new QuadTreeNode(this.box);
                this.root.isInternal = !0;
                this.root.isRoot = !0;
                this.root.divideBox()
            }
            calculateMassAndCenter() {
                this.visitNodeRecursive(null, null, function(node) {
                    node.updateMassAndCenter()
                })
            }
            insertNodes(points) {
                for (const point of points) {
                    this.root.insert(point, this.maxDepth)
                }
            }
            visitNodeRecursive(node, beforeCallback, afterCallback) {
                let goFurther;
                if (!node) {
                    node = this.root
                }
                if (node === this.root && beforeCallback) {
                    goFurther = beforeCallback(node)
                }
                if (goFurther === !1) {
                    return
                }
                for (const qtNode of node.nodes) {
                    if (qtNode.isInternal) {
                        if (beforeCallback) {
                            goFurther = beforeCallback(qtNode)
                        }
                        if (goFurther === !1) {
                            continue
                        }
                        this.visitNodeRecursive(qtNode, beforeCallback, afterCallback)
                    } else if (qtNode.body) {
                        if (beforeCallback) {
                            beforeCallback(qtNode.body)
                        }
                    }
                    if (afterCallback) {
                        afterCallback(qtNode)
                    }
                }
                if (node === this.root && afterCallback) {
                    afterCallback(node)
                }
            }
        }
        return QuadTree
    });
    _registerModule(_modules, 'Series/Networkgraph/ReingoldFruchtermanLayout.js', [_modules['Series/Networkgraph/EulerIntegration.js'], _modules['Core/Globals.js'], _modules['Series/GraphLayoutComposition.js'], _modules['Series/Networkgraph/QuadTree.js'], _modules['Core/Utilities.js'], _modules['Series/Networkgraph/VerletIntegration.js']], function(EulerIntegration, H, GraphLayout, QuadTree, U, VerletIntegration) {
        const {win} = H;
        const {clamp, defined, isFunction, fireEvent, pick} = U;
        class ReingoldFruchtermanLayout {
            constructor() {
                this.attractiveForce = void 0;
                this.box = {};
                this.currentStep = 0;
                this.initialRendering = !0;
                this.integration = void 0;
                this.links = [];
                this.nodes = [];
                this.options = void 0;
                this.quadTree = void 0;
                this.repulsiveForce = void 0;
                this.series = [];
                this.simulation = !1
            }
            static compose(ChartClass) {
                GraphLayout.compose(ChartClass);
                GraphLayout.integrations.euler = EulerIntegration;
                GraphLayout.integrations.verlet = VerletIntegration;
                GraphLayout.layouts['reingold-fruchterman'] = ReingoldFruchtermanLayout
            }
            init(options) {
                this.options = options;
                this.nodes = [];
                this.links = [];
                this.series = [];
                this.box = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
                this.setInitialRendering(!0);
                this.integration = GraphLayout.integrations[options.integration];
                this.enableSimulation = options.enableSimulation;
                this.attractiveForce = pick(options.attractiveForce, this.integration.attractiveForceFunction);
                this.repulsiveForce = pick(options.repulsiveForce, this.integration.repulsiveForceFunction);
                this.approximation = options.approximation
            }
            updateSimulation(enable) {
                this.enableSimulation = pick(enable, this.options.enableSimulation)
            }
            start() {
                const layout = this
                    , series = this.series
                    , options = this.options;
                layout.currentStep = 0;
                layout.forces = series[0] && series[0].forces || [];
                layout.chart = series[0] && series[0].chart;
                if (layout.initialRendering) {
                    layout.initPositions();
                    series.forEach(function(s) {
                        s.finishedAnimating = !0;
                        s.render()
                    })
                }
                layout.setK();
                layout.resetSimulation(options);
                if (layout.enableSimulation) {
                    layout.step()
                }
            }
            step() {
                const anyLayout = this
                    , allSeries = this.series;
                this.currentStep++;
                if (this.approximation === 'barnes-hut') {
                    this.createQuadTree();
                    this.quadTree.calculateMassAndCenter()
                }
                for (const forceName of this.forces || []) {
                    anyLayout[forceName + 'Forces'](this.temperature)
                }
                this.applyLimits();
                this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);
                this.prevSystemTemperature = this.systemTemperature;
                this.systemTemperature = this.getSystemTemperature();
                if (this.enableSimulation) {
                    for (const series of allSeries) {
                        if (series.chart) {
                            series.render()
                        }
                    }
                    if (this.maxIterations-- && isFinite(this.temperature) && !this.isStable()) {
                        if (this.simulation) {
                            win.cancelAnimationFrame(this.simulation)
                        }
                        this.simulation = win.requestAnimationFrame( () => this.step())
                    } else {
                        this.simulation = !1;
                        this.series.forEach( (s) => {
                                fireEvent(s, 'afterSimulation')
                            }
                        )
                    }
                }
            }
            stop() {
                if (this.simulation) {
                    win.cancelAnimationFrame(this.simulation)
                }
            }
            setArea(x, y, w, h) {
                this.box = {
                    left: x,
                    top: y,
                    width: w,
                    height: h
                }
            }
            setK() {
                this.k = this.options.linkLength || this.integration.getK(this)
            }
            addElementsToCollection(elements, collection) {
                for (const element of elements) {
                    if (collection.indexOf(element) === -1) {
                        collection.push(element)
                    }
                }
            }
            removeElementFromCollection(element, collection) {
                const index = collection.indexOf(element);
                if (index !== -1) {
                    collection.splice(index, 1)
                }
            }
            clear() {
                this.nodes.length = 0;
                this.links.length = 0;
                this.series.length = 0;
                this.resetSimulation()
            }
            resetSimulation() {
                this.forcedStop = !1;
                this.systemTemperature = 0;
                this.setMaxIterations();
                this.setTemperature();
                this.setDiffTemperature()
            }
            restartSimulation() {
                if (!this.simulation) {
                    this.setInitialRendering(!1);
                    if (!this.enableSimulation) {
                        this.setMaxIterations(1)
                    } else {
                        this.start()
                    }
                    if (this.chart) {
                        this.chart.redraw()
                    }
                    this.setInitialRendering(!0)
                } else {
                    this.resetSimulation()
                }
            }
            setMaxIterations(maxIterations) {
                this.maxIterations = pick(maxIterations, this.options.maxIterations)
            }
            setTemperature() {
                this.temperature = this.startTemperature = Math.sqrt(this.nodes.length)
            }
            setDiffTemperature() {
                this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1)
            }
            setInitialRendering(enable) {
                this.initialRendering = enable
            }
            createQuadTree() {
                this.quadTree = new QuadTree(this.box.left,this.box.top,this.box.width,this.box.height);
                this.quadTree.insertNodes(this.nodes)
            }
            initPositions() {
                const initialPositions = this.options.initialPositions;
                if (isFunction(initialPositions)) {
                    initialPositions.call(this);
                    for (const node of this.nodes) {
                        if (!defined(node.prevX)) {
                            node.prevX = node.plotX
                        }
                        if (!defined(node.prevY)) {
                            node.prevY = node.plotY
                        }
                        node.dispX = 0;
                        node.dispY = 0
                    }
                } else if (initialPositions === 'circle') {
                    this.setCircularPositions()
                } else {
                    this.setRandomPositions()
                }
            }
            setCircularPositions() {
                const box = this.box
                    , nodes = this.nodes
                    , nodesLength = nodes.length + 1
                    , angle = 2 * Math.PI / nodesLength
                    , rootNodes = nodes.filter(function(node) {
                        return node.linksTo.length === 0
                    })
                    , visitedNodes = {}
                    , radius = this.options.initialPositionRadius
                    , addToNodes = (node) => {
                        for (const link of node.linksFrom || []) {
                            if (!visitedNodes[link.toNode.id]) {
                                visitedNodes[link.toNode.id] = !0;
                                sortedNodes.push(link.toNode);
                                addToNodes(link.toNode)
                            }
                        }
                    }
                ;
                let sortedNodes = [];
                for (const rootNode of rootNodes) {
                    sortedNodes.push(rootNode);
                    addToNodes(rootNode)
                }
                if (!sortedNodes.length) {
                    sortedNodes = nodes
                } else {
                    for (const node of nodes) {
                        if (sortedNodes.indexOf(node) === -1) {
                            sortedNodes.push(node)
                        }
                    }
                }
                let node;
                for (let i = 0, iEnd = sortedNodes.length; i < iEnd; ++i) {
                    node = sortedNodes[i];
                    node.plotX = node.prevX = pick(node.plotX, box.width / 2 + radius * Math.cos(i * angle));
                    node.plotY = node.prevY = pick(node.plotY, box.height / 2 + radius * Math.sin(i * angle));
                    node.dispX = 0;
                    node.dispY = 0
                }
            }
            setRandomPositions() {
                const box = this.box
                    , nodes = this.nodes
                    , nodesLength = nodes.length + 1
                    , unrandom = (n) => {
                        let rand = n * n / Math.PI;
                        rand = rand - Math.floor(rand);
                        return rand
                    }
                ;
                let node;
                for (let i = 0, iEnd = nodes.length; i < iEnd; ++i) {
                    node = nodes[i];
                    node.plotX = node.prevX = pick(node.plotX, box.width * unrandom(i));
                    node.plotY = node.prevY = pick(node.plotY, box.height * unrandom(nodesLength + i));
                    node.dispX = 0;
                    node.dispY = 0
                }
            }
            force(name, ...args) {
                this.integration[name].apply(this, args)
            }
            barycenterForces() {
                this.getBarycenter();
                this.force('barycenter')
            }
            getBarycenter() {
                let systemMass = 0
                    , cx = 0
                    , cy = 0;
                for (const node of this.nodes) {
                    cx += node.plotX * node.mass;
                    cy += node.plotY * node.mass;
                    systemMass += node.mass
                }
                this.barycenter = {
                    x: cx,
                    y: cy,
                    xFactor: cx / systemMass,
                    yFactor: cy / systemMass
                };
                return this.barycenter
            }
            barnesHutApproximation(node, quadNode) {
                const distanceXY = this.getDistXY(node, quadNode)
                    , distanceR = this.vectorLength(distanceXY);
                let goDeeper, force;
                if (node !== quadNode && distanceR !== 0) {
                    if (quadNode.isInternal) {
                        if (quadNode.boxSize / distanceR < this.options.theta && distanceR !== 0) {
                            force = this.repulsiveForce(distanceR, this.k);
                            this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);
                            goDeeper = !1
                        } else {
                            goDeeper = !0
                        }
                    } else {
                        force = this.repulsiveForce(distanceR, this.k);
                        this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR)
                    }
                }
                return goDeeper
            }
            repulsiveForces() {
                if (this.approximation === 'barnes-hut') {
                    for (const node of this.nodes) {
                        this.quadTree.visitNodeRecursive(null, (quadNode) => (this.barnesHutApproximation(node, quadNode)))
                    }
                } else {
                    let force, distanceR, distanceXY;
                    for (const node of this.nodes) {
                        for (const repNode of this.nodes) {
                            if (node !== repNode && !node.fixedPosition) {
                                distanceXY = this.getDistXY(node, repNode);
                                distanceR = this.vectorLength(distanceXY);
                                if (distanceR !== 0) {
                                    force = this.repulsiveForce(distanceR, this.k);
                                    this.force('repulsive', node, force * repNode.mass, distanceXY, distanceR)
                                }
                            }
                        }
                    }
                }
            }
            attractiveForces() {
                let distanceXY, distanceR, force;
                for (const link of this.links) {
                    if (link.fromNode && link.toNode) {
                        distanceXY = this.getDistXY(link.fromNode, link.toNode);
                        distanceR = this.vectorLength(distanceXY);
                        if (distanceR !== 0) {
                            force = this.attractiveForce(distanceR, this.k);
                            this.force('attractive', link, force, distanceXY, distanceR)
                        }
                    }
                }
            }
            applyLimits() {
                const nodes = this.nodes;
                for (const node of nodes) {
                    if (node.fixedPosition) {
                        return
                    }
                    this.integration.integrate(this, node);
                    this.applyLimitBox(node, this.box);
                    node.dispX = 0;
                    node.dispY = 0
                }
            }
            applyLimitBox(node, box) {
                const radius = node.radius;
                node.plotX = clamp(node.plotX, box.left + radius, box.width - radius);
                node.plotY = clamp(node.plotY, box.top + radius, box.height - radius)
            }
            coolDown(temperature, temperatureStep, currentStep) {
                return temperature - temperatureStep * currentStep
            }
            isStable() {
                return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 0.00001 || this.temperature <= 0
            }
            getSystemTemperature() {
                let value = 0;
                for (const node of this.nodes) {
                    value += node.temperature
                }
                return value
            }
            vectorLength(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y)
            }
            getDistR(nodeA, nodeB) {
                const distance = this.getDistXY(nodeA, nodeB);
                return this.vectorLength(distance)
            }
            getDistXY(nodeA, nodeB) {
                const xDist = nodeA.plotX - nodeB.plotX
                    , yDist = nodeA.plotY - nodeB.plotY;
                return {
                    x: xDist,
                    y: yDist,
                    absX: Math.abs(xDist),
                    absY: Math.abs(yDist)
                }
            }
        }
        return ReingoldFruchtermanLayout
    });
    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleLayout.js', [_modules['Series/GraphLayoutComposition.js'], _modules['Series/PackedBubble/PackedBubbleIntegration.js'], _modules['Series/Networkgraph/ReingoldFruchtermanLayout.js'], _modules['Core/Utilities.js']], function(GraphLayout, PackedBubbleIntegration, ReingoldFruchtermanLayout, U) {
        const {addEvent, pick} = U;
        const composedMembers = [];
        function chartGetSelectedParentNodes() {
            const allSeries = this.series
                , selectedParentsNodes = [];
            allSeries.forEach( (series) => {
                    if (series.parentNode && series.parentNode.selected) {
                        selectedParentsNodes.push(series.parentNode)
                    }
                }
            );
            return selectedParentsNodes
        }
        function onChartBeforeRedraw() {
            if (this.allDataPoints) {
                delete this.allDataPoints
            }
        }
        class PackedBubbleLayout extends ReingoldFruchtermanLayout {
            constructor() {
                super(...arguments);
                this.index = NaN;
                this.nodes = [];
                this.options = void 0;
                this.series = []
            }
            static compose(ChartClass) {
                ReingoldFruchtermanLayout.compose(ChartClass);
                GraphLayout.integrations.packedbubble = PackedBubbleIntegration;
                GraphLayout.layouts.packedbubble = PackedBubbleLayout;
                if (U.pushUnique(composedMembers, ChartClass)) {
                    addEvent(ChartClass, 'beforeRedraw', onChartBeforeRedraw);
                    const chartProto = ChartClass.prototype;
                    chartProto.getSelectedParentNodes = chartGetSelectedParentNodes
                }
            }
            beforeStep() {
                if (this.options.marker) {
                    this.series.forEach( (series) => {
                            if (series) {
                                series.calculateParentRadius()
                            }
                        }
                    )
                }
            }
            isStable() {
                const tempDiff = Math.abs(this.prevSystemTemperature - this.systemTemperature);
                const upScaledTemperature = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
                return Math.abs(upScaledTemperature) < 1 && tempDiff < 0.00001 || this.temperature <= 0
            }
            setCircularPositions() {
                const layout = this
                    , box = layout.box
                    , nodes = layout.nodes
                    , nodesLength = nodes.length + 1
                    , angle = 2 * Math.PI / nodesLength
                    , radius = layout.options.initialPositionRadius;
                let centerX, centerY, index = 0;
                for (const node of nodes) {
                    if (layout.options.splitSeries && !node.isParentNode) {
                        centerX = node.series.parentNode.plotX;
                        centerY = node.series.parentNode.plotY
                    } else {
                        centerX = box.width / 2;
                        centerY = box.height / 2
                    }
                    node.plotX = node.prevX = pick(node.plotX, centerX + radius * Math.cos(node.index || index * angle));
                    node.plotY = node.prevY = pick(node.plotY, centerY + radius * Math.sin(node.index || index * angle));
                    node.dispX = 0;
                    node.dispY = 0;
                    index++
                }
            }
            repulsiveForces() {
                const layout = this
                    , bubblePadding = layout.options.bubblePadding;
                let force, distanceR, distanceXY;
                layout.nodes.forEach( (node) => {
                        node.degree = node.mass;
                        node.neighbours = 0;
                        layout.nodes.forEach( (repNode) => {
                                force = 0;
                                if (node !== repNode && !node.fixedPosition && (layout.options.seriesInteraction || node.series === repNode.series)) {
                                    distanceXY = layout.getDistXY(node, repNode);
                                    distanceR = (layout.vectorLength(distanceXY) - (node.marker.radius + repNode.marker.radius + bubblePadding));
                                    if (distanceR < 0) {
                                        node.degree += 0.01;
                                        node.neighbours++;
                                        force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode)
                                    }
                                    layout.force('repulsive', node, force * repNode.mass, distanceXY, repNode, distanceR)
                                }
                            }
                        )
                    }
                )
            }
            applyLimitBox(node, box) {
                const layout = this
                    , factor = 0.01;
                let distanceXY, distanceR;
                if (layout.options.splitSeries && !node.isParentNode && layout.options.parentNodeLimit) {
                    distanceXY = layout.getDistXY(node, node.series.parentNode);
                    distanceR = (node.series.parentNodeRadius - node.marker.radius - layout.vectorLength(distanceXY));
                    if (distanceR < 0 && distanceR > -2 * node.marker.radius) {
                        node.plotX -= distanceXY.x * factor;
                        node.plotY -= distanceXY.y * factor
                    }
                }
                super.applyLimitBox(node, box)
            }
        }
        GraphLayout.layouts.packedbubble = PackedBubbleLayout;
        return PackedBubbleLayout
    });
    _registerModule(_modules, 'Series/SimulationSeriesUtilities.js', [_modules['Core/Utilities.js'], _modules['Core/Animation/AnimationUtilities.js']], function(U, A) {
        const {syncTimeout} = U;
        const {animObject} = A;
        function initDataLabelsDefer() {
            const dlOptions = this.options.dataLabels;
            if (!dlOptions?.defer || !this.options.layoutAlgorithm?.enableSimulation) {
                this.deferDataLabels = !1
            } else {
                syncTimeout( () => {
                        this.deferDataLabels = !1
                    }
                    , dlOptions ? animObject(dlOptions.animation).defer : 0)
            }
        }
        function initDataLabels() {
            const series = this
                , dlOptions = series.options.dataLabels;
            if (!series.dataLabelsGroup) {
                const dataLabelsGroup = this.initDataLabelsGroup();
                if (!series.chart.styledMode && dlOptions?.style) {
                    dataLabelsGroup.css(dlOptions.style)
                }
                dataLabelsGroup.attr({
                    opacity: 0
                });
                if (series.visible) {
                    dataLabelsGroup.show()
                }
                return dataLabelsGroup
            }
            series.dataLabelsGroup.attr({
                opacity: 1
            });
            return series.dataLabelsGroup
        }
        const DataLabelsDeferUtils = {
            initDataLabels,
            initDataLabelsDefer
        };
        return DataLabelsDeferUtils
    });
    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleSeries.js', [_modules['Core/Color/Color.js'], _modules['Series/DragNodesComposition.js'], _modules['Series/GraphLayoutComposition.js'], _modules['Core/Globals.js'], _modules['Series/PackedBubble/PackedBubblePoint.js'], _modules['Series/PackedBubble/PackedBubbleSeriesDefaults.js'], _modules['Series/PackedBubble/PackedBubbleLayout.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/SimulationSeriesUtilities.js'], _modules['Core/Utilities.js'], _modules['Core/Animation/AnimationUtilities.js']], function(Color, DragNodesComposition, GraphLayout, H, PackedBubblePoint, PackedBubbleSeriesDefaults, PackedBubbleLayout, SeriesRegistry, D, U, A) {
        const {parse: color} = Color;
        const {noop} = H;
        const {series: {prototype: seriesProto}, seriesTypes: {bubble: BubbleSeries}} = SeriesRegistry;
        const {initDataLabels, initDataLabelsDefer} = D;
        const {addEvent, clamp, defined, extend, fireEvent, isArray, isNumber, merge, pick, syncTimeout} = U;
        const {animObject} = A;
        class PackedBubbleSeries extends BubbleSeries {
            constructor() {
                super(...arguments);
                this.chart = void 0;
                this.data = void 0;
                this.layout = void 0;
                this.options = void 0;
                this.parentNodeMass = 0;
                this.points = void 0;
                this.xData = void 0;
                this.deferDataLabels = !0
            }
            static compose(AxisClass, ChartClass, LegendClass, SeriesClass) {
                BubbleSeries.compose(AxisClass, ChartClass, LegendClass, SeriesClass);
                DragNodesComposition.compose(ChartClass);
                PackedBubbleLayout.compose(ChartClass)
            }
            accumulateAllPoints() {
                const chart = this.chart
                    , allDataPoints = [];
                let yData;
                for (const series of chart.series) {
                    if (series.is('packedbubble') && series.reserveSpace()) {
                        yData = series.yData || [];
                        for (let j = 0; j < yData.length; j++) {
                            allDataPoints.push([null, null, yData[j], series.index, j, {
                                id: j,
                                marker: {
                                    radius: 0
                                }
                            }])
                        }
                    }
                }
                return allDataPoints
            }
            addLayout() {
                const layoutOptions = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}
                    , layoutType = layoutOptions.type || 'packedbubble'
                    , chartOptions = this.chart.options.chart;
                let graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, layout;
                if (!graphLayoutsStorage) {
                    this.chart.graphLayoutsStorage = graphLayoutsStorage = {};
                    this.chart.graphLayoutsLookup = graphLayoutsLookup = []
                }
                layout = graphLayoutsStorage[layoutType];
                if (!layout) {
                    layoutOptions.enableSimulation = !defined(chartOptions.forExport) ? layoutOptions.enableSimulation : !chartOptions.forExport;
                    graphLayoutsStorage[layoutType] = layout = new GraphLayout.layouts[layoutType]();
                    layout.init(layoutOptions);
                    graphLayoutsLookup.splice(layout.index, 0, layout)
                }
                this.layout = layout;
                this.points.forEach( (node) => {
                        node.mass = 2;
                        node.degree = 1;
                        node.collisionNmb = 1
                    }
                );
                layout.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);
                layout.addElementsToCollection([this], layout.series);
                layout.addElementsToCollection(this.points, layout.nodes)
            }
            addSeriesLayout() {
                const layoutOptions = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}
                    , layoutType = (layoutOptions.type || 'packedbubble')
                    , graphLayoutsStorage = this.chart.graphLayoutsStorage
                    , graphLayoutsLookup = this.chart.graphLayoutsLookup
                    , parentNodeOptions = merge(layoutOptions, layoutOptions.parentNodeOptions, {
                    enableSimulation: this.layout.options.enableSimulation
                });
                let seriesLayout = graphLayoutsStorage[layoutType + '-series'];
                if (!seriesLayout) {
                    graphLayoutsStorage[layoutType + '-series'] = seriesLayout = new GraphLayout.layouts[layoutType]();
                    seriesLayout.init(parentNodeOptions);
                    graphLayoutsLookup.splice(seriesLayout.index, 0, seriesLayout)
                }
                this.parentNodeLayout = seriesLayout;
                this.createParentNodes()
            }
            calculateParentRadius() {
                const bBox = this.seriesBox()
                    , parentPadding = 20
                    , minParentRadius = 20;
                this.parentNodeRadius = clamp(Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ? Math.max(Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding);
                if (this.parentNode) {
                    this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius
                }
            }
            calculateZExtremes() {
                const chart = this.chart
                    , allSeries = chart.series;
                let zMin = this.options.zMin
                    , zMax = this.options.zMax
                    , valMin = Infinity
                    , valMax = -Infinity;
                if (zMin && zMax) {
                    return [zMin, zMax]
                }
                allSeries.forEach( (series) => {
                        series.yData.forEach( (y) => {
                                if (defined(y)) {
                                    if (y > valMax) {
                                        valMax = y
                                    }
                                    if (y < valMin) {
                                        valMin = y
                                    }
                                }
                            }
                        )
                    }
                );
                zMin = pick(zMin, valMin);
                zMax = pick(zMax, valMax);
                return [zMin, zMax]
            }
            checkOverlap(bubble1, bubble2) {
                const diffX = bubble1[0] - bubble2[0]
                    , diffY = bubble1[1] - bubble2[1]
                    , sumRad = bubble1[2] + bubble2[2];
                return (Math.sqrt(diffX * diffX + diffY * diffY) - Math.abs(sumRad)) < -0.001
            }
            createParentNodes() {
                const PackedBubblePoint = this.pointClass
                    , chart = this.chart
                    , parentNodeLayout = this.parentNodeLayout
                    , layoutOptions = this.layout.options;
                let nodeAdded, parentNode = this.parentNode, parentMarkerOptions = {
                    radius: this.parentNodeRadius,
                    lineColor: this.color,
                    fillColor: color(this.color).brighten(0.4).get()
                };
                if (layoutOptions.parentNodeOptions) {
                    parentMarkerOptions = merge(layoutOptions.parentNodeOptions.marker || {}, parentMarkerOptions)
                }
                this.parentNodeMass = 0;
                this.points.forEach( (p) => {
                        this.parentNodeMass += Math.PI * Math.pow(p.marker.radius, 2)
                    }
                );
                this.calculateParentRadius();
                parentNodeLayout.nodes.forEach( (node) => {
                        if (node.seriesIndex === this.index) {
                            nodeAdded = !0
                        }
                    }
                );
                parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);
                if (!nodeAdded) {
                    if (!parentNode) {
                        parentNode = (new PackedBubblePoint()).init(this, {
                            mass: this.parentNodeRadius / 2,
                            marker: parentMarkerOptions,
                            dataLabels: {
                                inside: !1
                            },
                            states: {
                                normal: {
                                    marker: parentMarkerOptions
                                },
                                hover: {
                                    marker: parentMarkerOptions
                                }
                            },
                            dataLabelOnNull: !0,
                            degree: this.parentNodeRadius,
                            isParentNode: !0,
                            seriesIndex: this.index
                        })
                    }
                    if (this.parentNode) {
                        parentNode.plotX = this.parentNode.plotX;
                        parentNode.plotY = this.parentNode.plotY
                    }
                    this.parentNode = parentNode;
                    parentNodeLayout.addElementsToCollection([this], parentNodeLayout.series);
                    parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes)
                }
            }
            deferLayout() {
                const layoutOptions = this.options.layoutAlgorithm;
                if (!this.visible) {
                    return
                }
                this.addLayout();
                if (layoutOptions.splitSeries) {
                    this.addSeriesLayout()
                }
            }
            destroy() {
                if (this.chart.graphLayoutsLookup) {
                    this.chart.graphLayoutsLookup.forEach( (layout) => {
                            layout.removeElementFromCollection(this, layout.series)
                        }
                        , this)
                }
                if (this.parentNode && this.parentNodeLayout) {
                    this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);
                    if (this.parentNode.dataLabel) {
                        this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()
                    }
                }
                seriesProto.destroy.apply(this, arguments)
            }
            drawDataLabels() {
                if (this.deferDataLabels) {
                    return
                }
                seriesProto.drawDataLabels.call(this, this.points);
                if (this.parentNode) {
                    this.parentNode.formatPrefix = 'parentNode';
                    seriesProto.drawDataLabels.call(this, [this.parentNode])
                }
            }
            drawGraph() {
                if (!this.layout || !this.layout.options.splitSeries) {
                    return
                }
                const chart = this.chart
                    , nodeMarker = this.layout.options.parentNodeOptions.marker
                    , parentOptions = {
                    fill: (nodeMarker.fillColor || color(this.color).brighten(0.4).get()),
                    opacity: nodeMarker.fillOpacity,
                    stroke: nodeMarker.lineColor || this.color,
                    'stroke-width': pick(nodeMarker.lineWidth, this.options.lineWidth)
                };
                let parentAttribs = {};
                this.parentNodesGroup = this.plotGroup('parentNodesGroup', 'parentNode', this.visible ? 'inherit' : 'hidden', 0.1, chart.seriesGroup);
                this.group?.attr({
                    zIndex: 2
                });
                this.calculateParentRadius();
                if (this.parentNode && defined(this.parentNode.plotX) && defined(this.parentNode.plotY) && defined(this.parentNodeRadius)) {
                    parentAttribs = merge({
                        x: this.parentNode.plotX - this.parentNodeRadius,
                        y: this.parentNode.plotY - this.parentNodeRadius,
                        width: this.parentNodeRadius * 2,
                        height: this.parentNodeRadius * 2
                    }, parentOptions);
                    if (!this.parentNode.graphic) {
                        this.graph = this.parentNode.graphic = chart.renderer.symbol(parentOptions.symbol).add(this.parentNodesGroup)
                    }
                    this.parentNode.graphic.attr(parentAttribs)
                }
            }
            drawTracker() {
                const parentNode = this.parentNode;
                let dataLabels;
                super.drawTracker();
                if (parentNode) {
                    dataLabels = (isArray(parentNode.dataLabels) ? parentNode.dataLabels : (parentNode.dataLabel ? [parentNode.dataLabel] : []));
                    if (parentNode.graphic) {
                        parentNode.graphic.element.point = parentNode
                    }
                    dataLabels.forEach( (dataLabel) => {
                            if (dataLabel.div) {
                                dataLabel.div.point = parentNode
                            } else {
                                dataLabel.element.point = parentNode
                            }
                        }
                    )
                }
            }
            getPointRadius() {
                const chart = this.chart
                    , plotWidth = chart.plotWidth
                    , plotHeight = chart.plotHeight
                    , seriesOptions = this.options
                    , useSimulation = seriesOptions.useSimulation
                    , smallestSize = Math.min(plotWidth, plotHeight)
                    , extremes = {}
                    , radii = []
                    , allDataPoints = chart.allDataPoints || []
                    , allDataPointsLength = allDataPoints.length;
                let minSize, maxSize, value, radius;
                ['minSize', 'maxSize'].forEach( (prop) => {
                        const length = parseInt(seriesOptions[prop], 10)
                            , isPercent = /%$/.test(seriesOptions[prop]);
                        extremes[prop] = isPercent ? smallestSize * length / 100 : length * Math.sqrt(allDataPointsLength)
                    }
                );
                chart.minRadius = minSize = extremes.minSize / Math.sqrt(allDataPointsLength);
                chart.maxRadius = maxSize = extremes.maxSize / Math.sqrt(allDataPointsLength);
                const zExtremes = useSimulation ? this.calculateZExtremes() : [minSize, maxSize];
                allDataPoints.forEach( (point, i) => {
                        value = useSimulation ? clamp(point[2], zExtremes[0], zExtremes[1]) : point[2];
                        radius = this.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);
                        if (radius === 0) {
                            radius = null
                        }
                        allDataPoints[i][2] = radius;
                        radii.push(radius)
                    }
                );
                this.radii = radii
            }
            init() {
                seriesProto.init.apply(this, arguments);
                initDataLabelsDefer.call(this);
                this.eventsToUnbind.push(addEvent(this, 'updatedData', function() {
                    this.chart.series.forEach( (s) => {
                            if (s.type === this.type) {
                                s.isDirty = !0
                            }
                        }
                        , this)
                }));
                return this
            }
            onMouseUp(dnPoint) {
                const point = dnPoint;
                if (point.fixedPosition && !point.removed) {
                    const layout = this.layout
                        , parentNodeLayout = this.parentNodeLayout;
                    let distanceXY, distanceR;
                    if (parentNodeLayout && layout.options.dragBetweenSeries) {
                        parentNodeLayout.nodes.forEach( (node) => {
                                if (point && point.marker && node !== point.series.parentNode) {
                                    distanceXY = layout.getDistXY(point, node);
                                    distanceR = (layout.vectorLength(distanceXY) - node.marker.radius - point.marker.radius);
                                    if (distanceR < 0) {
                                        node.series.addPoint(merge(point.options, {
                                            plotX: point.plotX,
                                            plotY: point.plotY
                                        }), !1);
                                        layout.removeElementFromCollection(point, layout.nodes);
                                        point.remove()
                                    }
                                }
                            }
                        )
                    }
                    DragNodesComposition.onMouseUp.apply(this, arguments)
                }
            }
            placeBubbles(allDataPoints) {
                const checkOverlap = this.checkOverlap
                    , positionBubble = this.positionBubble
                    , bubblePos = [];
                let stage = 1, j = 0, k = 0, calculatedBubble, arr = [], i;
                const sortedArr = allDataPoints.sort( (a, b) => b[2] - a[2]);
                if (sortedArr.length) {
                    bubblePos.push([[0, 0, sortedArr[0][2], sortedArr[0][3], sortedArr[0][4]]]);
                    if (sortedArr.length > 1) {
                        bubblePos.push([[0, (0 - sortedArr[1][2] - sortedArr[0][2]), sortedArr[1][2], sortedArr[1][3], sortedArr[1][4]]]);
                        for (i = 2; i < sortedArr.length; i++) {
                            sortedArr[i][2] = sortedArr[i][2] || 1;
                            calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]);
                            if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {
                                bubblePos.push([]);
                                k = 0;
                                bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));
                                stage++;
                                j = 0
                            } else if (stage > 1 && bubblePos[stage - 1][k + 1] && checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {
                                k++;
                                bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));
                                j++
                            } else {
                                j++;
                                bubblePos[stage].push(calculatedBubble)
                            }
                        }
                    }
                    this.chart.stages = bubblePos;
                    this.chart.rawPositions = [].concat.apply([], bubblePos);
                    this.resizeRadius();
                    arr = this.chart.rawPositions
                }
                return arr
            }
            pointAttribs(point, state) {
                const options = this.options
                    , hasParentMarker = point && point.isParentNode;
                let markerOptions = options.marker;
                if (hasParentMarker && options.layoutAlgorithm && options.layoutAlgorithm.parentNodeOptions) {
                    markerOptions = options.layoutAlgorithm.parentNodeOptions.marker
                }
                const fillOpacity = markerOptions.fillOpacity
                    , attr = seriesProto.pointAttribs.call(this, point, state);
                if (fillOpacity !== 1) {
                    attr['fill-opacity'] = fillOpacity
                }
                return attr
            }
            positionBubble(lastBubble, newOrigin, nextBubble) {
                const sqrt = Math.sqrt
                    , asin = Math.asin
                    , acos = Math.acos
                    , pow = Math.pow
                    , abs = Math.abs
                    , distance = sqrt(pow((lastBubble[0] - newOrigin[0]), 2) + pow((lastBubble[1] - newOrigin[1]), 2))
                    , alfa = acos((pow(distance, 2) + pow(nextBubble[2] + newOrigin[2], 2) - pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance))
                    , beta = asin(abs(lastBubble[0] - newOrigin[0]) / distance)
                    , gamma = (lastBubble[1] - newOrigin[1]) < 0 ? 0 : Math.PI
                    , delta = (lastBubble[0] - newOrigin[0]) * (lastBubble[1] - newOrigin[1]) < 0 ? 1 : -1
                    , finalAngle = gamma + alfa + beta * delta
                    , cosA = Math.cos(finalAngle)
                    , sinA = Math.sin(finalAngle)
                    , posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA
                    , posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;
                return [posX, posY, nextBubble[2], nextBubble[3], nextBubble[4]]
            }
            render() {
                const dataLabels = [];
                seriesProto.render.apply(this, arguments);
                if (!this.options.dataLabels.allowOverlap) {
                    this.data.forEach( (point) => {
                            if (isArray(point.dataLabels)) {
                                point.dataLabels.forEach( (dataLabel) => {
                                        dataLabels.push(dataLabel)
                                    }
                                )
                            }
                        }
                    );
                    if (this.options.useSimulation) {
                        this.chart.hideOverlappingLabels(dataLabels)
                    }
                }
            }
            resizeRadius() {
                const chart = this.chart
                    , positions = chart.rawPositions
                    , min = Math.min
                    , max = Math.max
                    , plotLeft = chart.plotLeft
                    , plotTop = chart.plotTop
                    , chartHeight = chart.plotHeight
                    , chartWidth = chart.plotWidth;
                let minX, maxX, minY, maxY, radius;
                minX = minY = Number.POSITIVE_INFINITY;
                maxX = maxY = Number.NEGATIVE_INFINITY;
                for (const position of positions) {
                    radius = position[2];
                    minX = min(minX, position[0] - radius);
                    maxX = max(maxX, position[0] + radius);
                    minY = min(minY, position[1] - radius);
                    maxY = max(maxY, position[1] + radius)
                }
                const bBox = [maxX - minX, maxY - minY]
                    , spaceRatio = [(chartWidth - plotLeft) / bBox[0], (chartHeight - plotTop) / bBox[1]]
                    , smallerDimension = min.apply([], spaceRatio);
                if (Math.abs(smallerDimension - 1) > 1e-10) {
                    for (const position of positions) {
                        position[2] *= smallerDimension
                    }
                    this.placeBubbles(positions)
                } else {
                    chart.diffY = chartHeight / 2 + plotTop - minY - (maxY - minY) / 2;
                    chart.diffX = chartWidth / 2 + plotLeft - minX - (maxX - minX) / 2
                }
            }
            seriesBox() {
                const chart = this.chart
                    , data = this.data
                    , max = Math.max
                    , min = Math.min
                    , bBox = [chart.plotLeft, chart.plotLeft + chart.plotWidth, chart.plotTop, chart.plotTop + chart.plotHeight];
                let radius;
                data.forEach( (p) => {
                        if (defined(p.plotX) && defined(p.plotY) && p.marker.radius) {
                            radius = p.marker.radius;
                            bBox[0] = min(bBox[0], p.plotX - radius);
                            bBox[1] = max(bBox[1], p.plotX + radius);
                            bBox[2] = min(bBox[2], p.plotY - radius);
                            bBox[3] = max(bBox[3], p.plotY + radius)
                        }
                    }
                );
                return isNumber(bBox.width / bBox.height) ? bBox : null
            }
            setVisible() {
                const series = this;
                seriesProto.setVisible.apply(series, arguments);
                if (series.parentNodeLayout && series.graph) {
                    if (series.visible) {
                        series.graph.show();
                        if (series.parentNode.dataLabel) {
                            series.parentNode.dataLabel.show()
                        }
                    } else {
                        series.graph.hide();
                        series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);
                        if (series.parentNode.dataLabel) {
                            series.parentNode.dataLabel.hide()
                        }
                    }
                } else if (series.layout) {
                    if (series.visible) {
                        series.layout.addElementsToCollection(series.points, series.layout.nodes)
                    } else {
                        series.points.forEach( (node) => {
                                series.layout.removeElementFromCollection(node, series.layout.nodes)
                            }
                        )
                    }
                }
            }
            translate() {
                const chart = this.chart
                    , data = this.data
                    , index = this.index
                    , useSimulation = this.options.useSimulation;
                let point, radius, positions;
                this.processedXData = this.xData;
                this.generatePoints();
                if (!defined(chart.allDataPoints)) {
                    chart.allDataPoints = this.accumulateAllPoints();
                    this.getPointRadius()
                }
                if (useSimulation) {
                    positions = chart.allDataPoints
                } else {
                    positions = this.placeBubbles(chart.allDataPoints);
                    this.options.draggable = !1
                }
                for (const position of positions) {
                    if (position[3] === index) {
                        point = data[position[4]];
                        radius = pick(position[2], void 0);
                        if (!useSimulation) {
                            point.plotX = (position[0] - chart.plotLeft + chart.diffX);
                            point.plotY = (position[1] - chart.plotTop + chart.diffY)
                        }
                        if (isNumber(radius)) {
                            point.marker = extend(point.marker, {
                                radius,
                                width: 2 * radius,
                                height: 2 * radius
                            });
                            point.radius = radius
                        }
                    }
                }
                if (useSimulation) {
                    this.deferLayout()
                }
                fireEvent(this, 'afterTranslate')
            }
        }
        PackedBubbleSeries.defaultOptions = merge(BubbleSeries.defaultOptions, PackedBubbleSeriesDefaults);
        extend(PackedBubbleSeries.prototype, {
            pointClass: PackedBubblePoint,
            axisTypes: [],
            directTouch: !0,
            forces: ['barycenter', 'repulsive'],
            hasDraggableNodes: !0,
            isCartesian: !1,
            noSharedTooltip: !0,
            pointArrayMap: ['value'],
            pointValKey: 'value',
            requireSorting: !1,
            trackerGroups: ['group', 'dataLabelsGroup', 'parentNodesGroup'],
            initDataLabels: initDataLabels,
            alignDataLabel: seriesProto.alignDataLabel,
            indexateNodes: noop,
            onMouseDown: DragNodesComposition.onMouseDown,
            onMouseMove: DragNodesComposition.onMouseMove,
            redrawHalo: DragNodesComposition.redrawHalo,
            searchPoint: noop
        });
        SeriesRegistry.registerSeriesType('packedbubble', PackedBubbleSeries);
        '';
        return PackedBubbleSeries
    });
    _registerModule(_modules, 'Series/Polygon/PolygonSeriesDefaults.js', [], function() {
        const PolygonSeriesDefaults = {
            marker: {
                enabled: !1,
                states: {
                    hover: {
                        enabled: !1
                    }
                }
            },
            stickyTracking: !1,
            tooltip: {
                followPointer: !0,
                pointFormat: ''
            },
            trackByArea: !0,
            legendSymbol: 'rectangle'
        };
        '';
        return PolygonSeriesDefaults
    });
    _registerModule(_modules, 'Series/Polygon/PolygonSeries.js', [_modules['Core/Globals.js'], _modules['Series/Polygon/PolygonSeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(H, PolygonSeriesDefaults, SeriesRegistry, U) {
        const {noop} = H;
        const {area: AreaSeries, line: LineSeries, scatter: ScatterSeries} = SeriesRegistry.seriesTypes;
        const {extend, merge} = U;
        class PolygonSeries extends ScatterSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0
            }
            getGraphPath() {
                const graphPath = LineSeries.prototype.getGraphPath.call(this);
                let i = graphPath.length + 1;
                while (i--) {
                    if ((i === graphPath.length || graphPath[i][0] === 'M') && i > 0) {
                        graphPath.splice(i, 0, ['Z'])
                    }
                }
                this.areaPath = graphPath;
                return graphPath
            }
            drawGraph() {
                this.options.fillColor = this.color;
                AreaSeries.prototype.drawGraph.call(this)
            }
        }
        PolygonSeries.defaultOptions = merge(ScatterSeries.defaultOptions, PolygonSeriesDefaults);
        extend(PolygonSeries.prototype, {
            type: 'polygon',
            drawTracker: LineSeries.prototype.drawTracker,
            setStackedPoints: noop
        });
        SeriesRegistry.registerSeriesType('polygon', PolygonSeries);
        return PolygonSeries
    });
    _registerModule(_modules, 'Core/Axis/RadialAxis.js', [_modules['Core/Axis/AxisDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(AxisDefaults, D, H, U) {
        const {defaultOptions} = D;
        const {noop} = H;
        const {addEvent, correctFloat, defined, extend, fireEvent, merge, pick, relativeLength, wrap} = U;
        var RadialAxis;
        (function(RadialAxis) {
                const composedMembers = [];
                const defaultCircularOptions = {
                    gridLineWidth: 1,
                    labels: {
                        align: void 0,
                        x: 0,
                        y: void 0,
                        style: {
                            textOverflow: 'none'
                        }
                    },
                    maxPadding: 0,
                    minPadding: 0,
                    showLastLabel: !1,
                    tickLength: 0
                };
                const defaultRadialGaugeOptions = {
                    labels: {
                        align: 'center',
                        distance: -25,
                        x: 0,
                        y: void 0
                    },
                    minorGridLineWidth: 0,
                    minorTickInterval: 'auto',
                    minorTickLength: 10,
                    minorTickPosition: 'inside',
                    minorTickWidth: 1,
                    tickLength: 10,
                    tickPosition: 'inside',
                    tickWidth: 2,
                    title: {
                        rotation: 0
                    },
                    zIndex: 2
                };
                const defaultRadialOptions = {
                    gridLineInterpolation: 'circle',
                    gridLineWidth: 1,
                    labels: {
                        align: 'right',
                        x: -3,
                        y: -2
                    },
                    showLastLabel: !1,
                    title: {
                        x: 4,
                        text: null,
                        rotation: 90
                    }
                };
                function beforeSetTickPositions() {
                    this.autoConnect = (this.isCircular && typeof pick(this.userMax, this.options.max) === 'undefined' && correctFloat(this.endAngleRad - this.startAngleRad) === correctFloat(2 * Math.PI));
                    if (!this.isCircular && this.chart.inverted) {
                        this.max++
                    }
                    if (this.autoConnect) {
                        this.max += ((this.categories && 1) || this.pointRange || this.closestPointRange || 0)
                    }
                }
                function compose(AxisClass, TickClass) {
                    if (U.pushUnique(composedMembers, AxisClass)) {
                        addEvent(AxisClass, 'afterInit', onAxisAfterInit);
                        addEvent(AxisClass, 'autoLabelAlign', onAxisAutoLabelAlign);
                        addEvent(AxisClass, 'destroy', onAxisDestroy);
                        addEvent(AxisClass, 'init', onAxisInit);
                        addEvent(AxisClass, 'initialAxisTranslation', onAxisInitialAxisTranslation)
                    }
                    if (U.pushUnique(composedMembers, TickClass)) {
                        addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);
                        addEvent(TickClass, 'afterGetPosition', onTickAfterGetPosition);
                        wrap(TickClass.prototype, 'getMarkPath', wrapTickGetMarkPath)
                    }
                    return AxisClass
                }
                RadialAxis.compose = compose;
                function createLabelCollector() {
                    return () => {
                        if (this.isRadial && this.tickPositions && this.options.labels && this.options.labels.allowOverlap !== !0) {
                            return this.tickPositions.map( (pos) => this.ticks[pos] && this.ticks[pos].label).filter( (label) => Boolean(label))
                        }
                    }
                }
                function createLabelCollectorHidden() {
                    return noop
                }
                function getCrosshairPosition(options, x1, y1) {
                    const center = this.pane.center;
                    let value = options.value, shapeArgs, end, x2, y2;
                    if (this.isCircular) {
                        if (!defined(value)) {
                            x2 = options.chartX || 0;
                            y2 = options.chartY || 0;
                            value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, !0)
                        } else if (options.point) {
                            shapeArgs = options.point.shapeArgs || {};
                            if (shapeArgs.start) {
                                value = this.chart.inverted ? this.translate(options.point.rectPlotY, !0) : options.point.x
                            }
                        }
                        end = this.getPosition(value);
                        x2 = end.x;
                        y2 = end.y
                    } else {
                        if (!defined(value)) {
                            x2 = options.chartX;
                            y2 = options.chartY
                        }
                        if (defined(x2) && defined(y2)) {
                            y1 = center[1] + this.chart.plotTop;
                            value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, !0)
                        }
                    }
                    return [value, x2 || 0, y2 || 0]
                }
                function getLinePath(_lineWidth, radius, innerRadius) {
                    const center = this.pane.center
                        , chart = this.chart
                        , left = this.left || 0
                        , top = this.top || 0;
                    let end, r = pick(radius, center[2] / 2 - this.offset), path;
                    if (typeof innerRadius === 'undefined') {
                        innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2
                    }
                    if (innerRadius) {
                        r += innerRadius
                    }
                    if (this.isCircular || typeof radius !== 'undefined') {
                        path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {
                            start: this.startAngleRad,
                            end: this.endAngleRad,
                            open: !0,
                            innerR: 0
                        });
                        path.xBounds = [left + center[0]];
                        path.yBounds = [top + center[1] - r]
                    } else {
                        end = this.postTranslate(this.angleRad, r);
                        path = [['M', this.center[0] + chart.plotLeft, this.center[1] + chart.plotTop], ['L', end.x, end.y]]
                    }
                    return path
                }
                function getOffset() {
                    const axisProto = this.constructor.prototype;
                    axisProto.getOffset.call(this);
                    this.chart.axisOffset[this.side] = 0
                }
                function getPlotBandPath(from, to, options) {
                    const chart = this.chart
                        , radiusToPixels = (radius) => {
                        if (typeof radius === 'string') {
                            let r = parseInt(radius, 10);
                            if (percentRegex.test(radius)) {
                                r = (r * fullRadius) / 100
                            }
                            return r
                        }
                        return radius
                    }
                        , center = this.center
                        , startAngleRad = this.startAngleRad
                        , fullRadius = center[2] / 2
                        , offset = Math.min(this.offset, 0)
                        , left = this.left || 0
                        , top = this.top || 0
                        , percentRegex = /%$/
                        , isCircular = this.isCircular;
                    let start, end, angle, xOnPerimeter, open, path, outerRadius = pick(radiusToPixels(options.outerRadius), fullRadius), innerRadius = radiusToPixels(options.innerRadius), thickness = pick(radiusToPixels(options.thickness), 10);
                    if (this.options.gridLineInterpolation === 'polygon') {
                        path = this.getPlotLinePath({
                            value: from
                        }).concat(this.getPlotLinePath({
                            value: to,
                            reverse: !0
                        }))
                    } else {
                        from = Math.max(from, this.min);
                        to = Math.min(to, this.max);
                        const transFrom = this.translate(from)
                            , transTo = this.translate(to);
                        if (!isCircular) {
                            outerRadius = transFrom || 0;
                            innerRadius = transTo || 0
                        }
                        if (options.shape === 'circle' || !isCircular) {
                            start = -Math.PI / 2;
                            end = Math.PI * 1.5;
                            open = !0
                        } else {
                            start = startAngleRad + (transFrom || 0);
                            end = startAngleRad + (transTo || 0)
                        }
                        outerRadius -= offset;
                        thickness -= offset;
                        path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {
                            start: Math.min(start, end),
                            end: Math.max(start, end),
                            innerR: pick(innerRadius, outerRadius - thickness),
                            open
                        });
                        if (isCircular) {
                            angle = (end + start) / 2;
                            xOnPerimeter = (left + center[0] + (center[2] / 2) * Math.cos(angle));
                            path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ? [xOnPerimeter, chart.plotWidth] : [0, xOnPerimeter];
                            path.yBounds = [top + center[1] + (center[2] / 2) * Math.sin(angle)];
                            path.yBounds[0] += ((angle > -Math.PI && angle < 0) || (angle > Math.PI)) ? -10 : 10
                        }
                    }
                    return path
                }
                function getPlotLinePath(options) {
                    const center = this.pane.center
                        , chart = this.chart
                        , inverted = chart.inverted
                        , reverse = options.reverse
                        , background = this.pane.options.background ? (this.pane.options.background[0] || this.pane.options.background) : {}
                        , innerRadius = background.innerRadius || '0%'
                        , outerRadius = background.outerRadius || '100%'
                        , x1 = center[0] + chart.plotLeft
                        , y1 = center[1] + chart.plotTop
                        , height = this.height
                        , isCrosshair = options.isCrosshair
                        , paneInnerR = center[3] / 2;
                    let value = options.value, innerRatio, distance, a, b, otherAxis, xy, tickPositions, crossPos, path;
                    const end = this.getPosition(value);
                    let x2 = end.x
                        , y2 = end.y;
                    if (isCrosshair) {
                        crossPos = this.getCrosshairPosition(options, x1, y1);
                        value = crossPos[0];
                        x2 = crossPos[1];
                        y2 = crossPos[2]
                    }
                    if (this.isCircular) {
                        distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        a = (typeof innerRadius === 'string') ? relativeLength(innerRadius, 1) : (innerRadius / distance);
                        b = (typeof outerRadius === 'string') ? relativeLength(outerRadius, 1) : (outerRadius / distance);
                        if (center && paneInnerR) {
                            innerRatio = paneInnerR / distance;
                            if (a < innerRatio) {
                                a = innerRatio
                            }
                            if (b < innerRatio) {
                                b = innerRatio
                            }
                        }
                        path = [['M', x1 + a * (x2 - x1), y1 - a * (y1 - y2)], ['L', x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]]
                    } else {
                        value = this.translate(value);
                        if (value) {
                            if (value < 0 || value > height) {
                                value = 0
                            }
                        }
                        if (this.options.gridLineInterpolation === 'circle') {
                            path = this.getLinePath(0, value, paneInnerR)
                        } else {
                            path = [];
                            chart[inverted ? 'yAxis' : 'xAxis'].forEach( (a) => {
                                    if (a.pane === this.pane) {
                                        otherAxis = a
                                    }
                                }
                            );
                            if (otherAxis) {
                                tickPositions = otherAxis.tickPositions;
                                if (otherAxis.autoConnect) {
                                    tickPositions = tickPositions.concat([tickPositions[0]])
                                }
                                if (reverse) {
                                    tickPositions = tickPositions.slice().reverse()
                                }
                                if (value) {
                                    value += paneInnerR
                                }
                                for (let i = 0; i < tickPositions.length; i++) {
                                    xy = otherAxis.getPosition(tickPositions[i], value);
                                    path.push(i ? ['L', xy.x, xy.y] : ['M', xy.x, xy.y])
                                }
                            }
                        }
                    }
                    return path
                }
                function getPosition(value, length) {
                    const translatedVal = this.translate(value);
                    return this.postTranslate(this.isCircular ? translatedVal : this.angleRad, pick(this.isCircular ? length : (translatedVal < 0 ? 0 : translatedVal), this.center[2] / 2) - this.offset)
                }
                function getTitlePosition() {
                    const center = this.center
                        , chart = this.chart
                        , titleOptions = this.options.title;
                    return {
                        x: chart.plotLeft + center[0] + (titleOptions.x || 0),
                        y: (chart.plotTop + center[1] - ({
                            high: 0.5,
                            middle: 0.25,
                            low: 0
                        }[titleOptions.align] * center[2]) + (titleOptions.y || 0))
                    }
                }
                function modify(axis) {
                    axis.beforeSetTickPositions = beforeSetTickPositions;
                    axis.createLabelCollector = createLabelCollector;
                    axis.getCrosshairPosition = getCrosshairPosition;
                    axis.getLinePath = getLinePath;
                    axis.getOffset = getOffset;
                    axis.getPlotBandPath = getPlotBandPath;
                    axis.getPlotLinePath = getPlotLinePath;
                    axis.getPosition = getPosition;
                    axis.getTitlePosition = getTitlePosition;
                    axis.postTranslate = postTranslate;
                    axis.setAxisSize = setAxisSize;
                    axis.setAxisTranslation = setAxisTranslation;
                    axis.setOptions = setOptions
                }
                function modifyAsHidden(radialAxis) {
                    radialAxis.isHidden = !0;
                    radialAxis.createLabelCollector = createLabelCollectorHidden;
                    radialAxis.getOffset = noop;
                    radialAxis.redraw = renderHidden;
                    radialAxis.render = renderHidden;
                    radialAxis.setScale = noop;
                    radialAxis.setCategories = noop;
                    radialAxis.setTitle = noop
                }
                function onAxisAfterInit() {
                    const chart = this.chart
                        , options = this.options
                        , isHidden = chart.angular && this.isXAxis
                        , pane = this.pane
                        , paneOptions = pane && pane.options;
                    if (!isHidden && pane && (chart.angular || chart.polar)) {
                        const fullCircle = Math.PI * 2
                            , start = (pick(paneOptions.startAngle, 0) - 90) * Math.PI / 180
                            , end = (pick(paneOptions.endAngle, pick(paneOptions.startAngle, 0) + 360) - 90) * Math.PI / 180;
                        this.angleRad = (options.angle || 0) * Math.PI / 180;
                        this.startAngleRad = start;
                        this.endAngleRad = end;
                        this.offset = options.offset || 0;
                        let normalizedStart = (start % fullCircle + fullCircle) % fullCircle
                            , normalizedEnd = (end % fullCircle + fullCircle) % fullCircle;
                        if (normalizedStart > Math.PI) {
                            normalizedStart -= fullCircle
                        }
                        if (normalizedEnd > Math.PI) {
                            normalizedEnd -= fullCircle
                        }
                        this.normalizedStartAngleRad = normalizedStart;
                        this.normalizedEndAngleRad = normalizedEnd
                    }
                }
                function onAxisAutoLabelAlign(e) {
                    if (this.isRadial) {
                        e.align = void 0;
                        e.preventDefault()
                    }
                }
                function onAxisDestroy() {
                    if (this.chart && this.chart.labelCollectors) {
                        const index = (this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1);
                        if (index >= 0) {
                            this.chart.labelCollectors.splice(index, 1)
                        }
                    }
                }
                function onAxisInit(e) {
                    const chart = this.chart
                        , inverted = chart.inverted
                        , angular = chart.angular
                        , polar = chart.polar
                        , isX = this.isXAxis
                        , coll = this.coll
                        , isHidden = angular && isX
                        , paneIndex = e.userOptions.pane || 0
                        , pane = this.pane = chart.pane && chart.pane[paneIndex];
                    let isCircular;
                    if (coll === 'colorAxis') {
                        this.isRadial = !1;
                        return
                    }
                    if (angular) {
                        if (isHidden) {
                            modifyAsHidden(this)
                        } else {
                            modify(this)
                        }
                        isCircular = !isX;
                        if (isCircular) {
                            this.defaultPolarOptions = defaultRadialGaugeOptions
                        }
                    } else if (polar) {
                        modify(this);
                        isCircular = this.horiz;
                        this.defaultPolarOptions = isCircular ? defaultCircularOptions : merge(coll === 'xAxis' ? AxisDefaults.defaultXAxisOptions : AxisDefaults.defaultYAxisOptions, defaultRadialOptions);
                        if (inverted && coll === 'yAxis') {
                            this.defaultPolarOptions.stackLabels = AxisDefaults.defaultYAxisOptions.stackLabels;
                            this.defaultPolarOptions.reversedStacks = !0
                        }
                    }
                    if (angular || polar) {
                        this.isRadial = !0;
                        if (!this.labelCollector) {
                            this.labelCollector = this.createLabelCollector()
                        }
                        if (this.labelCollector) {
                            chart.labelCollectors.push(this.labelCollector)
                        }
                    } else {
                        this.isRadial = !1
                    }
                    if (pane && isCircular) {
                        pane.axis = this
                    }
                    this.isCircular = isCircular
                }
                function onAxisInitialAxisTranslation() {
                    if (this.isRadial) {
                        this.beforeSetTickPositions()
                    }
                }
                function onTickAfterGetLabelPosition(e) {
                    const label = this.label;
                    if (!label) {
                        return
                    }
                    const axis = this.axis
                        , labelBBox = label.getBBox()
                        , labelOptions = axis.options.labels
                        , angle = ((axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180) % 360
                        , correctAngle = Math.round(angle)
                        , labelYPosCorrection = !defined(labelOptions.y) ? -labelBBox.height * 0.3 : 0;
                    let optionsY = labelOptions.y, ret, centerSlot = 20, align = labelOptions.align, labelDir = 'end', reducedAngle1 = correctAngle < 0 ? correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;
                    if (axis.isRadial) {
                        ret = axis.getPosition(this.pos, (axis.center[2] / 2) + relativeLength(pick(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));
                        if (labelOptions.rotation === 'auto') {
                            label.attr({
                                rotation: angle
                            })
                        } else if (!defined(optionsY)) {
                            optionsY = (axis.chart.renderer.fontMetrics(label).b - labelBBox.height / 2)
                        }
                        if (!defined(align)) {
                            if (axis.isCircular) {
                                if (labelBBox.width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
                                    centerSlot = 0
                                }
                                if (angle > centerSlot && angle < 180 - centerSlot) {
                                    align = 'left'
                                } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
                                    align = 'right'
                                } else {
                                    align = 'center'
                                }
                            } else {
                                align = 'center'
                            }
                            label.attr({
                                align: align
                            })
                        }
                        if (align === 'auto' && axis.tickPositions.length === 2 && axis.isCircular) {
                            if (reducedAngle1 > 90 && reducedAngle1 < 180) {
                                reducedAngle1 = 180 - reducedAngle1
                            } else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {
                                reducedAngle1 = 540 - reducedAngle1
                            }
                            if (reducedAngle2 > 180 && reducedAngle2 <= 360) {
                                reducedAngle2 = 360 - reducedAngle2
                            }
                            if ((axis.pane.options.startAngle === correctAngle) || (axis.pane.options.startAngle === correctAngle + 360) || (axis.pane.options.startAngle === correctAngle - 360)) {
                                labelDir = 'start'
                            }
                            if ((correctAngle >= -90 && correctAngle <= 90) || (correctAngle >= -360 && correctAngle <= -270) || (correctAngle >= 270 && correctAngle <= 360)) {
                                align = (labelDir === 'start') ? 'right' : 'left'
                            } else {
                                align = (labelDir === 'start') ? 'left' : 'right'
                            }
                            if (reducedAngle2 > 70 && reducedAngle2 < 110) {
                                align = 'center'
                            }
                            if (reducedAngle1 < 15 || (reducedAngle1 >= 180 && reducedAngle1 < 195)) {
                                translateY = labelBBox.height * 0.3
                            } else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {
                                translateY = labelDir === 'start' ? 0 : labelBBox.height * 0.75
                            } else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {
                                translateY = labelDir === 'start' ? labelBBox.height * 0.75 : 0
                            } else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {
                                translateY = labelDir === 'start' ? -labelBBox.height * 0.25 : labelBBox.height
                            } else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {
                                translateY = labelDir === 'start' ? labelBBox.height : -labelBBox.height * 0.25
                            }
                            if (reducedAngle2 < 15) {
                                translateX = labelDir === 'start' ? -labelBBox.height * 0.15 : labelBBox.height * 0.15
                            } else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {
                                translateX = labelDir === 'start' ? labelBBox.height * 0.15 : -labelBBox.height * 0.15
                            }
                            label.attr({
                                align: align
                            });
                            label.translate(translateX, translateY + labelYPosCorrection)
                        }
                        e.pos.x = ret.x + (labelOptions.x || 0);
                        e.pos.y = ret.y + (optionsY || 0)
                    }
                }
                function onTickAfterGetPosition(e) {
                    if (this.axis.getPosition) {
                        extend(e.pos, this.axis.getPosition(this.pos))
                    }
                }
                function postTranslate(angle, radius) {
                    const chart = this.chart
                        , center = this.center;
                    angle = this.startAngleRad + angle;
                    return {
                        x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
                        y: chart.plotTop + center[1] + Math.sin(angle) * radius
                    }
                }
                function renderHidden() {
                    this.isDirty = !1
                }
                function setAxisSize() {
                    const axisProto = this.constructor.prototype;
                    let center, start;
                    axisProto.setAxisSize.call(this);
                    if (this.isRadial) {
                        this.pane.updateCenter(this);
                        center = this.center = this.pane.center.slice();
                        if (this.isCircular) {
                            this.sector = this.endAngleRad - this.startAngleRad
                        } else {
                            start = this.postTranslate(this.angleRad, center[3] / 2);
                            center[0] = start.x - this.chart.plotLeft;
                            center[1] = start.y - this.chart.plotTop
                        }
                        this.len = this.width = this.height = (center[2] - center[3]) * pick(this.sector, 1) / 2
                    }
                }
                function setAxisTranslation() {
                    const axisProto = this.constructor.prototype;
                    axisProto.setAxisTranslation.call(this);
                    if (this.center) {
                        if (this.isCircular) {
                            this.transA = (this.endAngleRad - this.startAngleRad) / ((this.max - this.min) || 1)
                        } else {
                            this.transA = ((this.center[2] - this.center[3]) / 2) / ((this.max - this.min) || 1)
                        }
                        if (this.isXAxis) {
                            this.minPixelPadding = this.transA * this.minPointOffset
                        } else {
                            this.minPixelPadding = 0
                        }
                    }
                }
                function setOptions(userOptions) {
                    const options = this.options = merge(this.constructor.defaultOptions, this.defaultPolarOptions, defaultOptions[this.coll], userOptions);
                    if (!options.plotBands) {
                        options.plotBands = []
                    }
                    fireEvent(this, 'afterSetOptions')
                }
                function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
                    const axis = this.axis;
                    let endPoint, ret;
                    if (axis.isRadial) {
                        endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
                        ret = ['M', x, y, 'L', endPoint.x, endPoint.y]
                    } else {
                        ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer)
                    }
                    return ret
                }
            }
        )(RadialAxis || (RadialAxis = {}));
        return RadialAxis
    });
    _registerModule(_modules, 'Series/PolarComposition.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Extensions/Pane.js'], _modules['Core/Axis/RadialAxis.js'], _modules['Core/Utilities.js']], function(A, H, Series, Pane, RadialAxis, U) {
        const {animObject} = A;
        const {addEvent, defined, find, isNumber, merge, pick, relativeLength, splat, uniqueKey, wrap} = U;
        const composedMembers = [];
        function clipCircle(renderer, x, y, r, innerR) {
            const id = uniqueKey()
                , clipPath = renderer.createElement('clipPath').attr({
                id: id
            }).add(renderer.defs)
                , wrapper = innerR ? renderer.arc(x, y, r, innerR, 0, 2 * Math.PI).add(clipPath) : renderer.circle(x, y, r).add(clipPath);
            wrapper.id = id;
            wrapper.clipPath = clipPath;
            return wrapper
        }
        function findAlignments(angle, options) {
            let align, verticalAlign;
            if (options.align === null) {
                if (angle > 20 && angle < 160) {
                    align = 'left'
                } else if (angle > 200 && angle < 340) {
                    align = 'right'
                } else {
                    align = 'center'
                }
                options.align = align
            }
            if (options.verticalAlign === null) {
                if (angle < 45 || angle > 315) {
                    verticalAlign = 'bottom'
                } else if (angle > 135 && angle < 225) {
                    verticalAlign = 'top'
                } else {
                    verticalAlign = 'middle'
                }
                options.verticalAlign = verticalAlign
            }
            return options
        }
        function getConnectors(segment, index, calculateNeighbours, connectEnds) {
            const smoothing = 1.5
                , denom = smoothing + 1
                , addedNumber = connectEnds ? 1 : 0;
            let i, leftContX, leftContY, rightContX, rightContY, jointAngle;
            if (index >= 0 && index <= segment.length - 1) {
                i = index
            } else if (index < 0) {
                i = segment.length - 1 + index
            } else {
                i = 0
            }
            const prevPointInd = ((i - 1 < 0) ? segment.length - (1 + addedNumber) : i - 1)
                , nextPointInd = (i + 1 > segment.length - 1) ? addedNumber : i + 1
                , previousPoint = segment[prevPointInd]
                , nextPoint = segment[nextPointInd]
                , previousX = previousPoint.plotX
                , previousY = previousPoint.plotY
                , nextX = nextPoint.plotX
                , nextY = nextPoint.plotY
                , plotX = segment[i].plotX
                , plotY = segment[i].plotY;
            leftContX = (smoothing * plotX + previousX) / denom;
            leftContY = (smoothing * plotY + previousY) / denom;
            rightContX = (smoothing * plotX + nextX) / denom;
            rightContY = (smoothing * plotY + nextY) / denom;
            const dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2))
                , dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2))
                , leftContAngle = Math.atan2(leftContY - plotY, leftContX - plotX)
                , rightContAngle = Math.atan2(rightContY - plotY, rightContX - plotX);
            jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);
            if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
                jointAngle -= Math.PI
            }
            leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
            leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
            rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
            rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
            const ret = {
                rightContX: rightContX,
                rightContY: rightContY,
                leftContX: leftContX,
                leftContY: leftContY,
                plotX: plotX,
                plotY: plotY
            };
            if (calculateNeighbours) {
                ret.prevPointCont = getConnectors(segment, prevPointInd, !1, connectEnds)
            }
            return ret
        }
        function onChartAfterDrawChartBox() {
            (this.pane || []).forEach( (pane) => {
                    pane.render()
                }
            )
        }
        function onChartAfterInit(event) {
            const xAxis = event.args[0].xAxis
                , yAxis = event.args[0].yAxis
                , chart = event.args[0].chart;
            if (xAxis && yAxis) {
                if (yAxis.gridLineInterpolation === 'polygon') {
                    xAxis.startOnTick = !0;
                    xAxis.endOnTick = !0
                } else if (xAxis.gridLineInterpolation === 'polygon' && chart.inverted) {
                    yAxis.startOnTick = !0;
                    yAxis.endOnTick = !0
                }
            }
        }
        function onChartGetAxes() {
            if (!this.pane) {
                this.pane = []
            }
            this.options.pane = splat(this.options.pane);
            this.options.pane.forEach( (paneOptions) => {
                    new Pane(paneOptions,this)
                }
                , this)
        }
        function onPointerGetSelectionBox(event) {
            const marker = event.args.marker
                , xAxis = this.chart.xAxis[0]
                , yAxis = this.chart.yAxis[0]
                , inverted = this.chart.inverted
                , radialAxis = inverted ? yAxis : xAxis
                , linearAxis = inverted ? xAxis : yAxis;
            if (this.chart.polar) {
                event.preventDefault();
                let start = (marker.attr ? marker.attr('start') : marker.start) - radialAxis.startAngleRad;
                let r = (marker.attr ? marker.attr('r') : marker.r);
                let end = (marker.attr ? marker.attr('end') : marker.end) - radialAxis.startAngleRad;
                let innerR = (marker.attr ? marker.attr('innerR') : marker.innerR);
                event.result.x = start + radialAxis.pos;
                event.result.width = end - start;
                event.result.y = linearAxis.len + linearAxis.pos - innerR;
                event.result.height = innerR - r
            }
        }
        function onPointerGetSelectionMarkerAttrs(event) {
            const chart = this.chart;
            if (chart.polar && chart.hoverPane && chart.hoverPane.axis) {
                event.preventDefault();
                const center = chart.hoverPane.center
                    , mouseDownX = (this.mouseDownX || 0)
                    , mouseDownY = (this.mouseDownY || 0)
                    , chartY = event.args.chartY
                    , chartX = event.args.chartX
                    , fullCircle = Math.PI * 2
                    , startAngleRad = chart.hoverPane.axis.startAngleRad
                    , endAngleRad = chart.hoverPane.axis.endAngleRad
                    , linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0]
                    , attrs = {};
                let shapeType = 'arc';
                attrs.x = center[0] + chart.plotLeft;
                attrs.y = center[1] + chart.plotTop;
                if (this.zoomHor) {
                    const paneRadRange = startAngleRad > 0 ? endAngleRad - startAngleRad : Math.abs(startAngleRad) + Math.abs(endAngleRad);
                    let startAngle = Math.atan2(mouseDownY - chart.plotTop - center[1], mouseDownX - chart.plotLeft - center[0]) - startAngleRad
                        , endAngle = Math.atan2(chartY - chart.plotTop - center[1], chartX - chart.plotLeft - center[0]) - startAngleRad;
                    attrs.r = center[2] / 2;
                    attrs.innerR = center[3] / 2;
                    if (startAngle <= 0) {
                        startAngle += fullCircle
                    }
                    if (endAngle <= 0) {
                        endAngle += fullCircle
                    }
                    if (endAngle < startAngle) {
                        endAngle = [startAngle, startAngle = endAngle][0]
                    }
                    if (paneRadRange < fullCircle) {
                        const swapAngle = endAngleRad + (fullCircle - paneRadRange) / 2;
                        if (startAngleRad + endAngle > swapAngle) {
                            endAngle = startAngle;
                            startAngle = startAngleRad <= 0 ? startAngleRad : 0
                        }
                    }
                    const start = attrs.start = Math.max(startAngle + startAngleRad, startAngleRad)
                        , end = attrs.end = Math.min(endAngle + startAngleRad, endAngleRad);
                    if (linearAxis.options.gridLineInterpolation === 'polygon') {
                        const radialAxis = chart.hoverPane.axis
                            , tickInterval = radialAxis.tickInterval
                            , min = start - radialAxis.startAngleRad + radialAxis.pos
                            , max = end - start;
                        let path = linearAxis.getPlotLinePath({
                            value: linearAxis.max
                        })
                            , pathStart = radialAxis.toValue(min)
                            , pathEnd = radialAxis.toValue(min + max);
                        if (pathStart < radialAxis.getExtremes().min) {
                            const {min, max} = radialAxis.getExtremes();
                            pathStart = max - (min - pathStart)
                        }
                        if (pathEnd < radialAxis.getExtremes().min) {
                            const {min, max} = radialAxis.getExtremes();
                            pathEnd = max - (min - pathEnd)
                        }
                        if (pathEnd < pathStart) {
                            pathEnd = [pathStart, pathStart = pathEnd][0]
                        }
                        path = trimPath(path, pathStart, pathEnd, radialAxis);
                        path.push(['L', center[0] + chart.plotLeft, chart.plotTop + center[1]]);
                        attrs.d = path;
                        shapeType = 'path'
                    }
                }
                if (this.zoomVert) {
                    const linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0];
                    let innerR = Math.sqrt(Math.pow(mouseDownX - chart.plotLeft - center[0], 2) + Math.pow(mouseDownY - chart.plotTop - center[1], 2))
                        , r = Math.sqrt(Math.pow(chartX - chart.plotLeft - center[0], 2) + Math.pow(chartY - chart.plotTop - center[1], 2));
                    if (r < innerR) {
                        innerR = [r, r = innerR][0]
                    }
                    if (r > center[2] / 2) {
                        r = center[2] / 2
                    }
                    if (innerR < center[3] / 2) {
                        innerR = center[3] / 2
                    }
                    if (!this.zoomHor) {
                        attrs.start = startAngleRad;
                        attrs.end = endAngleRad
                    }
                    attrs.r = r;
                    attrs.innerR = innerR;
                    if (linearAxis.options.gridLineInterpolation === 'polygon') {
                        const end = linearAxis.toValue(linearAxis.len + linearAxis.pos - innerR)
                            , start = linearAxis.toValue(linearAxis.len + linearAxis.pos - r)
                            , path = linearAxis.getPlotLinePath({
                            value: start
                        }).concat(linearAxis.getPlotLinePath({
                            value: end,
                            reverse: !0
                        }));
                        attrs.d = path;
                        shapeType = 'path'
                    }
                }
                if (this.zoomHor && this.zoomVert && linearAxis.options.gridLineInterpolation === 'polygon') {
                    const radialAxis = chart.hoverPane.axis
                        , start = attrs.start || 0
                        , end = attrs.end || 0
                        , min = start - radialAxis.startAngleRad + radialAxis.pos
                        , max = end - start
                        , pathStart = radialAxis.toValue(min)
                        , pathEnd = radialAxis.toValue(min + max);
                    if (attrs.d instanceof Array) {
                        let innerPath = attrs.d.slice(0, attrs.d.length / 2)
                            , outerPath = attrs.d.slice(attrs.d.length / 2, attrs.d.length);
                        outerPath = [...outerPath].reverse();
                        const radialAxis = chart.hoverPane.axis;
                        innerPath = trimPath(innerPath, pathStart, pathEnd, radialAxis);
                        outerPath = trimPath(outerPath, pathStart, pathEnd, radialAxis);
                        if (outerPath) {
                            (outerPath[0][0]) = 'L'
                        }
                        outerPath = [...outerPath].reverse();
                        attrs.d = innerPath.concat(outerPath);
                        shapeType = 'path'
                    }
                }
                event.attrs = attrs;
                event.shapeType = shapeType
            }
        }
        function onSeriesAfterInit() {
            const chart = this.chart;
            if (chart.polar) {
                this.polar = new PolarAdditions(this);
                if (chart.inverted) {
                    this.isRadialSeries = !0;
                    if (this.is('column')) {
                        this.isRadialBar = !0
                    }
                }
            }
        }
        function onSeriesAfterTranslate() {
            if (this.chart.polar && this.xAxis) {
                const series = this
                    , {xAxis, yAxis} = series
                    , chart = series.chart;
                series.kdByAngle = chart.tooltip && chart.tooltip.shared;
                if (series.kdByAngle) {
                    series.searchPoint = searchPointByAngle
                } else {
                    series.options.findNearestPointBy = 'xy'
                }
                const points = series.points;
                let i = points.length;
                while (i--) {
                    if (!series.is('column') && !series.is('columnrange')) {
                        series.polar.toXY(points[i])
                    }
                    if (!chart.hasParallelCoordinates && !series.yAxis.reversed) {
                        if (pick(points[i].y, Number.MIN_VALUE) < yAxis.min || points[i].x < xAxis.min || points[i].x > xAxis.max) {
                            points[i].isNull = !0;
                            points[i].plotY = NaN
                        } else {
                            points[i].isNull = points[i].isValid && !points[i].isValid()
                        }
                    }
                }
                if (!this.hasClipCircleSetter) {
                    this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent(series, 'afterRender', function() {
                        let circ;
                        if (chart.polar && this.options.clip !== !1) {
                            circ = this.yAxis.pane.center;
                            if (!this.clipCircle) {
                                this.clipCircle = clipCircle(chart.renderer, circ[0], circ[1], circ[2] / 2, circ[3] / 2)
                            } else {
                                this.clipCircle.animate({
                                    x: circ[0],
                                    y: circ[1],
                                    r: circ[2] / 2,
                                    innerR: circ[3] / 2
                                })
                            }
                            this.group.clip(this.clipCircle);
                            this.setClip = H.noop
                        }
                    }))
                }
            }
        }
        function searchPointByAngle(e) {
            const series = this
                , chart = series.chart
                , xAxis = series.xAxis
                , center = xAxis.pane && xAxis.pane.center
                , plotX = e.chartX - (center && center[0] || 0) - chart.plotLeft
                , plotY = e.chartY - (center && center[1] || 0) - chart.plotTop;
            return series.searchKDTree({
                clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))
            })
        }
        function trimPath(path, start, end, radialAxis) {
            const tickInterval = radialAxis.tickInterval
                , ticks = radialAxis.tickPositions;
            let lastTick = find(ticks, (tick) => tick >= end)
                , firstTick = find([...ticks].reverse(), (tick) => tick <= start);
            if (!defined(lastTick)) {
                lastTick = ticks[ticks.length - 1]
            }
            if (!defined(firstTick)) {
                firstTick = ticks[0];
                lastTick += tickInterval;
                path[0][0] = 'L';
                path.unshift(path[path.length - 3])
            }
            path = path.slice(ticks.indexOf(firstTick), ticks.indexOf(lastTick) + 1);
            path[0][0] = 'M';
            return path
        }
        function wrapChartGet(proceed, id) {
            return find(this.pane || [], function(pane) {
                return pane.options.id === id
            }) || proceed.call(this, id)
        }
        function wrapColumnSeriesAlignDataLabel(proceed, point, dataLabel, options, alignTo, isNew) {
            const chart = this.chart
                , inside = pick(options.inside, !!this.options.stacking);
            let angle, shapeArgs, labelPos;
            if (chart.polar) {
                angle = point.rectPlotX / Math.PI * 180;
                if (!chart.inverted) {
                    options = findAlignments(angle, options)
                } else {
                    this.forceDL = chart.isInsidePlot(point.plotX, point.plotY);
                    if (inside && point.shapeArgs) {
                        shapeArgs = point.shapeArgs;
                        labelPos = this.yAxis.postTranslate(((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 - this.xAxis.startAngleRad, point.barX + point.pointWidth / 2);
                        alignTo = merge(alignTo, {
                            x: labelPos.x - chart.plotLeft,
                            y: labelPos.y - chart.plotTop
                        })
                    } else if (point.tooltipPos) {
                        alignTo = merge(alignTo, {
                            x: point.tooltipPos[0],
                            y: point.tooltipPos[1]
                        })
                    }
                    options.align = pick(options.align, 'center');
                    options.verticalAlign = pick(options.verticalAlign, 'middle')
                }
                Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
                if (this.isRadialBar && point.shapeArgs && point.shapeArgs.start === point.shapeArgs.end) {
                    dataLabel.hide()
                } else {
                    dataLabel.show()
                }
            } else {
                proceed.call(this, point, dataLabel, options, alignTo, isNew)
            }
        }
        function onAfterColumnTranslate() {
            const series = this
                , options = series.options
                , stacking = options.stacking
                , chart = series.chart
                , xAxis = series.xAxis
                , yAxis = series.yAxis
                , reversed = yAxis.reversed
                , center = yAxis.center
                , startAngleRad = xAxis.startAngleRad
                , endAngleRad = xAxis.endAngleRad
                , visibleRange = endAngleRad - startAngleRad;
            let threshold = options.threshold, thresholdAngleRad = 0, points, point, i, yMin, yMax, start = 0, end = 0, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;
            if (xAxis.isRadial) {
                points = series.points;
                i = points.length;
                yMin = yAxis.translate(yAxis.min);
                yMax = yAxis.translate(yAxis.max);
                threshold = options.threshold || 0;
                if (chart.inverted) {
                    if (isNumber(threshold)) {
                        thresholdAngleRad = yAxis.translate(threshold);
                        if (defined(thresholdAngleRad)) {
                            if (thresholdAngleRad < 0) {
                                thresholdAngleRad = 0
                            } else if (thresholdAngleRad > visibleRange) {
                                thresholdAngleRad = visibleRange
                            }
                            series.translatedThreshold = thresholdAngleRad + startAngleRad
                        }
                    }
                }
                while (i--) {
                    point = points[i];
                    barX = point.barX;
                    pointX = point.x;
                    pointY = point.y;
                    point.shapeType = 'arc';
                    if (chart.inverted) {
                        point.plotY = yAxis.translate(pointY);
                        if (stacking && yAxis.stacking) {
                            stack = yAxis.stacking.stacks[(pointY < 0 ? '-' : '') + series.stackKey];
                            if (series.visible && stack && stack[pointX]) {
                                if (!point.isNull) {
                                    stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];
                                    start = yAxis.translate(stackValues[0]);
                                    end = yAxis.translate(stackValues[1]);
                                    if (defined(start)) {
                                        start = U.clamp(start, 0, visibleRange)
                                    }
                                }
                            }
                        } else {
                            start = thresholdAngleRad;
                            end = point.plotY
                        }
                        if (start > end) {
                            end = [start, start = end][0]
                        }
                        if (!reversed) {
                            if (start < yMin) {
                                start = yMin
                            } else if (end > yMax) {
                                end = yMax
                            } else if (end < yMin || start > yMax) {
                                start = end = 0
                            }
                        } else {
                            if (end > yMin) {
                                end = yMin
                            } else if (start < yMax) {
                                start = yMax
                            } else if (start > yMin || end < yMax) {
                                start = end = visibleRange
                            }
                        }
                        if (yAxis.min > yAxis.max) {
                            start = end = reversed ? visibleRange : 0
                        }
                        start += startAngleRad;
                        end += startAngleRad;
                        if (center) {
                            point.barX = barX += center[3] / 2
                        }
                        innerR = Math.max(barX, 0);
                        r = Math.max(barX + point.pointWidth, 0);
                        const brOption = options.borderRadius
                            , brValue = typeof brOption === 'object' ? brOption.radius : brOption
                            , borderRadius = relativeLength(brValue || 0, r - innerR);
                        point.shapeArgs = {
                            x: center[0],
                            y: center[1],
                            r,
                            innerR,
                            start,
                            end,
                            borderRadius
                        };
                        point.opacity = start === end ? 0 : void 0;
                        point.plotY = (defined(series.translatedThreshold) && (start < series.translatedThreshold ? start : end)) - startAngleRad
                    } else {
                        start = barX + startAngleRad;
                        point.shapeArgs = series.polar.arc(point.yBottom, point.plotY, start, start + point.pointWidth);
                        point.shapeArgs.borderRadius = 0
                    }
                    series.polar.toXY(point);
                    if (chart.inverted) {
                        tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);
                        point.tooltipPos = [tooltipPos.x - chart.plotLeft, tooltipPos.y - chart.plotTop]
                    } else {
                        point.tooltipPos = [point.plotX, point.plotY]
                    }
                    if (center) {
                        point.ttBelow = point.plotY > center[1]
                    }
                }
            }
        }
        function wrapLineSeriesGetGraphPath(proceed, points) {
            const series = this;
            let firstValid, popLastPoint;
            if (this.chart.polar) {
                points = points || this.points;
                for (let i = 0; i < points.length; i++) {
                    if (!points[i].isNull) {
                        firstValid = i;
                        break
                    }
                }
                if (this.options.connectEnds !== !1 && typeof firstValid !== 'undefined') {
                    this.connectEnds = !0;
                    points.splice(points.length, 0, points[firstValid]);
                    popLastPoint = !0
                }
                points.forEach( (point) => {
                        if (typeof point.polarPlotY === 'undefined') {
                            series.polar.toXY(point)
                        }
                    }
                )
            }
            const ret = proceed.apply(this, [].slice.call(arguments, 1));
            if (popLastPoint) {
                points.pop()
            }
            return ret
        }
        function wrapPointerGetCoordinates(proceed, e) {
            const chart = this.chart;
            let ret = {
                xAxis: [],
                yAxis: []
            };
            if (chart.polar) {
                chart.axes.forEach( (axis) => {
                        if (axis.coll === 'colorAxis') {
                            return
                        }
                        const isXAxis = axis.isXAxis
                            , center = axis.center
                            , x = e.chartX - center[0] - chart.plotLeft
                            , y = e.chartY - center[1] - chart.plotTop;
                        ret[isXAxis ? 'xAxis' : 'yAxis'].push({
                            axis: axis,
                            value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), !0)
                        })
                    }
                )
            } else {
                ret = proceed.call(this, e)
            }
            return ret
        }
        function wrapPointerPinch(proceed, e) {
            if (this.chart.polar) {
                return
            }
            proceed.call(this, e)
        }
        function wrapSeriesAnimate(proceed, init) {
            const series = this
                , chart = this.chart
                , group = this.group
                , markerGroup = this.markerGroup
                , center = this.xAxis && this.xAxis.center
                , plotLeft = chart.plotLeft
                , plotTop = chart.plotTop;
            let animation = this.options.animation, attribs, paneInnerR, graphic, shapeArgs, r, innerR;
            if (chart.polar) {
                if (series.isRadialBar) {
                    if (!init) {
                        series.startAngleRad = pick(series.translatedThreshold, series.xAxis.startAngleRad);
                        H.seriesTypes.pie.prototype.animate.call(series, init)
                    }
                } else {
                    animation = animObject(animation);
                    if (series.is('column')) {
                        if (!init) {
                            paneInnerR = center[3] / 2;
                            series.points.forEach( (point) => {
                                    graphic = point.graphic;
                                    shapeArgs = point.shapeArgs;
                                    r = shapeArgs && shapeArgs.r;
                                    innerR = shapeArgs && shapeArgs.innerR;
                                    if (graphic && shapeArgs) {
                                        graphic.attr({
                                            r: paneInnerR,
                                            innerR: paneInnerR
                                        });
                                        graphic.animate({
                                            r: r,
                                            innerR: innerR
                                        }, series.options.animation)
                                    }
                                }
                            )
                        }
                    } else {
                        if (init) {
                            attribs = {
                                translateX: center[0] + plotLeft,
                                translateY: center[1] + plotTop,
                                scaleX: 0.001,
                                scaleY: 0.001
                            };
                            group.attr(attribs);
                            if (markerGroup) {
                                markerGroup.attr(attribs)
                            }
                        } else {
                            attribs = {
                                translateX: plotLeft,
                                translateY: plotTop,
                                scaleX: 1,
                                scaleY: 1
                            };
                            group.animate(attribs, animation);
                            if (markerGroup) {
                                markerGroup.animate(attribs, animation)
                            }
                        }
                    }
                }
            } else {
                proceed.call(this, init)
            }
        }
        function wrapSplineSeriesGetPointSpline(proceed, segment, point, i) {
            let ret, connectors;
            if (this.chart.polar) {
                if (!i) {
                    ret = ['M', point.plotX, point.plotY]
                } else {
                    connectors = getConnectors(segment, i, !0, this.connectEnds);
                    const rightContX = connectors.prevPointCont && connectors.prevPointCont.rightContX;
                    const rightContY = connectors.prevPointCont && connectors.prevPointCont.rightContY;
                    ret = ['C', isNumber(rightContX) ? rightContX : connectors.plotX, isNumber(rightContY) ? rightContY : connectors.plotY, isNumber(connectors.leftContX) ? connectors.leftContX : connectors.plotX, isNumber(connectors.leftContY) ? connectors.leftContY : connectors.plotY, connectors.plotX, connectors.plotY]
                }
            } else {
                ret = proceed.call(this, segment, point, i)
            }
            return ret
        }
        class PolarAdditions {
            static compose(AxisClass, ChartClass, PointerClass, SeriesClass, TickClass, AreaSplineRangeSeriesClass, ColumnSeriesClass, LineSeriesClass, SplineSeriesClass) {
                RadialAxis.compose(AxisClass, TickClass);
                if (U.pushUnique(composedMembers, ChartClass)) {
                    addEvent(ChartClass, 'afterDrawChartBox', onChartAfterDrawChartBox);
                    addEvent(ChartClass, 'getAxes', onChartGetAxes);
                    addEvent(ChartClass, 'init', onChartAfterInit);
                    const chartProto = ChartClass.prototype;
                    wrap(chartProto, 'get', wrapChartGet)
                }
                if (U.pushUnique(composedMembers, PointerClass)) {
                    const pointerProto = PointerClass.prototype;
                    wrap(pointerProto, 'getCoordinates', wrapPointerGetCoordinates);
                    wrap(pointerProto, 'pinch', wrapPointerPinch);
                    addEvent(PointerClass, 'getSelectionMarkerAttrs', onPointerGetSelectionMarkerAttrs);
                    addEvent(PointerClass, 'getSelectionBox', onPointerGetSelectionBox)
                }
                if (U.pushUnique(composedMembers, SeriesClass)) {
                    addEvent(SeriesClass, 'afterInit', onSeriesAfterInit);
                    addEvent(SeriesClass, 'afterTranslate', onSeriesAfterTranslate, {
                        order: 2
                    });
                    addEvent(SeriesClass, 'afterColumnTranslate', onAfterColumnTranslate, {
                        order: 4
                    });
                    const seriesProto = SeriesClass.prototype;
                    wrap(seriesProto, 'animate', wrapSeriesAnimate)
                }
                if (ColumnSeriesClass && U.pushUnique(composedMembers, ColumnSeriesClass)) {
                    const columnProto = ColumnSeriesClass.prototype;
                    wrap(columnProto, 'alignDataLabel', wrapColumnSeriesAlignDataLabel);
                    wrap(columnProto, 'animate', wrapSeriesAnimate)
                }
                if (LineSeriesClass && U.pushUnique(composedMembers, LineSeriesClass)) {
                    const lineProto = LineSeriesClass.prototype;
                    wrap(lineProto, 'getGraphPath', wrapLineSeriesGetGraphPath)
                }
                if (SplineSeriesClass && U.pushUnique(composedMembers, SplineSeriesClass)) {
                    const splineProto = SplineSeriesClass.prototype;
                    wrap(splineProto, 'getPointSpline', wrapSplineSeriesGetPointSpline);
                    if (AreaSplineRangeSeriesClass && U.pushUnique(composedMembers, AreaSplineRangeSeriesClass)) {
                        const areaSplineRangeProto = AreaSplineRangeSeriesClass.prototype;
                        areaSplineRangeProto.getPointSpline = splineProto.getPointSpline
                    }
                }
            }
            constructor(series) {
                this.series = series
            }
            arc(low, high, start, end) {
                const series = this.series
                    , center = series.xAxis.center
                    , len = series.yAxis.len
                    , paneInnerR = center[3] / 2;
                let r = len - high + paneInnerR
                    , innerR = len - pick(low, len) + paneInnerR;
                if (series.yAxis.reversed) {
                    if (r < 0) {
                        r = paneInnerR
                    }
                    if (innerR < 0) {
                        innerR = paneInnerR
                    }
                }
                return {
                    x: center[0],
                    y: center[1],
                    r: r,
                    innerR: innerR,
                    start: start,
                    end: end
                }
            }
            toXY(point) {
                const series = this.series
                    , chart = series.chart
                    , xAxis = series.xAxis
                    , yAxis = series.yAxis
                    , plotX = point.plotX
                    , inverted = chart.inverted
                    , pointY = point.y;
                let plotY = point.plotY, radius = inverted ? plotX : yAxis.len - plotY, clientX;
                if (inverted && series && !series.isRadialBar) {
                    point.plotY = plotY = isNumber(pointY) ? yAxis.translate(pointY) : 0
                }
                point.rectPlotX = plotX;
                point.rectPlotY = plotY;
                if (yAxis.center) {
                    radius += yAxis.center[3] / 2
                }
                if (isNumber(plotY)) {
                    const xy = inverted ? yAxis.postTranslate(plotY, radius) : xAxis.postTranslate(plotX, radius);
                    point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
                    point.plotY = point.polarPlotY = xy.y - chart.plotTop
                }
                if (series.kdByAngle) {
                    clientX = ((plotX / Math.PI * 180) + xAxis.pane.options.startAngle) % 360;
                    if (clientX < 0) {
                        clientX += 360
                    }
                    point.clientX = clientX
                } else {
                    point.clientX = point.plotX
                }
            }
        }
        return PolarAdditions
    });
    _registerModule(_modules, 'Core/Axis/WaterfallAxis.js', [_modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function(StackItem, U) {
        const {addEvent, objectEach, pushUnique} = U;
        var WaterfallAxis;
        (function(WaterfallAxis) {
                const composedMembers = [];
                function compose(AxisClass, ChartClass) {
                    if (pushUnique(composedMembers, AxisClass)) {
                        addEvent(AxisClass, 'init', onAxisInit);
                        addEvent(AxisClass, 'afterBuildStacks', onAxisAfterBuildStacks);
                        addEvent(AxisClass, 'afterRender', onAxisAfterRender)
                    }
                    if (pushUnique(composedMembers, ChartClass)) {
                        addEvent(ChartClass, 'beforeRedraw', onChartBeforeRedraw)
                    }
                }
                WaterfallAxis.compose = compose;
                function onAxisAfterBuildStacks() {
                    const axis = this
                        , stacks = axis.waterfall.stacks;
                    if (stacks) {
                        stacks.changed = !1;
                        delete stacks.alreadyChanged
                    }
                }
                function onAxisAfterRender() {
                    const axis = this
                        , stackLabelOptions = axis.options.stackLabels;
                    if (stackLabelOptions && stackLabelOptions.enabled && axis.waterfall.stacks) {
                        axis.waterfall.renderStackTotals()
                    }
                }
                function onAxisInit() {
                    const axis = this;
                    if (!axis.waterfall) {
                        axis.waterfall = new Composition(axis)
                    }
                }
                function onChartBeforeRedraw() {
                    const axes = this.axes
                        , series = this.series;
                    for (const seri of series) {
                        if (seri.options.stacking) {
                            for (const axis of axes) {
                                if (!axis.isXAxis) {
                                    axis.waterfall.stacks.changed = !0
                                }
                            }
                            break
                        }
                    }
                }
                class Composition {
                    constructor(axis) {
                        this.axis = axis;
                        this.stacks = {
                            changed: !1
                        }
                    }
                    renderStackTotals() {
                        const yAxis = this.axis
                            , waterfallStacks = yAxis.waterfall.stacks
                            , stackTotalGroup = (yAxis.stacking && yAxis.stacking.stackTotalGroup)
                            , dummyStackItem = new StackItem(yAxis,yAxis.options.stackLabels || {},!1,0,void 0);
                        this.dummyStackItem = dummyStackItem;
                        if (stackTotalGroup) {
                            objectEach(waterfallStacks, (type) => {
                                    objectEach(type, (stackItem, key) => {
                                            dummyStackItem.total = stackItem.stackTotal;
                                            dummyStackItem.x = +key;
                                            if (stackItem.label) {
                                                dummyStackItem.label = stackItem.label
                                            }
                                            StackItem.prototype.render.call(dummyStackItem, stackTotalGroup);
                                            stackItem.label = dummyStackItem.label;
                                            delete dummyStackItem.label
                                        }
                                    )
                                }
                            )
                        }
                        dummyStackItem.total = null
                    }
                }
                WaterfallAxis.Composition = Composition
            }
        )(WaterfallAxis || (WaterfallAxis = {}));
        return WaterfallAxis
    });
    _registerModule(_modules, 'Series/Waterfall/WaterfallPoint.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function(ColumnSeries, Point, U) {
        const {isNumber} = U;
        class WaterfallPoint extends ColumnSeries.prototype.pointClass {
            constructor() {
                super(...arguments);
                this.options = void 0;
                this.series = void 0
            }
            getClassName() {
                let className = Point.prototype.getClassName.call(this);
                if (this.isSum) {
                    className += ' highcharts-sum'
                } else if (this.isIntermediateSum) {
                    className += ' highcharts-intermediate-sum'
                }
                return className
            }
            isValid() {
                return (isNumber(this.y) || this.isSum || Boolean(this.isIntermediateSum))
            }
        }
        return WaterfallPoint
    });
    _registerModule(_modules, 'Series/Waterfall/WaterfallSeriesDefaults.js', [], function() {
        const WaterfallSeriesDefaults = {
            dataLabels: {
                inside: !0
            },
            lineWidth: 1,
            lineColor: "#333333",
            dashStyle: 'Dot',
            borderColor: "#333333",
            states: {
                hover: {
                    lineWidthPlus: 0
                }
            }
        };
        '';
        return WaterfallSeriesDefaults
    });
    _registerModule(_modules, 'Series/Waterfall/WaterfallSeries.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Core/Axis/WaterfallAxis.js'], _modules['Series/Waterfall/WaterfallPoint.js'], _modules['Series/Waterfall/WaterfallSeriesDefaults.js']], function(SeriesRegistry, U, WaterfallAxis, WaterfallPoint, WaterfallSeriesDefaults) {
        const {column: ColumnSeries, line: LineSeries} = SeriesRegistry.seriesTypes;
        const {addEvent, arrayMax, arrayMin, correctFloat, extend, isNumber, merge, objectEach, pick} = U;
        function ownProp(obj, key) {
            return Object.hasOwnProperty.call(obj, key)
        }
        class WaterfallSeries extends ColumnSeries {
            constructor() {
                super(...arguments);
                this.chart = void 0;
                this.data = void 0;
                this.options = void 0;
                this.points = void 0;
                this.stackedYNeg = void 0;
                this.stackedYPos = void 0;
                this.stackKey = void 0;
                this.xData = void 0;
                this.yAxis = void 0;
                this.yData = void 0
            }
            generatePoints() {
                ColumnSeries.prototype.generatePoints.apply(this);
                for (let i = 0, len = this.points.length; i < len; i++) {
                    const point = this.points[i]
                        , y = this.processedYData[i];
                    if (isNumber(y) && (point.isIntermediateSum || point.isSum)) {
                        point.y = correctFloat(y)
                    }
                }
            }
            processData(force) {
                const series = this
                    , options = series.options
                    , yData = series.yData
                    , points = options.data
                    , dataLength = yData.length
                    , threshold = options.threshold || 0;
                let point, subSum, sum, dataMin, dataMax, y;
                sum = subSum = dataMin = dataMax = 0;
                for (let i = 0; i < dataLength; i++) {
                    y = yData[i];
                    point = points && points[i] ? points[i] : {};
                    if (y === 'sum' || point.isSum) {
                        yData[i] = correctFloat(sum)
                    } else if (y === 'intermediateSum' || point.isIntermediateSum) {
                        yData[i] = correctFloat(subSum);
                        subSum = 0
                    } else {
                        sum += y;
                        subSum += y
                    }
                    dataMin = Math.min(sum, dataMin);
                    dataMax = Math.max(sum, dataMax)
                }
                super.processData.call(this, force);
                if (!options.stacking) {
                    series.dataMin = dataMin + threshold;
                    series.dataMax = dataMax
                }
                return
            }
            toYData(pt) {
                if (pt.isSum) {
                    return 'sum'
                }
                if (pt.isIntermediateSum) {
                    return 'intermediateSum'
                }
                return pt.y
            }
            updateParallelArrays(point, i) {
                super.updateParallelArrays.call(this, point, i);
                if (this.yData[0] === 'sum' || this.yData[0] === 'intermediateSum') {
                    this.yData[0] = null
                }
            }
            pointAttribs(point, state) {
                const upColor = this.options.upColor;
                if (upColor && !point.options.color && isNumber(point.y)) {
                    point.color = point.y > 0 ? upColor : void 0
                }
                const attr = ColumnSeries.prototype.pointAttribs.call(this, point, state);
                delete attr.dashstyle;
                return attr
            }
            getGraphPath() {
                return [['M', 0, 0]]
            }
            getCrispPath() {
                const data = this.data.filter( (d) => isNumber(d.y))
                    , yAxis = this.yAxis
                    , length = data.length
                    , graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2
                    , borderNormalizer = Math.round(this.borderWidth) % 2 / 2
                    , reversedXAxis = this.xAxis.reversed
                    , reversedYAxis = this.yAxis.reversed
                    , stacking = this.options.stacking
                    , path = [];
                for (let i = 1; i < length; i++) {
                    if (!(this.options.connectNulls || isNumber(this.data[data[i].index - 1].y))) {
                        continue
                    }
                    const box = data[i].box
                        , prevPoint = data[i - 1]
                        , prevY = prevPoint.y || 0
                        , prevBox = data[i - 1].box;
                    if (!box || !prevBox) {
                        continue
                    }
                    const prevStack = yAxis.waterfall.stacks[this.stackKey]
                        , isPos = prevY > 0 ? -prevBox.height : 0;
                    if (prevStack && prevBox && box) {
                        const prevStackX = prevStack[i - 1];
                        let yPos;
                        if (stacking) {
                            const connectorThreshold = prevStackX.connectorThreshold;
                            yPos = Math.round((yAxis.translate(connectorThreshold, !1, !0, !1, !0) + (reversedYAxis ? isPos : 0))) - graphNormalizer
                        } else {
                            yPos = prevBox.y + prevPoint.minPointLengthOffset + borderNormalizer - graphNormalizer
                        }
                        path.push(['M', (prevBox.x || 0) + (reversedXAxis ? 0 : (prevBox.width || 0)), yPos], ['L', (box.x || 0) + (reversedXAxis ? (box.width || 0) : 0), yPos])
                    }
                    if (prevBox && path.length && ((!stacking && prevY < 0 && !reversedYAxis) || (prevY > 0 && reversedYAxis))) {
                        const nextLast = path[path.length - 2];
                        if (nextLast && typeof nextLast[2] === 'number') {
                            nextLast[2] += prevBox.height || 0
                        }
                        const last = path[path.length - 1];
                        if (last && typeof last[2] === 'number') {
                            last[2] += prevBox.height || 0
                        }
                    }
                }
                return path
            }
            drawGraph() {
                LineSeries.prototype.drawGraph.call(this);
                if (this.graph) {
                    this.graph.attr({
                        d: this.getCrispPath()
                    })
                }
            }
            setStackedPoints(axis) {
                const series = this
                    , options = series.options
                    , waterfallStacks = axis.waterfall?.stacks
                    , seriesThreshold = options.threshold || 0
                    , stackKey = series.stackKey
                    , xData = series.xData
                    , xLength = xData.length;
                let stackThreshold = seriesThreshold, interSum = stackThreshold, actualStackX, totalYVal = 0, actualSum = 0, prevSum = 0, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;
                const calculateStackState = (firstS, nextS, sInx, sOff) => {
                        if (actualStackX) {
                            if (!statesLen) {
                                actualStackX.stackState[0] = firstS;
                                statesLen = actualStackX.stackState.length
                            } else {
                                for (sInx; sInx < statesLen; sInx++) {
                                    actualStackX.stackState[sInx] += sOff
                                }
                            }
                            actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS)
                        }
                    }
                ;
                if (axis.stacking && waterfallStacks) {
                    if (series.reserveSpace()) {
                        changed = waterfallStacks.changed;
                        alreadyChanged = waterfallStacks.alreadyChanged;
                        if (alreadyChanged && alreadyChanged.indexOf(stackKey) < 0) {
                            changed = !0
                        }
                        if (!waterfallStacks[stackKey]) {
                            waterfallStacks[stackKey] = {}
                        }
                        const actualStack = waterfallStacks[stackKey];
                        if (actualStack) {
                            for (let i = 0; i < xLength; i++) {
                                x = xData[i];
                                if (!actualStack[x] || changed) {
                                    actualStack[x] = {
                                        negTotal: 0,
                                        posTotal: 0,
                                        stackTotal: 0,
                                        threshold: 0,
                                        stateIndex: 0,
                                        stackState: [],
                                        label: ((changed && actualStack[x]) ? actualStack[x].label : void 0)
                                    }
                                }
                                actualStackX = actualStack[x];
                                yVal = series.yData[i];
                                if (yVal >= 0) {
                                    actualStackX.posTotal += yVal
                                } else {
                                    actualStackX.negTotal += yVal
                                }
                                xPoint = options.data[i];
                                posTotal = actualStackX.absolutePos = actualStackX.posTotal;
                                negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;
                                actualStackX.stackTotal = posTotal + negTotal;
                                statesLen = actualStackX.stackState.length;
                                if (xPoint && xPoint.isIntermediateSum) {
                                    calculateStackState(prevSum, actualSum, 0, prevSum);
                                    prevSum = actualSum;
                                    actualSum = seriesThreshold;
                                    stackThreshold ^= interSum;
                                    interSum ^= stackThreshold;
                                    stackThreshold ^= interSum
                                } else if (xPoint && xPoint.isSum) {
                                    calculateStackState(seriesThreshold, totalYVal, statesLen, 0);
                                    stackThreshold = seriesThreshold
                                } else {
                                    calculateStackState(stackThreshold, yVal, 0, totalYVal);
                                    if (xPoint) {
                                        totalYVal += yVal;
                                        actualSum += yVal
                                    }
                                }
                                actualStackX.stateIndex++;
                                actualStackX.threshold = stackThreshold;
                                stackThreshold += actualStackX.stackTotal
                            }
                        }
                        waterfallStacks.changed = !1;
                        if (!waterfallStacks.alreadyChanged) {
                            waterfallStacks.alreadyChanged = []
                        }
                        waterfallStacks.alreadyChanged.push(stackKey)
                    }
                }
            }
            getExtremes() {
                const stacking = this.options.stacking;
                let yAxis, waterfallStacks, stackedYNeg, stackedYPos;
                if (stacking) {
                    yAxis = this.yAxis;
                    waterfallStacks = yAxis.waterfall.stacks;
                    stackedYNeg = this.stackedYNeg = [];
                    stackedYPos = this.stackedYPos = [];
                    if (stacking === 'overlap') {
                        objectEach(waterfallStacks[this.stackKey], function(stackX) {
                            stackedYNeg.push(arrayMin(stackX.stackState));
                            stackedYPos.push(arrayMax(stackX.stackState))
                        })
                    } else {
                        objectEach(waterfallStacks[this.stackKey], function(stackX) {
                            stackedYNeg.push(stackX.negTotal + stackX.threshold);
                            stackedYPos.push(stackX.posTotal + stackX.threshold)
                        })
                    }
                    return {
                        dataMin: arrayMin(stackedYNeg),
                        dataMax: arrayMax(stackedYPos)
                    }
                }
                return {
                    dataMin: this.dataMin,
                    dataMax: this.dataMax
                }
            }
        }
        WaterfallSeries.defaultOptions = merge(ColumnSeries.defaultOptions, WaterfallSeriesDefaults);
        WaterfallSeries.compose = WaterfallAxis.compose;
        extend(WaterfallSeries.prototype, {
            getZonesGraphs: LineSeries.prototype.getZonesGraphs,
            pointValKey: 'y',
            showLine: !0,
            pointClass: WaterfallPoint
        });
        addEvent(WaterfallSeries, 'afterColumnTranslate', function() {
            const series = this
                , {options, points, yAxis} = series
                , minPointLength = pick(options.minPointLength, 5)
                , halfMinPointLength = minPointLength / 2
                , threshold = options.threshold || 0
                , stacking = options.stacking
                , actualStack = yAxis.waterfall.stacks[series.stackKey];
            let previousIntermediate = threshold, previousY = threshold, y, total, yPos, hPos;
            for (let i = 0; i < points.length; i++) {
                const point = points[i]
                    , yValue = series.processedYData[i]
                    , shapeArgs = point.shapeArgs
                    , box = extend({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                }, shapeArgs || {});
                point.box = box;
                const range = [0, yValue]
                    , pointY = point.y || 0;
                if (stacking) {
                    if (actualStack) {
                        const actualStackX = actualStack[i];
                        if (stacking === 'overlap') {
                            total = actualStackX.stackState[actualStackX.stateIndex--];
                            y = pointY >= 0 ? total : total - pointY;
                            if (ownProp(actualStackX, 'absolutePos')) {
                                delete actualStackX.absolutePos
                            }
                            if (ownProp(actualStackX, 'absoluteNeg')) {
                                delete actualStackX.absoluteNeg
                            }
                        } else {
                            if (pointY >= 0) {
                                total = actualStackX.threshold + actualStackX.posTotal;
                                actualStackX.posTotal -= pointY;
                                y = total
                            } else {
                                total = actualStackX.threshold + actualStackX.negTotal;
                                actualStackX.negTotal -= pointY;
                                y = total - pointY
                            }
                            if (!actualStackX.posTotal) {
                                if (isNumber(actualStackX.absolutePos) && ownProp(actualStackX, 'absolutePos')) {
                                    actualStackX.posTotal = actualStackX.absolutePos;
                                    delete actualStackX.absolutePos
                                }
                            }
                            if (!actualStackX.negTotal) {
                                if (isNumber(actualStackX.absoluteNeg) && ownProp(actualStackX, 'absoluteNeg')) {
                                    actualStackX.negTotal = actualStackX.absoluteNeg;
                                    delete actualStackX.absoluteNeg
                                }
                            }
                        }
                        if (!point.isSum) {
                            actualStackX.connectorThreshold = actualStackX.threshold + actualStackX.stackTotal
                        }
                        if (yAxis.reversed) {
                            yPos = (pointY >= 0) ? (y - pointY) : (y + pointY);
                            hPos = y
                        } else {
                            yPos = y;
                            hPos = y - pointY
                        }
                        point.below = yPos <= threshold;
                        box.y = yAxis.translate(yPos, !1, !0, !1, !0);
                        box.height = Math.abs(box.y - yAxis.translate(hPos, !1, !0, !1, !0));
                        const dummyStackItem = yAxis.waterfall.dummyStackItem;
                        if (dummyStackItem) {
                            dummyStackItem.x = i;
                            dummyStackItem.label = actualStack[i].label;
                            dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i], void 0, this.xAxis)
                        }
                    }
                } else {
                    y = Math.max(previousY, previousY + pointY) + range[0];
                    box.y = yAxis.translate(y, !1, !0, !1, !0);
                    if (point.isSum) {
                        box.y = yAxis.translate(range[1], !1, !0, !1, !0);
                        box.height = Math.min(yAxis.translate(range[0], !1, !0, !1, !0), yAxis.len) - box.y;
                        point.below = range[1] <= threshold
                    } else if (point.isIntermediateSum) {
                        if (pointY >= 0) {
                            yPos = range[1] + previousIntermediate;
                            hPos = previousIntermediate
                        } else {
                            yPos = previousIntermediate;
                            hPos = range[1] + previousIntermediate
                        }
                        if (yAxis.reversed) {
                            yPos ^= hPos;
                            hPos ^= yPos;
                            yPos ^= hPos
                        }
                        box.y = yAxis.translate(yPos, !1, !0, !1, !0);
                        box.height = Math.abs(box.y - Math.min(yAxis.translate(hPos, !1, !0, !1, !0), yAxis.len));
                        previousIntermediate += range[1];
                        point.below = yPos <= threshold
                    } else {
                        box.height = yValue > 0 ? yAxis.translate(previousY, !1, !0, !1, !0) - box.y : yAxis.translate(previousY, !1, !0, !1, !0) - yAxis.translate(previousY - yValue, !1, !0, !1, !0);
                        previousY += yValue;
                        point.below = previousY < threshold
                    }
                    if (box.height < 0) {
                        box.y += box.height;
                        box.height *= -1
                    }
                }
                point.plotY = box.y = Math.round(box.y || 0) - (series.borderWidth % 2) / 2;
                box.height = Math.max(Math.round(box.height || 0), 0.001);
                point.yBottom = box.y + box.height;
                if (box.height <= minPointLength && !point.isNull) {
                    box.height = minPointLength;
                    box.y -= halfMinPointLength;
                    point.plotY = box.y;
                    if (pointY < 0) {
                        point.minPointLengthOffset = -halfMinPointLength
                    } else {
                        point.minPointLengthOffset = halfMinPointLength
                    }
                } else {
                    if (point.isNull) {
                        box.width = 0
                    }
                    point.minPointLengthOffset = 0
                }
                const tooltipY = point.plotY + (point.negative ? box.height : 0);
                if (point.below) {
                    point.plotY += box.height
                }
                if (point.tooltipPos) {
                    if (series.chart.inverted) {
                        point.tooltipPos[0] = yAxis.len - tooltipY
                    } else {
                        point.tooltipPos[1] = tooltipY
                    }
                }
                point.isInside = this.isPointInside(point);
                merge(!0, point.shapeArgs, box)
            }
        }, {
            order: 2
        });
        SeriesRegistry.registerSeriesType('waterfall', WaterfallSeries);
        return WaterfallSeries
    });
    _registerModule(_modules, 'masters/highcharts-more.src.js', [_modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/Bubble/BubbleSeries.js'], _modules['Series/PackedBubble/PackedBubbleSeries.js'], _modules['Series/PolarComposition.js'], _modules['Series/Waterfall/WaterfallSeries.js']], function(Highcharts, SeriesRegistry, BubbleSeries, PackedBubbleSeries, PolarAdditions, WaterfallSeries) {
        const G = Highcharts;
        BubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);
        PackedBubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);
        PolarAdditions.compose(G.Axis, G.Chart, G.Pointer, G.Series, G.Tick, SeriesRegistry.seriesTypes.areasplinerange, SeriesRegistry.seriesTypes.column, SeriesRegistry.seriesTypes.line, SeriesRegistry.seriesTypes.spline);
        WaterfallSeries.compose(G.Axis, G.Chart)
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Exporting module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/exporting', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Core/Chart/ChartNavigationComposition.js', [], function() {
        var ChartNavigationComposition;
        (function(ChartNavigationComposition) {
                function compose(chart) {
                    if (!chart.navigation) {
                        chart.navigation = new Additions(chart)
                    }
                    return chart
                }
                ChartNavigationComposition.compose = compose;
                class Additions {
                    constructor(chart) {
                        this.updates = [];
                        this.chart = chart
                    }
                    addUpdate(updateFn) {
                        this.chart.navigation.updates.push(updateFn)
                    }
                    update(options, redraw) {
                        this.updates.forEach( (updateFn) => {
                                updateFn.call(this.chart, options, redraw)
                            }
                        )
                    }
                }
                ChartNavigationComposition.Additions = Additions
            }
        )(ChartNavigationComposition || (ChartNavigationComposition = {}));
        return ChartNavigationComposition
    });
    _registerModule(_modules, 'Extensions/Exporting/ExportingDefaults.js', [_modules['Core/Globals.js']], function(H) {
        const {isTouchDevice} = H;
        const exporting = {
            allowTableSorting: !0,
            type: 'image/png',
            url: 'https://export.highcharts.com/',
            pdfFont: {
                normal: void 0,
                bold: void 0,
                bolditalic: void 0,
                italic: void 0
            },
            printMaxWidth: 780,
            scale: 2,
            buttons: {
                contextButton: {
                    className: 'highcharts-contextbutton',
                    menuClassName: 'highcharts-contextmenu',
                    symbol: 'menu',
                    titleKey: 'contextButtonTitle',
                    menuItems: ['viewFullscreen', 'printChart', 'separator', 'downloadPNG', 'downloadJPEG', 'downloadPDF', 'downloadSVG']
                }
            },
            menuItemDefinitions: {
                viewFullscreen: {
                    textKey: 'viewFullscreen',
                    onclick: function() {
                        if (this.fullscreen) {
                            this.fullscreen.toggle()
                        }
                    }
                },
                printChart: {
                    textKey: 'printChart',
                    onclick: function() {
                        this.print()
                    }
                },
                separator: {
                    separator: !0
                },
                downloadPNG: {
                    textKey: 'downloadPNG',
                    onclick: function() {
                        this.exportChart()
                    }
                },
                downloadJPEG: {
                    textKey: 'downloadJPEG',
                    onclick: function() {
                        this.exportChart({
                            type: 'image/jpeg'
                        })
                    }
                },
                downloadPDF: {
                    textKey: 'downloadPDF',
                    onclick: function() {
                        this.exportChart({
                            type: 'application/pdf'
                        })
                    }
                },
                downloadSVG: {
                    textKey: 'downloadSVG',
                    onclick: function() {
                        this.exportChart({
                            type: 'image/svg+xml'
                        })
                    }
                }
            }
        };
        const lang = {
            viewFullscreen: 'View in full screen',
            exitFullscreen: 'Exit from full screen',
            printChart: 'Print chart',
            downloadPNG: 'Download PNG image',
            downloadJPEG: 'Download JPEG image',
            downloadPDF: 'Download PDF document',
            downloadSVG: 'Download SVG vector image',
            contextButtonTitle: 'Chart context menu'
        };
        const navigation = {
            buttonOptions: {
                symbolSize: 14,
                symbolX: 14.5,
                symbolY: 13.5,
                align: 'right',
                buttonSpacing: 3,
                height: 28,
                verticalAlign: 'top',
                width: 28,
                symbolFill: "#666666",
                symbolStroke: "#666666",
                symbolStrokeWidth: 3,
                theme: {
                    padding: 5
                }
            },
            menuStyle: {
                border: 'none',
                borderRadius: '3px',
                background: "#ffffff",
                padding: '0.5em'
            },
            menuItemStyle: {
                background: 'none',
                borderRadius: '3px',
                color: "#333333",
                padding: '0.5em',
                fontSize: isTouchDevice ? '0.9em' : '0.8em',
                transition: 'background 250ms, color 250ms'
            },
            menuItemHoverStyle: {
                background: "#f2f2f2"
            }
        };
        const ExportingDefaults = {
            exporting,
            lang,
            navigation
        };
        return ExportingDefaults
    });
    _registerModule(_modules, 'Extensions/Exporting/ExportingSymbols.js', [], function() {
        var ExportingSymbols;
        (function(ExportingSymbols) {
                const modifiedClasses = [];
                function compose(SVGRendererClass) {
                    if (modifiedClasses.indexOf(SVGRendererClass) === -1) {
                        modifiedClasses.push(SVGRendererClass);
                        const symbols = SVGRendererClass.prototype.symbols;
                        symbols.menu = menu;
                        symbols.menuball = menuball.bind(symbols)
                    }
                }
                ExportingSymbols.compose = compose;
                function menu(x, y, width, height) {
                    const arr = [['M', x, y + 2.5], ['L', x + width, y + 2.5], ['M', x, y + height / 2 + 0.5], ['L', x + width, y + height / 2 + 0.5], ['M', x, y + height - 1.5], ['L', x + width, y + height - 1.5]];
                    return arr
                }
                function menuball(x, y, width, height) {
                    const h = (height / 3) - 2;
                    let path = [];
                    path = path.concat(this.circle(width - h, y, h, h), this.circle(width - h, y + h + 4, h, h), this.circle(width - h, y + 2 * (h + 4), h, h));
                    return path
                }
            }
        )(ExportingSymbols || (ExportingSymbols = {}));
        return ExportingSymbols
    });
    _registerModule(_modules, 'Extensions/Exporting/Fullscreen.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Utilities.js']], function(AST, U) {
        const {addEvent, fireEvent} = U;
        const composedMembers = [];
        function onChartBeforeRender() {
            this.fullscreen = new Fullscreen(this)
        }
        class Fullscreen {
            static compose(ChartClass) {
                if (U.pushUnique(composedMembers, ChartClass)) {
                    addEvent(ChartClass, 'beforeRender', onChartBeforeRender)
                }
            }
            constructor(chart) {
                this.chart = chart;
                this.isOpen = !1;
                const container = chart.renderTo;
                if (!this.browserProps) {
                    if (typeof container.requestFullscreen === 'function') {
                        this.browserProps = {
                            fullscreenChange: 'fullscreenchange',
                            requestFullscreen: 'requestFullscreen',
                            exitFullscreen: 'exitFullscreen'
                        }
                    } else if (container.mozRequestFullScreen) {
                        this.browserProps = {
                            fullscreenChange: 'mozfullscreenchange',
                            requestFullscreen: 'mozRequestFullScreen',
                            exitFullscreen: 'mozCancelFullScreen'
                        }
                    } else if (container.webkitRequestFullScreen) {
                        this.browserProps = {
                            fullscreenChange: 'webkitfullscreenchange',
                            requestFullscreen: 'webkitRequestFullScreen',
                            exitFullscreen: 'webkitExitFullscreen'
                        }
                    } else if (container.msRequestFullscreen) {
                        this.browserProps = {
                            fullscreenChange: 'MSFullscreenChange',
                            requestFullscreen: 'msRequestFullscreen',
                            exitFullscreen: 'msExitFullscreen'
                        }
                    }
                }
            }
            close() {
                const fullscreen = this
                    , chart = fullscreen.chart
                    , optionsChart = chart.options.chart;
                fireEvent(chart, 'fullscreenClose', null, function() {
                    if (fullscreen.isOpen && fullscreen.browserProps && chart.container.ownerDocument instanceof Document) {
                        chart.container.ownerDocument[fullscreen.browserProps.exitFullscreen]()
                    }
                    if (fullscreen.unbindFullscreenEvent) {
                        fullscreen.unbindFullscreenEvent = fullscreen.unbindFullscreenEvent()
                    }
                    chart.setSize(fullscreen.origWidth, fullscreen.origHeight, !1);
                    fullscreen.origWidth = void 0;
                    fullscreen.origHeight = void 0;
                    optionsChart.width = fullscreen.origWidthOption;
                    optionsChart.height = fullscreen.origHeightOption;
                    fullscreen.origWidthOption = void 0;
                    fullscreen.origHeightOption = void 0;
                    fullscreen.isOpen = !1;
                    fullscreen.setButtonText()
                })
            }
            open() {
                const fullscreen = this
                    , chart = fullscreen.chart
                    , optionsChart = chart.options.chart;
                fireEvent(chart, 'fullscreenOpen', null, function() {
                    if (optionsChart) {
                        fullscreen.origWidthOption = optionsChart.width;
                        fullscreen.origHeightOption = optionsChart.height
                    }
                    fullscreen.origWidth = chart.chartWidth;
                    fullscreen.origHeight = chart.chartHeight;
                    if (fullscreen.browserProps) {
                        const unbindChange = addEvent(chart.container.ownerDocument, fullscreen.browserProps.fullscreenChange, function() {
                            if (fullscreen.isOpen) {
                                fullscreen.isOpen = !1;
                                fullscreen.close()
                            } else {
                                chart.setSize(null, null, !1);
                                fullscreen.isOpen = !0;
                                fullscreen.setButtonText()
                            }
                        });
                        const unbindDestroy = addEvent(chart, 'destroy', unbindChange);
                        fullscreen.unbindFullscreenEvent = () => {
                            unbindChange();
                            unbindDestroy()
                        }
                        ;
                        const promise = chart.renderTo[fullscreen.browserProps.requestFullscreen]();
                        if (promise) {
                            promise['catch'](function() {
                                alert('Full screen is not supported inside a frame.')
                            })
                        }
                    }
                })
            }
            setButtonText() {
                const chart = this.chart
                    , exportDivElements = chart.exportDivElements
                    , exportingOptions = chart.options.exporting
                    , menuItems = (exportingOptions && exportingOptions.buttons && exportingOptions.buttons.contextButton.menuItems)
                    , lang = chart.options.lang;
                if (exportingOptions && exportingOptions.menuItemDefinitions && lang && lang.exitFullscreen && lang.viewFullscreen && menuItems && exportDivElements) {
                    const exportDivElement = exportDivElements[menuItems.indexOf('viewFullscreen')];
                    if (exportDivElement) {
                        AST.setElementHTML(exportDivElement, !this.isOpen ? (exportingOptions.menuItemDefinitions.viewFullscreen.text || lang.viewFullscreen) : lang.exitFullscreen)
                    }
                }
            }
            toggle() {
                const fullscreen = this;
                if (!fullscreen.isOpen) {
                    fullscreen.open()
                } else {
                    fullscreen.close()
                }
            }
        }
        ('');
        ('');
        return Fullscreen
    });
    _registerModule(_modules, 'Core/HttpUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(G, U) {
        const {doc} = G;
        const {createElement, discardElement, merge, objectEach} = U;
        function ajax(settings) {
            const headers = {
                json: 'application/json',
                xml: 'application/xml',
                text: 'text/plain',
                octet: 'application/octet-stream'
            }
                , r = new XMLHttpRequest();
            function handleError(xhr, err) {
                if (settings.error) {
                    settings.error(xhr, err)
                } else {}
            }
            if (!settings.url) {
                return !1
            }
            r.open((settings.type || 'get').toUpperCase(), settings.url, !0);
            if (!settings.headers || !settings.headers['Content-Type']) {
                r.setRequestHeader('Content-Type', headers[settings.dataType || 'json'] || headers.text)
            }
            objectEach(settings.headers, function(val, key) {
                r.setRequestHeader(key, val)
            });
            if (settings.responseType) {
                r.responseType = settings.responseType
            }
            r.onreadystatechange = function() {
                let res;
                if (r.readyState === 4) {
                    if (r.status === 200) {
                        if (settings.responseType !== 'blob') {
                            res = r.responseText;
                            if (settings.dataType === 'json') {
                                try {
                                    res = JSON.parse(res)
                                } catch (e) {
                                    if (e instanceof Error) {
                                        return handleError(r, e)
                                    }
                                }
                            }
                        }
                        return settings.success && settings.success(res, r)
                    }
                    handleError(r, r.responseText)
                }
            }
            ;
            if (settings.data && typeof settings.data !== 'string') {
                settings.data = JSON.stringify(settings.data)
            }
            r.send(settings.data)
        }
        function getJSON(url, success) {
            HttpUtilities.ajax({
                url: url,
                success: success,
                dataType: 'json',
                headers: {
                    'Content-Type': 'text/plain'
                }
            })
        }
        function post(url, data, formAttributes) {
            const form = createElement('form', merge({
                method: 'post',
                action: url,
                enctype: 'multipart/form-data'
            }, formAttributes), {
                display: 'none'
            }, doc.body);
            objectEach(data, function(val, name) {
                createElement('input', {
                    type: 'hidden',
                    name: name,
                    value: val
                }, void 0, form)
            });
            form.submit();
            discardElement(form)
        }
        const HttpUtilities = {
            ajax,
            getJSON,
            post
        };
        ('');
        return HttpUtilities
    });
    _registerModule(_modules, 'Extensions/Exporting/Exporting.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Chart/ChartNavigationComposition.js'], _modules['Core/Defaults.js'], _modules['Extensions/Exporting/ExportingDefaults.js'], _modules['Extensions/Exporting/ExportingSymbols.js'], _modules['Extensions/Exporting/Fullscreen.js'], _modules['Core/Globals.js'], _modules['Core/HttpUtilities.js'], _modules['Core/Utilities.js']], function(AST, Chart, ChartNavigationComposition, D, ExportingDefaults, ExportingSymbols, Fullscreen, G, HU, U) {
        const {defaultOptions, setOptions} = D;
        const {doc, SVG_NS, win} = G;
        const {addEvent, css, createElement, discardElement, extend, find, fireEvent, isObject, merge, objectEach, pick, removeEvent, uniqueKey} = U;
        var Exporting;
        (function(Exporting) {
                const composedMembers = [];
                const inlineDenylist = [/-/, /^(clipPath|cssText|d|height|width)$/, /^font$/, /[lL]ogical(Width|Height)$/, /^parentRule$/, /^(cssRules|ownerRules)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/, /^[0-9]+$/];
                const inlineToAttributes = ['fill', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeWidth', 'textAnchor', 'x', 'y'];
                Exporting.inlineAllowlist = [];
                const unstyledElements = ['clipPath', 'defs', 'desc'];
                let printingChart;
                function addButton(options) {
                    const chart = this
                        , renderer = chart.renderer
                        , btnOptions = merge(chart.options.navigation.buttonOptions, options)
                        , onclick = btnOptions.onclick
                        , menuItems = btnOptions.menuItems
                        , symbolSize = btnOptions.symbolSize || 12;
                    let symbol;
                    if (!chart.btnCount) {
                        chart.btnCount = 0
                    }
                    if (!chart.exportDivElements) {
                        chart.exportDivElements = [];
                        chart.exportSVGElements = []
                    }
                    if (btnOptions.enabled === !1 || !btnOptions.theme) {
                        return
                    }
                    const attr = btnOptions.theme;
                    let callback;
                    if (!chart.styledMode) {
                        attr.fill = pick(attr.fill, "#ffffff");
                        attr.stroke = pick(attr.stroke, 'none')
                    }
                    if (onclick) {
                        callback = function(e) {
                            if (e) {
                                e.stopPropagation()
                            }
                            onclick.call(chart, e)
                        }
                    } else if (menuItems) {
                        callback = function(e) {
                            if (e) {
                                e.stopPropagation()
                            }
                            chart.contextMenu(button.menuClassName, menuItems, button.translateX || 0, button.translateY || 0, button.width || 0, button.height || 0, button);
                            button.setState(2)
                        }
                    }
                    if (btnOptions.text && btnOptions.symbol) {
                        attr.paddingLeft = pick(attr.paddingLeft, 30)
                    } else if (!btnOptions.text) {
                        extend(attr, {
                            width: btnOptions.width,
                            height: btnOptions.height,
                            padding: 0
                        })
                    }
                    if (!chart.styledMode) {
                        attr['stroke-linecap'] = 'round';
                        attr.fill = pick(attr.fill, "#ffffff");
                        attr.stroke = pick(attr.stroke, 'none')
                    }
                    const button = renderer.button(btnOptions.text, 0, 0, callback, attr, void 0, void 0, void 0, void 0, btnOptions.useHTML).addClass(options.className).attr({
                        title: pick(chart.options.lang[btnOptions._titleKey || btnOptions.titleKey], '')
                    });
                    button.menuClassName = (options.menuClassName || 'highcharts-menu-' + chart.btnCount++);
                    if (btnOptions.symbol) {
                        symbol = renderer.symbol(btnOptions.symbol, btnOptions.symbolX - (symbolSize / 2), btnOptions.symbolY - (symbolSize / 2), symbolSize, symbolSize, {
                            width: symbolSize,
                            height: symbolSize
                        }).addClass('highcharts-button-symbol').attr({
                            zIndex: 1
                        }).add(button);
                        if (!chart.styledMode) {
                            symbol.attr({
                                stroke: btnOptions.symbolStroke,
                                fill: btnOptions.symbolFill,
                                'stroke-width': btnOptions.symbolStrokeWidth || 1
                            })
                        }
                    }
                    button.add(chart.exportingGroup).align(extend(btnOptions, {
                        width: button.width,
                        x: pick(btnOptions.x, chart.buttonOffset)
                    }), !0, 'spacingBox');
                    chart.buttonOffset += (((button.width || 0) + btnOptions.buttonSpacing) * (btnOptions.align === 'right' ? -1 : 1));
                    chart.exportSVGElements.push(button, symbol)
                }
                function afterPrint() {
                    const chart = this;
                    if (!chart.printReverseInfo) {
                        return void 0
                    }
                    const {childNodes, origDisplay, resetParams} = chart.printReverseInfo;
                    chart.moveContainers(chart.renderTo);
                    [].forEach.call(childNodes, function(node, i) {
                        if (node.nodeType === 1) {
                            node.style.display = (origDisplay[i] || '')
                        }
                    });
                    chart.isPrinting = !1;
                    if (resetParams) {
                        chart.setSize.apply(chart, resetParams)
                    }
                    delete chart.printReverseInfo;
                    printingChart = void 0;
                    fireEvent(chart, 'afterPrint')
                }
                function beforePrint() {
                    const chart = this
                        , body = doc.body
                        , printMaxWidth = chart.options.exporting.printMaxWidth
                        , printReverseInfo = {
                        childNodes: body.childNodes,
                        origDisplay: [],
                        resetParams: void 0
                    };
                    chart.isPrinting = !0;
                    chart.pointer.reset(null, 0);
                    fireEvent(chart, 'beforePrint');
                    const handleMaxWidth = printMaxWidth && chart.chartWidth > printMaxWidth;
                    if (handleMaxWidth) {
                        printReverseInfo.resetParams = [chart.options.chart.width, void 0, !1];
                        chart.setSize(printMaxWidth, void 0, !1)
                    }
                    [].forEach.call(printReverseInfo.childNodes, function(node, i) {
                        if (node.nodeType === 1) {
                            printReverseInfo.origDisplay[i] = node.style.display;
                            node.style.display = 'none'
                        }
                    });
                    chart.moveContainers(body);
                    chart.printReverseInfo = printReverseInfo
                }
                function chartCallback(chart) {
                    const composition = chart;
                    composition.renderExporting();
                    addEvent(chart, 'redraw', composition.renderExporting);
                    addEvent(chart, 'destroy', composition.destroyExport)
                }
                function compose(ChartClass, SVGRendererClass) {
                    ExportingSymbols.compose(SVGRendererClass);
                    Fullscreen.compose(ChartClass);
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.afterPrint = afterPrint;
                        chartProto.exportChart = exportChart;
                        chartProto.inlineStyles = inlineStyles;
                        chartProto.print = print;
                        chartProto.sanitizeSVG = sanitizeSVG;
                        chartProto.getChartHTML = getChartHTML;
                        chartProto.getSVG = getSVG;
                        chartProto.getSVGForExport = getSVGForExport;
                        chartProto.getFilename = getFilename;
                        chartProto.moveContainers = moveContainers;
                        chartProto.beforePrint = beforePrint;
                        chartProto.contextMenu = contextMenu;
                        chartProto.addButton = addButton;
                        chartProto.destroyExport = destroyExport;
                        chartProto.renderExporting = renderExporting;
                        chartProto.callbacks.push(chartCallback);
                        addEvent(ChartClass, 'init', onChartInit);
                        if (G.isSafari) {
                            G.win.matchMedia('print').addListener(function(mqlEvent) {
                                if (!printingChart) {
                                    return void 0
                                }
                                if (mqlEvent.matches) {
                                    printingChart.beforePrint()
                                } else {
                                    printingChart.afterPrint()
                                }
                            })
                        }
                    }
                    if (U.pushUnique(composedMembers, setOptions)) {
                        defaultOptions.exporting = merge(ExportingDefaults.exporting, defaultOptions.exporting);
                        defaultOptions.lang = merge(ExportingDefaults.lang, defaultOptions.lang);
                        defaultOptions.navigation = merge(ExportingDefaults.navigation, defaultOptions.navigation)
                    }
                }
                Exporting.compose = compose;
                function contextMenu(className, items, x, y, width, height, button) {
                    const chart = this
                        , navOptions = chart.options.navigation
                        , chartWidth = chart.chartWidth
                        , chartHeight = chart.chartHeight
                        , cacheName = 'cache-' + className
                        , menuPadding = Math.max(width, height);
                    let innerMenu, menu = chart[cacheName];
                    if (!menu) {
                        chart.exportContextMenu = chart[cacheName] = menu = createElement('div', {
                            className: className
                        }, {
                            position: 'absolute',
                            zIndex: 1000,
                            padding: menuPadding + 'px',
                            pointerEvents: 'auto',
                            ...chart.renderer.style
                        }, chart.fixedDiv || chart.container);
                        innerMenu = createElement('ul', {
                            className: 'highcharts-menu'
                        }, chart.styledMode ? {} : {
                            listStyle: 'none',
                            margin: 0,
                            padding: 0
                        }, menu);
                        if (!chart.styledMode) {
                            css(innerMenu, extend({
                                MozBoxShadow: '3px 3px 10px #888',
                                WebkitBoxShadow: '3px 3px 10px #888',
                                boxShadow: '3px 3px 10px #888'
                            }, navOptions.menuStyle))
                        }
                        menu.hideMenu = function() {
                            css(menu, {
                                display: 'none'
                            });
                            if (button) {
                                button.setState(0)
                            }
                            chart.openMenu = !1;
                            css(chart.renderTo, {
                                overflow: 'hidden'
                            });
                            css(chart.container, {
                                overflow: 'hidden'
                            });
                            U.clearTimeout(menu.hideTimer);
                            fireEvent(chart, 'exportMenuHidden')
                        }
                        ;
                        chart.exportEvents.push(addEvent(menu, 'mouseleave', function() {
                            menu.hideTimer = win.setTimeout(menu.hideMenu, 500)
                        }), addEvent(menu, 'mouseenter', function() {
                            U.clearTimeout(menu.hideTimer)
                        }), addEvent(doc, 'mouseup', function(e) {
                            if (!chart.pointer.inClass(e.target, className)) {
                                menu.hideMenu()
                            }
                        }), addEvent(menu, 'click', function() {
                            if (chart.openMenu) {
                                menu.hideMenu()
                            }
                        }));
                        items.forEach(function(item) {
                            if (typeof item === 'string') {
                                item = chart.options.exporting.menuItemDefinitions[item]
                            }
                            if (isObject(item, !0)) {
                                let element;
                                if (item.separator) {
                                    element = createElement('hr', void 0, void 0, innerMenu)
                                } else {
                                    if (item.textKey === 'viewData' && chart.isDataTableVisible) {
                                        item.textKey = 'hideData'
                                    }
                                    element = createElement('li', {
                                        className: 'highcharts-menu-item',
                                        onclick: function(e) {
                                            if (e) {
                                                e.stopPropagation()
                                            }
                                            menu.hideMenu();
                                            if (item.onclick) {
                                                item.onclick.apply(chart, arguments)
                                            }
                                        }
                                    }, void 0, innerMenu);
                                    AST.setElementHTML(element, item.text || chart.options.lang[item.textKey]);
                                    if (!chart.styledMode) {
                                        element.onmouseover = function() {
                                            css(this, navOptions.menuItemHoverStyle)
                                        }
                                        ;
                                        element.onmouseout = function() {
                                            css(this, navOptions.menuItemStyle)
                                        }
                                        ;
                                        css(element, extend({
                                            cursor: 'pointer'
                                        }, navOptions.menuItemStyle || {}))
                                    }
                                }
                                chart.exportDivElements.push(element)
                            }
                        });
                        chart.exportDivElements.push(innerMenu, menu);
                        chart.exportMenuWidth = menu.offsetWidth;
                        chart.exportMenuHeight = menu.offsetHeight
                    }
                    const menuStyle = {
                        display: 'block'
                    };
                    if (x + chart.exportMenuWidth > chartWidth) {
                        menuStyle.right = (chartWidth - x - width - menuPadding) + 'px'
                    } else {
                        menuStyle.left = (x - menuPadding) + 'px'
                    }
                    if (y + height + chart.exportMenuHeight > chartHeight && button.alignOptions.verticalAlign !== 'top') {
                        menuStyle.bottom = (chartHeight - y - menuPadding) + 'px'
                    } else {
                        menuStyle.top = (y + height - menuPadding) + 'px'
                    }
                    css(menu, menuStyle);
                    css(chart.renderTo, {
                        overflow: ''
                    });
                    css(chart.container, {
                        overflow: ''
                    });
                    chart.openMenu = !0;
                    fireEvent(chart, 'exportMenuShown')
                }
                function destroyExport(e) {
                    const chart = e ? e.target : this
                        , exportSVGElements = chart.exportSVGElements
                        , exportDivElements = chart.exportDivElements
                        , exportEvents = chart.exportEvents;
                    let cacheName;
                    if (exportSVGElements) {
                        exportSVGElements.forEach( (elem, i) => {
                                if (elem) {
                                    elem.onclick = elem.ontouchstart = null;
                                    cacheName = 'cache-' + elem.menuClassName;
                                    if (chart[cacheName]) {
                                        delete chart[cacheName]
                                    }
                                    exportSVGElements[i] = elem.destroy()
                                }
                            }
                        );
                        exportSVGElements.length = 0
                    }
                    if (chart.exportingGroup) {
                        chart.exportingGroup.destroy();
                        delete chart.exportingGroup
                    }
                    if (exportDivElements) {
                        exportDivElements.forEach(function(elem, i) {
                            if (elem) {
                                U.clearTimeout(elem.hideTimer);
                                removeEvent(elem, 'mouseleave');
                                exportDivElements[i] = elem.onmouseout = elem.onmouseover = elem.ontouchstart = elem.onclick = null;
                                discardElement(elem)
                            }
                        });
                        exportDivElements.length = 0
                    }
                    if (exportEvents) {
                        exportEvents.forEach(function(unbind) {
                            unbind()
                        });
                        exportEvents.length = 0
                    }
                }
                function exportChart(exportingOptions, chartOptions) {
                    const svg = this.getSVGForExport(exportingOptions, chartOptions);
                    exportingOptions = merge(this.options.exporting, exportingOptions);
                    HU.post(exportingOptions.url, {
                        filename: exportingOptions.filename ? exportingOptions.filename.replace(/\//g, '-') : this.getFilename(),
                        type: exportingOptions.type,
                        width: exportingOptions.width,
                        scale: exportingOptions.scale,
                        svg: svg
                    }, exportingOptions.formAttributes)
                }
                function getChartHTML() {
                    if (this.styledMode) {
                        this.inlineStyles()
                    }
                    return this.container.innerHTML
                }
                function getFilename() {
                    const s = this.userOptions.title && this.userOptions.title.text;
                    let filename = this.options.exporting.filename;
                    if (filename) {
                        return filename.replace(/\//g, '-')
                    }
                    if (typeof s === 'string') {
                        filename = s.toLowerCase().replace(/<\/?[^>]+(>|$)/g, '').replace(/[\s_]+/g, '-').replace(/[^a-z0-9\-]/g, '').replace(/^[\-]+/g, '').replace(/[\-]+/g, '-').substr(0, 24).replace(/[\-]+$/g, '')
                    }
                    if (!filename || filename.length < 5) {
                        filename = 'chart'
                    }
                    return filename
                }
                function getSVG(chartOptions) {
                    const chart = this;
                    let svg, seriesOptions, options = merge(chart.options, chartOptions);
                    options.plotOptions = merge(chart.userOptions.plotOptions, chartOptions && chartOptions.plotOptions);
                    options.time = merge(chart.userOptions.time, chartOptions && chartOptions.time);
                    const sandbox = createElement('div', null, {
                        position: 'absolute',
                        top: '-9999em',
                        width: chart.chartWidth + 'px',
                        height: chart.chartHeight + 'px'
                    }, doc.body);
                    const cssWidth = chart.renderTo.style.width
                        , cssHeight = chart.renderTo.style.height
                        , sourceWidth = options.exporting.sourceWidth || options.chart.width || (/px$/.test(cssWidth) && parseInt(cssWidth, 10)) || (options.isGantt ? 800 : 600)
                        , sourceHeight = options.exporting.sourceHeight || options.chart.height || (/px$/.test(cssHeight) && parseInt(cssHeight, 10)) || 400;
                    extend(options.chart, {
                        animation: !1,
                        renderTo: sandbox,
                        forExport: !0,
                        renderer: 'SVGRenderer',
                        width: sourceWidth,
                        height: sourceHeight
                    });
                    options.exporting.enabled = !1;
                    delete options.data;
                    options.series = [];
                    chart.series.forEach(function(serie) {
                        seriesOptions = merge(serie.userOptions, {
                            animation: !1,
                            enableMouseTracking: !1,
                            showCheckbox: !1,
                            visible: serie.visible
                        });
                        if (!seriesOptions.isInternal) {
                            options.series.push(seriesOptions)
                        }
                    });
                    const colls = {};
                    chart.axes.forEach(function(axis) {
                        if (!axis.userOptions.internalKey) {
                            axis.userOptions.internalKey = uniqueKey()
                        }
                        if (!axis.options.isInternal) {
                            if (!colls[axis.coll]) {
                                colls[axis.coll] = !0;
                                options[axis.coll] = []
                            }
                            options[axis.coll].push(merge(axis.userOptions, {
                                visible: axis.visible
                            }))
                        }
                    });
                    const chartCopy = new chart.constructor(options,chart.callback);
                    if (chartOptions) {
                        ['xAxis', 'yAxis', 'series'].forEach(function(coll) {
                            const collOptions = {};
                            if (chartOptions[coll]) {
                                collOptions[coll] = chartOptions[coll];
                                chartCopy.update(collOptions)
                            }
                        })
                    }
                    chart.axes.forEach(function(axis) {
                        const axisCopy = find(chartCopy.axes, function(copy) {
                            return copy.options.internalKey === axis.userOptions.internalKey
                        })
                            , extremes = axis.getExtremes()
                            , userMin = extremes.userMin
                            , userMax = extremes.userMax;
                        if (axisCopy && ((typeof userMin !== 'undefined' && userMin !== axisCopy.min) || (typeof userMax !== 'undefined' && userMax !== axisCopy.max))) {
                            axisCopy.setExtremes(userMin, userMax, !0, !1)
                        }
                    });
                    svg = chartCopy.getChartHTML();
                    fireEvent(this, 'getSVG', {
                        chartCopy: chartCopy
                    });
                    svg = chart.sanitizeSVG(svg, options);
                    options = null;
                    chartCopy.destroy();
                    discardElement(sandbox);
                    return svg
                }
                function getSVGForExport(options, chartOptions) {
                    const chartExportingOptions = this.options.exporting;
                    return this.getSVG(merge({
                        chart: {
                            borderRadius: 0
                        }
                    }, chartExportingOptions.chartOptions, chartOptions, {
                        exporting: {
                            sourceWidth: ((options && options.sourceWidth) || chartExportingOptions.sourceWidth),
                            sourceHeight: ((options && options.sourceHeight) || chartExportingOptions.sourceHeight)
                        }
                    }))
                }
                function hyphenate(prop) {
                    return prop.replace(/([A-Z])/g, function(a, b) {
                        return '-' + b.toLowerCase()
                    })
                }
                function inlineStyles() {
                    const denylist = inlineDenylist
                        , allowlist = Exporting.inlineAllowlist
                        , defaultStyles = {};
                    let dummySVG;
                    const iframe = doc.createElement('iframe');
                    css(iframe, {
                        width: '1px',
                        height: '1px',
                        visibility: 'hidden'
                    });
                    doc.body.appendChild(iframe);
                    const iframeDoc = (iframe.contentWindow && iframe.contentWindow.document);
                    if (iframeDoc) {
                        iframeDoc.body.appendChild(iframeDoc.createElementNS(SVG_NS, 'svg'))
                    }
                    function recurse(node) {
                        const filteredStyles = {};
                        let styles, parentStyles, dummy, denylisted, allowlisted, i;
                        function filterStyles(val, prop) {
                            denylisted = allowlisted = !1;
                            if (allowlist.length) {
                                i = allowlist.length;
                                while (i-- && !allowlisted) {
                                    allowlisted = allowlist[i].test(prop)
                                }
                                denylisted = !allowlisted
                            }
                            if (prop === 'transform' && val === 'none') {
                                denylisted = !0
                            }
                            i = denylist.length;
                            while (i-- && !denylisted) {
                                denylisted = (denylist[i].test(prop) || typeof val === 'function')
                            }
                            if (!denylisted) {
                                if ((parentStyles[prop] !== val || node.nodeName === 'svg') && defaultStyles[node.nodeName][prop] !== val) {
                                    if (!inlineToAttributes || inlineToAttributes.indexOf(prop) !== -1) {
                                        if (val) {
                                            node.setAttribute(hyphenate(prop), val)
                                        }
                                    } else {
                                        filteredStyles[prop] = val
                                    }
                                }
                            }
                        }
                        if (iframeDoc && node.nodeType === 1 && unstyledElements.indexOf(node.nodeName) === -1) {
                            styles = win.getComputedStyle(node, null);
                            parentStyles = node.nodeName === 'svg' ? {} : win.getComputedStyle(node.parentNode, null);
                            if (!defaultStyles[node.nodeName]) {
                                dummySVG = iframeDoc.getElementsByTagName('svg')[0];
                                dummy = iframeDoc.createElementNS(node.namespaceURI, node.nodeName);
                                dummySVG.appendChild(dummy);
                                const s = win.getComputedStyle(dummy, null)
                                    , defaults = {};
                                for (const key in s) {
                                    if (typeof s[key] === 'string' && !/^[0-9]+$/.test(key)) {
                                        defaults[key] = s[key]
                                    }
                                }
                                defaultStyles[node.nodeName] = defaults;
                                if (node.nodeName === 'text') {
                                    delete defaultStyles.text.fill
                                }
                                dummySVG.removeChild(dummy)
                            }
                            for (const p in styles) {
                                if (G.isFirefox || G.isMS || G.isSafari || Object.hasOwnProperty.call(styles, p)) {
                                    filterStyles(styles[p], p)
                                }
                            }
                            css(node, filteredStyles);
                            if (node.nodeName === 'svg') {
                                node.setAttribute('stroke-width', '1px')
                            }
                            if (node.nodeName === 'text') {
                                return
                            }
                            [].forEach.call(node.children || node.childNodes, recurse)
                        }
                    }
                    function tearDown() {
                        dummySVG.parentNode.removeChild(dummySVG);
                        iframe.parentNode.removeChild(iframe)
                    }
                    recurse(this.container.querySelector('svg'));
                    tearDown()
                }
                function moveContainers(moveTo) {
                    const chart = this;
                    (chart.fixedDiv ? [chart.fixedDiv, chart.scrollingContainer] : [chart.container]).forEach(function(div) {
                        moveTo.appendChild(div)
                    })
                }
                function onChartInit() {
                    const chart = this
                        , update = (prop, options, redraw) => {
                            chart.isDirtyExporting = !0;
                            merge(!0, chart.options[prop], options);
                            if (pick(redraw, !0)) {
                                chart.redraw()
                            }
                        }
                    ;
                    chart.exporting = {
                        update: function(options, redraw) {
                            update('exporting', options, redraw)
                        }
                    };
                    ChartNavigationComposition.compose(chart).navigation.addUpdate( (options, redraw) => {
                            update('navigation', options, redraw)
                        }
                    )
                }
                function print() {
                    const chart = this;
                    if (chart.isPrinting) {
                        return
                    }
                    printingChart = chart;
                    if (!G.isSafari) {
                        chart.beforePrint()
                    }
                    setTimeout( () => {
                            win.focus();
                            win.print();
                            if (!G.isSafari) {
                                setTimeout( () => {
                                        chart.afterPrint()
                                    }
                                    , 1000)
                            }
                        }
                        , 1)
                }
                function renderExporting() {
                    const chart = this
                        , exportingOptions = chart.options.exporting
                        , buttons = exportingOptions.buttons
                        , isDirty = chart.isDirtyExporting || !chart.exportSVGElements;
                    chart.buttonOffset = 0;
                    if (chart.isDirtyExporting) {
                        chart.destroyExport()
                    }
                    if (isDirty && exportingOptions.enabled !== !1) {
                        chart.exportEvents = [];
                        chart.exportingGroup = chart.exportingGroup || chart.renderer.g('exporting-group').attr({
                            zIndex: 3
                        }).add();
                        objectEach(buttons, function(button) {
                            chart.addButton(button)
                        });
                        chart.isDirtyExporting = !1
                    }
                }
                function sanitizeSVG(svg, options) {
                    const split = svg.indexOf('</svg>') + 6;
                    let html = svg.substr(split);
                    svg = svg.substr(0, split);
                    if (options && options.exporting && options.exporting.allowHTML) {
                        if (html) {
                            html = '<foreignObject x="0" y="0" ' + 'width="' + options.chart.width + '" ' + 'height="' + options.chart.height + '">' + '<body xmlns="http://www.w3.org/1999/xhtml">' + html.replace(/(<(?:img|br).*?(?=\>))>/g, '$1 />') + '</body>' + '</foreignObject>';
                            svg = svg.replace('</svg>', html + '</svg>')
                        }
                    }
                    svg = svg.replace(/zIndex="[^"]+"/g, '').replace(/symbolName="[^"]+"/g, '').replace(/jQuery[0-9]+="[^"]+"/g, '').replace(/url\(("|&quot;)(.*?)("|&quot;)\;?\)/g, 'url($2)').replace(/url\([^#]+#/g, 'url(#').replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (|NS[0-9]+\:)href=/g, ' xlink:href=').replace(/\n/, ' ').replace(/(fill|stroke)="rgba\(([ 0-9]+,[ 0-9]+,[ 0-9]+),([ 0-9\.]+)\)"/g, '$1="rgb($2)" $1-opacity="$3"').replace(/&nbsp;/g, '\u00A0').replace(/&shy;/g, '\u00AD');
                    return svg
                }
            }
        )(Exporting || (Exporting = {}));
        ('');
        ('');
        return Exporting
    });
    _registerModule(_modules, 'masters/modules/exporting.src.js', [_modules['Core/Globals.js'], _modules['Extensions/Exporting/Exporting.js'], _modules['Core/HttpUtilities.js']], function(Highcharts, Exporting, HttpUtilities) {
        const G = Highcharts;
        G.HttpUtilities = HttpUtilities;
        G.ajax = HttpUtilities.ajax;
        G.getJSON = HttpUtilities.getJSON;
        G.post = HttpUtilities.post;
        Exporting.compose(G.Chart, G.Renderer)
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Client side exporting module
 *
 * (c) 2015-2021 Torstein Honsi / Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/offline-exporting', ['highcharts', 'highcharts/modules/exporting'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Extensions/DownloadURL.js', [_modules['Core/Globals.js']], function(H) {
        const {isSafari, win, win: {document: doc}} = H;
        const domurl = win.URL || win.webkitURL || win;
        function dataURLtoBlob(dataURL) {
            const parts = dataURL.replace(/filename=.*;/, '').match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
            if (parts && parts.length > 3 && (win.atob) && win.ArrayBuffer && win.Uint8Array && win.Blob && (domurl.createObjectURL)) {
                const binStr = win.atob(parts[3])
                    , buf = new win.ArrayBuffer(binStr.length)
                    , binary = new win.Uint8Array(buf);
                for (let i = 0; i < binary.length; ++i) {
                    binary[i] = binStr.charCodeAt(i)
                }
                return domurl.createObjectURL(new win.Blob([binary],{
                    'type': parts[1]
                }))
            }
        }
        function downloadURL(dataURL, filename) {
            const nav = win.navigator
                , a = doc.createElement('a');
            if (typeof dataURL !== 'string' && !(dataURL instanceof String) && nav.msSaveOrOpenBlob) {
                nav.msSaveOrOpenBlob(dataURL, filename);
                return
            }
            dataURL = '' + dataURL;
            const isOldEdgeBrowser = /Edge\/\d+/.test(nav.userAgent)
                , safariBlob = (isSafari && typeof dataURL === 'string' && dataURL.indexOf('data:application/pdf') === 0);
            if (safariBlob || isOldEdgeBrowser || dataURL.length > 2000000) {
                dataURL = dataURLtoBlob(dataURL) || '';
                if (!dataURL) {
                    throw new Error('Failed to convert to blob')
                }
            }
            if (typeof a.download !== 'undefined') {
                a.href = dataURL;
                a.download = filename;
                doc.body.appendChild(a);
                a.click();
                doc.body.removeChild(a)
            } else {
                try {
                    if (!win.open(dataURL, 'chart')) {
                        throw new Error('Failed to open window')
                    }
                } catch {
                    win.location.href = dataURL
                }
            }
        }
        const DownloadURL = {
            dataURLtoBlob,
            downloadURL
        };
        return DownloadURL
    });
    _registerModule(_modules, 'Extensions/OfflineExporting/OfflineExportingDefaults.js', [], function() {
        const OfflineExportingDefaults = {
            libURL: 'https://code.highcharts.com/11.2.0/lib/',
            menuItemDefinitions: {
                downloadPNG: {
                    textKey: 'downloadPNG',
                    onclick: function() {
                        this.exportChartLocal()
                    }
                },
                downloadJPEG: {
                    textKey: 'downloadJPEG',
                    onclick: function() {
                        this.exportChartLocal({
                            type: 'image/jpeg'
                        })
                    }
                },
                downloadSVG: {
                    textKey: 'downloadSVG',
                    onclick: function() {
                        this.exportChartLocal({
                            type: 'image/svg+xml'
                        })
                    }
                },
                downloadPDF: {
                    textKey: 'downloadPDF',
                    onclick: function() {
                        this.exportChartLocal({
                            type: 'application/pdf'
                        })
                    }
                }
            }
        };
        return OfflineExportingDefaults
    });
    _registerModule(_modules, 'Extensions/OfflineExporting/OfflineExporting.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Defaults.js'], _modules['Extensions/DownloadURL.js'], _modules['Extensions/Exporting/Exporting.js'], _modules['Core/Globals.js'], _modules['Core/HttpUtilities.js'], _modules['Extensions/OfflineExporting/OfflineExportingDefaults.js'], _modules['Core/Utilities.js']], function(AST, Chart, D, DownloadURL, Exporting, H, HU, OfflineExportingDefaults, U) {
        const {defaultOptions} = D;
        const {downloadURL} = DownloadURL;
        const {win, doc} = H;
        const {ajax} = HU;
        const {addEvent, error, extend, fireEvent, merge} = U;
        AST.allowedAttributes.push('data-z-index', 'fill-opacity', 'rx', 'ry', 'stroke-dasharray', 'stroke-linejoin', 'text-anchor', 'transform', 'version', 'viewBox', 'visibility', 'xmlns', 'xmlns:xlink');
        AST.allowedTags.push('desc', 'clippath', 'g');
        const composedMembers = [];
        var OfflineExporting;
        (function(OfflineExporting) {
                OfflineExporting.CanVGRenderer = {},
                    OfflineExporting.domurl = win.URL || win.webkitURL || win,
                    OfflineExporting.loadEventDeferDelay = H.isMS ? 150 : 0;
                function compose(ChartClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.getSVGForLocalExport = getSVGForLocalExport;
                        chartProto.exportChartLocal = exportChartLocal;
                        merge(!0, defaultOptions.exporting, OfflineExportingDefaults)
                    }
                    return ChartClass
                }
                OfflineExporting.compose = compose;
                function downloadSVGLocal(svg, options, failCallback, successCallback) {
                    const dummySVGContainer = doc.createElement('div')
                        , imageType = options.type || 'image/png'
                        , filename = ((options.filename || 'chart') + '.' + (imageType === 'image/svg+xml' ? 'svg' : imageType.split('/')[1]))
                        , scale = options.scale || 1;
                    let svgurl, blob, finallyHandler, libURL = (options.libURL || defaultOptions.exporting.libURL), objectURLRevoke = !0, pdfFont = options.pdfFont;
                    libURL = libURL.slice(-1) !== '/' ? libURL + '/' : libURL;
                    const loadPdfFonts = (svgElement, callback) => {
                            const hasNonASCII = (s) => (/[^\u0000-\u007F\u200B]+/.test(s));
                            const addFont = (variant, base64) => {
                                    win.jspdf.jsPDF.API.events.push(['initialized', function() {
                                        this.addFileToVFS(variant, base64);
                                        this.addFont(variant, 'HighchartsFont', variant);
                                        if (!this.getFontList().HighchartsFont) {
                                            this.setFont('HighchartsFont')
                                        }
                                    }
                                    ])
                                }
                            ;
                            if (pdfFont && !hasNonASCII(svgElement.textContent || '')) {
                                pdfFont = void 0
                            }
                            const variants = ['normal', 'italic', 'bold', 'bolditalic'];
                            let normalBase64;
                            const shiftAndLoadVariant = () => {
                                    const variant = variants.shift();
                                    if (!variant) {
                                        return callback()
                                    }
                                    const url = pdfFont && pdfFont[variant];
                                    if (url) {
                                        ajax({
                                            url,
                                            responseType: 'blob',
                                            success: (data, xhr) => {
                                                const reader = new FileReader();
                                                reader.onloadend = function() {
                                                    if (typeof this.result === 'string') {
                                                        const base64 = this.result.split(',')[1];
                                                        addFont(variant, base64);
                                                        if (variant === 'normal') {
                                                            normalBase64 = base64
                                                        }
                                                    }
                                                    shiftAndLoadVariant()
                                                }
                                                ;
                                                reader.readAsDataURL(xhr.response)
                                            }
                                            ,
                                            error: shiftAndLoadVariant
                                        })
                                    } else {
                                        if (normalBase64) {
                                            addFont(variant, normalBase64)
                                        }
                                        shiftAndLoadVariant()
                                    }
                                }
                            ;
                            shiftAndLoadVariant()
                        }
                    ;
                    const downloadPDF = () => {
                            AST.setElementHTML(dummySVGContainer, svg);
                            const textElements = dummySVGContainer.getElementsByTagName('text')
                                , setStylePropertyFromParents = function(el, propName) {
                                let curParent = el;
                                while (curParent && curParent !== dummySVGContainer) {
                                    if (curParent.style[propName]) {
                                        let value = curParent.style[propName];
                                        if (propName === 'fontSize' && /em$/.test(value)) {
                                            value = Math.round(parseFloat(value) * 16) + 'px'
                                        }
                                        el.style[propName] = value;
                                        break
                                    }
                                    curParent = curParent.parentNode
                                }
                            };
                            let titleElements, outlineElements;
                            [].forEach.call(textElements, function(el) {
                                ['fontFamily', 'fontSize'].forEach( (property) => {
                                        setStylePropertyFromParents(el, property)
                                    }
                                );
                                el.style.fontFamily = pdfFont && pdfFont.normal ? 'HighchartsFont' : String(el.style.fontFamily && el.style.fontFamily.split(' ').splice(-1));
                                titleElements = el.getElementsByTagName('title');
                                [].forEach.call(titleElements, function(titleElement) {
                                    el.removeChild(titleElement)
                                });
                                outlineElements = el.getElementsByClassName('highcharts-text-outline');
                                while (outlineElements.length > 0) {
                                    el.removeChild(outlineElements[0])
                                }
                            });
                            const svgNode = dummySVGContainer.querySelector('svg');
                            if (svgNode) {
                                loadPdfFonts(svgNode, () => {
                                        svgToPdf(svgNode, 0, scale, (pdfData) => {
                                                try {
                                                    downloadURL(pdfData, filename);
                                                    if (successCallback) {
                                                        successCallback()
                                                    }
                                                } catch (e) {
                                                    failCallback(e)
                                                }
                                            }
                                        )
                                    }
                                )
                            }
                        }
                    ;
                    if (imageType === 'image/svg+xml') {
                        try {
                            if (typeof win.MSBlobBuilder !== 'undefined') {
                                blob = new win.MSBlobBuilder();
                                blob.append(svg);
                                svgurl = blob.getBlob('image/svg+xml')
                            } else {
                                svgurl = svgToDataUrl(svg)
                            }
                            downloadURL(svgurl, filename);
                            if (successCallback) {
                                successCallback()
                            }
                        } catch (e) {
                            failCallback(e)
                        }
                    } else if (imageType === 'application/pdf') {
                        if (win.jspdf && win.jspdf.jsPDF) {
                            downloadPDF()
                        } else {
                            objectURLRevoke = !0;
                            getScript(libURL + 'jspdf.js', function() {
                                getScript(libURL + 'svg2pdf.js', downloadPDF)
                            })
                        }
                    } else {
                        svgurl = svgToDataUrl(svg);
                        finallyHandler = function() {
                            try {
                                OfflineExporting.domurl.revokeObjectURL(svgurl)
                            } catch (e) {}
                        }
                        ;
                        imageToDataUrl(svgurl, imageType, {}, scale, function(imageURL) {
                            try {
                                downloadURL(imageURL, filename);
                                if (successCallback) {
                                    successCallback()
                                }
                            } catch (e) {
                                failCallback(e)
                            }
                        }, function() {
                            const canvas = doc.createElement('canvas')
                                , ctx = canvas.getContext('2d')
                                , imageWidth = svg.match(/^<svg[^>]*width\s*=\s*\"?(\d+)\"?[^>]*>/)[1] * scale
                                , imageHeight = svg.match(/^<svg[^>]*height\s*=\s*\"?(\d+)\"?[^>]*>/)[1] * scale
                                , downloadWithCanVG = function() {
                                const v = win.canvg.Canvg.fromString(ctx, svg);
                                v.start();
                                try {
                                    downloadURL(win.navigator.msSaveOrOpenBlob ? canvas.msToBlob() : canvas.toDataURL(imageType), filename);
                                    if (successCallback) {
                                        successCallback()
                                    }
                                } catch (e) {
                                    failCallback(e)
                                } finally {
                                    finallyHandler()
                                }
                            };
                            canvas.width = imageWidth;
                            canvas.height = imageHeight;
                            if (win.canvg) {
                                downloadWithCanVG()
                            } else {
                                objectURLRevoke = !0;
                                getScript(libURL + 'canvg.js', function() {
                                    downloadWithCanVG()
                                })
                            }
                        }, failCallback, failCallback, function() {
                            if (objectURLRevoke) {
                                finallyHandler()
                            }
                        })
                    }
                }
                OfflineExporting.downloadSVGLocal = downloadSVGLocal;
                function exportChartLocal(exportingOptions, chartOptions) {
                    const chart = this
                        , options = merge(chart.options.exporting, exportingOptions)
                        , fallbackToExportServer = function(err) {
                        if (options.fallbackToExportServer === !1) {
                            if (options.error) {
                                options.error(options, err)
                            } else {
                                error(28, !0)
                            }
                        } else {
                            chart.exportChart(options)
                        }
                    }
                        , svgSuccess = function(svg) {
                        if (svg.indexOf('<foreignObject') > -1 && options.type !== 'image/svg+xml' && (H.isMS || options.type === 'application/pdf')) {
                            fallbackToExportServer(new Error('Image type not supported for charts with embedded HTML'))
                        } else {
                            OfflineExporting.downloadSVGLocal(svg, extend({
                                filename: chart.getFilename()
                            }, options), fallbackToExportServer, () => fireEvent(chart, 'exportChartLocalSuccess'))
                        }
                    }
                        , hasExternalImages = function() {
                        return [].some.call(chart.container.getElementsByTagName('image'), function(image) {
                            const href = image.getAttribute('href');
                            return (href !== '' && typeof href === 'string' && href.indexOf('data:') !== 0)
                        })
                    };
                    if (H.isMS && chart.styledMode && !Exporting.inlineAllowlist.length) {
                        Exporting.inlineAllowlist.push(/^blockSize/, /^border/, /^caretColor/, /^color/, /^columnRule/, /^columnRuleColor/, /^cssFloat/, /^cursor/, /^fill$/, /^fillOpacity/, /^font/, /^inlineSize/, /^length/, /^lineHeight/, /^opacity/, /^outline/, /^parentRule/, /^rx$/, /^ry$/, /^stroke/, /^textAlign/, /^textAnchor/, /^textDecoration/, /^transform/, /^vectorEffect/, /^visibility/, /^x$/, /^y$/)
                    }
                    if ((H.isMS && (options.type === 'application/pdf' || chart.container.getElementsByTagName('image').length && options.type !== 'image/svg+xml')) || (options.type === 'application/pdf' && hasExternalImages())) {
                        fallbackToExportServer(new Error('Image type not supported for this chart/browser.'));
                        return
                    }
                    chart.getSVGForLocalExport(options, chartOptions || {}, fallbackToExportServer, svgSuccess)
                }
                function getScript(scriptLocation, callback) {
                    const head = doc.getElementsByTagName('head')[0]
                        , script = doc.createElement('script');
                    script.type = 'text/javascript';
                    script.src = scriptLocation;
                    script.onload = callback;
                    script.onerror = function() {
                        error('Error loading script ' + scriptLocation)
                    }
                    ;
                    head.appendChild(script)
                }
                OfflineExporting.getScript = getScript;
                function getSVGForLocalExport(options, chartOptions, failCallback, successCallback) {
                    const chart = this
                        , sanitize = (svg) => chart.sanitizeSVG(svg, chartCopyOptions)
                        , checkDone = () => {
                            if (images && imagesEmbedded === imagesLength) {
                                successCallback(sanitize(chartCopyContainer.innerHTML))
                            }
                        }
                        , embeddedSuccess = (imageURL, imageType, callbackArgs) => {
                            ++imagesEmbedded;
                            callbackArgs.imageElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imageURL);
                            checkDone()
                        }
                    ;
                    let el, chartCopyContainer, chartCopyOptions, href = null, images, imagesLength = 0, imagesEmbedded = 0;
                    chart.unbindGetSVG = addEvent(chart, 'getSVG', (e) => {
                            chartCopyOptions = e.chartCopy.options;
                            chartCopyContainer = e.chartCopy.container.cloneNode(!0);
                            images = chartCopyContainer && chartCopyContainer.getElementsByTagName('image') || [];
                            imagesLength = images.length
                        }
                    );
                    chart.getSVGForExport(options, chartOptions);
                    try {
                        if (!images || !images.length) {
                            successCallback(sanitize(chartCopyContainer.innerHTML));
                            return
                        }
                        for (let i = 0; i < images.length; i++) {
                            el = images[i];
                            href = el.getAttributeNS('http://www.w3.org/1999/xlink', 'href');
                            if (href) {
                                OfflineExporting.imageToDataUrl(href, 'image/png', {
                                    imageElement: el
                                }, options.scale, embeddedSuccess, failCallback, failCallback, failCallback)
                            } else {
                                imagesEmbedded++;
                                el.parentNode.removeChild(el);
                                i--;
                                checkDone()
                            }
                        }
                    } catch (e) {
                        failCallback(e)
                    }
                    chart.unbindGetSVG()
                }
                function imageToDataUrl(imageURL, imageType, callbackArgs, scale, successCallback, taintedCallback, noCanvasSupportCallback, failedLoadCallback, finallyCallback) {
                    let img = new win.Image(), taintedHandler;
                    const loadHandler = () => {
                            setTimeout(function() {
                                const canvas = doc.createElement('canvas')
                                    , ctx = canvas.getContext && canvas.getContext('2d');
                                let dataURL;
                                try {
                                    if (!ctx) {
                                        noCanvasSupportCallback(imageURL, imageType, callbackArgs, scale)
                                    } else {
                                        canvas.height = img.height * scale;
                                        canvas.width = img.width * scale;
                                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                                        try {
                                            dataURL = canvas.toDataURL(imageType);
                                            successCallback(dataURL, imageType, callbackArgs, scale)
                                        } catch (e) {
                                            taintedHandler(imageURL, imageType, callbackArgs, scale)
                                        }
                                    }
                                } finally {
                                    if (finallyCallback) {
                                        finallyCallback(imageURL, imageType, callbackArgs, scale)
                                    }
                                }
                            }, OfflineExporting.loadEventDeferDelay)
                        }
                        , errorHandler = () => {
                            failedLoadCallback(imageURL, imageType, callbackArgs, scale);
                            if (finallyCallback) {
                                finallyCallback(imageURL, imageType, callbackArgs, scale)
                            }
                        }
                    ;
                    taintedHandler = () => {
                        img = new win.Image();
                        taintedHandler = taintedCallback;
                        img.crossOrigin = 'Anonymous';
                        img.onload = loadHandler;
                        img.onerror = errorHandler;
                        img.src = imageURL
                    }
                    ;
                    img.onload = loadHandler;
                    img.onerror = errorHandler;
                    img.src = imageURL
                }
                OfflineExporting.imageToDataUrl = imageToDataUrl;
                function svgToDataUrl(svg) {
                    const userAgent = win.navigator.userAgent;
                    const webKit = (userAgent.indexOf('WebKit') > -1 && userAgent.indexOf('Chrome') < 0);
                    try {
                        if (!webKit && svg.indexOf('<foreignObject') === -1) {
                            return OfflineExporting.domurl.createObjectURL(new win.Blob([svg],{
                                type: 'image/svg+xml;charset-utf-16'
                            }))
                        }
                    } catch (e) {}
                    return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg)
                }
                OfflineExporting.svgToDataUrl = svgToDataUrl;
                function svgToPdf(svgElement, margin, scale, callback) {
                    const width = (Number(svgElement.getAttribute('width')) + 2 * margin) * scale
                        , height = (Number(svgElement.getAttribute('height')) + 2 * margin) * scale
                        , pdfDoc = new win.jspdf.jsPDF(height > width ? 'p' : 'l','pt',[width, height]);
                    [].forEach.call(svgElement.querySelectorAll('*[visibility="hidden"]'), function(node) {
                        node.parentNode.removeChild(node)
                    });
                    const gradients = svgElement.querySelectorAll('linearGradient');
                    for (let index = 0; index < gradients.length; index++) {
                        const gradient = gradients[index];
                        const stops = gradient.querySelectorAll('stop');
                        let i = 0;
                        while (i < stops.length && stops[i].getAttribute('offset') === '0' && stops[i + 1].getAttribute('offset') === '0') {
                            stops[i].remove();
                            i++
                        }
                    }
                    [].forEach.call(svgElement.querySelectorAll('tspan'), (tspan) => {
                            if (tspan.textContent === '\u200B') {
                                tspan.textContent = ' ';
                                tspan.setAttribute('dx', -5)
                            }
                        }
                    );
                    pdfDoc.svg(svgElement, {
                        x: 0,
                        y: 0,
                        width,
                        height,
                        removeInvalid: !0
                    }).then( () => callback(pdfDoc.output('datauristring')))
                }
                OfflineExporting.svgToPdf = svgToPdf
            }
        )(OfflineExporting || (OfflineExporting = {}));
        return OfflineExporting
    });
    _registerModule(_modules, 'masters/modules/offline-exporting.src.js', [_modules['Core/Globals.js'], _modules['Extensions/DownloadURL.js'], _modules['Extensions/OfflineExporting/OfflineExporting.js']], function(Highcharts, DownloadURL, OfflineExporting) {
        const G = Highcharts;
        G.dataURLtoBlob = DownloadURL.dataURLtoBlob;
        G.downloadSVGLocal = OfflineExporting.downloadSVGLocal;
        G.downloadURL = DownloadURL.downloadURL;
        OfflineExporting.compose(G.Chart)
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Exporting module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/export-data', ['highcharts', 'highcharts/modules/exporting'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Extensions/DownloadURL.js', [_modules['Core/Globals.js']], function(H) {
        const {isSafari, win, win: {document: doc}} = H;
        const domurl = win.URL || win.webkitURL || win;
        function dataURLtoBlob(dataURL) {
            const parts = dataURL.replace(/filename=.*;/, '').match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
            if (parts && parts.length > 3 && (win.atob) && win.ArrayBuffer && win.Uint8Array && win.Blob && (domurl.createObjectURL)) {
                const binStr = win.atob(parts[3])
                    , buf = new win.ArrayBuffer(binStr.length)
                    , binary = new win.Uint8Array(buf);
                for (let i = 0; i < binary.length; ++i) {
                    binary[i] = binStr.charCodeAt(i)
                }
                return domurl.createObjectURL(new win.Blob([binary],{
                    'type': parts[1]
                }))
            }
        }
        function downloadURL(dataURL, filename) {
            const nav = win.navigator
                , a = doc.createElement('a');
            if (typeof dataURL !== 'string' && !(dataURL instanceof String) && nav.msSaveOrOpenBlob) {
                nav.msSaveOrOpenBlob(dataURL, filename);
                return
            }
            dataURL = '' + dataURL;
            const isOldEdgeBrowser = /Edge\/\d+/.test(nav.userAgent)
                , safariBlob = (isSafari && typeof dataURL === 'string' && dataURL.indexOf('data:application/pdf') === 0);
            if (safariBlob || isOldEdgeBrowser || dataURL.length > 2000000) {
                dataURL = dataURLtoBlob(dataURL) || '';
                if (!dataURL) {
                    throw new Error('Failed to convert to blob')
                }
            }
            if (typeof a.download !== 'undefined') {
                a.href = dataURL;
                a.download = filename;
                doc.body.appendChild(a);
                a.click();
                doc.body.removeChild(a)
            } else {
                try {
                    if (!win.open(dataURL, 'chart')) {
                        throw new Error('Failed to open window')
                    }
                } catch {
                    win.location.href = dataURL
                }
            }
        }
        const DownloadURL = {
            dataURLtoBlob,
            downloadURL
        };
        return DownloadURL
    });
    _registerModule(_modules, 'Extensions/ExportData/ExportDataDefaults.js', [], function() {
        const exporting = {
            csv: {
                annotations: {
                    itemDelimiter: '; ',
                    join: !1
                },
                columnHeaderFormatter: null,
                dateFormat: '%Y-%m-%d %H:%M:%S',
                decimalPoint: null,
                itemDelimiter: null,
                lineDelimiter: '\n'
            },
            showTable: !1,
            useMultiLevelHeaders: !0,
            useRowspanHeaders: !0
        };
        const lang = {
            downloadCSV: 'Download CSV',
            downloadXLS: 'Download XLS',
            exportData: {
                annotationHeader: 'Annotations',
                categoryHeader: 'Category',
                categoryDatetimeHeader: 'DateTime'
            },
            viewData: 'View data table',
            hideData: 'Hide data table'
        };
        const ExportDataDefaults = {
            exporting,
            lang
        };
        ('');
        return ExportDataDefaults
    });
    _registerModule(_modules, 'Extensions/ExportData/ExportData.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Extensions/ExportData/ExportDataDefaults.js'], _modules['Core/Globals.js'], _modules['Core/Defaults.js'], _modules['Extensions/DownloadURL.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(AST, ExportDataDefaults, H, D, DownloadURL, SeriesRegistry, U) {
        const {doc, win} = H;
        const {getOptions, setOptions} = D;
        const {downloadURL} = DownloadURL;
        const {series: SeriesClass, seriesTypes: {arearange: AreaRangeSeries, gantt: GanttSeries, map: MapSeries, mapbubble: MapBubbleSeries, treemap: TreemapSeries, xrange: XRangeSeries}} = SeriesRegistry;
        const {addEvent, defined, extend, find, fireEvent, isNumber, pick} = U;
        const composedMembers = [];
        function chartDownloadCSV() {
            const csv = this.getCSV(!0);
            downloadURL(getBlobFromContent(csv, 'text/csv') || 'data:text/csv,\uFEFF' + encodeURIComponent(csv), this.getFilename() + '.csv')
        }
        function chartDownloadXLS() {
            const uri = 'data:application/vnd.ms-excel;base64,'
                , template = '<html xmlns:o="urn:schemas-microsoft-com:office:office" ' + 'xmlns:x="urn:schemas-microsoft-com:office:excel" ' + 'xmlns="http://www.w3.org/TR/REC-html40">' + '<head><!--[if gte mso 9]><xml><x:ExcelWorkbook>' + '<x:ExcelWorksheets><x:ExcelWorksheet>' + '<x:Name>Ark1</x:Name>' + '<x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions>' + '</x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook>' + '</xml><![endif]-->' + '<style>td{border:none;font-family: Calibri, sans-serif;} ' + '.number{mso-number-format:"0.00";} ' + '.text{ mso-number-format:"\@";}</style>' + '<meta name=ProgId content=Excel.Sheet>' + '<meta charset=UTF-8>' + '</head><body>' + this.getTable(!0) + '</body></html>'
                , base64 = function(s) {
                return win.btoa(unescape(encodeURIComponent(s)))
            };
            downloadURL(getBlobFromContent(template, 'application/vnd.ms-excel') || uri + base64(template), this.getFilename() + '.xls')
        }
        function chartGetCSV(useLocalDecimalPoint) {
            let csv = '';
            const rows = this.getDataRows()
                , csvOptions = this.options.exporting.csv
                , decimalPoint = pick(csvOptions.decimalPoint, csvOptions.itemDelimiter !== ',' && useLocalDecimalPoint ? (1.1).toLocaleString()[1] : '.')
                , itemDelimiter = pick(csvOptions.itemDelimiter, decimalPoint === ',' ? ';' : ',')
                , lineDelimiter = csvOptions.lineDelimiter;
            rows.forEach( (row, i) => {
                    let val = ''
                        , j = row.length;
                    while (j--) {
                        val = row[j];
                        if (typeof val === 'string') {
                            val = `"${val}"`
                        }
                        if (typeof val === 'number') {
                            if (decimalPoint !== '.') {
                                val = val.toString().replace('.', decimalPoint)
                            }
                        }
                        row[j] = val
                    }
                    row.length = rows.length ? rows[0].length : 0;
                    csv += row.join(itemDelimiter);
                    if (i < rows.length - 1) {
                        csv += lineDelimiter
                    }
                }
            );
            return csv
        }
        function chartGetDataRows(multiLevelHeaders) {
            const hasParallelCoords = this.hasParallelCoordinates
                , time = this.time
                , csvOptions = ((this.options.exporting && this.options.exporting.csv) || {})
                , xAxes = this.xAxis
                , rows = {}
                , rowArr = []
                , topLevelColumnTitles = []
                , columnTitles = []
                , langOptions = this.options.lang
                , exportDataOptions = langOptions.exportData
                , categoryHeader = exportDataOptions.categoryHeader
                , categoryDatetimeHeader = exportDataOptions.categoryDatetimeHeader
                , columnHeaderFormatter = function(item, key, keyLength) {
                if (csvOptions.columnHeaderFormatter) {
                    const s = csvOptions.columnHeaderFormatter(item, key, keyLength);
                    if (s !== !1) {
                        return s
                    }
                }
                if (!item) {
                    return categoryHeader
                }
                if (!(item instanceof SeriesClass)) {
                    return (item.options.title && item.options.title.text) || (item.dateTime ? categoryDatetimeHeader : categoryHeader)
                }
                if (multiLevelHeaders) {
                    return {
                        columnTitle: keyLength > 1 ? key : item.name,
                        topLevelColumnTitle: item.name
                    }
                }
                return item.name + (keyLength > 1 ? ' (' + key + ')' : '')
            }
                , getCategoryAndDateTimeMap = function(series, pointArrayMap, pIdx) {
                const categoryMap = {}
                    , dateTimeValueAxisMap = {};
                pointArrayMap.forEach(function(prop) {
                    const axisName = ((series.keyToAxis && series.keyToAxis[prop]) || prop) + 'Axis'
                        , axis = isNumber(pIdx) ? series.chart[axisName][pIdx] : series[axisName];
                    categoryMap[prop] = (axis && axis.categories) || [];
                    dateTimeValueAxisMap[prop] = (axis && axis.dateTime)
                });
                return {
                    categoryMap: categoryMap,
                    dateTimeValueAxisMap: dateTimeValueAxisMap
                }
            }
                , getPointArray = function(series, xAxis) {
                const pointArrayMap = series.pointArrayMap || ['y']
                    , namedPoints = series.data.some( (d) => (typeof d.y !== 'undefined') && d.name);
                if (namedPoints && xAxis && !xAxis.categories && series.exportKey !== 'name') {
                    return ['x', ...pointArrayMap]
                }
                return pointArrayMap
            }
                , xAxisIndices = [];
            let xAxis, dataRows, columnTitleObj, i = 0, x, xTitle;
            this.series.forEach(function(series) {
                const keys = series.options.keys
                    , xAxis = series.xAxis
                    , pointArrayMap = keys || getPointArray(series, xAxis)
                    , valueCount = pointArrayMap.length
                    , xTaken = !series.requireSorting && {}
                    , xAxisIndex = xAxes.indexOf(xAxis);
                let categoryAndDatetimeMap = getCategoryAndDateTimeMap(series, pointArrayMap), mockSeries, j;
                if (series.options.includeInDataExport !== !1 && !series.options.isInternal && series.visible !== !1) {
                    if (!find(xAxisIndices, function(index) {
                        return index[0] === xAxisIndex
                    })) {
                        xAxisIndices.push([xAxisIndex, i])
                    }
                    j = 0;
                    while (j < valueCount) {
                        columnTitleObj = columnHeaderFormatter(series, pointArrayMap[j], pointArrayMap.length);
                        columnTitles.push(columnTitleObj.columnTitle || columnTitleObj);
                        if (multiLevelHeaders) {
                            topLevelColumnTitles.push(columnTitleObj.topLevelColumnTitle || columnTitleObj)
                        }
                        j++
                    }
                    mockSeries = {
                        chart: series.chart,
                        autoIncrement: series.autoIncrement,
                        options: series.options,
                        pointArrayMap: series.pointArrayMap,
                        index: series.index
                    };
                    const seriesIndex = mockSeries.index;
                    series.options.data.forEach(function eachData(options, pIdx) {
                        const mockPoint = {
                            series: mockSeries
                        };
                        let key, prop, val;
                        if (hasParallelCoords) {
                            categoryAndDatetimeMap = getCategoryAndDateTimeMap(series, pointArrayMap, pIdx)
                        }
                        series.pointClass.prototype.applyOptions.apply(mockPoint, [options]);
                        const name = series.data[pIdx] && series.data[pIdx].name;
                        key = (mockPoint.x ?? '') + ',' + name;
                        j = 0;
                        if (!xAxis || series.exportKey === 'name' || (!hasParallelCoords && xAxis && xAxis.hasNames) && name) {
                            key = name
                        }
                        if (xTaken) {
                            if (xTaken[key]) {
                                key += '|' + pIdx
                            }
                            xTaken[key] = !0
                        }
                        if (!rows[key]) {
                            rows[key] = [];
                            rows[key].xValues = [];
                            const arr = [];
                            for (let i = 0; i < series.chart.series.length; i++) {
                                arr[i] = 0
                            }
                            rows[key].pointers = arr;
                            rows[key].pointers[series.index] = 1
                        } else {
                            const modifiedKey = `${key},${rows[key].pointers[series.index]}`
                                , originalKey = key;
                            if (rows[key].pointers[series.index]) {
                                if (!rows[modifiedKey]) {
                                    rows[modifiedKey] = [];
                                    rows[modifiedKey].xValues = [];
                                    rows[modifiedKey].pointers = []
                                }
                                key = modifiedKey
                            }
                            rows[originalKey].pointers[series.index] += 1
                        }
                        rows[key].x = mockPoint.x;
                        rows[key].name = name;
                        rows[key].xValues[xAxisIndex] = mockPoint.x;
                        while (j < valueCount) {
                            prop = pointArrayMap[j];
                            val = mockPoint[prop];
                            rows[key][i + j] = pick(categoryAndDatetimeMap.categoryMap[prop][val], categoryAndDatetimeMap.dateTimeValueAxisMap[prop] ? time.dateFormat(csvOptions.dateFormat, val) : null, val);
                            j++
                        }
                    });
                    i = i + j
                }
            });
            for (x in rows) {
                if (Object.hasOwnProperty.call(rows, x)) {
                    rowArr.push(rows[x])
                }
            }
            let xAxisIndex, column;
            dataRows = multiLevelHeaders ? [topLevelColumnTitles, columnTitles] : [columnTitles];
            i = xAxisIndices.length;
            while (i--) {
                xAxisIndex = xAxisIndices[i][0];
                column = xAxisIndices[i][1];
                xAxis = xAxes[xAxisIndex];
                rowArr.sort(function(a, b) {
                    return a.xValues[xAxisIndex] - b.xValues[xAxisIndex]
                });
                xTitle = columnHeaderFormatter(xAxis);
                dataRows[0].splice(column, 0, xTitle);
                if (multiLevelHeaders && dataRows[1]) {
                    dataRows[1].splice(column, 0, xTitle)
                }
                rowArr.forEach(function(row) {
                    let category = row.name;
                    if (xAxis && !defined(category)) {
                        if (xAxis.dateTime) {
                            if (row.x instanceof Date) {
                                row.x = row.x.getTime()
                            }
                            category = time.dateFormat(csvOptions.dateFormat, row.x)
                        } else if (xAxis.categories) {
                            category = pick(xAxis.names[row.x], xAxis.categories[row.x], row.x)
                        } else {
                            category = row.x
                        }
                    }
                    row.splice(column, 0, category)
                })
            }
            dataRows = dataRows.concat(rowArr);
            fireEvent(this, 'exportData', {
                dataRows: dataRows
            });
            return dataRows
        }
        function chartGetTable(useLocalDecimalPoint) {
            const serialize = (node) => {
                    if (!node.tagName || node.tagName === '#text') {
                        return node.textContent || ''
                    }
                    const attributes = node.attributes;
                    let html = `<${node.tagName}`;
                    if (attributes) {
                        Object.keys(attributes).forEach( (key) => {
                                const value = attributes[key];
                                html += ` ${key}="${value}"`
                            }
                        )
                    }
                    html += '>';
                    html += node.textContent || '';
                    (node.children || []).forEach( (child) => {
                            html += serialize(child)
                        }
                    );
                    html += `</${node.tagName}>`;
                    return html
                }
            ;
            const tree = this.getTableAST(useLocalDecimalPoint);
            return serialize(tree)
        }
        function chartGetTableAST(useLocalDecimalPoint) {
            let rowLength = 0;
            const treeChildren = [];
            const options = this.options
                , decimalPoint = useLocalDecimalPoint ? (1.1).toLocaleString()[1] : '.'
                , useMultiLevelHeaders = pick(options.exporting.useMultiLevelHeaders, !0)
                , rows = this.getDataRows(useMultiLevelHeaders)
                , topHeaders = useMultiLevelHeaders ? rows.shift() : null
                , subHeaders = rows.shift()
                , isRowEqual = function(row1, row2) {
                let i = row1.length;
                if (row2.length === i) {
                    while (i--) {
                        if (row1[i] !== row2[i]) {
                            return !1
                        }
                    }
                } else {
                    return !1
                }
                return !0
            }
                , getCellHTMLFromValue = function(tagName, classes, attributes, value) {
                let textContent = pick(value, '')
                    , className = 'highcharts-text' + (classes ? ' ' + classes : '');
                if (typeof textContent === 'number') {
                    textContent = textContent.toString();
                    if (decimalPoint === ',') {
                        textContent = textContent.replace('.', decimalPoint)
                    }
                    className = 'highcharts-number'
                } else if (!value) {
                    className = 'highcharts-empty'
                }
                attributes = extend({
                    'class': className
                }, attributes);
                return {
                    tagName,
                    attributes,
                    textContent
                }
            }
                , getTableHeaderHTML = function(topheaders, subheaders, rowLength) {
                const theadChildren = [];
                let i = 0, len = rowLength || subheaders && subheaders.length, next, cur, curColspan = 0, rowspan;
                if (useMultiLevelHeaders && topheaders && subheaders && !isRowEqual(topheaders, subheaders)) {
                    const trChildren = [];
                    for (; i < len; ++i) {
                        cur = topheaders[i];
                        next = topheaders[i + 1];
                        if (cur === next) {
                            ++curColspan
                        } else if (curColspan) {
                            trChildren.push(getCellHTMLFromValue('th', 'highcharts-table-topheading', {
                                scope: 'col',
                                colspan: curColspan + 1
                            }, cur));
                            curColspan = 0
                        } else {
                            if (cur === subheaders[i]) {
                                if (options.exporting.useRowspanHeaders) {
                                    rowspan = 2;
                                    delete subheaders[i]
                                } else {
                                    rowspan = 1;
                                    subheaders[i] = ''
                                }
                            } else {
                                rowspan = 1
                            }
                            const cell = getCellHTMLFromValue('th', 'highcharts-table-topheading', {
                                scope: 'col'
                            }, cur);
                            if (rowspan > 1 && cell.attributes) {
                                cell.attributes.valign = 'top';
                                cell.attributes.rowspan = rowspan
                            }
                            trChildren.push(cell)
                        }
                    }
                    theadChildren.push({
                        tagName: 'tr',
                        children: trChildren
                    })
                }
                if (subheaders) {
                    const trChildren = [];
                    for (i = 0,
                             len = subheaders.length; i < len; ++i) {
                        if (typeof subheaders[i] !== 'undefined') {
                            trChildren.push(getCellHTMLFromValue('th', null, {
                                scope: 'col'
                            }, subheaders[i]))
                        }
                    }
                    theadChildren.push({
                        tagName: 'tr',
                        children: trChildren
                    })
                }
                return {
                    tagName: 'thead',
                    children: theadChildren
                }
            };
            if (options.exporting.tableCaption !== !1) {
                treeChildren.push({
                    tagName: 'caption',
                    attributes: {
                        'class': 'highcharts-table-caption'
                    },
                    textContent: pick(options.exporting.tableCaption, (options.title.text ? options.title.text : 'Chart'))
                })
            }
            for (let i = 0, len = rows.length; i < len; ++i) {
                if (rows[i].length > rowLength) {
                    rowLength = rows[i].length
                }
            }
            treeChildren.push(getTableHeaderHTML(topHeaders, subHeaders, Math.max(rowLength, subHeaders.length)));
            const trs = [];
            rows.forEach(function(row) {
                const trChildren = [];
                for (let j = 0; j < rowLength; j++) {
                    trChildren.push(getCellHTMLFromValue(j ? 'td' : 'th', null, j ? {} : {
                        scope: 'row'
                    }, row[j]))
                }
                trs.push({
                    tagName: 'tr',
                    children: trChildren
                })
            });
            treeChildren.push({
                tagName: 'tbody',
                children: trs
            });
            const e = {
                tree: {
                    tagName: 'table',
                    id: `highcharts-data-table-${this.index}`,
                    children: treeChildren
                }
            };
            fireEvent(this, 'aftergetTableAST', e);
            return e.tree
        }
        function chartHideData() {
            this.toggleDataTable(!1)
        }
        function chartToggleDataTable(show) {
            show = pick(show, !this.isDataTableVisible);
            const createContainer = show && !this.dataTableDiv;
            if (createContainer) {
                this.dataTableDiv = doc.createElement('div');
                this.dataTableDiv.className = 'highcharts-data-table';
                this.renderTo.parentNode.insertBefore(this.dataTableDiv, this.renderTo.nextSibling)
            }
            if (this.dataTableDiv) {
                const style = this.dataTableDiv.style
                    , oldDisplay = style.display;
                style.display = show ? 'block' : 'none';
                if (show) {
                    this.dataTableDiv.innerHTML = AST.emptyHTML;
                    const ast = new AST([this.getTableAST()]);
                    ast.addToDOM(this.dataTableDiv);
                    fireEvent(this, 'afterViewData', {
                        element: this.dataTableDiv,
                        wasHidden: createContainer || oldDisplay !== style.display
                    })
                } else {
                    fireEvent(this, 'afterHideData')
                }
            }
            this.isDataTableVisible = show;
            const exportDivElements = this.exportDivElements
                , options = this.options.exporting
                , menuItems = options && options.buttons && options.buttons.contextButton.menuItems
                , lang = this.options.lang;
            if (options && options.menuItemDefinitions && lang && lang.viewData && lang.hideData && menuItems && exportDivElements) {
                const exportDivElement = exportDivElements[menuItems.indexOf('viewData')];
                if (exportDivElement) {
                    AST.setElementHTML(exportDivElement, this.isDataTableVisible ? lang.hideData : lang.viewData)
                }
            }
        }
        function chartViewData() {
            this.toggleDataTable(!0)
        }
        function compose(ChartClass) {
            if (U.pushUnique(composedMembers, ChartClass)) {
                addEvent(ChartClass, 'afterViewData', onChartAfterViewData);
                addEvent(ChartClass, 'render', onChartRenderer);
                const chartProto = ChartClass.prototype;
                chartProto.downloadCSV = chartDownloadCSV;
                chartProto.downloadXLS = chartDownloadXLS;
                chartProto.getCSV = chartGetCSV;
                chartProto.getDataRows = chartGetDataRows;
                chartProto.getTable = chartGetTable;
                chartProto.getTableAST = chartGetTableAST;
                chartProto.hideData = chartHideData;
                chartProto.toggleDataTable = chartToggleDataTable;
                chartProto.viewData = chartViewData
            }
            if (U.pushUnique(composedMembers, setOptions)) {
                const exportingOptions = getOptions().exporting;
                if (exportingOptions) {
                    extend(exportingOptions.menuItemDefinitions, {
                        downloadCSV: {
                            textKey: 'downloadCSV',
                            onclick: function() {
                                this.downloadCSV()
                            }
                        },
                        downloadXLS: {
                            textKey: 'downloadXLS',
                            onclick: function() {
                                this.downloadXLS()
                            }
                        },
                        viewData: {
                            textKey: 'viewData',
                            onclick: function() {
                                this.toggleDataTable()
                            }
                        }
                    });
                    if (exportingOptions.buttons && exportingOptions.buttons.contextButton.menuItems) {
                        exportingOptions.buttons.contextButton.menuItems.push('separator', 'downloadCSV', 'downloadXLS', 'viewData')
                    }
                }
                setOptions(ExportDataDefaults)
            }
            if (AreaRangeSeries && U.pushUnique(composedMembers, AreaRangeSeries)) {
                AreaRangeSeries.prototype.keyToAxis = {
                    low: 'y',
                    high: 'y'
                }
            }
            if (GanttSeries && U.pushUnique(composedMembers, GanttSeries)) {
                GanttSeries.prototype.exportKey = 'name';
                GanttSeries.prototype.keyToAxis = {
                    start: 'x',
                    end: 'x'
                }
            }
            if (XRangeSeries && U.pushUnique(composedMembers, XRangeSeries)) {
                XRangeSeries.prototype.keyToAxis = {
                    x2: 'x'
                }
            }
            if (MapSeries && U.pushUnique(composedMembers, MapSeries)) {
                MapSeries.prototype.exportKey = 'name'
            }
            if (MapBubbleSeries && U.pushUnique(composedMembers, MapBubbleSeries)) {
                MapBubbleSeries.prototype.exportKey = 'name'
            }
            if (TreemapSeries && U.pushUnique(composedMembers, TreemapSeries)) {
                TreemapSeries.prototype.exportKey = 'name'
            }
        }
        function getBlobFromContent(content, type) {
            const nav = win.navigator
                , domurl = win.URL || win.webkitURL || win;
            try {
                if ((nav.msSaveOrOpenBlob) && win.MSBlobBuilder) {
                    const blob = new win.MSBlobBuilder();
                    blob.append(content);
                    return blob.getBlob('image/svg+xml')
                }
                return domurl.createObjectURL(new win.Blob(['\uFEFF' + content],{
                    type: type
                }))
            } catch (e) {}
        }
        function onChartAfterViewData() {
            const chart = this
                , dataTableDiv = chart.dataTableDiv
                , getCellValue = (tr, index) => tr.children[index].textContent
                , comparer = (index, ascending) => (a, b) => {
                    const sort = (v1, v2) => (v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2) ? v1 - v2 : v1.toString().localeCompare(v2));
                    return sort(getCellValue(ascending ? a : b, index), getCellValue(ascending ? b : a, index))
                }
            ;
            if (dataTableDiv && chart.options.exporting && chart.options.exporting.allowTableSorting) {
                const row = dataTableDiv.querySelector('thead tr');
                if (row) {
                    row.childNodes.forEach( (th) => {
                            const table = th.closest('table');
                            th.addEventListener('click', function() {
                                const rows = [...dataTableDiv.querySelectorAll('tr:not(thead tr)')]
                                    , headers = [...th.parentNode.children];
                                rows.sort(comparer(headers.indexOf(th), chart.ascendingOrderInTable = !chart.ascendingOrderInTable)).forEach( (tr) => {
                                        table.appendChild(tr)
                                    }
                                );
                                headers.forEach( (th) => {
                                        ['highcharts-sort-ascending', 'highcharts-sort-descending'].forEach( (className) => {
                                                if (th.classList.contains(className)) {
                                                    th.classList.remove(className)
                                                }
                                            }
                                        )
                                    }
                                );
                                th.classList.add(chart.ascendingOrderInTable ? 'highcharts-sort-ascending' : 'highcharts-sort-descending')
                            })
                        }
                    )
                }
            }
        }
        function onChartRenderer() {
            if (this.options && this.options.exporting && this.options.exporting.showTable && !this.options.chart.forExport) {
                this.viewData()
            }
        }
        const ExportData = {
            compose
        };
        ('');
        return ExportData
    });
    _registerModule(_modules, 'masters/modules/export-data.src.js', [_modules['Core/Globals.js'], _modules['Extensions/DownloadURL.js'], _modules['Extensions/ExportData/ExportData.js']], function(Highcharts, DownloadURL, ExportData) {
        const G = Highcharts;
        G.dataURLtoBlob = DownloadURL.dataURLtoBlob;
        G.downloadURL = DownloadURL.downloadURL;
        ExportData.compose(G.Chart)
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Data module
 *
 * (c) 2012-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/data', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Core/HttpUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(G, U) {
        const {doc} = G;
        const {createElement, discardElement, merge, objectEach} = U;
        function ajax(settings) {
            const headers = {
                json: 'application/json',
                xml: 'application/xml',
                text: 'text/plain',
                octet: 'application/octet-stream'
            }
                , r = new XMLHttpRequest();
            function handleError(xhr, err) {
                if (settings.error) {
                    settings.error(xhr, err)
                } else {}
            }
            if (!settings.url) {
                return !1
            }
            r.open((settings.type || 'get').toUpperCase(), settings.url, !0);
            if (!settings.headers || !settings.headers['Content-Type']) {
                r.setRequestHeader('Content-Type', headers[settings.dataType || 'json'] || headers.text)
            }
            objectEach(settings.headers, function(val, key) {
                r.setRequestHeader(key, val)
            });
            if (settings.responseType) {
                r.responseType = settings.responseType
            }
            r.onreadystatechange = function() {
                let res;
                if (r.readyState === 4) {
                    if (r.status === 200) {
                        if (settings.responseType !== 'blob') {
                            res = r.responseText;
                            if (settings.dataType === 'json') {
                                try {
                                    res = JSON.parse(res)
                                } catch (e) {
                                    if (e instanceof Error) {
                                        return handleError(r, e)
                                    }
                                }
                            }
                        }
                        return settings.success && settings.success(res, r)
                    }
                    handleError(r, r.responseText)
                }
            }
            ;
            if (settings.data && typeof settings.data !== 'string') {
                settings.data = JSON.stringify(settings.data)
            }
            r.send(settings.data)
        }
        function getJSON(url, success) {
            HttpUtilities.ajax({
                url: url,
                success: success,
                dataType: 'json',
                headers: {
                    'Content-Type': 'text/plain'
                }
            })
        }
        function post(url, data, formAttributes) {
            const form = createElement('form', merge({
                method: 'post',
                action: url,
                enctype: 'multipart/form-data'
            }, formAttributes), {
                display: 'none'
            }, doc.body);
            objectEach(data, function(val, name) {
                createElement('input', {
                    type: 'hidden',
                    name: name,
                    value: val
                }, void 0, form)
            });
            form.submit();
            discardElement(form)
        }
        const HttpUtilities = {
            ajax,
            getJSON,
            post
        };
        ('');
        return HttpUtilities
    });
    _registerModule(_modules, 'Extensions/Data.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/HttpUtilities.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Chart, D, G, HU, Point, SeriesRegistry, U) {
        const {getOptions} = D;
        const {doc} = G;
        const {ajax} = HU;
        const {seriesTypes} = SeriesRegistry;
        const {addEvent, defined, extend, fireEvent, isNumber, merge, objectEach, pick, splat} = U;
        function getFreeIndexes(numberOfColumns, seriesBuilders) {
            const freeIndexes = []
                , freeIndexValues = [];
            let s, i, referencedIndexes;
            for (i = 0; i < numberOfColumns; i = i + 1) {
                freeIndexes.push(!0)
            }
            for (s = 0; s < seriesBuilders.length; s = s + 1) {
                referencedIndexes = seriesBuilders[s].getReferencedColumnIndexes();
                for (i = 0; i < referencedIndexes.length; i = i + 1) {
                    freeIndexes[referencedIndexes[i]] = !1
                }
            }
            for (i = 0; i < freeIndexes.length; i = i + 1) {
                if (freeIndexes[i]) {
                    freeIndexValues.push(i)
                }
            }
            return freeIndexValues
        }
        function hasURLOption(options) {
            return Boolean(options && (options.rowsURL || options.csvURL || options.columnsURL))
        }
        class Data {
            static data(dataOptions, chartOptions={}, chart) {
                return new Data(dataOptions,chartOptions,chart)
            }
            static rowsToColumns(rows) {
                let row, rowsLength, col, colsLength, columns;
                if (rows) {
                    columns = [];
                    rowsLength = rows.length;
                    for (row = 0; row < rowsLength; row++) {
                        colsLength = rows[row].length;
                        for (col = 0; col < colsLength; col++) {
                            if (!columns[col]) {
                                columns[col] = []
                            }
                            columns[col][row] = rows[row][col]
                        }
                    }
                }
                return columns
            }
            constructor(dataOptions, chartOptions={}, chart) {
                this.rowsToColumns = Data.rowsToColumns;
                this.dateFormats = {
                    'YYYY/mm/dd': {
                        regex: /^([0-9]{4})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{1,2})$/,
                        parser: function(match) {
                            return (match ? Date.UTC(+match[1], match[2] - 1, +match[3]) : NaN)
                        }
                    },
                    'dd/mm/YYYY': {
                        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
                        parser: function(match) {
                            return (match ? Date.UTC(+match[3], match[2] - 1, +match[1]) : NaN)
                        },
                        alternative: 'mm/dd/YYYY'
                    },
                    'mm/dd/YYYY': {
                        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{4})$/,
                        parser: function(match) {
                            return (match ? Date.UTC(+match[3], match[1] - 1, +match[2]) : NaN)
                        }
                    },
                    'dd/mm/YY': {
                        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
                        parser: function(match) {
                            if (!match) {
                                return NaN
                            }
                            const d = new Date();
                            let year = +match[3];
                            if (year > (d.getFullYear() - 2000)) {
                                year += 1900
                            } else {
                                year += 2000
                            }
                            return Date.UTC(year, match[2] - 1, +match[1])
                        },
                        alternative: 'mm/dd/YY'
                    },
                    'mm/dd/YY': {
                        regex: /^([0-9]{1,2})[\-\/\.]([0-9]{1,2})[\-\/\.]([0-9]{2})$/,
                        parser: function(match) {
                            return (match ? Date.UTC(+match[3] + 2000, match[1] - 1, +match[2]) : NaN)
                        }
                    }
                };
                this.chart = chart;
                this.chartOptions = chartOptions;
                this.options = dataOptions;
                this.rawColumns = [];
                this.init(dataOptions, chartOptions, chart)
            }
            init(dataOptions, chartOptions, chart) {
                let decimalPoint = dataOptions.decimalPoint, hasData;
                if (chartOptions) {
                    this.chartOptions = chartOptions
                }
                if (chart) {
                    this.chart = chart
                }
                if (decimalPoint !== '.' && decimalPoint !== ',') {
                    decimalPoint = void 0
                }
                this.options = dataOptions;
                this.columns = (dataOptions.columns || this.rowsToColumns(dataOptions.rows) || []);
                this.firstRowAsNames = pick(dataOptions.firstRowAsNames, this.firstRowAsNames, !0);
                this.decimalRegex = (decimalPoint && new RegExp('^(-?[0-9]+)' + decimalPoint + '([0-9]+)$'));
                if (this.liveDataTimeout !== void 0) {
                    clearTimeout(this.liveDataTimeout)
                }
                this.rawColumns = [];
                if (this.columns.length) {
                    this.dataFound();
                    hasData = !hasURLOption(dataOptions)
                }
                if (!hasData) {
                    hasData = this.fetchLiveData()
                }
                if (!hasData) {
                    hasData = Boolean(this.parseCSV().length)
                }
                if (!hasData) {
                    hasData = Boolean(this.parseTable().length)
                }
                if (!hasData) {
                    hasData = this.parseGoogleSpreadsheet()
                }
                if (!hasData && dataOptions.afterComplete) {
                    dataOptions.afterComplete()
                }
            }
            getColumnDistribution() {
                const chartOptions = this.chartOptions
                    , options = this.options
                    , xColumns = []
                    , getValueCount = function(type) {
                    return (seriesTypes[type || 'line'].prototype.pointArrayMap || [0]).length
                }
                    , getPointArrayMap = function(type) {
                    return seriesTypes[type || 'line'].prototype.pointArrayMap
                }
                    , globalType = (chartOptions && chartOptions.chart && chartOptions.chart.type)
                    , individualCounts = []
                    , seriesBuilders = []
                    , seriesMapping = ((options && options.seriesMapping) || (chartOptions && chartOptions.series && chartOptions.series.map(function() {
                    return {
                        x: 0
                    }
                })) || []);
                let seriesIndex = 0, i;
                ((chartOptions && chartOptions.series) || []).forEach( (series) => {
                        individualCounts.push(getValueCount(series.type || globalType))
                    }
                );
                seriesMapping.forEach( (mapping) => {
                        xColumns.push(mapping.x || 0)
                    }
                );
                if (xColumns.length === 0) {
                    xColumns.push(0)
                }
                seriesMapping.forEach( (mapping) => {
                        const builder = new SeriesBuilder()
                            , numberOfValueColumnsNeeded = individualCounts[seriesIndex] || getValueCount(globalType)
                            , seriesArr = (chartOptions && chartOptions.series) || []
                            , series = seriesArr[seriesIndex] || {}
                            , defaultPointArrayMap = getPointArrayMap(series.type || globalType)
                            , pointArrayMap = defaultPointArrayMap || ['y'];
                        if (defined(mapping.x) || series.isCartesian || !defaultPointArrayMap) {
                            builder.addColumnReader(mapping.x, 'x')
                        }
                        objectEach(mapping, function(val, name) {
                            if (name !== 'x') {
                                builder.addColumnReader(val, name)
                            }
                        });
                        for (i = 0; i < numberOfValueColumnsNeeded; i++) {
                            if (!builder.hasReader(pointArrayMap[i])) {
                                builder.addColumnReader(void 0, pointArrayMap[i])
                            }
                        }
                        seriesBuilders.push(builder);
                        seriesIndex++
                    }
                );
                let globalPointArrayMap = getPointArrayMap(globalType);
                if (typeof globalPointArrayMap === 'undefined') {
                    globalPointArrayMap = ['y']
                }
                this.valueCount = {
                    global: getValueCount(globalType),
                    xColumns: xColumns,
                    individual: individualCounts,
                    seriesBuilders: seriesBuilders,
                    globalPointArrayMap: globalPointArrayMap
                }
            }
            dataFound() {
                if (this.options.switchRowsAndColumns) {
                    this.columns = this.rowsToColumns(this.columns)
                }
                this.getColumnDistribution();
                this.parseTypes();
                if (this.parsed() !== !1) {
                    this.complete()
                }
            }
            parseCSV(inOptions) {
                const self = this
                    , columns = this.columns = []
                    , options = inOptions || this.options
                    , startColumn = (typeof options.startColumn !== 'undefined' && options.startColumn) ? options.startColumn : 0
                    , endColumn = options.endColumn || Number.MAX_VALUE
                    , dataTypes = []
                    , potDelimiters = {
                    ',': 0,
                    ';': 0,
                    '\t': 0
                };
                let csv = options.csv, startRow = (typeof options.startRow !== 'undefined' && options.startRow ? options.startRow : 0), endRow = options.endRow || Number.MAX_VALUE, itemDelimiter, lines, rowIt = 0;
                function parseRow(columnStr, rowNumber, noAdd, callbacks) {
                    let i = 0
                        , c = ''
                        , cl = ''
                        , cn = ''
                        , token = ''
                        , actualColumn = 0
                        , column = 0;
                    function read(j) {
                        c = columnStr[j];
                        cl = columnStr[j - 1];
                        cn = columnStr[j + 1]
                    }
                    function pushType(type) {
                        if (dataTypes.length < column + 1) {
                            dataTypes.push([type])
                        }
                        if (dataTypes[column][dataTypes[column].length - 1] !== type) {
                            dataTypes[column].push(type)
                        }
                    }
                    function push() {
                        if (startColumn > actualColumn || actualColumn > endColumn) {
                            ++actualColumn;
                            token = '';
                            return
                        }
                        if (!isNaN(parseFloat(token)) && isFinite(token)) {
                            token = parseFloat(token);
                            pushType('number')
                        } else if (!isNaN(Date.parse(token))) {
                            token = token.replace(/\//g, '-');
                            pushType('date')
                        } else {
                            pushType('string')
                        }
                        if (columns.length < column + 1) {
                            columns.push([])
                        }
                        if (!noAdd) {
                            columns[column][rowNumber] = token
                        }
                        token = '';
                        ++column;
                        ++actualColumn
                    }
                    if (!columnStr.trim().length) {
                        return
                    }
                    if (columnStr.trim()[0] === '#') {
                        return
                    }
                    for (; i < columnStr.length; i++) {
                        read(i);
                        if (c === '"') {
                            read(++i);
                            while (i < columnStr.length) {
                                if (c === '"' && cl !== '"' && cn !== '"') {
                                    break
                                }
                                if (c !== '"' || (c === '"' && cl !== '"')) {
                                    token += c
                                }
                                read(++i)
                            }
                        } else if (callbacks && callbacks[c]) {
                            if (callbacks[c](c, token)) {
                                push()
                            }
                        } else if (c === itemDelimiter) {
                            push()
                        } else {
                            token += c
                        }
                    }
                    push()
                }
                function guessDelimiter(lines) {
                    let points = 0
                        , commas = 0
                        , guessed = !1;
                    lines.some(function(columnStr, i) {
                        let inStr = !1, c, cn, cl, token = '';
                        if (i > 13) {
                            return !0
                        }
                        for (let j = 0; j < columnStr.length; j++) {
                            c = columnStr[j];
                            cn = columnStr[j + 1];
                            cl = columnStr[j - 1];
                            if (c === '#') {
                                return
                            }
                            if (c === '"') {
                                if (inStr) {
                                    if (cl !== '"' && cn !== '"') {
                                        while (cn === ' ' && j < columnStr.length) {
                                            cn = columnStr[++j]
                                        }
                                        if (typeof potDelimiters[cn] !== 'undefined') {
                                            potDelimiters[cn]++
                                        }
                                        inStr = !1
                                    }
                                } else {
                                    inStr = !0
                                }
                            } else if (typeof potDelimiters[c] !== 'undefined') {
                                token = token.trim();
                                if (!isNaN(Date.parse(token))) {
                                    potDelimiters[c]++
                                } else if (isNaN(token) || !isFinite(token)) {
                                    potDelimiters[c]++
                                }
                                token = ''
                            } else {
                                token += c
                            }
                            if (c === ',') {
                                commas++
                            }
                            if (c === '.') {
                                points++
                            }
                        }
                    });
                    if (potDelimiters[';'] > potDelimiters[',']) {
                        guessed = ';'
                    } else if (potDelimiters[','] > potDelimiters[';']) {
                        guessed = ','
                    } else {
                        guessed = ','
                    }
                    if (!options.decimalPoint) {
                        if (points > commas) {
                            options.decimalPoint = '.'
                        } else {
                            options.decimalPoint = ','
                        }
                        self.decimalRegex = new RegExp('^(-?[0-9]+)' + options.decimalPoint + '([0-9]+)$')
                    }
                    return guessed
                }
                function deduceDateFormat(data, limit) {
                    const format = 'YYYY/mm/dd'
                        , stable = []
                        , max = [];
                    let thing, guessedFormat = [], calculatedFormat, i = 0, madeDeduction = !1, j;
                    if (!limit || limit > data.length) {
                        limit = data.length
                    }
                    for (; i < limit; i++) {
                        if (typeof data[i] !== 'undefined' && data[i] && data[i].length) {
                            thing = data[i].trim().replace(/\//g, ' ').replace(/\-/g, ' ').replace(/\./g, ' ').split(' ');
                            guessedFormat = ['', '', ''];
                            for (j = 0; j < thing.length; j++) {
                                if (j < guessedFormat.length) {
                                    thing[j] = parseInt(thing[j], 10);
                                    if (thing[j]) {
                                        max[j] = (!max[j] || max[j] < thing[j]) ? thing[j] : max[j];
                                        if (typeof stable[j] !== 'undefined') {
                                            if (stable[j] !== thing[j]) {
                                                stable[j] = !1
                                            }
                                        } else {
                                            stable[j] = thing[j]
                                        }
                                        if (thing[j] > 31) {
                                            if (thing[j] < 100) {
                                                guessedFormat[j] = 'YY'
                                            } else {
                                                guessedFormat[j] = 'YYYY'
                                            }
                                        } else if (thing[j] > 12 && thing[j] <= 31) {
                                            guessedFormat[j] = 'dd';
                                            madeDeduction = !0
                                        } else if (!guessedFormat[j].length) {
                                            guessedFormat[j] = 'mm'
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (madeDeduction) {
                        for (j = 0; j < stable.length; j++) {
                            if (stable[j] !== !1) {
                                if (max[j] > 12 && guessedFormat[j] !== 'YY' && guessedFormat[j] !== 'YYYY') {
                                    guessedFormat[j] = 'YY'
                                }
                            } else if (max[j] > 12 && guessedFormat[j] === 'mm') {
                                guessedFormat[j] = 'dd'
                            }
                        }
                        if (guessedFormat.length === 3 && guessedFormat[1] === 'dd' && guessedFormat[2] === 'dd') {
                            guessedFormat[2] = 'YY'
                        }
                        calculatedFormat = guessedFormat.join('/');
                        if (!(options.dateFormats || self.dateFormats)[calculatedFormat]) {
                            fireEvent('deduceDateFailed');
                            return format
                        }
                        return calculatedFormat
                    }
                    return format
                }
                function deduceAxisTypes() {}
                if (csv && options.beforeParse) {
                    csv = options.beforeParse.call(this, csv)
                }
                if (csv) {
                    lines = csv.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split(options.lineDelimiter || '\n');
                    if (!startRow || startRow < 0) {
                        startRow = 0
                    }
                    if (!endRow || endRow >= lines.length) {
                        endRow = lines.length - 1
                    }
                    if (options.itemDelimiter) {
                        itemDelimiter = options.itemDelimiter
                    } else {
                        itemDelimiter = null;
                        itemDelimiter = guessDelimiter(lines)
                    }
                    let offset = 0;
                    for (rowIt = startRow; rowIt <= endRow; rowIt++) {
                        if (lines[rowIt][0] === '#') {
                            offset++
                        } else {
                            parseRow(lines[rowIt], rowIt - startRow - offset)
                        }
                    }
                    deduceAxisTypes();
                    if ((!options.columnTypes || options.columnTypes.length === 0) && dataTypes.length && dataTypes[0].length && dataTypes[0][1] === 'date' && !options.dateFormat) {
                        options.dateFormat = deduceDateFormat(columns[0])
                    }
                    this.dataFound()
                }
                return columns
            }
            parseTable() {
                const options = this.options
                    , columns = this.columns || []
                    , startRow = options.startRow || 0
                    , endRow = options.endRow || Number.MAX_VALUE
                    , startColumn = options.startColumn || 0
                    , endColumn = options.endColumn || Number.MAX_VALUE;
                if (options.table) {
                    let table = options.table;
                    if (typeof table === 'string') {
                        table = doc.getElementById(table)
                    }
                    [].forEach.call(table.getElementsByTagName('tr'), (tr, rowNo) => {
                            if (rowNo >= startRow && rowNo <= endRow) {
                                [].forEach.call(tr.children, (item, colNo) => {
                                        const row = columns[colNo - startColumn];
                                        let i = 1;
                                        if ((item.tagName === 'TD' || item.tagName === 'TH') && colNo >= startColumn && colNo <= endColumn) {
                                            if (!columns[colNo - startColumn]) {
                                                columns[colNo - startColumn] = []
                                            }
                                            columns[colNo - startColumn][rowNo - startRow] = item.innerHTML;
                                            while (rowNo - startRow >= i && row[rowNo - startRow - i] === void 0) {
                                                row[rowNo - startRow - i] = null;
                                                i++
                                            }
                                        }
                                    }
                                )
                            }
                        }
                    );
                    this.dataFound()
                }
                return columns
            }
            fetchLiveData() {
                const data = this
                    , chart = this.chart
                    , options = this.options
                    , maxRetries = 3
                    , pollingEnabled = options.enablePolling
                    , originalOptions = merge(options);
                let currentRetries = 0
                    , updateIntervalMs = (options.dataRefreshRate || 2) * 1000;
                if (!hasURLOption(options)) {
                    return !1
                }
                if (updateIntervalMs < 1000) {
                    updateIntervalMs = 1000
                }
                delete options.csvURL;
                delete options.rowsURL;
                delete options.columnsURL;
                function performFetch(initialFetch) {
                    function request(url, done, tp) {
                        if (!url || !/^(http|\/|\.\/|\.\.\/)/.test(url)) {
                            if (url && options.error) {
                                options.error('Invalid URL')
                            }
                            return !1
                        }
                        if (initialFetch) {
                            clearTimeout(data.liveDataTimeout);
                            chart.liveDataURL = url
                        }
                        function poll() {
                            if (pollingEnabled && chart.liveDataURL === url) {
                                data.liveDataTimeout = setTimeout(performFetch, updateIntervalMs)
                            }
                        }
                        ajax({
                            url: url,
                            dataType: tp || 'json',
                            success: function(res) {
                                if (chart && chart.series) {
                                    done(res)
                                }
                                poll()
                            },
                            error: function(xhr, text) {
                                if (++currentRetries < maxRetries) {
                                    poll()
                                }
                                return options.error && options.error(text, xhr)
                            }
                        });
                        return !0
                    }
                    if (!request(originalOptions.csvURL, function(res) {
                        chart.update({
                            data: {
                                csv: res
                            }
                        })
                    }, 'text')) {
                        if (!request(originalOptions.rowsURL, function(res) {
                            chart.update({
                                data: {
                                    rows: res
                                }
                            })
                        })) {
                            request(originalOptions.columnsURL, function(res) {
                                chart.update({
                                    data: {
                                        columns: res
                                    }
                                })
                            })
                        }
                    }
                }
                performFetch(!0);
                return hasURLOption(options)
            }
            parseGoogleSpreadsheet() {
                const data = this
                    , options = this.options
                    , googleSpreadsheetKey = options.googleSpreadsheetKey
                    , chart = this.chart
                    , refreshRate = Math.max((options.dataRefreshRate || 2) * 1000, 4000);
                const getRange = () => {
                        if (options.googleSpreadsheetRange) {
                            return options.googleSpreadsheetRange
                        }
                        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                        const start = (alphabet.charAt(options.startColumn || 0) || 'A') + ((options.startRow || 0) + 1);
                        let end = alphabet.charAt(pick(options.endColumn, -1)) || 'ZZ';
                        if (defined(options.endRow)) {
                            end += options.endRow + 1
                        }
                        return `${start}:${end}`
                    }
                ;
                function fetchSheet(fn) {
                    const url = ['https://sheets.googleapis.com/v4/spreadsheets', googleSpreadsheetKey, 'values', getRange(), '?alt=json&' + 'majorDimension=COLUMNS&' + 'valueRenderOption=UNFORMATTED_VALUE&' + 'dateTimeRenderOption=FORMATTED_STRING&' + 'key=' + options.googleAPIKey].join('/');
                    ajax({
                        url,
                        dataType: 'json',
                        success: function(json) {
                            fn(json);
                            if (options.enablePolling) {
                                data.liveDataTimeout = setTimeout(function() {
                                    fetchSheet(fn)
                                }, refreshRate)
                            }
                        },
                        error: function(xhr, text) {
                            return options.error && options.error(text, xhr)
                        }
                    })
                }
                if (googleSpreadsheetKey) {
                    delete options.googleSpreadsheetKey;
                    fetchSheet(function(json) {
                        const columns = json.values;
                        if (!columns || columns.length === 0) {
                            return !1
                        }
                        const rowCount = columns.reduce( (rowCount, column) => Math.max(rowCount, column.length), 0);
                        columns.forEach( (column) => {
                                for (let i = 0; i < rowCount; i++) {
                                    if (typeof column[i] === 'undefined') {
                                        column[i] = null
                                    }
                                }
                            }
                        );
                        if (chart && chart.series) {
                            chart.update({
                                data: {
                                    columns: columns
                                }
                            })
                        } else {
                            data.columns = columns;
                            data.dataFound()
                        }
                    })
                }
                return !1
            }
            trim(str, inside) {
                if (typeof str === 'string') {
                    str = str.replace(/^\s+|\s+$/g, '');
                    if (inside && /^-?[0-9\s]+$/.test(str)) {
                        str = str.replace(/\s/g, '')
                    }
                    if (this.decimalRegex) {
                        str = str.replace(this.decimalRegex, '$1.$2')
                    }
                }
                return str
            }
            parseTypes() {
                const columns = this.columns || [];
                let col = columns.length;
                while (col--) {
                    this.parseColumn(columns[col], col)
                }
            }
            parseColumn(column, col) {
                const rawColumns = this.rawColumns
                    , columns = this.columns
                    , firstRowAsNames = this.firstRowAsNames
                    , isXColumn = this.valueCount.xColumns.indexOf(col) !== -1
                    , backup = []
                    , chartOptions = this.chartOptions
                    , columnTypes = this.options.columnTypes || []
                    , columnType = columnTypes[col]
                    , forceCategory = isXColumn && ((chartOptions && chartOptions.xAxis && splat(chartOptions.xAxis)[0].type === 'category') || columnType === 'string')
                    , columnHasName = defined(column.name);
                let row = column.length, val, floatVal, trimVal, trimInsideVal, dateVal, diff, descending;
                if (!rawColumns[col]) {
                    rawColumns[col] = []
                }
                while (row--) {
                    val = backup[row] || column[row];
                    trimVal = this.trim(val);
                    trimInsideVal = this.trim(val, !0);
                    floatVal = parseFloat(trimInsideVal);
                    if (typeof rawColumns[col][row] === 'undefined') {
                        rawColumns[col][row] = trimVal
                    }
                    if (forceCategory || (row === 0 && firstRowAsNames && !columnHasName)) {
                        column[row] = '' + trimVal
                    } else if (+trimInsideVal === floatVal) {
                        column[row] = floatVal;
                        if (floatVal > 365 * 24 * 3600 * 1000 && columnType !== 'float') {
                            column.isDatetime = !0
                        } else {
                            column.isNumeric = !0
                        }
                        if (typeof column[row + 1] !== 'undefined') {
                            descending = floatVal > column[row + 1]
                        }
                    } else {
                        if (trimVal && trimVal.length) {
                            dateVal = this.parseDate(val)
                        }
                        if (isXColumn && isNumber(dateVal) && columnType !== 'float') {
                            backup[row] = val;
                            column[row] = dateVal;
                            column.isDatetime = !0;
                            if (typeof column[row + 1] !== 'undefined') {
                                diff = dateVal > column[row + 1];
                                if (diff !== descending && typeof descending !== 'undefined') {
                                    if (this.alternativeFormat) {
                                        this.dateFormat = this.alternativeFormat;
                                        row = column.length;
                                        this.alternativeFormat = this.dateFormats[this.dateFormat].alternative
                                    } else {
                                        column.unsorted = !0
                                    }
                                }
                                descending = diff
                            }
                        } else {
                            column[row] = trimVal === '' ? null : trimVal;
                            if (row !== 0 && (column.isDatetime || column.isNumeric)) {
                                column.mixed = !0
                            }
                        }
                    }
                }
                if (isXColumn && column.mixed) {
                    columns[col] = rawColumns[col]
                }
                if (isXColumn && descending && this.options.sort) {
                    for (col = 0; col < columns.length; col++) {
                        columns[col].reverse();
                        if (firstRowAsNames) {
                            columns[col].unshift(columns[col].pop())
                        }
                    }
                }
            }
            parseDate(val) {
                const parseDate = this.options.parseDate;
                let ret, key, format, dateFormat = this.options.dateFormat || this.dateFormat, match;
                if (parseDate) {
                    ret = parseDate(val)
                } else if (typeof val === 'string') {
                    if (!dateFormat) {
                        for (key in this.dateFormats) {
                            format = this.dateFormats[key];
                            match = val.match(format.regex);
                            if (match) {
                                this.dateFormat = dateFormat = key;
                                this.alternativeFormat = format.alternative;
                                ret = format.parser(match);
                                break
                            }
                        }
                    } else {
                        format = this.dateFormats[dateFormat];
                        if (!format) {
                            format = this.dateFormats['YYYY/mm/dd']
                        }
                        match = val.match(format.regex);
                        if (match) {
                            ret = format.parser(match)
                        }
                    }
                    if (!match) {
                        if (val.match(/:.+(GMT|UTC|[Z+-])/)) {
                            val = val.replace(/\s*(?:GMT|UTC)?([+-])(\d\d)(\d\d)$/, '$1$2:$3').replace(/(?:\s+|GMT|UTC)([+-])/, '$1').replace(/(\d)\s*(?:GMT|UTC|Z)$/, '$1+00:00')
                        }
                        match = Date.parse(val);
                        if (typeof match === 'object' && match !== null && match.getTime) {
                            ret = (match.getTime() - match.getTimezoneOffset() * 60000)
                        } else if (isNumber(match)) {
                            ret = match - (new Date(match)).getTimezoneOffset() * 60000
                        }
                    }
                }
                return ret
            }
            getData() {
                if (this.columns) {
                    return this.rowsToColumns(this.columns).slice(1)
                }
            }
            parsed() {
                if (this.options.parsed) {
                    return this.options.parsed.call(this, this.columns)
                }
            }
            complete() {
                const columns = this.columns
                    , xColumns = []
                    , options = this.options
                    , allSeriesBuilders = [];
                let type, series, data, i, j, r, seriesIndex, chartOptions, builder, freeIndexes, typeCol, index;
                xColumns.length = columns.length;
                if (options.complete || options.afterComplete) {
                    if (this.firstRowAsNames) {
                        for (i = 0; i < columns.length; i++) {
                            const curCol = columns[i];
                            if (!defined(curCol.name)) {
                                curCol.name = pick(curCol.shift(), '').toString()
                            }
                        }
                    }
                    series = [];
                    freeIndexes = getFreeIndexes(columns.length, this.valueCount.seriesBuilders);
                    for (seriesIndex = 0; seriesIndex < this.valueCount.seriesBuilders.length; seriesIndex++) {
                        builder = this.valueCount.seriesBuilders[seriesIndex];
                        if (builder.populateColumns(freeIndexes)) {
                            allSeriesBuilders.push(builder)
                        }
                    }
                    while (freeIndexes.length > 0) {
                        builder = new SeriesBuilder();
                        builder.addColumnReader(0, 'x');
                        index = freeIndexes.indexOf(0);
                        if (index !== -1) {
                            freeIndexes.splice(index, 1)
                        }
                        for (i = 0; i < this.valueCount.global; i++) {
                            builder.addColumnReader(void 0, this.valueCount.globalPointArrayMap[i])
                        }
                        if (builder.populateColumns(freeIndexes)) {
                            allSeriesBuilders.push(builder)
                        }
                    }
                    if (allSeriesBuilders.length > 0 && allSeriesBuilders[0].readers.length > 0) {
                        typeCol = columns[allSeriesBuilders[0].readers[0].columnIndex];
                        if (typeof typeCol !== 'undefined') {
                            if (typeCol.isDatetime) {
                                type = 'datetime'
                            } else if (!typeCol.isNumeric) {
                                type = 'category'
                            }
                        }
                    }
                    if (type === 'category') {
                        for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
                            builder = allSeriesBuilders[seriesIndex];
                            for (r = 0; r < builder.readers.length; r++) {
                                if (builder.readers[r].configName === 'x') {
                                    builder.readers[r].configName = 'name'
                                }
                            }
                        }
                    }
                    for (seriesIndex = 0; seriesIndex < allSeriesBuilders.length; seriesIndex++) {
                        builder = allSeriesBuilders[seriesIndex];
                        data = [];
                        for (j = 0; j < columns[0].length; j++) {
                            data[j] = builder.read(columns, j)
                        }
                        series[seriesIndex] = {
                            data: data
                        };
                        if (builder.name) {
                            series[seriesIndex].name = builder.name
                        }
                        if (type === 'category') {
                            series[seriesIndex].turboThreshold = 0
                        }
                    }
                    chartOptions = {
                        series: series
                    };
                    if (type) {
                        chartOptions.xAxis = {
                            type: type
                        };
                        if (type === 'category') {
                            chartOptions.xAxis.uniqueNames = !1
                        }
                    }
                    if (options.complete) {
                        options.complete(chartOptions)
                    }
                    if (options.afterComplete) {
                        options.afterComplete(chartOptions)
                    }
                }
            }
            update(options, redraw) {
                const chart = this.chart
                    , chartOptions = chart.options;
                if (options) {
                    options.afterComplete = function(dataOptions) {
                        if (dataOptions) {
                            if (dataOptions.xAxis && chart.xAxis[0] && dataOptions.xAxis.type === chart.xAxis[0].options.type) {
                                delete dataOptions.xAxis
                            }
                            chart.update(dataOptions, redraw, !0)
                        }
                    }
                    ;
                    merge(!0, chartOptions.data, options);
                    if (chartOptions.data && chartOptions.data.googleSpreadsheetKey && !options.columns) {
                        delete chartOptions.data.columns
                    }
                    this.init(chartOptions.data)
                }
            }
        }
        addEvent(Chart, 'init', function(e) {
            const chart = this
                , callback = e.args[1]
                , defaultDataOptions = getOptions().data;
            let userOptions = (e.args[0] || {});
            if ((defaultDataOptions || userOptions && userOptions.data) && !chart.hasDataDef) {
                chart.hasDataDef = !0;
                const dataOptions = merge(defaultDataOptions, userOptions.data);
                chart.data = new Data(extend(dataOptions, {
                    afterComplete: function(dataOptions) {
                        let i, series;
                        if (Object.hasOwnProperty.call(userOptions, 'series')) {
                            if (typeof userOptions.series === 'object') {
                                i = Math.max(userOptions.series.length, dataOptions && dataOptions.series ? dataOptions.series.length : 0);
                                while (i--) {
                                    series = userOptions.series[i] || {};
                                    userOptions.series[i] = merge(series, dataOptions && dataOptions.series ? dataOptions.series[i] : {})
                                }
                            } else {
                                delete userOptions.series
                            }
                        }
                        userOptions = merge(dataOptions, userOptions);
                        chart.init(userOptions, callback)
                    }
                }),userOptions,chart);
                e.preventDefault()
            }
        });
        class SeriesBuilder {
            constructor() {
                this.readers = [];
                this.pointIsArray = !0
            }
            populateColumns(freeIndexes) {
                const builder = this;
                let enoughColumns = !0;
                builder.readers.forEach( (reader) => {
                        if (typeof reader.columnIndex === 'undefined') {
                            reader.columnIndex = freeIndexes.shift()
                        }
                    }
                );
                builder.readers.forEach( (reader) => {
                        if (typeof reader.columnIndex === 'undefined') {
                            enoughColumns = !1
                        }
                    }
                );
                return enoughColumns
            }
            read(columns, rowIndex) {
                const builder = this
                    , pointIsArray = builder.pointIsArray
                    , point = pointIsArray ? [] : {};
                builder.readers.forEach( (reader) => {
                        const value = columns[reader.columnIndex][rowIndex];
                        if (pointIsArray) {
                            point.push(value)
                        } else {
                            if (reader.configName.indexOf('.') > 0) {
                                Point.prototype.setNestedProperty(point, value, reader.configName)
                            } else {
                                point[reader.configName] = value
                            }
                        }
                    }
                );
                if (typeof this.name === 'undefined' && builder.readers.length >= 2) {
                    const columnIndexes = [];
                    builder.readers.forEach(function(reader) {
                        if (reader.configName === 'x' || reader.configName === 'name' || reader.configName === 'y') {
                            if (typeof reader.columnIndex !== 'undefined') {
                                columnIndexes.push(reader.columnIndex)
                            }
                        }
                    });
                    if (columnIndexes.length >= 2) {
                        columnIndexes.shift();
                        columnIndexes.sort(function(a, b) {
                            return a - b
                        })
                    }
                    this.name = columns[pick(columnIndexes.shift(), 0)].name
                }
                return point
            }
            addColumnReader(columnIndex, configName) {
                this.readers.push({
                    columnIndex: columnIndex,
                    configName: configName
                });
                if (!(configName === 'x' || configName === 'y' || typeof configName === 'undefined')) {
                    this.pointIsArray = !1
                }
            }
            getReferencedColumnIndexes() {
                const referencedColumnIndexes = [];
                let i, columnReader;
                for (i = 0; i < this.readers.length; i = i + 1) {
                    columnReader = this.readers[i];
                    if (typeof columnReader.columnIndex !== 'undefined') {
                        referencedColumnIndexes.push(columnReader.columnIndex)
                    }
                }
                return referencedColumnIndexes
            }
            hasReader(configName) {
                let i, columnReader;
                for (i = 0; i < this.readers.length; i = i + 1) {
                    columnReader = this.readers[i];
                    if (columnReader.configName === configName) {
                        return !0
                    }
                }
            }
        }
        ('');
        return Data
    });
    _registerModule(_modules, 'masters/modules/data.src.js', [_modules['Core/Globals.js'], _modules['Core/HttpUtilities.js'], _modules['Extensions/Data.js']], function(Highcharts, HttpUtilities, Data) {
        const G = Highcharts;
        G.ajax = HttpUtilities.ajax;
        G.data = Data.data;
        G.getJSON = HttpUtilities.getJSON;
        G.post = HttpUtilities.post;
        G.Data = Data;
        G.HttpUtilities = HttpUtilities
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Accessibility module
 *
 * (c) 2010-2021 Highsoft AS
 * Author: Oystein Moseng
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/accessibility', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Accessibility/Utils/HTMLUtilities.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {doc, win} = H;
        const {css} = U;
        const simulatedEventTarget = win.EventTarget && new win.EventTarget() || 'none';
        function addClass(el, className) {
            if (el.classList) {
                el.classList.add(className)
            } else if (el.className.indexOf(className) < 0) {
                el.className += ' ' + className
            }
        }
        function removeClass(el, className) {
            if (el.classList) {
                el.classList.remove(className)
            } else {
                el.className = el.className.replace(new RegExp(className,'g'), '')
            }
        }
        function cloneMouseEvent(e) {
            if (typeof win.MouseEvent === 'function') {
                return new win.MouseEvent(e.type,e)
            }
            if (doc.createEvent) {
                const evt = doc.createEvent('MouseEvent');
                if (evt.initMouseEvent) {
                    evt.initMouseEvent(e.type, e.bubbles, e.cancelable, e.view || win, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
                    return evt
                }
            }
            return getFakeMouseEvent(e.type)
        }
        function cloneTouchEvent(e) {
            const touchListToTouchArray = (l) => {
                    const touchArray = [];
                    for (let i = 0; i < l.length; ++i) {
                        const item = l.item(i);
                        if (item) {
                            touchArray.push(item)
                        }
                    }
                    return touchArray
                }
            ;
            if (typeof win.TouchEvent === 'function') {
                const newEvent = new win.TouchEvent(e.type,{
                    touches: touchListToTouchArray(e.touches),
                    targetTouches: touchListToTouchArray(e.targetTouches),
                    changedTouches: touchListToTouchArray(e.changedTouches),
                    ctrlKey: e.ctrlKey,
                    shiftKey: e.shiftKey,
                    altKey: e.altKey,
                    metaKey: e.metaKey,
                    bubbles: e.bubbles,
                    cancelable: e.cancelable,
                    composed: e.composed,
                    detail: e.detail,
                    view: e.view
                });
                if (e.defaultPrevented) {
                    newEvent.preventDefault()
                }
                return newEvent
            }
            const fakeEvt = cloneMouseEvent(e);
            fakeEvt.touches = e.touches;
            fakeEvt.changedTouches = e.changedTouches;
            fakeEvt.targetTouches = e.targetTouches;
            return fakeEvt
        }
        function escapeStringForHTML(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;')
        }
        function getElement(id) {
            return doc.getElementById(id)
        }
        function getFakeMouseEvent(type, position, relatedTarget) {
            const pos = position || {
                x: 0,
                y: 0
            };
            if (typeof win.MouseEvent === 'function') {
                return new win.MouseEvent(type,{
                    bubbles: !0,
                    cancelable: !0,
                    composed: !0,
                    button: 0,
                    buttons: 1,
                    relatedTarget: relatedTarget || simulatedEventTarget,
                    view: win,
                    detail: type === 'click' ? 1 : 0,
                    screenX: pos.x,
                    screenY: pos.y,
                    clientX: pos.x,
                    clientY: pos.y
                })
            }
            if (doc.createEvent) {
                const evt = doc.createEvent('MouseEvent');
                if (evt.initMouseEvent) {
                    evt.initMouseEvent(type, !0, !0, win, type === 'click' ? 1 : 0, pos.x, pos.y, pos.x, pos.y, !1, !1, !1, !1, 0, null);
                    return evt
                }
            }
            return {
                type: type
            }
        }
        function getHeadingTagNameForElement(element) {
            const getIncreasedHeadingLevel = (tagName) => {
                    const headingLevel = parseInt(tagName.slice(1), 10)
                        , newLevel = Math.min(6, headingLevel + 1);
                    return 'h' + newLevel
                }
            ;
            const isHeading = (tagName) => /H[1-6]/.test(tagName);
            const getPreviousSiblingsHeading = (el) => {
                    let sibling = el;
                    while (sibling = sibling.previousSibling) {
                        const tagName = sibling.tagName || '';
                        if (isHeading(tagName)) {
                            return tagName
                        }
                    }
                    return ''
                }
            ;
            const getHeadingRecursive = (el) => {
                    const prevSiblingsHeading = getPreviousSiblingsHeading(el);
                    if (prevSiblingsHeading) {
                        return getIncreasedHeadingLevel(prevSiblingsHeading)
                    }
                    const parent = el.parentElement;
                    if (!parent) {
                        return 'p'
                    }
                    const parentTagName = parent.tagName;
                    if (isHeading(parentTagName)) {
                        return getIncreasedHeadingLevel(parentTagName)
                    }
                    return getHeadingRecursive(parent)
                }
            ;
            return getHeadingRecursive(element)
        }
        function removeElement(element) {
            if (element && element.parentNode) {
                element.parentNode.removeChild(element)
            }
        }
        function removeChildNodes(element) {
            while (element.lastChild) {
                element.removeChild(element.lastChild)
            }
        }
        function reverseChildNodes(node) {
            let i = node.childNodes.length;
            while (i--) {
                node.appendChild(node.childNodes[i])
            }
        }
        function stripHTMLTagsFromString(str, isForExport=!1) {
            return (typeof str === 'string') ? (isForExport ? str.replace(/<\/?[^>]+(>|$)/g, '') : str.replace(/<\/?(?!\s)[^>]+(>|$)/g, '')) : str
        }
        function visuallyHideElement(element) {
            css(element, {
                position: 'absolute',
                width: '1px',
                height: '1px',
                overflow: 'hidden',
                whiteSpace: 'nowrap',
                clip: 'rect(1px, 1px, 1px, 1px)',
                marginTop: '-3px',
                '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=1)',
                filter: 'alpha(opacity=1)',
                opacity: 0.01
            })
        }
        const HTMLUtilities = {
            addClass,
            cloneMouseEvent,
            cloneTouchEvent,
            escapeStringForHTML,
            getElement,
            getFakeMouseEvent,
            getHeadingTagNameForElement,
            removeChildNodes,
            removeClass,
            removeElement,
            reverseChildNodes,
            simulatedEventTarget,
            stripHTMLTagsFromString,
            visuallyHideElement
        };
        return HTMLUtilities
    });
    _registerModule(_modules, 'Accessibility/A11yI18n.js', [_modules['Core/Templating.js'], _modules['Core/Utilities.js']], function(F, U) {
        const {format} = F;
        const {getNestedProperty, pick} = U;
        var A11yI18nComposition;
        (function(A11yI18nComposition) {
                const composedMembers = [];
                function compose(ChartClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.langFormat = langFormat
                    }
                    return ChartClass
                }
                A11yI18nComposition.compose = compose;
                function formatExtendedStatement(statement, ctx) {
                    const eachStart = statement.indexOf('#each(')
                        , pluralStart = statement.indexOf('#plural(')
                        , indexStart = statement.indexOf('[')
                        , indexEnd = statement.indexOf(']');
                    let arr, result;
                    if (eachStart > -1) {
                        const eachEnd = statement.slice(eachStart).indexOf(')') + eachStart
                            , preEach = statement.substring(0, eachStart)
                            , postEach = statement.substring(eachEnd + 1)
                            , eachStatement = statement.substring(eachStart + 6, eachEnd)
                            , eachArguments = eachStatement.split(',');
                        let lenArg = Number(eachArguments[1]), len;
                        result = '';
                        arr = getNestedProperty(eachArguments[0], ctx);
                        if (arr) {
                            lenArg = isNaN(lenArg) ? arr.length : lenArg;
                            len = lenArg < 0 ? arr.length + lenArg : Math.min(lenArg, arr.length);
                            for (let i = 0; i < len; ++i) {
                                result += preEach + arr[i] + postEach
                            }
                        }
                        return result.length ? result : ''
                    }
                    if (pluralStart > -1) {
                        const pluralEnd = (statement.slice(pluralStart).indexOf(')') + pluralStart)
                            , pluralStatement = statement.substring(pluralStart + 8, pluralEnd)
                            , pluralArguments = pluralStatement.split(',')
                            , num = Number(getNestedProperty(pluralArguments[0], ctx));
                        switch (num) {
                            case 0:
                                result = pick(pluralArguments[4], pluralArguments[1]);
                                break;
                            case 1:
                                result = pick(pluralArguments[2], pluralArguments[1]);
                                break;
                            case 2:
                                result = pick(pluralArguments[3], pluralArguments[1]);
                                break;
                            default:
                                result = pluralArguments[1]
                        }
                        return result ? stringTrim(result) : ''
                    }
                    if (indexStart > -1) {
                        const arrayName = statement.substring(0, indexStart)
                            , ix = Number(statement.substring(indexStart + 1, indexEnd));
                        let val;
                        arr = getNestedProperty(arrayName, ctx);
                        if (!isNaN(ix) && arr) {
                            if (ix < 0) {
                                val = arr[arr.length + ix];
                                if (typeof val === 'undefined') {
                                    val = arr[0]
                                }
                            } else {
                                val = arr[ix];
                                if (typeof val === 'undefined') {
                                    val = arr[arr.length - 1]
                                }
                            }
                        }
                        return typeof val !== 'undefined' ? val : ''
                    }
                    return '{' + statement + '}'
                }
                function i18nFormat(formatString, context, chart) {
                    const getFirstBracketStatement = (sourceStr, offset) => {
                        const str = sourceStr.slice(offset || 0)
                            , startBracket = str.indexOf('{')
                            , endBracket = str.indexOf('}');
                        if (startBracket > -1 && endBracket > startBracket) {
                            return {
                                statement: str.substring(startBracket + 1, endBracket),
                                begin: offset + startBracket + 1,
                                end: offset + endBracket
                            }
                        }
                    }
                        , tokens = [];
                    let bracketRes, constRes, cursor = 0;
                    do {
                        bracketRes = getFirstBracketStatement(formatString, cursor);
                        constRes = formatString.substring(cursor, bracketRes && bracketRes.begin - 1);
                        if (constRes.length) {
                            tokens.push({
                                value: constRes,
                                type: 'constant'
                            })
                        }
                        if (bracketRes) {
                            tokens.push({
                                value: bracketRes.statement,
                                type: 'statement'
                            })
                        }
                        cursor = bracketRes ? bracketRes.end + 1 : cursor + 1
                    } while (bracketRes);
                    tokens.forEach( (token) => {
                            if (token.type === 'statement') {
                                token.value = formatExtendedStatement(token.value, context)
                            }
                        }
                    );
                    return format(tokens.reduce( (acc, cur) => acc + cur.value, ''), context, chart)
                }
                A11yI18nComposition.i18nFormat = i18nFormat;
                function langFormat(langKey, context) {
                    const keys = langKey.split('.');
                    let formatString = this.options.lang
                        , i = 0;
                    for (; i < keys.length; ++i) {
                        formatString = formatString && formatString[keys[i]]
                    }
                    return typeof formatString === 'string' ? i18nFormat(formatString, context, this) : ''
                }
                function stringTrim(str) {
                    return str.trim && str.trim() || str.replace(/^\s+|\s+$/g, '')
                }
            }
        )(A11yI18nComposition || (A11yI18nComposition = {}));
        return A11yI18nComposition
    });
    _registerModule(_modules, 'Accessibility/Utils/ChartUtilities.js', [_modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function(H, HU, U) {
        const {doc} = H;
        const {stripHTMLTagsFromString: stripHTMLTags} = HU;
        const {defined, find, fireEvent} = U;
        function fireEventOnWrappedOrUnwrappedElement(el, eventObject) {
            const type = eventObject.type;
            const hcEvents = el.hcEvents;
            if (!!doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
                if (el.dispatchEvent) {
                    el.dispatchEvent(eventObject)
                } else {
                    el.fireEvent(type, eventObject)
                }
            } else if (hcEvents && hcEvents[type]) {
                fireEvent(el, type, eventObject)
            } else if (el.element) {
                fireEventOnWrappedOrUnwrappedElement(el.element, eventObject)
            }
        }
        function getChartTitle(chart) {
            return stripHTMLTags(chart.options.title.text || chart.langFormat('accessibility.defaultChartTitle', {
                chart: chart
            }), chart.renderer.forExport)
        }
        function getAxisDescription(axis) {
            return axis && (axis.options.accessibility?.description || axis.axisTitle?.textStr || axis.options.id || axis.categories && 'categories' || axis.dateTime && 'Time' || 'values')
        }
        function getAxisRangeDescription(axis) {
            const axisOptions = axis.options || {};
            if (axisOptions.accessibility && typeof axisOptions.accessibility.rangeDescription !== 'undefined') {
                return axisOptions.accessibility.rangeDescription
            }
            if (axis.categories) {
                return getCategoryAxisRangeDesc(axis)
            }
            if (axis.dateTime && (axis.min === 0 || axis.dataMin === 0)) {
                return getAxisTimeLengthDesc(axis)
            }
            return getAxisFromToDescription(axis)
        }
        function getCategoryAxisRangeDesc(axis) {
            const chart = axis.chart;
            if (axis.dataMax && axis.dataMin) {
                return chart.langFormat('accessibility.axis.rangeCategories', {
                    chart: chart,
                    axis: axis,
                    numCategories: axis.dataMax - axis.dataMin + 1
                })
            }
            return ''
        }
        function getAxisTimeLengthDesc(axis) {
            const chart = axis.chart
                , range = {}
                , min = axis.dataMin || axis.min || 0
                , max = axis.dataMax || axis.max || 0;
            let rangeUnit = 'Seconds';
            range.Seconds = (max - min) / 1000;
            range.Minutes = range.Seconds / 60;
            range.Hours = range.Minutes / 60;
            range.Days = range.Hours / 24;
            ['Minutes', 'Hours', 'Days'].forEach(function(unit) {
                if (range[unit] > 2) {
                    rangeUnit = unit
                }
            });
            const rangeValue = range[rangeUnit].toFixed(rangeUnit !== 'Seconds' && rangeUnit !== 'Minutes' ? 1 : 0);
            return chart.langFormat('accessibility.axis.timeRange' + rangeUnit, {
                chart: chart,
                axis: axis,
                range: rangeValue.replace('.0', '')
            })
        }
        function getAxisFromToDescription(axis) {
            const chart = axis.chart
                , options = chart.options
                , dateRangeFormat = (options && options.accessibility && options.accessibility.screenReaderSection.axisRangeDateFormat || '')
                , extremes = {
                min: axis.dataMin || axis.min || 0,
                max: axis.dataMax || axis.max || 0
            }
                , format = function(key) {
                return axis.dateTime ? chart.time.dateFormat(dateRangeFormat, extremes[key]) : extremes[key].toString()
            };
            return chart.langFormat('accessibility.axis.rangeFromTo', {
                chart: chart,
                axis: axis,
                rangeFrom: format('min'),
                rangeTo: format('max')
            })
        }
        function getSeriesFirstPointElement(series) {
            if (series.points && series.points.length) {
                const firstPointWithGraphic = find(series.points, (p) => !!p.graphic);
                return (firstPointWithGraphic && firstPointWithGraphic.graphic && firstPointWithGraphic.graphic.element)
            }
        }
        function getSeriesA11yElement(series) {
            const firstPointEl = getSeriesFirstPointElement(series);
            return (firstPointEl && firstPointEl.parentNode || series.graph && series.graph.element || series.group && series.group.element)
        }
        function unhideChartElementFromAT(chart, element) {
            element.setAttribute('aria-hidden', !1);
            if (element === chart.renderTo || !element.parentNode || element.parentNode === doc.body) {
                return
            }
            Array.prototype.forEach.call(element.parentNode.childNodes, function(node) {
                if (!node.hasAttribute('aria-hidden')) {
                    node.setAttribute('aria-hidden', !0)
                }
            });
            unhideChartElementFromAT(chart, element.parentNode)
        }
        function hideSeriesFromAT(series) {
            const seriesEl = getSeriesA11yElement(series);
            if (seriesEl) {
                seriesEl.setAttribute('aria-hidden', !0)
            }
        }
        function getSeriesFromName(chart, name) {
            if (!name) {
                return chart.series
            }
            return (chart.series || []).filter(function(s) {
                return s.name === name
            })
        }
        function getPointFromXY(series, x, y) {
            let i = series.length, res;
            while (i--) {
                res = find(series[i].points || [], function(p) {
                    return p.x === x && p.y === y
                });
                if (res) {
                    return res
                }
            }
        }
        function getRelativePointAxisPosition(axis, point) {
            if (!defined(axis.dataMin) || !defined(axis.dataMax)) {
                return 0
            }
            const axisStart = axis.toPixels(axis.dataMin)
                , axisEnd = axis.toPixels(axis.dataMax)
                , positionProp = axis.coll === 'xAxis' ? 'x' : 'y'
                , pointPos = axis.toPixels(point[positionProp] || 0);
            return (pointPos - axisStart) / (axisEnd - axisStart)
        }
        function scrollAxisToPoint(point) {
            const xAxis = point.series.xAxis
                , yAxis = point.series.yAxis
                , axis = (xAxis && xAxis.scrollbar ? xAxis : yAxis)
                , scrollbar = (axis && axis.scrollbar);
            if (scrollbar && defined(scrollbar.to) && defined(scrollbar.from)) {
                const range = scrollbar.to - scrollbar.from;
                const pos = getRelativePointAxisPosition(axis, point);
                scrollbar.updatePosition(pos - range / 2, pos + range / 2);
                fireEvent(scrollbar, 'changed', {
                    from: scrollbar.from,
                    to: scrollbar.to,
                    trigger: 'scrollbar',
                    DOMEvent: null
                })
            }
        }
        const ChartUtilities = {
            fireEventOnWrappedOrUnwrappedElement,
            getChartTitle,
            getAxisDescription,
            getAxisRangeDescription,
            getPointFromXY,
            getSeriesFirstPointElement,
            getSeriesFromName,
            getSeriesA11yElement,
            unhideChartElementFromAT,
            hideSeriesFromAT,
            scrollAxisToPoint
        };
        return ChartUtilities
    });
    _registerModule(_modules, 'Accessibility/Utils/DOMElementProvider.js', [_modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function(H, HU) {
        const {doc} = H;
        const {removeElement} = HU;
        class DOMElementProvider {
            constructor() {
                this.elements = []
            }
            createElement() {
                const el = doc.createElement.apply(doc, arguments);
                this.elements.push(el);
                return el
            }
            destroyCreatedElements() {
                this.elements.forEach(function(element) {
                    removeElement(element)
                });
                this.elements = []
            }
        }
        return DOMElementProvider
    });
    _registerModule(_modules, 'Accessibility/Utils/EventProvider.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {addEvent} = U;
        class EventProvider {
            constructor() {
                this.eventRemovers = []
            }
            addEvent() {
                const remover = addEvent.apply(H, arguments);
                this.eventRemovers.push(remover);
                return remover
            }
            removeAddedEvents() {
                this.eventRemovers.forEach( (remover) => remover());
                this.eventRemovers = []
            }
        }
        return EventProvider
    });
    _registerModule(_modules, 'Accessibility/AccessibilityComponent.js', [_modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function(CU, DOMElementProvider, EventProvider, HU, U) {
        const {fireEventOnWrappedOrUnwrappedElement} = CU;
        const {getFakeMouseEvent} = HU;
        const {extend} = U;
        class AccessibilityComponent {
            constructor() {
                this.chart = void 0;
                this.domElementProvider = void 0;
                this.eventProvider = void 0;
                this.keyCodes = void 0;
                this.proxyProvider = void 0
            }
            initBase(chart, proxyProvider) {
                this.chart = chart;
                this.eventProvider = new EventProvider();
                this.domElementProvider = new DOMElementProvider();
                this.proxyProvider = proxyProvider;
                this.keyCodes = {
                    left: 37,
                    right: 39,
                    up: 38,
                    down: 40,
                    enter: 13,
                    space: 32,
                    esc: 27,
                    tab: 9,
                    pageUp: 33,
                    pageDown: 34,
                    end: 35,
                    home: 36
                }
            }
            addEvent(el, type, fn, options) {
                return this.eventProvider.addEvent(el, type, fn, options)
            }
            createElement(tagName, options) {
                return this.domElementProvider.createElement(tagName, options)
            }
            fakeClickEvent(el) {
                const fakeEvent = getFakeMouseEvent('click');
                fireEventOnWrappedOrUnwrappedElement(el, fakeEvent)
            }
            destroyBase() {
                this.domElementProvider.destroyCreatedElements();
                this.eventProvider.removeAddedEvents()
            }
        }
        extend(AccessibilityComponent.prototype, {
            init() {},
            getKeyboardNavigation: function() {},
            onChartUpdate() {},
            onChartRender() {},
            destroy() {}
        });
        return AccessibilityComponent
    });
    _registerModule(_modules, 'Accessibility/KeyboardNavigationHandler.js', [_modules['Core/Utilities.js']], function(U) {
        const {find} = U;
        class KeyboardNavigationHandler {
            constructor(chart, options) {
                this.chart = chart;
                this.keyCodeMap = options.keyCodeMap || [];
                this.validate = options.validate;
                this.init = options.init;
                this.terminate = options.terminate;
                this.response = {
                    success: 1,
                    prev: 2,
                    next: 3,
                    noHandler: 4,
                    fail: 5
                }
            }
            run(e) {
                const keyCode = e.which || e.keyCode;
                let response = this.response.noHandler;
                const handlerCodeSet = find(this.keyCodeMap, function(codeSet) {
                    return codeSet[0].indexOf(keyCode) > -1
                });
                if (handlerCodeSet) {
                    response = handlerCodeSet[1].call(this, keyCode, e)
                } else if (keyCode === 9) {
                    response = this.response[e.shiftKey ? 'prev' : 'next']
                }
                return response
            }
        }
        ('');
        return KeyboardNavigationHandler
    });
    _registerModule(_modules, 'Accessibility/Components/ContainerComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function(AccessibilityComponent, KeyboardNavigationHandler, CU, H, HU) {
        const {unhideChartElementFromAT, getChartTitle} = CU;
        const {doc} = H;
        const {stripHTMLTagsFromString: stripHTMLTags} = HU;
        class ContainerComponent extends AccessibilityComponent {
            onChartUpdate() {
                this.handleSVGTitleElement();
                this.setSVGContainerLabel();
                this.setGraphicContainerAttrs();
                this.setRenderToAttrs();
                this.makeCreditsAccessible()
            }
            handleSVGTitleElement() {
                const chart = this.chart
                    , titleId = 'highcharts-title-' + chart.index
                    , titleContents = stripHTMLTags(chart.langFormat('accessibility.svgContainerTitle', {
                    chartTitle: getChartTitle(chart)
                }));
                if (titleContents.length) {
                    const titleElement = this.svgTitleElement = this.svgTitleElement || doc.createElementNS('http://www.w3.org/2000/svg', 'title');
                    titleElement.textContent = titleContents;
                    titleElement.id = titleId;
                    chart.renderTo.insertBefore(titleElement, chart.renderTo.firstChild)
                }
            }
            setSVGContainerLabel() {
                const chart = this.chart
                    , svgContainerLabel = chart.langFormat('accessibility.svgContainerLabel', {
                    chartTitle: getChartTitle(chart)
                });
                if (chart.renderer.box && svgContainerLabel.length) {
                    chart.renderer.box.setAttribute('aria-label', svgContainerLabel)
                }
            }
            setGraphicContainerAttrs() {
                const chart = this.chart
                    , label = chart.langFormat('accessibility.graphicContainerLabel', {
                    chartTitle: getChartTitle(chart)
                });
                if (label.length) {
                    chart.container.setAttribute('aria-label', label)
                }
            }
            setRenderToAttrs() {
                const chart = this.chart
                    , shouldHaveLandmark = chart.options.accessibility.landmarkVerbosity !== 'disabled'
                    , containerLabel = chart.langFormat('accessibility.chartContainerLabel', {
                    title: getChartTitle(chart),
                    chart: chart
                });
                if (containerLabel) {
                    chart.renderTo.setAttribute('role', shouldHaveLandmark ? 'region' : 'group');
                    chart.renderTo.setAttribute('aria-label', containerLabel)
                }
            }
            makeCreditsAccessible() {
                const chart = this.chart
                    , credits = chart.credits;
                if (credits) {
                    if (credits.textStr) {
                        credits.element.setAttribute('aria-label', chart.langFormat('accessibility.credits', {
                            creditsStr: stripHTMLTags(credits.textStr, chart.renderer.forExport)
                        }))
                    }
                    unhideChartElementFromAT(chart, credits.element)
                }
            }
            getKeyboardNavigation() {
                const chart = this.chart;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [],
                    validate: function() {
                        return !0
                    },
                    init: function() {
                        const a11y = chart.accessibility;
                        if (a11y) {
                            a11y.keyboardNavigation.tabindexContainer.focus()
                        }
                    }
                })
            }
            destroy() {
                this.chart.renderTo.setAttribute('aria-hidden', !0)
            }
        }
        return ContainerComponent
    });
    _registerModule(_modules, 'Accessibility/FocusBorder.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, pick} = U;
        var FocusBorderComposition;
        (function(FocusBorderComposition) {
                const composedMembers = [];
                const svgElementBorderUpdateTriggers = ['x', 'y', 'transform', 'width', 'height', 'r', 'd', 'stroke-width'];
                function compose(ChartClass, SVGElementClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.renderFocusBorder = chartRenderFocusBorder;
                        chartProto.setFocusToElement = chartSetFocusToElement
                    }
                    if (U.pushUnique(composedMembers, SVGElementClass)) {
                        const svgElementProto = SVGElementClass.prototype;
                        svgElementProto.addFocusBorder = svgElementAddFocusBorder;
                        svgElementProto.removeFocusBorder = svgElementRemoveFocusBorder
                    }
                }
                FocusBorderComposition.compose = compose;
                function chartRenderFocusBorder() {
                    const focusElement = this.focusElement
                        , focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder;
                    if (focusElement) {
                        focusElement.removeFocusBorder();
                        if (focusBorderOptions.enabled) {
                            focusElement.addFocusBorder(focusBorderOptions.margin, {
                                stroke: focusBorderOptions.style.color,
                                strokeWidth: focusBorderOptions.style.lineWidth,
                                r: focusBorderOptions.style.borderRadius
                            })
                        }
                    }
                }
                function chartSetFocusToElement(svgElement, focusElement) {
                    const focusBorderOptions = this.options.accessibility.keyboardNavigation.focusBorder
                        , browserFocusElement = focusElement || svgElement.element;
                    if (browserFocusElement && browserFocusElement.focus) {
                        if (!(browserFocusElement.hcEvents && browserFocusElement.hcEvents.focusin)) {
                            addEvent(browserFocusElement, 'focusin', function() {})
                        }
                        browserFocusElement.focus();
                        if (focusBorderOptions.hideBrowserFocusOutline) {
                            browserFocusElement.style.outline = 'none'
                        }
                    }
                    if (this.focusElement) {
                        this.focusElement.removeFocusBorder()
                    }
                    this.focusElement = svgElement;
                    this.renderFocusBorder()
                }
                function svgElementAddDestroyFocusBorderHook(el) {
                    if (el.focusBorderDestroyHook) {
                        return
                    }
                    const origDestroy = el.destroy;
                    el.destroy = function() {
                        if (el.focusBorder && el.focusBorder.destroy) {
                            el.focusBorder.destroy()
                        }
                        return origDestroy.apply(el, arguments)
                    }
                    ;
                    el.focusBorderDestroyHook = origDestroy
                }
                function svgElementAddFocusBorder(margin, attribs) {
                    if (this.focusBorder) {
                        this.removeFocusBorder()
                    }
                    const bb = this.getBBox()
                        , pad = pick(margin, 3)
                        , parent = this.parentGroup
                        , scaleX = this.scaleX || parent && parent.scaleX
                        , scaleY = this.scaleY || parent && parent.scaleY
                        , oneDefined = scaleX ? !scaleY : scaleY
                        , scaleBoth = oneDefined ? Math.abs(scaleX || scaleY || 1) : (Math.abs(scaleX || 1) + Math.abs(scaleY || 1)) / 2;
                    bb.x += this.translateX ? this.translateX : 0;
                    bb.y += this.translateY ? this.translateY : 0;
                    let borderPosX = bb.x - pad
                        , borderPosY = bb.y - pad
                        , borderWidth = bb.width + 2 * pad
                        , borderHeight = bb.height + 2 * pad;
                    function getTextAnchorCorrection(text) {
                        let posXCorrection = 0
                            , posYCorrection = 0;
                        if (text.attr('text-anchor') === 'middle') {
                            posXCorrection = posYCorrection = 0.5
                        } else if (!text.rotation) {
                            posYCorrection = 0.75
                        } else {
                            posXCorrection = 0.25
                        }
                        return {
                            x: posXCorrection,
                            y: posYCorrection
                        }
                    }
                    const isLabel = !!this.text;
                    if (this.element.nodeName === 'text' || isLabel) {
                        const isRotated = !!this.rotation;
                        const correction = !isLabel ? getTextAnchorCorrection(this) : {
                            x: isRotated ? 1 : 0,
                            y: 0
                        };
                        const attrX = +this.attr('x');
                        const attrY = +this.attr('y');
                        if (!isNaN(attrX)) {
                            borderPosX = attrX - (bb.width * correction.x) - pad
                        }
                        if (!isNaN(attrY)) {
                            borderPosY = attrY - (bb.height * correction.y) - pad
                        }
                        if (isLabel && isRotated) {
                            const temp = borderWidth;
                            borderWidth = borderHeight;
                            borderHeight = temp;
                            if (!isNaN(attrX)) {
                                borderPosX = attrX - (bb.height * correction.x) - pad
                            }
                            if (!isNaN(attrY)) {
                                borderPosY = attrY - (bb.width * correction.y) - pad
                            }
                        }
                    }
                    this.focusBorder = this.renderer.rect(borderPosX, borderPosY, borderWidth, borderHeight, parseInt((attribs && attribs.r || 0).toString(), 10) / scaleBoth).addClass('highcharts-focus-border').attr({
                        zIndex: 99
                    }).add(parent);
                    if (!this.renderer.styledMode) {
                        this.focusBorder.attr({
                            stroke: attribs && attribs.stroke,
                            'stroke-width': (attribs && attribs.strokeWidth || 0) / scaleBoth
                        })
                    }
                    avgElementAddUpdateFocusBorderHooks(this, margin, attribs);
                    svgElementAddDestroyFocusBorderHook(this)
                }
                function avgElementAddUpdateFocusBorderHooks(el, ...updateParams) {
                    if (el.focusBorderUpdateHooks) {
                        return
                    }
                    el.focusBorderUpdateHooks = {};
                    svgElementBorderUpdateTriggers.forEach( (trigger) => {
                            const setterKey = trigger + 'Setter';
                            const origSetter = el[setterKey] || el._defaultSetter;
                            el.focusBorderUpdateHooks[setterKey] = origSetter;
                            el[setterKey] = function() {
                                const ret = origSetter.apply(el, arguments);
                                el.addFocusBorder.apply(el, updateParams);
                                return ret
                            }
                        }
                    )
                }
                function svgElementRemoveDestroyFocusBorderHook(el) {
                    if (!el.focusBorderDestroyHook) {
                        return
                    }
                    el.destroy = el.focusBorderDestroyHook;
                    delete el.focusBorderDestroyHook
                }
                function svgElementRemoveFocusBorder() {
                    svgElementRemoveUpdateFocusBorderHooks(this);
                    svgElementRemoveDestroyFocusBorderHook(this);
                    if (this.focusBorder) {
                        this.focusBorder.destroy();
                        delete this.focusBorder
                    }
                }
                function svgElementRemoveUpdateFocusBorderHooks(el) {
                    if (!el.focusBorderUpdateHooks) {
                        return
                    }
                    Object.keys(el.focusBorderUpdateHooks).forEach( (setterKey) => {
                            const origSetter = el.focusBorderUpdateHooks[setterKey];
                            if (origSetter === el._defaultSetter) {
                                delete el[setterKey]
                            } else {
                                el[setterKey] = origSetter
                            }
                        }
                    );
                    delete el.focusBorderUpdateHooks
                }
            }
        )(FocusBorderComposition || (FocusBorderComposition = {}));
        return FocusBorderComposition
    });
    _registerModule(_modules, 'Accessibility/Utils/Announcer.js', [_modules['Core/Renderer/HTML/AST.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function(AST, DOMElementProvider, H, HU, U) {
        const {doc} = H;
        const {addClass, visuallyHideElement} = HU;
        const {attr} = U;
        class Announcer {
            constructor(chart, type) {
                this.chart = chart;
                this.domElementProvider = new DOMElementProvider();
                this.announceRegion = this.addAnnounceRegion(type)
            }
            destroy() {
                this.domElementProvider.destroyCreatedElements()
            }
            announce(message) {
                AST.setElementHTML(this.announceRegion, message);
                if (this.clearAnnouncementRegionTimer) {
                    clearTimeout(this.clearAnnouncementRegionTimer)
                }
                this.clearAnnouncementRegionTimer = setTimeout( () => {
                        this.announceRegion.innerHTML = AST.emptyHTML;
                        delete this.clearAnnouncementRegionTimer
                    }
                    , 3000)
            }
            addAnnounceRegion(type) {
                const chartContainer = (this.chart.announcerContainer || this.createAnnouncerContainer())
                    , div = this.domElementProvider.createElement('div');
                attr(div, {
                    'aria-hidden': !1,
                    'aria-live': type,
                    'aria-atomic': !0
                });
                if (this.chart.styledMode) {
                    addClass(div, 'highcharts-visually-hidden')
                } else {
                    visuallyHideElement(div)
                }
                chartContainer.appendChild(div);
                return div
            }
            createAnnouncerContainer() {
                const chart = this.chart
                    , container = doc.createElement('div');
                attr(container, {
                    'aria-hidden': !1,
                    'class': 'highcharts-announcer-container'
                });
                container.style.position = 'relative';
                chart.renderTo.insertBefore(container, chart.renderTo.firstChild);
                chart.announcerContainer = container;
                return container
            }
        }
        return Announcer
    });
    _registerModule(_modules, 'Accessibility/Components/AnnotationsA11y.js', [_modules['Accessibility/Utils/HTMLUtilities.js']], function(HTMLUtilities) {
        const {escapeStringForHTML, stripHTMLTagsFromString} = HTMLUtilities;
        function getChartAnnotationLabels(chart) {
            const annotations = chart.annotations || [];
            return annotations.reduce( (acc, cur) => {
                    if (cur.options && cur.options.visible !== !1) {
                        acc = acc.concat(cur.labels)
                    }
                    return acc
                }
                , [])
        }
        function getLabelText(label) {
            return ((label.options && label.options.accessibility && label.options.accessibility.description) || (label.graphic && label.graphic.text && label.graphic.text.textStr) || '')
        }
        function getAnnotationLabelDescription(label) {
            const a11yDesc = (label.options && label.options.accessibility && label.options.accessibility.description);
            if (a11yDesc) {
                return a11yDesc
            }
            const chart = label.chart;
            const labelText = getLabelText(label);
            const points = label.points;
            const getAriaLabel = (point) => (point.graphic && point.graphic.element && point.graphic.element.getAttribute('aria-label') || '');
            const getValueDesc = (point) => {
                    const valDesc = (point.accessibility && point.accessibility.valueDescription || getAriaLabel(point));
                    const seriesName = (point && point.series.name || '');
                    return (seriesName ? seriesName + ', ' : '') + 'data point ' + valDesc
                }
            ;
            const pointValueDescriptions = points.filter( (p) => !!p.graphic).map(getValueDesc).filter( (desc) => !!desc);
            const numPoints = pointValueDescriptions.length;
            const pointsSelector = numPoints > 1 ? 'MultiplePoints' : numPoints ? 'SinglePoint' : 'NoPoints';
            const langFormatStr = ('accessibility.screenReaderSection.annotations.description' + pointsSelector);
            const context = {
                annotationText: labelText,
                annotation: label,
                numPoints: numPoints,
                annotationPoint: pointValueDescriptions[0],
                additionalAnnotationPoints: pointValueDescriptions.slice(1)
            };
            return chart.langFormat(langFormatStr, context)
        }
        function getAnnotationListItems(chart) {
            const labels = getChartAnnotationLabels(chart);
            return labels.map( (label) => {
                    const desc = escapeStringForHTML(stripHTMLTagsFromString(getAnnotationLabelDescription(label), chart.renderer.forExport));
                    return desc ? `<li>${desc}</li>` : ''
                }
            )
        }
        function getAnnotationsInfoHTML(chart) {
            const annotations = chart.annotations;
            if (!(annotations && annotations.length)) {
                return ''
            }
            const annotationItems = getAnnotationListItems(chart);
            return `<ul style="list-style-type: none">${annotationItems.join(' ')}</ul>`
        }
        function getPointAnnotationTexts(point) {
            const labels = getChartAnnotationLabels(point.series.chart);
            const pointLabels = labels.filter( (label) => label.points.indexOf(point) > -1);
            if (!pointLabels.length) {
                return []
            }
            return pointLabels.map( (label) => `${getLabelText(label)}`)
        }
        const AnnotationsA11y = {
            getAnnotationsInfoHTML,
            getAnnotationLabelDescription,
            getAnnotationListItems,
            getPointAnnotationTexts
        };
        return AnnotationsA11y
    });
    _registerModule(_modules, 'Accessibility/Components/InfoRegionsComponent.js', [_modules['Accessibility/A11yI18n.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/Components/AnnotationsA11y.js'], _modules['Core/Renderer/HTML/AST.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Templating.js'], _modules['Core/Globals.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function(A11yI18n, AccessibilityComponent, Announcer, AnnotationsA11y, AST, CU, F, H, HU, U) {
        const {getAnnotationsInfoHTML} = AnnotationsA11y;
        const {getAxisDescription, getAxisRangeDescription, getChartTitle, unhideChartElementFromAT} = CU;
        const {format} = F;
        const {doc} = H;
        const {addClass, getElement, getHeadingTagNameForElement, stripHTMLTagsFromString, visuallyHideElement} = HU;
        const {attr, pick} = U;
        function getTableSummary(chart) {
            return chart.langFormat('accessibility.table.tableSummary', {
                chart: chart
            })
        }
        function getTypeDescForMapChart(chart, formatContext) {
            return formatContext.mapTitle ? chart.langFormat('accessibility.chartTypes.mapTypeDescription', formatContext) : chart.langFormat('accessibility.chartTypes.unknownMap', formatContext)
        }
        function getTypeDescForCombinationChart(chart, formatContext) {
            return chart.langFormat('accessibility.chartTypes.combinationChart', formatContext)
        }
        function getTypeDescForEmptyChart(chart, formatContext) {
            return chart.langFormat('accessibility.chartTypes.emptyChart', formatContext)
        }
        function buildTypeDescriptionFromSeries(chart, types, context) {
            const firstType = types[0]
                , typeExplaination = chart.langFormat('accessibility.seriesTypeDescriptions.' + firstType, context)
                , multi = chart.series && chart.series.length < 2 ? 'Single' : 'Multiple';
            return (chart.langFormat('accessibility.chartTypes.' + firstType + multi, context) || chart.langFormat('accessibility.chartTypes.default' + multi, context)) + (typeExplaination ? ' ' + typeExplaination : '')
        }
        function getTypeDescription(chart, types) {
            const firstType = types[0]
                , firstSeries = chart.series && chart.series[0] || {}
                , mapTitle = chart.mapView && chart.mapView.geoMap && chart.mapView.geoMap.title
                , formatContext = {
                numSeries: chart.series.length,
                numPoints: firstSeries.points && firstSeries.points.length,
                chart,
                mapTitle
            };
            if (!firstType) {
                return getTypeDescForEmptyChart(chart, formatContext)
            }
            if (firstType === 'map' || firstType === 'tiledwebmap') {
                return getTypeDescForMapChart(chart, formatContext)
            }
            if (chart.types.length > 1) {
                return getTypeDescForCombinationChart(chart, formatContext)
            }
            return buildTypeDescriptionFromSeries(chart, types, formatContext)
        }
        function stripEmptyHTMLTags(str) {
            return str.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, '')
        }
        class InfoRegionsComponent extends AccessibilityComponent {
            constructor() {
                super(...arguments);
                this.announcer = void 0;
                this.screenReaderSections = {}
            }
            init() {
                const chart = this.chart;
                const component = this;
                this.initRegionsDefinitions();
                this.addEvent(chart, 'aftergetTableAST', function(e) {
                    component.onDataTableCreated(e)
                });
                this.addEvent(chart, 'afterViewData', function(e) {
                    if (e.wasHidden) {
                        component.dataTableDiv = e.element;
                        setTimeout(function() {
                            component.focusDataTable()
                        }, 300)
                    }
                });
                this.addEvent(chart, 'afterHideData', function() {
                    if (component.viewDataTableButton) {
                        component.viewDataTableButton.setAttribute('aria-expanded', 'false')
                    }
                });
                this.announcer = new Announcer(chart,'assertive')
            }
            initRegionsDefinitions() {
                const component = this
                    , accessibilityOptions = this.chart.options.accessibility;
                this.screenReaderSections = {
                    before: {
                        element: null,
                        buildContent: function(chart) {
                            const formatter = accessibilityOptions.screenReaderSection.beforeChartFormatter;
                            return formatter ? formatter(chart) : component.defaultBeforeChartFormatter(chart)
                        },
                        insertIntoDOM: function(el, chart) {
                            chart.renderTo.insertBefore(el, chart.renderTo.firstChild)
                        },
                        afterInserted: function() {
                            if (typeof component.sonifyButtonId !== 'undefined') {
                                component.initSonifyButton(component.sonifyButtonId)
                            }
                            if (typeof component.dataTableButtonId !== 'undefined') {
                                component.initDataTableButton(component.dataTableButtonId)
                            }
                        }
                    },
                    after: {
                        element: null,
                        buildContent: function(chart) {
                            const formatter = accessibilityOptions.screenReaderSection.afterChartFormatter;
                            return formatter ? formatter(chart) : component.defaultAfterChartFormatter()
                        },
                        insertIntoDOM: function(el, chart) {
                            chart.renderTo.insertBefore(el, chart.container.nextSibling)
                        },
                        afterInserted: function() {
                            if (component.chart.accessibility && accessibilityOptions.keyboardNavigation.enabled) {
                                component.chart.accessibility.keyboardNavigation.updateExitAnchor()
                            }
                        }
                    }
                }
            }
            onChartRender() {
                const component = this;
                this.linkedDescriptionElement = this.getLinkedDescriptionElement();
                this.setLinkedDescriptionAttrs();
                Object.keys(this.screenReaderSections).forEach(function(regionKey) {
                    component.updateScreenReaderSection(regionKey)
                })
            }
            getLinkedDescriptionElement() {
                const chartOptions = this.chart.options
                    , linkedDescOption = chartOptions.accessibility.linkedDescription;
                if (!linkedDescOption) {
                    return
                }
                if (typeof linkedDescOption !== 'string') {
                    return linkedDescOption
                }
                const query = format(linkedDescOption, this.chart)
                    , queryMatch = doc.querySelectorAll(query);
                if (queryMatch.length === 1) {
                    return queryMatch[0]
                }
            }
            setLinkedDescriptionAttrs() {
                const el = this.linkedDescriptionElement;
                if (el) {
                    el.setAttribute('aria-hidden', 'true');
                    addClass(el, 'highcharts-linked-description')
                }
            }
            updateScreenReaderSection(regionKey) {
                const chart = this.chart;
                const region = this.screenReaderSections[regionKey];
                const content = region.buildContent(chart);
                const sectionDiv = region.element = (region.element || this.createElement('div'));
                const hiddenDiv = (sectionDiv.firstChild || this.createElement('div'));
                if (content) {
                    this.setScreenReaderSectionAttribs(sectionDiv, regionKey);
                    AST.setElementHTML(hiddenDiv, content);
                    sectionDiv.appendChild(hiddenDiv);
                    region.insertIntoDOM(sectionDiv, chart);
                    if (chart.styledMode) {
                        addClass(hiddenDiv, 'highcharts-visually-hidden')
                    } else {
                        visuallyHideElement(hiddenDiv)
                    }
                    unhideChartElementFromAT(chart, hiddenDiv);
                    if (region.afterInserted) {
                        region.afterInserted()
                    }
                } else {
                    if (sectionDiv.parentNode) {
                        sectionDiv.parentNode.removeChild(sectionDiv)
                    }
                    region.element = null
                }
            }
            setScreenReaderSectionAttribs(sectionDiv, regionKey) {
                const chart = this.chart
                    , labelText = chart.langFormat('accessibility.screenReaderSection.' + regionKey + 'RegionLabel', {
                    chart: chart,
                    chartTitle: getChartTitle(chart)
                })
                    , sectionId = `highcharts-screen-reader-region-${regionKey}-${chart.index}`;
                attr(sectionDiv, {
                    id: sectionId,
                    'aria-label': labelText || void 0
                });
                sectionDiv.style.position = 'relative';
                if (labelText) {
                    sectionDiv.setAttribute('role', chart.options.accessibility.landmarkVerbosity === 'all' ? 'region' : 'group')
                }
            }
            defaultBeforeChartFormatter() {
                const chart = this.chart
                    , format = chart.options.accessibility.screenReaderSection.beforeChartFormat;
                if (!format) {
                    return ''
                }
                const axesDesc = this.getAxesDescription()
                    , shouldHaveSonifyBtn = (chart.sonify && chart.options.sonification && chart.options.sonification.enabled)
                    , sonifyButtonId = 'highcharts-a11y-sonify-data-btn-' + chart.index
                    , dataTableButtonId = 'hc-linkto-highcharts-data-table-' + chart.index
                    , annotationsList = getAnnotationsInfoHTML(chart)
                    , annotationsTitleStr = chart.langFormat('accessibility.screenReaderSection.annotations.heading', {
                    chart: chart
                })
                    , context = {
                    headingTagName: getHeadingTagNameForElement(chart.renderTo),
                    chartTitle: getChartTitle(chart),
                    typeDescription: this.getTypeDescriptionText(),
                    chartSubtitle: this.getSubtitleText(),
                    chartLongdesc: this.getLongdescText(),
                    xAxisDescription: axesDesc.xAxis,
                    yAxisDescription: axesDesc.yAxis,
                    playAsSoundButton: shouldHaveSonifyBtn ? this.getSonifyButtonText(sonifyButtonId) : '',
                    viewTableButton: chart.getCSV ? this.getDataTableButtonText(dataTableButtonId) : '',
                    annotationsTitle: annotationsList ? annotationsTitleStr : '',
                    annotationsList: annotationsList
                }
                    , formattedString = A11yI18n.i18nFormat(format, context, chart);
                this.dataTableButtonId = dataTableButtonId;
                this.sonifyButtonId = sonifyButtonId;
                return stripEmptyHTMLTags(formattedString)
            }
            defaultAfterChartFormatter() {
                const chart = this.chart;
                const format = chart.options.accessibility.screenReaderSection.afterChartFormat;
                if (!format) {
                    return ''
                }
                const context = {
                    endOfChartMarker: this.getEndOfChartMarkerText()
                };
                const formattedString = A11yI18n.i18nFormat(format, context, chart);
                return stripEmptyHTMLTags(formattedString)
            }
            getLinkedDescription() {
                const el = this.linkedDescriptionElement
                    , content = el && el.innerHTML || '';
                return stripHTMLTagsFromString(content, this.chart.renderer.forExport)
            }
            getLongdescText() {
                const chartOptions = this.chart.options
                    , captionOptions = chartOptions.caption
                    , captionText = captionOptions && captionOptions.text
                    , linkedDescription = this.getLinkedDescription();
                return (chartOptions.accessibility.description || linkedDescription || captionText || '')
            }
            getTypeDescriptionText() {
                const chart = this.chart;
                return chart.types ? chart.options.accessibility.typeDescription || getTypeDescription(chart, chart.types) : ''
            }
            getDataTableButtonText(buttonId) {
                const chart = this.chart
                    , buttonText = chart.langFormat('accessibility.table.viewAsDataTableButtonText', {
                    chart: chart,
                    chartTitle: getChartTitle(chart)
                });
                return '<button id="' + buttonId + '">' + buttonText + '</button>'
            }
            getSonifyButtonText(buttonId) {
                const chart = this.chart;
                if (chart.options.sonification && chart.options.sonification.enabled === !1) {
                    return ''
                }
                const buttonText = chart.langFormat('accessibility.sonification.playAsSoundButtonText', {
                    chart: chart,
                    chartTitle: getChartTitle(chart)
                });
                return '<button id="' + buttonId + '">' + buttonText + '</button>'
            }
            getSubtitleText() {
                const subtitle = (this.chart.options.subtitle);
                return stripHTMLTagsFromString(subtitle && subtitle.text || '', this.chart.renderer.forExport)
            }
            getEndOfChartMarkerText() {
                const chart = this.chart
                    , markerText = chart.langFormat('accessibility.screenReaderSection.endOfChartMarker', {
                    chart: chart
                })
                    , id = 'highcharts-end-of-chart-marker-' + chart.index;
                return '<div id="' + id + '">' + markerText + '</div>'
            }
            onDataTableCreated(e) {
                const chart = this.chart;
                if (chart.options.accessibility.enabled) {
                    if (this.viewDataTableButton) {
                        this.viewDataTableButton.setAttribute('aria-expanded', 'true')
                    }
                    const attributes = e.tree.attributes || {};
                    attributes.tabindex = -1;
                    attributes.summary = getTableSummary(chart);
                    e.tree.attributes = attributes
                }
            }
            focusDataTable() {
                const tableDiv = this.dataTableDiv
                    , table = tableDiv && tableDiv.getElementsByTagName('table')[0];
                if (table && table.focus) {
                    table.focus()
                }
            }
            initSonifyButton(sonifyButtonId) {
                const el = this.sonifyButton = getElement(sonifyButtonId);
                const chart = this.chart;
                const defaultHandler = (e) => {
                        if (el) {
                            el.setAttribute('aria-hidden', 'true');
                            el.setAttribute('aria-label', '')
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        const announceMsg = chart.langFormat('accessibility.sonification.playAsSoundClickAnnouncement', {
                            chart: chart
                        });
                        this.announcer.announce(announceMsg);
                        setTimeout( () => {
                                if (el) {
                                    el.removeAttribute('aria-hidden');
                                    el.removeAttribute('aria-label')
                                }
                                if (chart.sonify) {
                                    chart.sonify()
                                }
                            }
                            , 1000)
                    }
                ;
                if (el && chart) {
                    el.setAttribute('tabindex', -1);
                    el.onclick = function(e) {
                        const onPlayAsSoundClick = (chart.options.accessibility && chart.options.accessibility.screenReaderSection.onPlayAsSoundClick);
                        (onPlayAsSoundClick || defaultHandler).call(this, e, chart)
                    }
                }
            }
            initDataTableButton(tableButtonId) {
                const el = this.viewDataTableButton = getElement(tableButtonId)
                    , chart = this.chart
                    , tableId = tableButtonId.replace('hc-linkto-', '');
                if (el) {
                    attr(el, {
                        tabindex: -1,
                        'aria-expanded': !!getElement(tableId)
                    });
                    el.onclick = chart.options.accessibility.screenReaderSection.onViewDataTableClick || function() {
                        chart.viewData()
                    }
                }
            }
            getAxesDescription() {
                const chart = this.chart
                    , shouldDescribeColl = function(collectionKey, defaultCondition) {
                    const axes = chart[collectionKey];
                    return axes.length > 1 || axes[0] && pick(axes[0].options.accessibility && axes[0].options.accessibility.enabled, defaultCondition)
                }
                    , hasNoMap = !!chart.types && chart.types.indexOf('map') < 0 && chart.types.indexOf('treemap') < 0 && chart.types.indexOf('tilemap') < 0
                    , hasCartesian = !!chart.hasCartesianSeries
                    , showXAxes = shouldDescribeColl('xAxis', !chart.angular && hasCartesian && hasNoMap)
                    , showYAxes = shouldDescribeColl('yAxis', hasCartesian && hasNoMap)
                    , desc = {};
                if (showXAxes) {
                    desc.xAxis = this.getAxisDescriptionText('xAxis')
                }
                if (showYAxes) {
                    desc.yAxis = this.getAxisDescriptionText('yAxis')
                }
                return desc
            }
            getAxisDescriptionText(collectionKey) {
                const chart = this.chart;
                const axes = chart[collectionKey];
                return chart.langFormat('accessibility.axis.' + collectionKey + 'Description' + (axes.length > 1 ? 'Plural' : 'Singular'), {
                    chart: chart,
                    names: axes.map(function(axis) {
                        return getAxisDescription(axis)
                    }),
                    ranges: axes.map(function(axis) {
                        return getAxisRangeDescription(axis)
                    }),
                    numAxes: axes.length
                })
            }
            destroy() {
                if (this.announcer) {
                    this.announcer.destroy()
                }
            }
        }
        return InfoRegionsComponent
    });
    _registerModule(_modules, 'Accessibility/Components/MenuComponent.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Utilities.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function(Chart, U, AccessibilityComponent, KeyboardNavigationHandler, ChartUtilities, HTMLUtilities) {
        const {attr} = U;
        const {getChartTitle, unhideChartElementFromAT} = ChartUtilities;
        const {getFakeMouseEvent} = HTMLUtilities;
        function getExportMenuButtonElement(chart) {
            return chart.exportSVGElements && chart.exportSVGElements[0]
        }
        function exportingShouldHaveA11y(chart) {
            const exportingOpts = chart.options.exporting
                , exportButton = getExportMenuButtonElement(chart);
            return !!(exportingOpts && exportingOpts.enabled !== !1 && exportingOpts.accessibility && exportingOpts.accessibility.enabled && exportButton && exportButton.element)
        }
        class MenuComponent extends AccessibilityComponent {
            init() {
                const chart = this.chart
                    , component = this;
                this.addEvent(chart, 'exportMenuShown', function() {
                    component.onMenuShown()
                });
                this.addEvent(chart, 'exportMenuHidden', function() {
                    component.onMenuHidden()
                });
                this.createProxyGroup()
            }
            onMenuHidden() {
                const menu = this.chart.exportContextMenu;
                if (menu) {
                    menu.setAttribute('aria-hidden', 'true')
                }
                this.setExportButtonExpandedState('false')
            }
            onMenuShown() {
                const chart = this.chart
                    , menu = chart.exportContextMenu;
                if (menu) {
                    this.addAccessibleContextMenuAttribs();
                    unhideChartElementFromAT(chart, menu)
                }
                this.setExportButtonExpandedState('true')
            }
            setExportButtonExpandedState(stateStr) {
                if (this.exportButtonProxy) {
                    this.exportButtonProxy.innerElement.setAttribute('aria-expanded', stateStr)
                }
            }
            onChartRender() {
                const chart = this.chart
                    , focusEl = chart.focusElement
                    , a11y = chart.accessibility;
                this.proxyProvider.clearGroup('chartMenu');
                this.proxyMenuButton();
                if (this.exportButtonProxy && focusEl && focusEl === chart.exportingGroup) {
                    if (focusEl.focusBorder) {
                        chart.setFocusToElement(focusEl, this.exportButtonProxy.innerElement)
                    } else if (a11y) {
                        a11y.keyboardNavigation.tabindexContainer.focus()
                    }
                }
            }
            proxyMenuButton() {
                const chart = this.chart;
                const proxyProvider = this.proxyProvider;
                const buttonEl = getExportMenuButtonElement(chart);
                if (exportingShouldHaveA11y(chart) && buttonEl) {
                    this.exportButtonProxy = proxyProvider.addProxyElement('chartMenu', {
                        click: buttonEl
                    }, 'button', {
                        'aria-label': chart.langFormat('accessibility.exporting.menuButtonLabel', {
                            chart: chart,
                            chartTitle: getChartTitle(chart)
                        }),
                        'aria-expanded': !1,
                        title: chart.options.lang.contextButtonTitle || null
                    })
                }
            }
            createProxyGroup() {
                const chart = this.chart;
                if (chart && this.proxyProvider) {
                    this.proxyProvider.addGroup('chartMenu')
                }
            }
            addAccessibleContextMenuAttribs() {
                const chart = this.chart
                    , exportList = chart.exportDivElements;
                if (exportList && exportList.length) {
                    exportList.forEach( (item) => {
                            if (item) {
                                if (item.tagName === 'LI' && !(item.children && item.children.length)) {
                                    item.setAttribute('tabindex', -1)
                                } else {
                                    item.setAttribute('aria-hidden', 'true')
                                }
                            }
                        }
                    );
                    const parentDiv = (exportList[0] && exportList[0].parentNode);
                    if (parentDiv) {
                        attr(parentDiv, {
                            'aria-hidden': void 0,
                            'aria-label': chart.langFormat('accessibility.exporting.chartMenuLabel', {
                                chart
                            }),
                            role: 'list'
                        })
                    }
                }
            }
            getKeyboardNavigation() {
                const keys = this.keyCodes
                    , chart = this.chart
                    , component = this;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[[keys.left, keys.up], function() {
                        return component.onKbdPrevious(this)
                    }
                    ], [[keys.right, keys.down], function() {
                        return component.onKbdNext(this)
                    }
                    ], [[keys.enter, keys.space], function() {
                        return component.onKbdClick(this)
                    }
                    ]],
                    validate: function() {
                        return !!chart.exporting && chart.options.exporting.enabled !== !1 && chart.options.exporting.accessibility.enabled !== !1
                    },
                    init: function() {
                        const proxy = component.exportButtonProxy;
                        const svgEl = component.chart.exportingGroup;
                        if (proxy && svgEl) {
                            chart.setFocusToElement(svgEl, proxy.innerElement)
                        }
                    },
                    terminate: function() {
                        chart.hideExportMenu()
                    }
                })
            }
            onKbdPrevious(keyboardNavigationHandler) {
                const chart = this.chart;
                const a11yOptions = chart.options.accessibility;
                const response = keyboardNavigationHandler.response;
                let i = chart.highlightedExportItemIx || 0;
                while (i--) {
                    if (chart.highlightExportItem(i)) {
                        return response.success
                    }
                }
                if (a11yOptions.keyboardNavigation.wrapAround) {
                    chart.highlightLastExportItem();
                    return response.success
                }
                return response.prev
            }
            onKbdNext(keyboardNavigationHandler) {
                const chart = this.chart;
                const a11yOptions = chart.options.accessibility;
                const response = keyboardNavigationHandler.response;
                for (let i = (chart.highlightedExportItemIx || 0) + 1; i < chart.exportDivElements.length; ++i) {
                    if (chart.highlightExportItem(i)) {
                        return response.success
                    }
                }
                if (a11yOptions.keyboardNavigation.wrapAround) {
                    chart.highlightExportItem(0);
                    return response.success
                }
                return response.next
            }
            onKbdClick(keyboardNavigationHandler) {
                const chart = this.chart;
                const curHighlightedItem = chart.exportDivElements[chart.highlightedExportItemIx];
                const exportButtonElement = getExportMenuButtonElement(chart).element;
                if (chart.openMenu) {
                    this.fakeClickEvent(curHighlightedItem)
                } else {
                    this.fakeClickEvent(exportButtonElement);
                    chart.highlightExportItem(0)
                }
                return keyboardNavigationHandler.response.success
            }
        }
        (function(MenuComponent) {
                const composedMembers = [];
                function compose(ChartClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = Chart.prototype;
                        chartProto.hideExportMenu = chartHideExportMenu;
                        chartProto.highlightExportItem = chartHighlightExportItem;
                        chartProto.highlightLastExportItem = chartHighlightLastExportItem;
                        chartProto.showExportMenu = chartShowExportMenu
                    }
                }
                MenuComponent.compose = compose;
                function chartShowExportMenu() {
                    const exportButton = getExportMenuButtonElement(this);
                    if (exportButton) {
                        const el = exportButton.element;
                        if (el.onclick) {
                            el.onclick(getFakeMouseEvent('click'))
                        }
                    }
                }
                function chartHideExportMenu() {
                    const chart = this
                        , exportList = chart.exportDivElements;
                    if (exportList && chart.exportContextMenu && chart.openMenu) {
                        exportList.forEach( (el) => {
                                if (el && el.className === 'highcharts-menu-item' && el.onmouseout) {
                                    el.onmouseout(getFakeMouseEvent('mouseout'))
                                }
                            }
                        );
                        chart.highlightedExportItemIx = 0;
                        chart.exportContextMenu.hideMenu();
                        chart.container.focus()
                    }
                }
                function chartHighlightExportItem(ix) {
                    const listItem = this.exportDivElements && this.exportDivElements[ix];
                    const curHighlighted = this.exportDivElements && this.exportDivElements[this.highlightedExportItemIx];
                    if (listItem && listItem.tagName === 'LI' && !(listItem.children && listItem.children.length)) {
                        const hasSVGFocusSupport = !!(this.renderTo.getElementsByTagName('g')[0] || {}).focus;
                        if (listItem.focus && hasSVGFocusSupport) {
                            listItem.focus()
                        }
                        if (curHighlighted && curHighlighted.onmouseout) {
                            curHighlighted.onmouseout(getFakeMouseEvent('mouseout'))
                        }
                        if (listItem.onmouseover) {
                            listItem.onmouseover(getFakeMouseEvent('mouseover'))
                        }
                        this.highlightedExportItemIx = ix;
                        return !0
                    }
                    return !1
                }
                function chartHighlightLastExportItem() {
                    const chart = this;
                    if (chart.exportDivElements) {
                        let i = chart.exportDivElements.length;
                        while (i--) {
                            if (chart.highlightExportItem(i)) {
                                return !0
                            }
                        }
                    }
                    return !1
                }
            }
        )(MenuComponent || (MenuComponent = {}));
        return MenuComponent
    });
    _registerModule(_modules, 'Accessibility/KeyboardNavigation.js', [_modules['Core/Globals.js'], _modules['Accessibility/Components/MenuComponent.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function(H, MenuComponent, U, EventProvider, HTMLUtilities) {
        const {doc, win} = H;
        const {addEvent, fireEvent} = U;
        const {getElement, simulatedEventTarget} = HTMLUtilities;
        class KeyboardNavigation {
            constructor(chart, components) {
                this.chart = void 0;
                this.components = void 0;
                this.currentModuleIx = NaN;
                this.eventProvider = void 0;
                this.exitAnchor = void 0;
                this.modules = [];
                this.tabindexContainer = void 0;
                this.init(chart, components)
            }
            init(chart, components) {
                const ep = this.eventProvider = new EventProvider();
                this.chart = chart;
                this.components = components;
                this.modules = [];
                this.currentModuleIx = 0;
                this.update();
                ep.addEvent(this.tabindexContainer, 'keydown', (e) => this.onKeydown(e));
                ep.addEvent(this.tabindexContainer, 'focus', (e) => this.onFocus(e));
                ['mouseup', 'touchend'].forEach( (eventName) => ep.addEvent(doc, eventName, (e) => this.onMouseUp(e)));
                ['mousedown', 'touchstart'].forEach( (eventName) => ep.addEvent(chart.renderTo, eventName, () => {
                        this.isClickingChart = !0
                    }
                ))
            }
            update(order) {
                const a11yOptions = this.chart.options.accessibility
                    , keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation
                    , components = this.components;
                this.updateContainerTabindex();
                if (keyboardOptions && keyboardOptions.enabled && order && order.length) {
                    this.modules = order.reduce(function(modules, componentName) {
                        const navModules = components[componentName].getKeyboardNavigation();
                        return modules.concat(navModules)
                    }, []);
                    this.updateExitAnchor()
                } else {
                    this.modules = [];
                    this.currentModuleIx = 0;
                    this.removeExitAnchor()
                }
            }
            updateExitAnchor() {
                const endMarkerId = `highcharts-end-of-chart-marker-${this.chart.index}`
                    , endMarker = getElement(endMarkerId);
                this.removeExitAnchor();
                if (endMarker) {
                    this.makeElementAnExitAnchor(endMarker);
                    this.exitAnchor = endMarker
                } else {
                    this.createExitAnchor()
                }
            }
            move(direction) {
                const curModule = this.modules && this.modules[this.currentModuleIx];
                if (curModule && curModule.terminate) {
                    curModule.terminate(direction)
                }
                if (this.chart.focusElement) {
                    this.chart.focusElement.removeFocusBorder()
                }
                this.currentModuleIx += direction;
                const newModule = this.modules && this.modules[this.currentModuleIx];
                if (newModule) {
                    if (newModule.validate && !newModule.validate()) {
                        return this.move(direction)
                    }
                    if (newModule.init) {
                        newModule.init(direction);
                        return !0
                    }
                }
                this.currentModuleIx = 0;
                this.exiting = !0;
                if (direction > 0) {
                    this.exitAnchor && this.exitAnchor.focus()
                } else {
                    this.tabindexContainer.focus()
                }
                return !1
            }
            onFocus(e) {
                const chart = this.chart
                    , focusComesFromChart = (e.relatedTarget && chart.container.contains(e.relatedTarget))
                    , a11yOptions = chart.options.accessibility
                    , keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation
                    , enabled = keyboardOptions && keyboardOptions.enabled;
                if (enabled && !this.exiting && !this.tabbingInBackwards && !this.isClickingChart && !focusComesFromChart) {
                    const ix = this.getFirstValidModuleIx();
                    if (ix !== null) {
                        this.currentModuleIx = ix;
                        this.modules[ix].init(1)
                    }
                }
                this.exiting = !1
            }
            onMouseUp(e) {
                delete this.isClickingChart;
                if (!this.keyboardReset && e.relatedTarget !== simulatedEventTarget) {
                    const chart = this.chart;
                    if (!e.target || !chart.container.contains(e.target)) {
                        const curMod = this.modules && this.modules[this.currentModuleIx || 0];
                        if (curMod && curMod.terminate) {
                            curMod.terminate()
                        }
                        this.currentModuleIx = 0
                    }
                    if (chart.focusElement) {
                        chart.focusElement.removeFocusBorder();
                        delete chart.focusElement
                    }
                    this.keyboardReset = !0
                }
            }
            onKeydown(ev) {
                const e = ev || win.event
                    , curNavModule = (this.modules && this.modules.length && this.modules[this.currentModuleIx]);
                let preventDefault;
                const target = e.target;
                if (target && target.nodeName === 'INPUT' && !target.classList.contains('highcharts-a11y-proxy-element')) {
                    return
                }
                this.keyboardReset = !1;
                this.exiting = !1;
                if (curNavModule) {
                    const response = curNavModule.run(e);
                    if (response === curNavModule.response.success) {
                        preventDefault = !0
                    } else if (response === curNavModule.response.prev) {
                        preventDefault = this.move(-1)
                    } else if (response === curNavModule.response.next) {
                        preventDefault = this.move(1)
                    }
                    if (preventDefault) {
                        e.preventDefault();
                        e.stopPropagation()
                    }
                }
            }
            updateContainerTabindex() {
                const a11yOptions = this.chart.options.accessibility
                    , keyboardOptions = a11yOptions && a11yOptions.keyboardNavigation
                    , shouldHaveTabindex = !(keyboardOptions && keyboardOptions.enabled === !1)
                    , chart = this.chart
                    , container = chart.container;
                let tabindexContainer;
                if (chart.renderTo.hasAttribute('tabindex')) {
                    container.removeAttribute('tabindex');
                    tabindexContainer = chart.renderTo
                } else {
                    tabindexContainer = container
                }
                this.tabindexContainer = tabindexContainer;
                const curTabindex = tabindexContainer.getAttribute('tabindex');
                if (shouldHaveTabindex && !curTabindex) {
                    tabindexContainer.setAttribute('tabindex', '0')
                } else if (!shouldHaveTabindex) {
                    chart.container.removeAttribute('tabindex')
                }
            }
            createExitAnchor() {
                const chart = this.chart
                    , exitAnchor = this.exitAnchor = doc.createElement('div');
                chart.renderTo.appendChild(exitAnchor);
                this.makeElementAnExitAnchor(exitAnchor)
            }
            makeElementAnExitAnchor(el) {
                const chartTabindex = this.tabindexContainer.getAttribute('tabindex') || 0;
                el.setAttribute('class', 'highcharts-exit-anchor');
                el.setAttribute('tabindex', chartTabindex);
                el.setAttribute('aria-hidden', !1);
                this.addExitAnchorEventsToEl(el)
            }
            removeExitAnchor() {
                if (this.exitAnchor && this.exitAnchor.parentNode) {
                    this.exitAnchor.parentNode.removeChild(this.exitAnchor);
                    delete this.exitAnchor
                }
            }
            addExitAnchorEventsToEl(element) {
                const chart = this.chart
                    , keyboardNavigation = this;
                this.eventProvider.addEvent(element, 'focus', function(ev) {
                    const e = ev || win.event
                        , focusComesFromChart = (e.relatedTarget && chart.container.contains(e.relatedTarget))
                        , comingInBackwards = !(focusComesFromChart || keyboardNavigation.exiting);
                    if (chart.focusElement) {
                        delete chart.focusElement
                    }
                    if (comingInBackwards) {
                        keyboardNavigation.tabbingInBackwards = !0;
                        keyboardNavigation.tabindexContainer.focus();
                        delete keyboardNavigation.tabbingInBackwards;
                        e.preventDefault();
                        if (keyboardNavigation.modules && keyboardNavigation.modules.length) {
                            keyboardNavigation.currentModuleIx = keyboardNavigation.modules.length - 1;
                            const curModule = keyboardNavigation.modules[keyboardNavigation.currentModuleIx];
                            if (curModule && curModule.validate && !curModule.validate()) {
                                keyboardNavigation.move(-1)
                            } else if (curModule) {
                                curModule.init(-1)
                            }
                        }
                    } else {
                        keyboardNavigation.exiting = !1
                    }
                })
            }
            getFirstValidModuleIx() {
                const len = this.modules.length;
                for (let i = 0; i < len; ++i) {
                    const mod = this.modules[i];
                    if (!mod.validate || mod.validate()) {
                        return i
                    }
                }
                return null
            }
            destroy() {
                this.removeExitAnchor();
                this.eventProvider.removeAddedEvents();
                this.chart.container.removeAttribute('tabindex')
            }
        }
        (function(KeyboardNavigation) {
                const composedMembers = [];
                function compose(ChartClass) {
                    MenuComponent.compose(ChartClass);
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.dismissPopupContent = chartDismissPopupContent
                    }
                    if (U.pushUnique(composedMembers, doc)) {
                        addEvent(doc, 'keydown', documentOnKeydown)
                    }
                    return ChartClass
                }
                KeyboardNavigation.compose = compose;
                function chartDismissPopupContent() {
                    const chart = this;
                    fireEvent(this, 'dismissPopupContent', {}, function() {
                        if (chart.tooltip) {
                            chart.tooltip.hide(0)
                        }
                        chart.hideExportMenu()
                    })
                }
                function documentOnKeydown(e) {
                    const keycode = e.which || e.keyCode;
                    const esc = 27;
                    if (keycode === esc && H.charts) {
                        H.charts.forEach( (chart) => {
                                if (chart && chart.dismissPopupContent) {
                                    chart.dismissPopupContent()
                                }
                            }
                        )
                    }
                }
            }
        )(KeyboardNavigation || (KeyboardNavigation = {}));
        return KeyboardNavigation
    });
    _registerModule(_modules, 'Accessibility/Components/LegendComponent.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Legend/Legend.js'], _modules['Core/Utilities.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function(A, H, Legend, U, AccessibilityComponent, KeyboardNavigationHandler, CU, HU) {
        const {animObject} = A;
        const {doc} = H;
        const {addEvent, fireEvent, isNumber, pick, syncTimeout} = U;
        const {getChartTitle} = CU;
        const {stripHTMLTagsFromString: stripHTMLTags, addClass, removeClass} = HU;
        function scrollLegendToItem(legend, itemIx) {
            const itemPage = (legend.allItems[itemIx].legendItem || {}).pageIx
                , curPage = legend.currentPage;
            if (typeof itemPage !== 'undefined' && itemPage + 1 !== curPage) {
                legend.scroll(1 + itemPage - curPage)
            }
        }
        function shouldDoLegendA11y(chart) {
            const items = chart.legend && chart.legend.allItems
                , legendA11yOptions = (chart.options.legend.accessibility || {})
                , unsupportedColorAxis = chart.colorAxis && chart.colorAxis.some( (c) => !c.dataClasses || !c.dataClasses.length);
            return !!(items && items.length && !unsupportedColorAxis && legendA11yOptions.enabled !== !1)
        }
        function setLegendItemHoverState(hoverActive, item) {
            const legendItem = item.legendItem || {};
            item.setState(hoverActive ? 'hover' : '', !0);
            for (const key of ['group', 'label', 'symbol']) {
                const svgElement = legendItem[key];
                const element = svgElement && svgElement.element || svgElement;
                if (element) {
                    fireEvent(element, hoverActive ? 'mouseover' : 'mouseout')
                }
            }
        }
        class LegendComponent extends AccessibilityComponent {
            constructor() {
                super(...arguments);
                this.highlightedLegendItemIx = NaN;
                this.proxyGroup = null
            }
            init() {
                const component = this;
                this.recreateProxies();
                this.addEvent(Legend, 'afterScroll', function() {
                    if (this.chart === component.chart) {
                        component.proxyProvider.updateGroupProxyElementPositions('legend');
                        component.updateLegendItemProxyVisibility();
                        if (component.highlightedLegendItemIx > -1) {
                            this.chart.highlightLegendItem(component.highlightedLegendItemIx)
                        }
                    }
                });
                this.addEvent(Legend, 'afterPositionItem', function(e) {
                    if (this.chart === component.chart && this.chart.renderer) {
                        component.updateProxyPositionForItem(e.item)
                    }
                });
                this.addEvent(Legend, 'afterRender', function() {
                    if (this.chart === component.chart && this.chart.renderer && component.recreateProxies()) {
                        syncTimeout( () => component.proxyProvider.updateGroupProxyElementPositions('legend'), animObject(pick(this.chart.renderer.globalAnimation, !0)).duration)
                    }
                })
            }
            updateLegendItemProxyVisibility() {
                const chart = this.chart;
                const legend = chart.legend;
                const items = legend.allItems || [];
                const curPage = legend.currentPage || 1;
                const clipHeight = legend.clipHeight || 0;
                let legendItem;
                items.forEach( (item) => {
                        if (item.a11yProxyElement) {
                            const hasPages = legend.pages && legend.pages.length;
                            const proxyEl = item.a11yProxyElement.element;
                            let hide = !1;
                            legendItem = item.legendItem || {};
                            if (hasPages) {
                                const itemPage = legendItem.pageIx || 0;
                                const y = legendItem.y || 0;
                                const h = legendItem.label ? Math.round(legendItem.label.getBBox().height) : 0;
                                hide = y + h - legend.pages[itemPage] > clipHeight || itemPage !== curPage - 1
                            }
                            if (hide) {
                                if (chart.styledMode) {
                                    addClass(proxyEl, 'highcharts-a11y-invisible')
                                } else {
                                    proxyEl.style.visibility = 'hidden'
                                }
                            } else {
                                removeClass(proxyEl, 'highcharts-a11y-invisible');
                                proxyEl.style.visibility = ''
                            }
                        }
                    }
                )
            }
            onChartRender() {
                if (!shouldDoLegendA11y(this.chart)) {
                    this.removeProxies()
                }
            }
            highlightAdjacentLegendPage(direction) {
                const chart = this.chart;
                const legend = chart.legend;
                const curPageIx = legend.currentPage || 1;
                const newPageIx = curPageIx + direction;
                const pages = legend.pages || [];
                if (newPageIx > 0 && newPageIx <= pages.length) {
                    let i = 0, res;
                    for (const item of legend.allItems) {
                        if (((item.legendItem || {}).pageIx || 0) + 1 === newPageIx) {
                            res = chart.highlightLegendItem(i);
                            if (res) {
                                this.highlightedLegendItemIx = i
                            }
                        }
                        ++i
                    }
                }
            }
            updateProxyPositionForItem(item) {
                if (item.a11yProxyElement) {
                    item.a11yProxyElement.refreshPosition()
                }
            }
            recreateProxies() {
                const focusedElement = doc.activeElement;
                const proxyGroup = this.proxyGroup;
                const shouldRestoreFocus = focusedElement && proxyGroup && proxyGroup.contains(focusedElement);
                this.removeProxies();
                if (shouldDoLegendA11y(this.chart)) {
                    this.addLegendProxyGroup();
                    this.proxyLegendItems();
                    this.updateLegendItemProxyVisibility();
                    this.updateLegendTitle();
                    if (shouldRestoreFocus) {
                        this.chart.highlightLegendItem(this.highlightedLegendItemIx)
                    }
                    return !0
                }
                return !1
            }
            removeProxies() {
                this.proxyProvider.removeGroup('legend')
            }
            updateLegendTitle() {
                const chart = this.chart;
                const legendTitle = stripHTMLTags((chart.legend && chart.legend.options.title && chart.legend.options.title.text || '').replace(/<br ?\/?>/g, ' '), chart.renderer.forExport);
                const legendLabel = chart.langFormat('accessibility.legend.legendLabel' + (legendTitle ? '' : 'NoTitle'), {
                    chart,
                    legendTitle,
                    chartTitle: getChartTitle(chart)
                });
                this.proxyProvider.updateGroupAttrs('legend', {
                    'aria-label': legendLabel
                })
            }
            addLegendProxyGroup() {
                const a11yOptions = this.chart.options.accessibility;
                const groupRole = a11yOptions.landmarkVerbosity === 'all' ? 'region' : null;
                this.proxyGroup = this.proxyProvider.addGroup('legend', 'ul', {
                    'aria-label': '_placeholder_',
                    role: groupRole
                })
            }
            proxyLegendItems() {
                const component = this
                    , items = (this.chart.legend || {}).allItems || [];
                let legendItem;
                items.forEach( (item) => {
                        legendItem = item.legendItem || {};
                        if (legendItem.label && legendItem.label.element) {
                            component.proxyLegendItem(item)
                        }
                    }
                )
            }
            proxyLegendItem(item) {
                const legendItem = item.legendItem || {};
                if (!legendItem.label || !legendItem.group) {
                    return
                }
                const itemLabel = this.chart.langFormat('accessibility.legend.legendItem', {
                    chart: this.chart,
                    itemName: stripHTMLTags(item.name, this.chart.renderer.forExport),
                    item
                });
                const attribs = {
                    tabindex: -1,
                    'aria-pressed': item.visible,
                    'aria-label': itemLabel
                };
                const proxyPositioningElement = legendItem.group.div ? legendItem.label : legendItem.group;
                item.a11yProxyElement = this.proxyProvider.addProxyElement('legend', {
                    click: legendItem.label,
                    visual: proxyPositioningElement.element
                }, 'button', attribs)
            }
            getKeyboardNavigation() {
                const keys = this.keyCodes
                    , component = this
                    , chart = this.chart;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[[keys.left, keys.right, keys.up, keys.down], function(keyCode) {
                        return component.onKbdArrowKey(this, keyCode)
                    }
                    ], [[keys.enter, keys.space], function() {
                        return component.onKbdClick(this)
                    }
                    ], [[keys.pageDown, keys.pageUp], function(keyCode) {
                        const direction = keyCode === keys.pageDown ? 1 : -1;
                        component.highlightAdjacentLegendPage(direction);
                        return this.response.success
                    }
                    ]],
                    validate: function() {
                        return component.shouldHaveLegendNavigation()
                    },
                    init: function() {
                        chart.highlightLegendItem(0);
                        component.highlightedLegendItemIx = 0
                    },
                    terminate: function() {
                        component.highlightedLegendItemIx = -1;
                        chart.legend.allItems.forEach( (item) => setLegendItemHoverState(!1, item))
                    }
                })
            }
            onKbdArrowKey(keyboardNavigationHandler, keyCode) {
                const keys = this.keyCodes
                    , response = keyboardNavigationHandler.response
                    , chart = this.chart
                    , a11yOptions = chart.options.accessibility
                    , numItems = chart.legend.allItems.length
                    , direction = (keyCode === keys.left || keyCode === keys.up) ? -1 : 1;
                const res = chart.highlightLegendItem(this.highlightedLegendItemIx + direction);
                if (res) {
                    this.highlightedLegendItemIx += direction;
                    return response.success
                }
                if (numItems > 1 && a11yOptions.keyboardNavigation.wrapAround) {
                    keyboardNavigationHandler.init(direction);
                    return response.success
                }
                return response.success
            }
            onKbdClick(keyboardNavigationHandler) {
                const legendItem = this.chart.legend.allItems[this.highlightedLegendItemIx];
                if (legendItem && legendItem.a11yProxyElement) {
                    legendItem.a11yProxyElement.click()
                }
                return keyboardNavigationHandler.response.success
            }
            shouldHaveLegendNavigation() {
                if (!shouldDoLegendA11y(this.chart)) {
                    return !1
                }
                const chart = this.chart
                    , legendOptions = chart.options.legend || {}
                    , legendA11yOptions = (legendOptions.accessibility || {});
                return !!(chart.legend.display && legendA11yOptions.keyboardNavigation && legendA11yOptions.keyboardNavigation.enabled)
            }
            destroy() {
                this.removeProxies()
            }
        }
        (function(LegendComponent) {
                const composedMembers = [];
                function chartHighlightLegendItem(ix) {
                    const items = this.legend.allItems;
                    const oldIx = this.accessibility && this.accessibility.components.legend.highlightedLegendItemIx;
                    const itemToHighlight = items[ix]
                        , legendItem = itemToHighlight.legendItem || {};
                    if (itemToHighlight) {
                        if (isNumber(oldIx) && items[oldIx]) {
                            setLegendItemHoverState(!1, items[oldIx])
                        }
                        scrollLegendToItem(this.legend, ix);
                        const legendItemProp = legendItem.label;
                        const proxyBtn = itemToHighlight.a11yProxyElement && itemToHighlight.a11yProxyElement.innerElement;
                        if (legendItemProp && legendItemProp.element && proxyBtn) {
                            this.setFocusToElement(legendItemProp, proxyBtn)
                        }
                        setLegendItemHoverState(!0, itemToHighlight);
                        return !0
                    }
                    return !1
                }
                function compose(ChartClass, LegendClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.highlightLegendItem = chartHighlightLegendItem
                    }
                    if (U.pushUnique(composedMembers, LegendClass)) {
                        addEvent(LegendClass, 'afterColorizeItem', legendOnAfterColorizeItem)
                    }
                }
                LegendComponent.compose = compose;
                function legendOnAfterColorizeItem(e) {
                    const chart = this.chart
                        , a11yOptions = chart.options.accessibility
                        , legendItem = e.item;
                    if (a11yOptions.enabled && legendItem && legendItem.a11yProxyElement) {
                        legendItem.a11yProxyElement.innerElement.setAttribute('aria-pressed', e.visible ? 'true' : 'false')
                    }
                }
            }
        )(LegendComponent || (LegendComponent = {}));
        return LegendComponent
    });
    _registerModule(_modules, 'Core/Axis/NavigatorAxisComposition.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function(H, U) {
        const {isTouchDevice} = H;
        const {addEvent, correctFloat, defined, isNumber, pick} = U;
        const composedMembers = [];
        function onAxisInit() {
            const axis = this;
            if (!axis.navigatorAxis) {
                axis.navigatorAxis = new NavigatorAxisAdditions(axis)
            }
        }
        function onAxisZoom(e) {
            const axis = this
                , chart = axis.chart
                , chartOptions = chart.options
                , navigator = chartOptions.navigator
                , navigatorAxis = axis.navigatorAxis
                , pinchType = chart.zooming.pinchType
                , rangeSelector = chartOptions.rangeSelector
                , zoomType = chart.zooming.type;
            if (axis.isXAxis && ((navigator && navigator.enabled) || (rangeSelector && rangeSelector.enabled))) {
                if (zoomType === 'y') {
                    e.zoomed = !1
                } else if (((!isTouchDevice && zoomType === 'xy') || (isTouchDevice && pinchType === 'xy')) && axis.options.range) {
                    const previousZoom = navigatorAxis.previousZoom;
                    if (defined(e.newMin)) {
                        navigatorAxis.previousZoom = [axis.min, axis.max]
                    } else if (previousZoom) {
                        e.newMin = previousZoom[0];
                        e.newMax = previousZoom[1];
                        navigatorAxis.previousZoom = void 0
                    }
                }
            }
            if (typeof e.zoomed !== 'undefined') {
                e.preventDefault()
            }
        }
        class NavigatorAxisAdditions {
            static compose(AxisClass) {
                if (U.pushUnique(composedMembers, AxisClass)) {
                    AxisClass.keepProps.push('navigatorAxis');
                    addEvent(AxisClass, 'init', onAxisInit);
                    addEvent(AxisClass, 'zoom', onAxisZoom)
                }
            }
            constructor(axis) {
                this.axis = axis
            }
            destroy() {
                this.axis = void 0
            }
            toFixedRange(pxMin, pxMax, fixedMin, fixedMax) {
                const axis = this.axis
                    , chart = axis.chart;
                let newMin = pick(fixedMin, axis.translate(pxMin, !0, !axis.horiz))
                    , newMax = pick(fixedMax, axis.translate(pxMax, !0, !axis.horiz));
                const fixedRange = chart && chart.fixedRange
                    , halfPointRange = (axis.pointRange || 0) / 2;
                if (!defined(fixedMin)) {
                    newMin = correctFloat(newMin + halfPointRange)
                }
                if (!defined(fixedMax)) {
                    newMax = correctFloat(newMax - halfPointRange)
                }
                if (fixedRange && axis.dataMin && axis.dataMax) {
                    if (newMax >= axis.dataMax) {
                        newMin = correctFloat(axis.dataMax - fixedRange)
                    }
                    if (newMin <= axis.dataMin) {
                        newMax = correctFloat(axis.dataMin + fixedRange)
                    }
                }
                if (!isNumber(newMin) || !isNumber(newMax)) {
                    newMin = newMax = void 0
                }
                return {
                    min: newMin,
                    max: newMax
                }
            }
        }
        return NavigatorAxisAdditions
    });
    _registerModule(_modules, 'Stock/Navigator/NavigatorDefaults.js', [_modules['Core/Color/Color.js'], _modules['Core/Series/SeriesRegistry.js']], function(Color, SeriesRegistry) {
        const {parse: color} = Color;
        const {seriesTypes} = SeriesRegistry;
        const NavigatorDefaults = {
            height: 40,
            margin: 25,
            maskInside: !0,
            handles: {
                width: 7,
                height: 15,
                symbols: ['navigator-handle', 'navigator-handle'],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: "#f2f2f2",
                borderColor: "#999999"
            },
            maskFill: color("#667aff").setOpacity(0.3).get(),
            outlineColor: "#999999",
            outlineWidth: 1,
            series: {
                type: (typeof seriesTypes.areaspline === 'undefined' ? 'line' : 'areaspline'),
                fillOpacity: 0.05,
                lineWidth: 1,
                compare: null,
                sonification: {
                    enabled: !1
                },
                dataGrouping: {
                    approximation: 'average',
                    enabled: !0,
                    groupPixelWidth: 2,
                    firstAnchor: 'firstPoint',
                    anchor: 'middle',
                    lastAnchor: 'lastPoint',
                    units: [['millisecond', [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ['second', [1, 2, 5, 10, 15, 30]], ['minute', [1, 2, 5, 10, 15, 30]], ['hour', [1, 2, 3, 4, 6, 8, 12]], ['day', [1, 2, 3, 4]], ['week', [1, 2, 3]], ['month', [1, 3, 6]], ['year', null]]
                },
                dataLabels: {
                    enabled: !1,
                    zIndex: 2
                },
                id: 'highcharts-navigator-series',
                className: 'highcharts-navigator-series',
                lineColor: null,
                marker: {
                    enabled: !1
                },
                threshold: null
            },
            xAxis: {
                overscroll: 0,
                className: 'highcharts-navigator-xaxis',
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: "#e6e6e6",
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                    align: 'left',
                    style: {
                        color: "#000000",
                        fontSize: '0.7em',
                        opacity: 0.6,
                        textOutline: '2px contrast'
                    },
                    x: 3,
                    y: -4
                },
                crosshair: !1
            },
            yAxis: {
                className: 'highcharts-navigator-yaxis',
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: 0.1,
                maxPadding: 0.1,
                labels: {
                    enabled: !1
                },
                crosshair: !1,
                title: {
                    text: null
                },
                tickLength: 0,
                tickWidth: 0
            }
        };
        ('');
        return NavigatorDefaults
    });
    _registerModule(_modules, 'Stock/Navigator/NavigatorSymbols.js', [], function() {
        function navigatorHandle(_x, _y, width, height, options={}) {
            const halfWidth = options.width ? options.width / 2 : width
                , markerPosition = Math.round(halfWidth / 3) + 0.5;
            height = options.height || height;
            return [['M', -halfWidth - 1, 0.5], ['L', halfWidth, 0.5], ['L', halfWidth, height + 0.5], ['L', -halfWidth - 1, height + 0.5], ['L', -halfWidth - 1, 0.5], ['M', -markerPosition, 4], ['L', -markerPosition, height - 3], ['M', markerPosition - 1, 4], ['L', markerPosition - 1, height - 3]]
        }
        const NavigatorSymbols = {
            'navigator-handle': navigatorHandle
        };
        return NavigatorSymbols
    });
    _registerModule(_modules, 'Stock/Navigator/NavigatorComposition.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Axis/NavigatorAxisComposition.js'], _modules['Stock/Navigator/NavigatorDefaults.js'], _modules['Stock/Navigator/NavigatorSymbols.js'], _modules['Core/Renderer/RendererRegistry.js'], _modules['Core/Utilities.js']], function(D, H, NavigatorAxisAdditions, NavigatorDefaults, NavigatorSymbols, RendererRegistry, U) {
        const {defaultOptions, setOptions} = D;
        const {isTouchDevice} = H;
        const {getRendererType} = RendererRegistry;
        const {addEvent, extend, merge, pick} = U;
        const composedMembers = [];
        let NavigatorConstructor;
        function compose(AxisClass, ChartClass, NavigatorClass, SeriesClass) {
            NavigatorAxisAdditions.compose(AxisClass);
            NavigatorConstructor = NavigatorClass;
            if (U.pushUnique(composedMembers, ChartClass)) {
                const chartProto = ChartClass.prototype;
                chartProto.callbacks.push(onChartCallback);
                addEvent(ChartClass, 'afterAddSeries', onChartAfterAddSeries);
                addEvent(ChartClass, 'afterSetChartSize', onChartAfterSetChartSize);
                addEvent(ChartClass, 'afterUpdate', onChartAfterUpdate);
                addEvent(ChartClass, 'beforeRender', onChartBeforeRender);
                addEvent(ChartClass, 'beforeShowResetZoom', onChartBeforeShowResetZoom);
                addEvent(ChartClass, 'update', onChartUpdate)
            }
            if (U.pushUnique(composedMembers, SeriesClass)) {
                addEvent(SeriesClass, 'afterUpdate', onSeriesAfterUpdate)
            }
            if (U.pushUnique(composedMembers, getRendererType)) {
                extend(getRendererType().prototype.symbols, NavigatorSymbols)
            }
            if (U.pushUnique(composedMembers, setOptions)) {
                extend(defaultOptions, {
                    navigator: NavigatorDefaults
                })
            }
        }
        function onChartAfterAddSeries() {
            if (this.navigator) {
                this.navigator.setBaseSeries(null, !1)
            }
        }
        function onChartAfterSetChartSize() {
            const legend = this.legend
                , navigator = this.navigator;
            let legendOptions, xAxis, yAxis;
            if (navigator) {
                legendOptions = legend && legend.options;
                xAxis = navigator.xAxis;
                yAxis = navigator.yAxis;
                const {scrollbarHeight, scrollButtonSize} = navigator;
                if (this.inverted) {
                    navigator.left = navigator.opposite ? this.chartWidth - scrollbarHeight - navigator.height : this.spacing[3] + scrollbarHeight;
                    navigator.top = this.plotTop + scrollButtonSize
                } else {
                    navigator.left = pick(xAxis.left, this.plotLeft + scrollButtonSize);
                    navigator.top = navigator.navigatorOptions.top || this.chartHeight - navigator.height - scrollbarHeight - (this.scrollbar?.options.margin || 0) - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - ((legendOptions && legendOptions.verticalAlign === 'bottom' && legendOptions.layout !== 'proximate' && legendOptions.enabled && !legendOptions.floating) ? legend.legendHeight + pick(legendOptions.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0)
                }
                if (xAxis && yAxis) {
                    if (this.inverted) {
                        xAxis.options.left = yAxis.options.left = navigator.left
                    } else {
                        xAxis.options.top = yAxis.options.top = navigator.top
                    }
                    xAxis.setAxisSize();
                    yAxis.setAxisSize()
                }
            }
        }
        function onChartAfterUpdate(event) {
            if (!this.navigator && !this.scroller && (this.options.navigator.enabled || this.options.scrollbar.enabled)) {
                this.scroller = this.navigator = new NavigatorConstructor(this);
                if (pick(event.redraw, !0)) {
                    this.redraw(event.animation)
                }
            }
        }
        function onChartBeforeRender() {
            const options = this.options;
            if (options.navigator.enabled || options.scrollbar.enabled) {
                this.scroller = this.navigator = new NavigatorConstructor(this)
            }
        }
        function onChartBeforeShowResetZoom() {
            const chartOptions = this.options
                , navigator = chartOptions.navigator
                , rangeSelector = chartOptions.rangeSelector;
            if (((navigator && navigator.enabled) || (rangeSelector && rangeSelector.enabled)) && ((!isTouchDevice && this.zooming.type === 'x') || (isTouchDevice && this.zooming.pinchType === 'x'))) {
                return !1
            }
        }
        function onChartCallback(chart) {
            const navigator = chart.navigator;
            if (navigator && chart.xAxis[0]) {
                const extremes = chart.xAxis[0].getExtremes();
                navigator.render(extremes.min, extremes.max)
            }
        }
        function onChartUpdate(e) {
            const navigatorOptions = (e.options.navigator || {})
                , scrollbarOptions = (e.options.scrollbar || {});
            if (!this.navigator && !this.scroller && (navigatorOptions.enabled || scrollbarOptions.enabled)) {
                merge(!0, this.options.navigator, navigatorOptions);
                merge(!0, this.options.scrollbar, scrollbarOptions);
                delete e.options.navigator;
                delete e.options.scrollbar
            }
        }
        function onSeriesAfterUpdate() {
            if (this.chart.navigator && !this.options.isInternal) {
                this.chart.navigator.setBaseSeries(null, !1)
            }
        }
        const NavigatorComposition = {
            compose
        };
        return NavigatorComposition
    });
    _registerModule(_modules, 'Core/Axis/ScrollbarAxis.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, defined, pick, pushUnique} = U;
        var ScrollbarAxis;
        (function(ScrollbarAxis) {
                const composedMembers = [];
                let Scrollbar;
                function compose(AxisClass, ScrollbarClass) {
                    if (pushUnique(composedMembers, ScrollbarClass)) {
                        Scrollbar = ScrollbarClass
                    }
                    if (pushUnique(composedMembers, AxisClass)) {
                        addEvent(AxisClass, 'afterGetOffset', onAxisAfterGetOffset);
                        addEvent(AxisClass, 'afterInit', onAxisAfterInit);
                        addEvent(AxisClass, 'afterRender', onAxisAfterRender)
                    }
                }
                ScrollbarAxis.compose = compose;
                function getExtremes(axis) {
                    const axisMin = pick(axis.options && axis.options.min, axis.min);
                    const axisMax = pick(axis.options && axis.options.max, axis.max);
                    return {
                        axisMin,
                        axisMax,
                        scrollMin: defined(axis.dataMin) ? Math.min(axisMin, axis.min, axis.dataMin, pick(axis.threshold, Infinity)) : axisMin,
                        scrollMax: defined(axis.dataMax) ? Math.max(axisMax, axis.max, axis.dataMax, pick(axis.threshold, -Infinity)) : axisMax
                    }
                }
                function onAxisAfterGetOffset() {
                    const axis = this
                        , scrollbar = axis.scrollbar
                        , opposite = scrollbar && !scrollbar.options.opposite
                        , index = axis.horiz ? 2 : opposite ? 3 : 1;
                    if (scrollbar) {
                        axis.chart.scrollbarsOffsets = [0, 0];
                        axis.chart.axisOffset[index] += scrollbar.size + (scrollbar.options.margin || 0)
                    }
                }
                function onAxisAfterInit() {
                    const axis = this;
                    if (axis.options && axis.options.scrollbar && axis.options.scrollbar.enabled) {
                        axis.options.scrollbar.vertical = !axis.horiz;
                        axis.options.startOnTick = axis.options.endOnTick = !1;
                        axis.scrollbar = new Scrollbar(axis.chart.renderer,axis.options.scrollbar,axis.chart);
                        addEvent(axis.scrollbar, 'changed', function(e) {
                            const {axisMin, axisMax, scrollMin: unitedMin, scrollMax: unitedMax} = getExtremes(axis)
                                , range = unitedMax - unitedMin;
                            let to, from;
                            if (!defined(axisMin) || !defined(axisMax)) {
                                return
                            }
                            if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {
                                to = unitedMin + range * this.to;
                                from = unitedMin + range * this.from
                            } else {
                                to = unitedMin + range * (1 - this.from);
                                from = unitedMin + range * (1 - this.to)
                            }
                            if (this.shouldUpdateExtremes(e.DOMType)) {
                                const animate = e.DOMType === 'mousemove' || e.DOMType === 'touchmove' ? !1 : void 0;
                                axis.setExtremes(from, to, !0, animate, e)
                            } else {
                                this.setRange(this.from, this.to)
                            }
                        })
                    }
                }
                function onAxisAfterRender() {
                    const axis = this
                        , {scrollMin, scrollMax} = getExtremes(axis)
                        , scrollbar = axis.scrollbar
                        , offset = (axis.axisTitleMargin + (axis.titleOffset || 0))
                        , scrollbarsOffsets = axis.chart.scrollbarsOffsets
                        , axisMargin = axis.options.margin || 0;
                    let offsetsIndex, from, to;
                    if (scrollbar && scrollbarsOffsets) {
                        if (axis.horiz) {
                            if (!axis.opposite) {
                                scrollbarsOffsets[1] += offset
                            }
                            scrollbar.position(axis.left, (axis.top + axis.height + 2 + scrollbarsOffsets[1] - (axis.opposite ? axisMargin : 0)), axis.width, axis.height);
                            if (!axis.opposite) {
                                scrollbarsOffsets[1] += axisMargin
                            }
                            offsetsIndex = 1
                        } else {
                            if (axis.opposite) {
                                scrollbarsOffsets[0] += offset
                            }
                            let xPosition;
                            if (!scrollbar.options.opposite) {
                                xPosition = axis.opposite ? 0 : axisMargin
                            } else {
                                xPosition = axis.left + axis.width + 2 + scrollbarsOffsets[0] - (axis.opposite ? 0 : axisMargin)
                            }
                            scrollbar.position(xPosition, axis.top, axis.width, axis.height);
                            if (axis.opposite) {
                                scrollbarsOffsets[0] += axisMargin
                            }
                            offsetsIndex = 0
                        }
                        scrollbarsOffsets[offsetsIndex] += scrollbar.size + (scrollbar.options.margin || 0);
                        if (isNaN(scrollMin) || isNaN(scrollMax) || !defined(axis.min) || !defined(axis.max) || axis.min === axis.max) {
                            scrollbar.setRange(0, 1)
                        } else {
                            from = ((axis.min - scrollMin) / (scrollMax - scrollMin));
                            to = ((axis.max - scrollMin) / (scrollMax - scrollMin));
                            if ((axis.horiz && !axis.reversed) || (!axis.horiz && axis.reversed)) {
                                scrollbar.setRange(from, to)
                            } else {
                                scrollbar.setRange(1 - to, 1 - from)
                            }
                        }
                    }
                }
            }
        )(ScrollbarAxis || (ScrollbarAxis = {}));
        return ScrollbarAxis
    });
    _registerModule(_modules, 'Stock/Scrollbar/ScrollbarDefaults.js', [_modules['Core/Globals.js']], function(H) {
        const {isTouchDevice} = H;
        const ScrollbarDefaults = {
            height: 10,
            barBorderRadius: 5,
            buttonBorderRadius: 0,
            buttonsEnabled: !1,
            liveRedraw: void 0,
            margin: void 0,
            minWidth: 6,
            opposite: !0,
            step: 0.2,
            zIndex: 3,
            barBackgroundColor: "#cccccc",
            barBorderWidth: 0,
            barBorderColor: "#cccccc",
            buttonArrowColor: "#333333",
            buttonBackgroundColor: "#e6e6e6",
            buttonBorderColor: "#cccccc",
            buttonBorderWidth: 1,
            rifleColor: 'none',
            trackBackgroundColor: 'rgba(255, 255, 255, 0.001)',
            trackBorderColor: "#cccccc",
            trackBorderRadius: 5,
            trackBorderWidth: 1
        };
        return ScrollbarDefaults
    });
    _registerModule(_modules, 'Stock/Scrollbar/Scrollbar.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Axis/ScrollbarAxis.js'], _modules['Stock/Scrollbar/ScrollbarDefaults.js'], _modules['Core/Utilities.js']], function(D, H, ScrollbarAxis, ScrollbarDefaults, U) {
        const {defaultOptions} = D;
        const {addEvent, correctFloat, defined, destroyObjectProperties, fireEvent, merge, pick, removeEvent} = U;
        class Scrollbar {
            static compose(AxisClass) {
                ScrollbarAxis.compose(AxisClass, Scrollbar)
            }
            static swapXY(path, vertical) {
                if (vertical) {
                    path.forEach( (seg) => {
                            const len = seg.length;
                            let temp;
                            for (let i = 0; i < len; i += 2) {
                                temp = seg[i + 1];
                                if (typeof temp === 'number') {
                                    seg[i + 1] = seg[i + 2];
                                    seg[i + 2] = temp
                                }
                            }
                        }
                    )
                }
                return path
            }
            constructor(renderer, options, chart) {
                this._events = [];
                this.chart = void 0;
                this.chartX = 0;
                this.chartY = 0;
                this.from = 0;
                this.group = void 0;
                this.options = void 0;
                this.renderer = void 0;
                this.scrollbar = void 0;
                this.scrollbarButtons = [];
                this.scrollbarGroup = void 0;
                this.scrollbarLeft = 0;
                this.scrollbarRifles = void 0;
                this.scrollbarStrokeWidth = 1;
                this.scrollbarTop = 0;
                this.size = 0;
                this.to = 0;
                this.track = void 0;
                this.trackBorderWidth = 1;
                this.userOptions = void 0;
                this.x = 0;
                this.y = 0;
                this.init(renderer, options, chart)
            }
            addEvents() {
                const buttonsOrder = this.options.inverted ? [1, 0] : [0, 1]
                    , buttons = this.scrollbarButtons
                    , bar = this.scrollbarGroup.element
                    , track = this.track.element
                    , mouseDownHandler = this.mouseDownHandler.bind(this)
                    , mouseMoveHandler = this.mouseMoveHandler.bind(this)
                    , mouseUpHandler = this.mouseUpHandler.bind(this);
                const _events = [[buttons[buttonsOrder[0]].element, 'click', this.buttonToMinClick.bind(this)], [buttons[buttonsOrder[1]].element, 'click', this.buttonToMaxClick.bind(this)], [track, 'click', this.trackClick.bind(this)], [bar, 'mousedown', mouseDownHandler], [bar.ownerDocument, 'mousemove', mouseMoveHandler], [bar.ownerDocument, 'mouseup', mouseUpHandler]];
                if (H.hasTouch) {
                    _events.push([bar, 'touchstart', mouseDownHandler], [bar.ownerDocument, 'touchmove', mouseMoveHandler], [bar.ownerDocument, 'touchend', mouseUpHandler])
                }
                _events.forEach(function(args) {
                    addEvent.apply(null, args)
                });
                this._events = _events
            }
            buttonToMaxClick(e) {
                const scroller = this;
                const range = ((scroller.to - scroller.from) * pick(scroller.options.step, 0.2));
                scroller.updatePosition(scroller.from + range, scroller.to + range);
                fireEvent(scroller, 'changed', {
                    from: scroller.from,
                    to: scroller.to,
                    trigger: 'scrollbar',
                    DOMEvent: e
                })
            }
            buttonToMinClick(e) {
                const scroller = this;
                const range = correctFloat(scroller.to - scroller.from) * pick(scroller.options.step, 0.2);
                scroller.updatePosition(correctFloat(scroller.from - range), correctFloat(scroller.to - range));
                fireEvent(scroller, 'changed', {
                    from: scroller.from,
                    to: scroller.to,
                    trigger: 'scrollbar',
                    DOMEvent: e
                })
            }
            cursorToScrollbarPosition(normalizedEvent) {
                const scroller = this
                    , options = scroller.options
                    , minWidthDifference = options.minWidth > scroller.calculatedWidth ? options.minWidth : 0;
                return {
                    chartX: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
                    chartY: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
                }
            }
            destroy() {
                const scroller = this
                    , navigator = scroller.chart.scroller;
                scroller.removeEvents();
                ['track', 'scrollbarRifles', 'scrollbar', 'scrollbarGroup', 'group'].forEach(function(prop) {
                    if (scroller[prop] && scroller[prop].destroy) {
                        scroller[prop] = scroller[prop].destroy()
                    }
                });
                if (navigator && scroller === navigator.scrollbar) {
                    navigator.scrollbar = null;
                    destroyObjectProperties(navigator.scrollbarButtons)
                }
            }
            drawScrollbarButton(index) {
                const scroller = this
                    , renderer = scroller.renderer
                    , scrollbarButtons = scroller.scrollbarButtons
                    , options = scroller.options
                    , size = scroller.size
                    , group = renderer.g().add(scroller.group);
                scrollbarButtons.push(group);
                if (options.buttonsEnabled) {
                    const rect = renderer.rect().addClass('highcharts-scrollbar-button').add(group);
                    if (!scroller.chart.styledMode) {
                        rect.attr({
                            stroke: options.buttonBorderColor,
                            'stroke-width': options.buttonBorderWidth,
                            fill: options.buttonBackgroundColor
                        })
                    }
                    rect.attr(rect.crisp({
                        x: -0.5,
                        y: -0.5,
                        width: size + 1,
                        height: size + 1,
                        r: options.buttonBorderRadius
                    }, rect.strokeWidth()));
                    const arrow = renderer.path(Scrollbar.swapXY([['M', size / 2 + (index ? -1 : 1), size / 2 - 3], ['L', size / 2 + (index ? -1 : 1), size / 2 + 3], ['L', size / 2 + (index ? 2 : -2), size / 2]], options.vertical)).addClass('highcharts-scrollbar-arrow').add(scrollbarButtons[index]);
                    if (!scroller.chart.styledMode) {
                        arrow.attr({
                            fill: options.buttonArrowColor
                        })
                    }
                }
            }
            init(renderer, options, chart) {
                const scroller = this;
                scroller.scrollbarButtons = [];
                scroller.renderer = renderer;
                scroller.userOptions = options;
                scroller.options = merge(ScrollbarDefaults, defaultOptions.scrollbar, options);
                scroller.options.margin = pick(scroller.options.margin, 10);
                scroller.chart = chart;
                scroller.size = pick(scroller.options.size, scroller.options.height);
                if (options.enabled) {
                    scroller.render();
                    scroller.addEvents()
                }
            }
            mouseDownHandler(e) {
                const scroller = this
                    , normalizedEvent = scroller.chart.pointer.normalize(e)
                    , mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
                scroller.chartX = mousePosition.chartX;
                scroller.chartY = mousePosition.chartY;
                scroller.initPositions = [scroller.from, scroller.to];
                scroller.grabbedCenter = !0
            }
            mouseMoveHandler(e) {
                const scroller = this
                    , normalizedEvent = scroller.chart.pointer.normalize(e)
                    , options = scroller.options
                    , direction = options.vertical ? 'chartY' : 'chartX'
                    , initPositions = scroller.initPositions || [];
                let scrollPosition, chartPosition, change;
                if (scroller.grabbedCenter && (!e.touches || e.touches[0][direction] !== 0)) {
                    chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
                    scrollPosition = scroller[direction];
                    change = chartPosition - scrollPosition;
                    scroller.hasDragged = !0;
                    scroller.updatePosition(initPositions[0] + change, initPositions[1] + change);
                    if (scroller.hasDragged) {
                        fireEvent(scroller, 'changed', {
                            from: scroller.from,
                            to: scroller.to,
                            trigger: 'scrollbar',
                            DOMType: e.type,
                            DOMEvent: e
                        })
                    }
                }
            }
            mouseUpHandler(e) {
                const scroller = this;
                if (scroller.hasDragged) {
                    fireEvent(scroller, 'changed', {
                        from: scroller.from,
                        to: scroller.to,
                        trigger: 'scrollbar',
                        DOMType: e.type,
                        DOMEvent: e
                    })
                }
                scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = null
            }
            position(x, y, width, height) {
                const scroller = this
                    , options = scroller.options
                    , {buttonsEnabled, margin=0, vertical} = options
                    , method = scroller.rendered ? 'animate' : 'attr';
                let xOffset = height
                    , yOffset = 0;
                scroller.group.show();
                scroller.x = x;
                scroller.y = y + this.trackBorderWidth;
                scroller.width = width;
                scroller.height = height;
                scroller.xOffset = xOffset;
                scroller.yOffset = yOffset;
                if (vertical) {
                    scroller.width = scroller.yOffset = width = yOffset = scroller.size;
                    scroller.xOffset = xOffset = 0;
                    scroller.yOffset = yOffset = buttonsEnabled ? scroller.size : 0;
                    scroller.barWidth = height - (buttonsEnabled ? width * 2 : 0);
                    scroller.x = x = x + margin
                } else {
                    scroller.height = height = scroller.size;
                    scroller.xOffset = xOffset = buttonsEnabled ? scroller.size : 0;
                    scroller.barWidth = width - (buttonsEnabled ? height * 2 : 0);
                    scroller.y = scroller.y + margin
                }
                scroller.group[method]({
                    translateX: x,
                    translateY: scroller.y
                });
                scroller.track[method]({
                    width: width,
                    height: height
                });
                scroller.scrollbarButtons[1][method]({
                    translateX: vertical ? 0 : width - xOffset,
                    translateY: vertical ? height - yOffset : 0
                })
            }
            removeEvents() {
                this._events.forEach(function(args) {
                    removeEvent.apply(null, args)
                });
                this._events.length = 0
            }
            render() {
                const scroller = this
                    , renderer = scroller.renderer
                    , options = scroller.options
                    , size = scroller.size
                    , styledMode = scroller.chart.styledMode
                    , group = renderer.g('scrollbar').attr({
                    zIndex: options.zIndex
                }).hide().add();
                scroller.group = group;
                scroller.track = renderer.rect().addClass('highcharts-scrollbar-track').attr({
                    r: options.trackBorderRadius || 0,
                    height: size,
                    width: size
                }).add(group);
                if (!styledMode) {
                    scroller.track.attr({
                        fill: options.trackBackgroundColor,
                        stroke: options.trackBorderColor,
                        'stroke-width': options.trackBorderWidth
                    })
                }
                const trackBorderWidth = scroller.trackBorderWidth = scroller.track.strokeWidth();
                scroller.track.attr({
                    x: -trackBorderWidth % 2 / 2,
                    y: -trackBorderWidth % 2 / 2
                });
                scroller.scrollbarGroup = renderer.g().add(group);
                scroller.scrollbar = renderer.rect().addClass('highcharts-scrollbar-thumb').attr({
                    height: size - trackBorderWidth,
                    width: size - trackBorderWidth,
                    r: options.barBorderRadius || 0
                }).add(scroller.scrollbarGroup);
                scroller.scrollbarRifles = renderer.path(Scrollbar.swapXY([['M', -3, size / 4], ['L', -3, 2 * size / 3], ['M', 0, size / 4], ['L', 0, 2 * size / 3], ['M', 3, size / 4], ['L', 3, 2 * size / 3]], options.vertical)).addClass('highcharts-scrollbar-rifles').add(scroller.scrollbarGroup);
                if (!styledMode) {
                    scroller.scrollbar.attr({
                        fill: options.barBackgroundColor,
                        stroke: options.barBorderColor,
                        'stroke-width': options.barBorderWidth
                    });
                    scroller.scrollbarRifles.attr({
                        stroke: options.rifleColor,
                        'stroke-width': 1
                    })
                }
                scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
                scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % 2 / 2, -scroller.scrollbarStrokeWidth % 2 / 2);
                scroller.drawScrollbarButton(0);
                scroller.drawScrollbarButton(1)
            }
            setRange(from, to) {
                const scroller = this
                    , options = scroller.options
                    , vertical = options.vertical
                    , minWidth = options.minWidth
                    , fullWidth = scroller.barWidth
                    , method = (this.rendered && !this.hasDragged && !(this.chart.navigator && this.chart.navigator.hasDragged)) ? 'animate' : 'attr';
                if (!defined(fullWidth)) {
                    return
                }
                const toPX = fullWidth * Math.min(to, 1);
                let fromPX, newSize;
                from = Math.max(from, 0);
                fromPX = Math.ceil(fullWidth * from);
                scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);
                if (newSize < minWidth) {
                    fromPX = (fullWidth - minWidth + newSize) * from;
                    newSize = minWidth
                }
                const newPos = Math.floor(fromPX + scroller.xOffset + scroller.yOffset);
                const newRiflesPos = newSize / 2 - 0.5;
                scroller.from = from;
                scroller.to = to;
                if (!vertical) {
                    scroller.scrollbarGroup[method]({
                        translateX: newPos
                    });
                    scroller.scrollbar[method]({
                        width: newSize
                    });
                    scroller.scrollbarRifles[method]({
                        translateX: newRiflesPos
                    });
                    scroller.scrollbarLeft = newPos;
                    scroller.scrollbarTop = 0
                } else {
                    scroller.scrollbarGroup[method]({
                        translateY: newPos
                    });
                    scroller.scrollbar[method]({
                        height: newSize
                    });
                    scroller.scrollbarRifles[method]({
                        translateY: newRiflesPos
                    });
                    scroller.scrollbarTop = newPos;
                    scroller.scrollbarLeft = 0
                }
                if (newSize <= 12) {
                    scroller.scrollbarRifles.hide()
                } else {
                    scroller.scrollbarRifles.show()
                }
                if (options.showFull === !1) {
                    if (from <= 0 && to >= 1) {
                        scroller.group.hide()
                    } else {
                        scroller.group.show()
                    }
                }
                scroller.rendered = !0
            }
            shouldUpdateExtremes(eventType) {
                return (pick(this.options.liveRedraw, H.svg && !H.isTouchDevice && !this.chart.boosted) || eventType === 'mouseup' || eventType === 'touchend' || !defined(eventType))
            }
            trackClick(e) {
                const scroller = this;
                const normalizedEvent = scroller.chart.pointer.normalize(e)
                    , range = scroller.to - scroller.from
                    , top = scroller.y + scroller.scrollbarTop
                    , left = scroller.x + scroller.scrollbarLeft;
                if ((scroller.options.vertical && normalizedEvent.chartY > top) || (!scroller.options.vertical && normalizedEvent.chartX > left)) {
                    scroller.updatePosition(scroller.from + range, scroller.to + range)
                } else {
                    scroller.updatePosition(scroller.from - range, scroller.to - range)
                }
                fireEvent(scroller, 'changed', {
                    from: scroller.from,
                    to: scroller.to,
                    trigger: 'scrollbar',
                    DOMEvent: e
                })
            }
            update(options) {
                this.destroy();
                this.init(this.chart.renderer, merge(!0, this.options, options), this.chart)
            }
            updatePosition(from, to) {
                if (to > 1) {
                    from = correctFloat(1 - correctFloat(to - from));
                    to = 1
                }
                if (from < 0) {
                    to = correctFloat(to - from);
                    from = 0
                }
                this.from = from;
                this.to = to
            }
        }
        Scrollbar.defaultOptions = ScrollbarDefaults;
        defaultOptions.scrollbar = merge(!0, Scrollbar.defaultOptions, defaultOptions.scrollbar);
        return Scrollbar
    });
    _registerModule(_modules, 'Stock/Navigator/Navigator.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Axis/NavigatorAxisComposition.js'], _modules['Stock/Navigator/NavigatorComposition.js'], _modules['Stock/Scrollbar/Scrollbar.js'], _modules['Core/Utilities.js']], function(Axis, D, H, NavigatorAxisAdditions, NavigatorComposition, Scrollbar, U) {
        const {defaultOptions} = D;
        const {hasTouch, isTouchDevice} = H;
        const {addEvent, clamp, correctFloat, defined, destroyObjectProperties, erase, extend, find, fireEvent, isArray, isNumber, merge, pick, removeEvent, splat} = U;
        function numExt(extreme, ...args) {
            const numbers = [].filter.call(args, isNumber);
            if (numbers.length) {
                return Math[extreme].apply(0, numbers)
            }
        }
        class Navigator {
            static compose(AxisClass, ChartClass, SeriesClass) {
                NavigatorComposition.compose(AxisClass, ChartClass, Navigator, SeriesClass)
            }
            constructor(chart) {
                this.baseSeries = void 0;
                this.chart = void 0;
                this.handles = void 0;
                this.height = void 0;
                this.left = void 0;
                this.navigatorEnabled = void 0;
                this.navigatorGroup = void 0;
                this.navigatorOptions = void 0;
                this.navigatorSeries = void 0;
                this.navigatorSize = void 0;
                this.opposite = void 0;
                this.outline = void 0;
                this.range = void 0;
                this.rendered = void 0;
                this.scrollbarHeight = 0;
                this.scrollButtonSize = void 0;
                this.shades = void 0;
                this.size = void 0;
                this.top = void 0;
                this.xAxis = void 0;
                this.yAxis = void 0;
                this.zoomedMax = void 0;
                this.zoomedMin = void 0;
                this.init(chart)
            }
            drawHandle(x, index, inverted, verb) {
                const navigator = this
                    , height = navigator.navigatorOptions.handles.height;
                navigator.handles[index][verb](inverted ? {
                    translateX: Math.round(navigator.left + navigator.height / 2),
                    translateY: Math.round(navigator.top + parseInt(x, 10) + 0.5 - height)
                } : {
                    translateX: Math.round(navigator.left + parseInt(x, 10)),
                    translateY: Math.round(navigator.top + navigator.height / 2 - height / 2 - 1)
                })
            }
            drawOutline(zoomedMin, zoomedMax, inverted, verb) {
                const navigator = this
                    , maskInside = navigator.navigatorOptions.maskInside
                    , outlineWidth = navigator.outline.strokeWidth()
                    , halfOutline = outlineWidth / 2
                    , outlineCorrection = (outlineWidth % 2) / 2
                    , scrollButtonSize = navigator.scrollButtonSize
                    , navigatorSize = navigator.size
                    , navigatorTop = navigator.top
                    , height = navigator.height
                    , lineTop = navigatorTop - halfOutline
                    , lineBtm = navigatorTop + height;
                let left = navigator.left, verticalMin, path;
                if (inverted) {
                    verticalMin = navigatorTop + zoomedMax + outlineCorrection;
                    zoomedMax = navigatorTop + zoomedMin + outlineCorrection;
                    path = [['M', left + height, navigatorTop - scrollButtonSize - outlineCorrection], ['L', left + height, verticalMin], ['L', left, verticalMin], ['M', left, zoomedMax], ['L', left + height, zoomedMax], ['L', left + height, navigatorTop + navigatorSize + scrollButtonSize]];
                    if (maskInside) {
                        path.push(['M', left + height, verticalMin - halfOutline], ['L', left + height, zoomedMax + halfOutline])
                    }
                } else {
                    left -= scrollButtonSize;
                    zoomedMin += left + scrollButtonSize - outlineCorrection;
                    zoomedMax += left + scrollButtonSize - outlineCorrection;
                    path = [['M', left, lineTop], ['L', zoomedMin, lineTop], ['L', zoomedMin, lineBtm], ['M', zoomedMax, lineBtm], ['L', zoomedMax, lineTop], ['L', left + navigatorSize + scrollButtonSize * 2, navigatorTop + halfOutline]];
                    if (maskInside) {
                        path.push(['M', zoomedMin - halfOutline, lineTop], ['L', zoomedMax + halfOutline, lineTop])
                    }
                }
                navigator.outline[verb]({
                    d: path
                })
            }
            drawMasks(zoomedMin, zoomedMax, inverted, verb) {
                const navigator = this
                    , left = navigator.left
                    , top = navigator.top
                    , navigatorHeight = navigator.height;
                let height, width, x, y;
                if (inverted) {
                    x = [left, left, left];
                    y = [top, top + zoomedMin, top + zoomedMax];
                    width = [navigatorHeight, navigatorHeight, navigatorHeight];
                    height = [zoomedMin, zoomedMax - zoomedMin, navigator.size - zoomedMax]
                } else {
                    x = [left, left + zoomedMin, left + zoomedMax];
                    y = [top, top, top];
                    width = [zoomedMin, zoomedMax - zoomedMin, navigator.size - zoomedMax];
                    height = [navigatorHeight, navigatorHeight, navigatorHeight]
                }
                navigator.shades.forEach( (shade, i) => {
                        shade[verb]({
                            x: x[i],
                            y: y[i],
                            width: width[i],
                            height: height[i]
                        })
                    }
                )
            }
            renderElements() {
                const navigator = this
                    , navigatorOptions = navigator.navigatorOptions
                    , maskInside = navigatorOptions.maskInside
                    , chart = navigator.chart
                    , inverted = chart.inverted
                    , renderer = chart.renderer
                    , mouseCursor = {
                    cursor: inverted ? 'ns-resize' : 'ew-resize'
                }
                    , navigatorGroup = navigator.navigatorGroup = renderer.g('navigator').attr({
                    zIndex: 8,
                    visibility: 'hidden'
                }).add();
                [!maskInside, maskInside, !maskInside].forEach( (hasMask, index) => {
                        const shade = renderer.rect().addClass('highcharts-navigator-mask' + (index === 1 ? '-inside' : '-outside')).add(navigatorGroup);
                        if (!chart.styledMode) {
                            shade.attr({
                                fill: hasMask ? navigatorOptions.maskFill : 'rgba(0,0,0,0)'
                            });
                            if (index === 1) {
                                shade.css(mouseCursor)
                            }
                        }
                        navigator.shades[index] = shade
                    }
                );
                navigator.outline = renderer.path().addClass('highcharts-navigator-outline').add(navigatorGroup);
                if (!chart.styledMode) {
                    navigator.outline.attr({
                        'stroke-width': navigatorOptions.outlineWidth,
                        stroke: navigatorOptions.outlineColor
                    })
                }
                if (navigatorOptions.handles && navigatorOptions.handles.enabled) {
                    const handlesOptions = navigatorOptions.handles
                        , {height, width} = handlesOptions;
                    [0, 1].forEach( (index) => {
                            navigator.handles[index] = renderer.symbol(handlesOptions.symbols[index], -width / 2 - 1, 0, width, height, handlesOptions);
                            if (chart.inverted) {
                                navigator.handles[index].attr({
                                    rotation: 90,
                                    rotationOriginX: Math.floor(-width / 2),
                                    rotationOriginY: (height + width) / 2
                                })
                            }
                            navigator.handles[index].attr({
                                zIndex: 7 - index
                            }).addClass('highcharts-navigator-handle ' + 'highcharts-navigator-handle-' + ['left', 'right'][index]).add(navigatorGroup);
                            if (!chart.styledMode) {
                                navigator.handles[index].attr({
                                    fill: handlesOptions.backgroundColor,
                                    stroke: handlesOptions.borderColor,
                                    'stroke-width': handlesOptions.lineWidth
                                }).css(mouseCursor)
                            }
                        }
                    )
                }
            }
            update(options) {
                (this.series || []).forEach( (series) => {
                        if (series.baseSeries) {
                            delete series.baseSeries.navigatorSeries
                        }
                    }
                );
                this.destroy();
                const chartOptions = this.chart.options;
                merge(!0, chartOptions.navigator, options);
                this.init(this.chart)
            }
            render(min, max, pxMin, pxMax) {
                const navigator = this
                    , chart = navigator.chart
                    , xAxis = navigator.xAxis
                    , pointRange = xAxis.pointRange || 0
                    , scrollbarXAxis = xAxis.navigatorAxis.fake ? chart.xAxis[0] : xAxis
                    , navigatorEnabled = navigator.navigatorEnabled
                    , rendered = navigator.rendered
                    , inverted = chart.inverted
                    , minRange = chart.xAxis[0].minRange
                    , maxRange = chart.xAxis[0].options.maxRange
                    , scrollButtonSize = navigator.scrollButtonSize;
                let navigatorWidth, scrollbarLeft, scrollbarTop, scrollbarHeight = navigator.scrollbarHeight, navigatorSize, verb;
                if (this.hasDragged && !defined(pxMin)) {
                    return
                }
                min = correctFloat(min - pointRange / 2);
                max = correctFloat(max + pointRange / 2);
                if (!isNumber(min) || !isNumber(max)) {
                    if (rendered) {
                        pxMin = 0;
                        pxMax = pick(xAxis.width, scrollbarXAxis.width)
                    } else {
                        return
                    }
                }
                navigator.left = pick(xAxis.left, chart.plotLeft + scrollButtonSize + (inverted ? chart.plotWidth : 0));
                let zoomedMax = navigator.size = navigatorSize = pick(xAxis.len, (inverted ? chart.plotHeight : chart.plotWidth) - 2 * scrollButtonSize);
                if (inverted) {
                    navigatorWidth = scrollbarHeight
                } else {
                    navigatorWidth = navigatorSize + 2 * scrollButtonSize
                }
                pxMin = pick(pxMin, xAxis.toPixels(min, !0));
                pxMax = pick(pxMax, xAxis.toPixels(max, !0));
                if (!isNumber(pxMin) || Math.abs(pxMin) === Infinity) {
                    pxMin = 0;
                    pxMax = navigatorWidth
                }
                const newMin = xAxis.toValue(pxMin, !0)
                    , newMax = xAxis.toValue(pxMax, !0)
                    , currentRange = Math.abs(correctFloat(newMax - newMin));
                if (currentRange < minRange) {
                    if (this.grabbedLeft) {
                        pxMin = xAxis.toPixels(newMax - minRange - pointRange, !0)
                    } else if (this.grabbedRight) {
                        pxMax = xAxis.toPixels(newMin + minRange + pointRange, !0)
                    }
                } else if (defined(maxRange) && correctFloat(currentRange - pointRange) > maxRange) {
                    if (this.grabbedLeft) {
                        pxMin = xAxis.toPixels(newMax - maxRange - pointRange, !0)
                    } else if (this.grabbedRight) {
                        pxMax = xAxis.toPixels(newMin + maxRange + pointRange, !0)
                    }
                }
                navigator.zoomedMax = clamp(Math.max(pxMin, pxMax), 0, zoomedMax);
                navigator.zoomedMin = clamp(navigator.fixedWidth ? navigator.zoomedMax - navigator.fixedWidth : Math.min(pxMin, pxMax), 0, zoomedMax);
                navigator.range = navigator.zoomedMax - navigator.zoomedMin;
                zoomedMax = Math.round(navigator.zoomedMax);
                const zoomedMin = Math.round(navigator.zoomedMin);
                if (navigatorEnabled) {
                    navigator.navigatorGroup.attr({
                        visibility: 'inherit'
                    });
                    verb = rendered && !navigator.hasDragged ? 'animate' : 'attr';
                    navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
                    navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
                    if (navigator.navigatorOptions.handles.enabled) {
                        navigator.drawHandle(zoomedMin, 0, inverted, verb);
                        navigator.drawHandle(zoomedMax, 1, inverted, verb)
                    }
                }
                if (navigator.scrollbar) {
                    if (inverted) {
                        scrollbarTop = navigator.top - scrollButtonSize;
                        scrollbarLeft = navigator.left - scrollbarHeight + (navigatorEnabled || !scrollbarXAxis.opposite ? 0 : (scrollbarXAxis.titleOffset || 0) + scrollbarXAxis.axisTitleMargin);
                        scrollbarHeight = navigatorSize + 2 * scrollButtonSize
                    } else {
                        scrollbarTop = navigator.top + (navigatorEnabled ? navigator.height : -scrollbarHeight);
                        scrollbarLeft = navigator.left - scrollButtonSize
                    }
                    navigator.scrollbar.position(scrollbarLeft, scrollbarTop, navigatorWidth, scrollbarHeight);
                    navigator.scrollbar.setRange(navigator.zoomedMin / (navigatorSize || 1), navigator.zoomedMax / (navigatorSize || 1))
                }
                navigator.rendered = !0;
                fireEvent(this, 'afterRender')
            }
            addMouseEvents() {
                const navigator = this
                    , chart = navigator.chart
                    , container = chart.container;
                let eventsToUnbind = [], mouseMoveHandler, mouseUpHandler;
                navigator.mouseMoveHandler = mouseMoveHandler = function(e) {
                    navigator.onMouseMove(e)
                }
                ;
                navigator.mouseUpHandler = mouseUpHandler = function(e) {
                    navigator.onMouseUp(e)
                }
                ;
                eventsToUnbind = navigator.getPartsEvents('mousedown');
                eventsToUnbind.push(addEvent(chart.renderTo, 'mousemove', mouseMoveHandler), addEvent(container.ownerDocument, 'mouseup', mouseUpHandler));
                if (hasTouch) {
                    eventsToUnbind.push(addEvent(chart.renderTo, 'touchmove', mouseMoveHandler), addEvent(container.ownerDocument, 'touchend', mouseUpHandler));
                    eventsToUnbind.concat(navigator.getPartsEvents('touchstart'))
                }
                navigator.eventsToUnbind = eventsToUnbind;
                if (navigator.series && navigator.series[0]) {
                    eventsToUnbind.push(addEvent(navigator.series[0].xAxis, 'foundExtremes', function() {
                        chart.navigator.modifyNavigatorAxisExtremes()
                    }))
                }
            }
            getPartsEvents(eventName) {
                const navigator = this
                    , events = [];
                ['shades', 'handles'].forEach(function(name) {
                    navigator[name].forEach(function(navigatorItem, index) {
                        events.push(addEvent(navigatorItem.element, eventName, function(e) {
                            navigator[name + 'Mousedown'](e, index)
                        }))
                    })
                });
                return events
            }
            shadesMousedown(e, index) {
                e = this.chart.pointer.normalize(e);
                const navigator = this
                    , chart = navigator.chart
                    , xAxis = navigator.xAxis
                    , zoomedMin = navigator.zoomedMin
                    , navigatorSize = navigator.size
                    , range = navigator.range;
                let navigatorPosition = navigator.left, chartX = e.chartX, fixedMax, fixedMin, ext, left;
                if (chart.inverted) {
                    chartX = e.chartY;
                    navigatorPosition = navigator.top
                }
                if (index === 1) {
                    navigator.grabbedCenter = chartX;
                    navigator.fixedWidth = range;
                    navigator.dragOffset = chartX - zoomedMin
                } else {
                    left = chartX - navigatorPosition - range / 2;
                    if (index === 0) {
                        left = Math.max(0, left)
                    } else if (index === 2 && left + range >= navigatorSize) {
                        left = navigatorSize - range;
                        if (navigator.reversedExtremes) {
                            left -= range;
                            fixedMin = navigator.getUnionExtremes().dataMin
                        } else {
                            fixedMax = navigator.getUnionExtremes().dataMax
                        }
                    }
                    if (left !== zoomedMin) {
                        navigator.fixedWidth = range;
                        ext = xAxis.navigatorAxis.toFixedRange(left, left + range, fixedMin, fixedMax);
                        if (defined(ext.min)) {
                            chart.xAxis[0].setExtremes(Math.min(ext.min, ext.max), Math.max(ext.min, ext.max), !0, null, {
                                trigger: 'navigator'
                            })
                        }
                    }
                }
            }
            handlesMousedown(e, index) {
                e = this.chart.pointer.normalize(e);
                const navigator = this
                    , chart = navigator.chart
                    , baseXAxis = chart.xAxis[0]
                    , reverse = navigator.reversedExtremes;
                if (index === 0) {
                    navigator.grabbedLeft = !0;
                    navigator.otherHandlePos = navigator.zoomedMax;
                    navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max
                } else {
                    navigator.grabbedRight = !0;
                    navigator.otherHandlePos = navigator.zoomedMin;
                    navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min
                }
                chart.fixedRange = null
            }
            onMouseMove(e) {
                const navigator = this
                    , chart = navigator.chart
                    , navigatorSize = navigator.navigatorSize
                    , range = navigator.range
                    , dragOffset = navigator.dragOffset
                    , inverted = chart.inverted;
                let left = navigator.left, chartX;
                if (!e.touches || e.touches[0].pageX !== 0) {
                    e = chart.pointer.normalize(e);
                    chartX = e.chartX;
                    if (inverted) {
                        left = navigator.top;
                        chartX = e.chartY
                    }
                    if (navigator.grabbedLeft) {
                        navigator.hasDragged = !0;
                        navigator.render(0, 0, chartX - left, navigator.otherHandlePos)
                    } else if (navigator.grabbedRight) {
                        navigator.hasDragged = !0;
                        navigator.render(0, 0, navigator.otherHandlePos, chartX - left)
                    } else if (navigator.grabbedCenter) {
                        navigator.hasDragged = !0;
                        if (chartX < dragOffset) {
                            chartX = dragOffset
                        } else if (chartX > navigatorSize + dragOffset - range) {
                            chartX = navigatorSize + dragOffset - range
                        }
                        navigator.render(0, 0, chartX - dragOffset, chartX - dragOffset + range)
                    }
                    if (navigator.hasDragged && navigator.scrollbar && pick(navigator.scrollbar.options.liveRedraw, !isTouchDevice && !this.chart.boosted)) {
                        e.DOMType = e.type;
                        setTimeout(function() {
                            navigator.onMouseUp(e)
                        }, 0)
                    }
                }
            }
            onMouseUp(e) {
                const navigator = this
                    , chart = navigator.chart
                    , xAxis = navigator.xAxis
                    , scrollbar = navigator.scrollbar
                    , DOMEvent = e.DOMEvent || e
                    , inverted = chart.inverted
                    , verb = navigator.rendered && !navigator.hasDragged ? 'animate' : 'attr';
                let zoomedMax, zoomedMin, unionExtremes, fixedMin, fixedMax, ext;
                if ((navigator.hasDragged && (!scrollbar || !scrollbar.hasDragged)) || e.trigger === 'scrollbar') {
                    unionExtremes = navigator.getUnionExtremes();
                    if (navigator.zoomedMin === navigator.otherHandlePos) {
                        fixedMin = navigator.fixedExtreme
                    } else if (navigator.zoomedMax === navigator.otherHandlePos) {
                        fixedMax = navigator.fixedExtreme
                    }
                    if (navigator.zoomedMax === navigator.size) {
                        fixedMax = navigator.reversedExtremes ? unionExtremes.dataMin : unionExtremes.dataMax
                    }
                    if (navigator.zoomedMin === 0) {
                        fixedMin = navigator.reversedExtremes ? unionExtremes.dataMax : unionExtremes.dataMin
                    }
                    ext = xAxis.navigatorAxis.toFixedRange(navigator.zoomedMin, navigator.zoomedMax, fixedMin, fixedMax);
                    if (defined(ext.min)) {
                        chart.xAxis[0].setExtremes(Math.min(ext.min, ext.max), Math.max(ext.min, ext.max), !0, navigator.hasDragged ? !1 : null, {
                            trigger: 'navigator',
                            triggerOp: 'navigator-drag',
                            DOMEvent: DOMEvent
                        })
                    }
                }
                if (e.DOMType !== 'mousemove' && e.DOMType !== 'touchmove') {
                    navigator.grabbedLeft = navigator.grabbedRight = navigator.grabbedCenter = navigator.fixedWidth = navigator.fixedExtreme = navigator.otherHandlePos = navigator.hasDragged = navigator.dragOffset = null
                }
                if (navigator.navigatorEnabled && isNumber(navigator.zoomedMin) && isNumber(navigator.zoomedMax)) {
                    zoomedMin = Math.round(navigator.zoomedMin);
                    zoomedMax = Math.round(navigator.zoomedMax);
                    if (navigator.shades) {
                        navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb)
                    }
                    if (navigator.outline) {
                        navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb)
                    }
                    if (navigator.navigatorOptions.handles.enabled && Object.keys(navigator.handles).length === navigator.handles.length) {
                        navigator.drawHandle(zoomedMin, 0, inverted, verb);
                        navigator.drawHandle(zoomedMax, 1, inverted, verb)
                    }
                }
            }
            removeEvents() {
                if (this.eventsToUnbind) {
                    this.eventsToUnbind.forEach(function(unbind) {
                        unbind()
                    });
                    this.eventsToUnbind = void 0
                }
                this.removeBaseSeriesEvents()
            }
            removeBaseSeriesEvents() {
                const baseSeries = this.baseSeries || [];
                if (this.navigatorEnabled && baseSeries[0]) {
                    if (this.navigatorOptions.adaptToUpdatedData !== !1) {
                        baseSeries.forEach(function(series) {
                            removeEvent(series, 'updatedData', this.updatedDataHandler)
                        }, this)
                    }
                    if (baseSeries[0].xAxis) {
                        removeEvent(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes)
                    }
                }
            }
            init(chart) {
                const chartOptions = chart.options
                    , navigatorOptions = chartOptions.navigator || {}
                    , navigatorEnabled = navigatorOptions.enabled
                    , scrollbarOptions = chartOptions.scrollbar || {}
                    , scrollbarEnabled = scrollbarOptions.enabled
                    , height = navigatorEnabled && navigatorOptions.height || 0
                    , scrollbarHeight = scrollbarEnabled && scrollbarOptions.height || 0
                    , scrollButtonSize = scrollbarOptions.buttonsEnabled && scrollbarHeight || 0;
                this.handles = [];
                this.shades = [];
                this.chart = chart;
                this.setBaseSeries();
                this.height = height;
                this.scrollbarHeight = scrollbarHeight;
                this.scrollButtonSize = scrollButtonSize;
                this.scrollbarEnabled = scrollbarEnabled;
                this.navigatorEnabled = navigatorEnabled;
                this.navigatorOptions = navigatorOptions;
                this.scrollbarOptions = scrollbarOptions;
                this.opposite = pick(navigatorOptions.opposite, Boolean(!navigatorEnabled && chart.inverted));
                const navigator = this
                    , baseSeries = navigator.baseSeries
                    , xAxisIndex = chart.xAxis.length
                    , yAxisIndex = chart.yAxis.length
                    , baseXaxis = baseSeries && baseSeries[0] && baseSeries[0].xAxis || chart.xAxis[0] || {
                    options: {}
                };
                chart.isDirtyBox = !0;
                if (navigator.navigatorEnabled) {
                    navigator.xAxis = new Axis(chart,merge({
                        breaks: baseXaxis.options.breaks,
                        ordinal: baseXaxis.options.ordinal
                    }, navigatorOptions.xAxis, {
                        id: 'navigator-x-axis',
                        yAxis: 'navigator-y-axis',
                        type: 'datetime',
                        index: xAxisIndex,
                        isInternal: !0,
                        offset: 0,
                        keepOrdinalPadding: !0,
                        startOnTick: !1,
                        endOnTick: !1,
                        minPadding: 0,
                        maxPadding: 0,
                        zoomEnabled: !1
                    }, chart.inverted ? {
                        offsets: [scrollButtonSize, 0, -scrollButtonSize, 0],
                        width: height
                    } : {
                        offsets: [0, -scrollButtonSize, 0, scrollButtonSize],
                        height: height
                    }),'xAxis');
                    navigator.yAxis = new Axis(chart,merge(navigatorOptions.yAxis, {
                        id: 'navigator-y-axis',
                        alignTicks: !1,
                        offset: 0,
                        index: yAxisIndex,
                        isInternal: !0,
                        reversed: pick((navigatorOptions.yAxis && navigatorOptions.yAxis.reversed), (chart.yAxis[0] && chart.yAxis[0].reversed), !1),
                        zoomEnabled: !1
                    }, chart.inverted ? {
                        width: height
                    } : {
                        height: height
                    }),'yAxis');
                    if (baseSeries || navigatorOptions.series.data) {
                        navigator.updateNavigatorSeries(!1)
                    } else if (chart.series.length === 0) {
                        navigator.unbindRedraw = addEvent(chart, 'beforeRedraw', function() {
                            if (chart.series.length > 0 && !navigator.series) {
                                navigator.setBaseSeries();
                                navigator.unbindRedraw()
                            }
                        })
                    }
                    navigator.reversedExtremes = (chart.inverted && !navigator.xAxis.reversed) || (!chart.inverted && navigator.xAxis.reversed);
                    navigator.renderElements();
                    navigator.addMouseEvents()
                } else {
                    navigator.xAxis = {
                        chart,
                        navigatorAxis: {
                            fake: !0
                        },
                        translate: function(value, reverse) {
                            const axis = chart.xAxis[0]
                                , ext = axis.getExtremes()
                                , scrollTrackWidth = axis.len - 2 * scrollButtonSize
                                , min = numExt('min', axis.options.min, ext.dataMin)
                                , valueRange = numExt('max', axis.options.max, ext.dataMax) - min;
                            return reverse ? (value * valueRange / scrollTrackWidth) + min : scrollTrackWidth * (value - min) / valueRange
                        },
                        toPixels: function(value) {
                            return this.translate(value)
                        },
                        toValue: function(value) {
                            return this.translate(value, !0)
                        }
                    };
                    navigator.xAxis.navigatorAxis.axis = navigator.xAxis;
                    navigator.xAxis.navigatorAxis.toFixedRange = (NavigatorAxisAdditions.prototype.toFixedRange.bind(navigator.xAxis.navigatorAxis))
                }
                if (chart.options.scrollbar.enabled) {
                    const options = merge(chart.options.scrollbar, {
                        vertical: chart.inverted
                    });
                    if (!isNumber(options.margin) && navigator.navigatorEnabled) {
                        options.margin = chart.inverted ? -3 : 3
                    }
                    chart.scrollbar = navigator.scrollbar = new Scrollbar(chart.renderer,options,chart);
                    addEvent(navigator.scrollbar, 'changed', function(e) {
                        const range = navigator.size
                            , to = range * this.to
                            , from = range * this.from;
                        navigator.hasDragged = navigator.scrollbar.hasDragged;
                        navigator.render(0, 0, from, to);
                        if (this.shouldUpdateExtremes(e.DOMType)) {
                            setTimeout(function() {
                                navigator.onMouseUp(e)
                            })
                        }
                    })
                }
                navigator.addBaseSeriesEvents();
                navigator.addChartEvents()
            }
            getUnionExtremes(returnFalseOnNoBaseSeries) {
                const baseAxis = this.chart.xAxis[0]
                    , navAxis = this.xAxis
                    , navAxisOptions = navAxis.options
                    , baseAxisOptions = baseAxis.options;
                let ret;
                if (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== null) {
                    ret = {
                        dataMin: pick(navAxisOptions && navAxisOptions.min, numExt('min', baseAxisOptions.min, baseAxis.dataMin, navAxis.dataMin, navAxis.min)),
                        dataMax: pick(navAxisOptions && navAxisOptions.max, numExt('max', baseAxisOptions.max, baseAxis.dataMax, navAxis.dataMax, navAxis.max))
                    }
                }
                return ret
            }
            setBaseSeries(baseSeriesOptions, redraw) {
                const chart = this.chart
                    , baseSeries = this.baseSeries = [];
                baseSeriesOptions = (baseSeriesOptions || chart.options && chart.options.navigator.baseSeries || (chart.series.length ? find(chart.series, (s) => (!s.options.isInternal)).index : 0));
                (chart.series || []).forEach( (series, i) => {
                        if (!series.options.isInternal && (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) && series.options.showInNavigator !== !1)) {
                            baseSeries.push(series)
                        }
                    }
                );
                if (this.xAxis && !this.xAxis.navigatorAxis.fake) {
                    this.updateNavigatorSeries(!0, redraw)
                }
            }
            updateNavigatorSeries(addEvents, redraw) {
                const navigator = this
                    , chart = navigator.chart
                    , baseSeries = navigator.baseSeries
                    , navSeriesMixin = {
                    enableMouseTracking: !1,
                    index: null,
                    linkedTo: null,
                    group: 'nav',
                    padXAxis: !1,
                    xAxis: 'navigator-x-axis',
                    yAxis: 'navigator-y-axis',
                    showInLegend: !1,
                    stacking: void 0,
                    isInternal: !0,
                    states: {
                        inactive: {
                            opacity: 1
                        }
                    }
                }
                    , navigatorSeries = navigator.series = (navigator.series || []).filter( (navSeries) => {
                        const base = navSeries.baseSeries;
                        if (baseSeries.indexOf(base) < 0) {
                            if (base) {
                                removeEvent(base, 'updatedData', navigator.updatedDataHandler);
                                delete base.navigatorSeries
                            }
                            if (navSeries.chart) {
                                navSeries.destroy()
                            }
                            return !1
                        }
                        return !0
                    }
                );
                let baseOptions, mergedNavSeriesOptions, chartNavigatorSeriesOptions = navigator.navigatorOptions.series, baseNavigatorOptions;
                if (baseSeries && baseSeries.length) {
                    baseSeries.forEach( (base) => {
                            const linkedNavSeries = base.navigatorSeries
                                , userNavOptions = extend({
                                color: base.color,
                                visible: base.visible
                            }, !isArray(chartNavigatorSeriesOptions) ? chartNavigatorSeriesOptions : defaultOptions.navigator.series);
                            if (linkedNavSeries && navigator.navigatorOptions.adaptToUpdatedData === !1) {
                                return
                            }
                            navSeriesMixin.name = 'Navigator ' + baseSeries.length;
                            baseOptions = base.options || {};
                            baseNavigatorOptions = baseOptions.navigatorOptions || {};
                            userNavOptions.dataLabels = splat(userNavOptions.dataLabels);
                            mergedNavSeriesOptions = merge(baseOptions, navSeriesMixin, userNavOptions, baseNavigatorOptions);
                            mergedNavSeriesOptions.pointRange = pick(userNavOptions.pointRange, baseNavigatorOptions.pointRange, defaultOptions.plotOptions[mergedNavSeriesOptions.type || 'line'].pointRange);
                            const navigatorSeriesData = baseNavigatorOptions.data || userNavOptions.data;
                            navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
                            mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data && baseOptions.data.slice(0);
                            if (linkedNavSeries && linkedNavSeries.options) {
                                linkedNavSeries.update(mergedNavSeriesOptions, redraw)
                            } else {
                                base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
                                base.navigatorSeries.baseSeries = base;
                                navigatorSeries.push(base.navigatorSeries)
                            }
                        }
                    )
                }
                if (chartNavigatorSeriesOptions.data && !(baseSeries && baseSeries.length) || isArray(chartNavigatorSeriesOptions)) {
                    navigator.hasNavigatorData = !1;
                    chartNavigatorSeriesOptions = splat(chartNavigatorSeriesOptions);
                    chartNavigatorSeriesOptions.forEach( (userSeriesOptions, i) => {
                            navSeriesMixin.name = 'Navigator ' + (navigatorSeries.length + 1);
                            mergedNavSeriesOptions = merge(defaultOptions.navigator.series, {
                                color: chart.series[i] && !chart.series[i].options.isInternal && chart.series[i].color || chart.options.colors[i] || chart.options.colors[0]
                            }, navSeriesMixin, userSeriesOptions);
                            mergedNavSeriesOptions.data = userSeriesOptions.data;
                            if (mergedNavSeriesOptions.data) {
                                navigator.hasNavigatorData = !0;
                                navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions))
                            }
                        }
                    )
                }
                if (addEvents) {
                    this.addBaseSeriesEvents()
                }
            }
            addBaseSeriesEvents() {
                const navigator = this
                    , baseSeries = navigator.baseSeries || [];
                if (baseSeries[0] && baseSeries[0].xAxis) {
                    baseSeries[0].eventsToUnbind.push(addEvent(baseSeries[0].xAxis, 'foundExtremes', this.modifyBaseAxisExtremes))
                }
                baseSeries.forEach( (base) => {
                        base.eventsToUnbind.push(addEvent(base, 'show', function() {
                            if (this.navigatorSeries) {
                                this.navigatorSeries.setVisible(!0, !1)
                            }
                        }));
                        base.eventsToUnbind.push(addEvent(base, 'hide', function() {
                            if (this.navigatorSeries) {
                                this.navigatorSeries.setVisible(!1, !1)
                            }
                        }));
                        if (this.navigatorOptions.adaptToUpdatedData !== !1) {
                            if (base.xAxis) {
                                base.eventsToUnbind.push(addEvent(base, 'updatedData', this.updatedDataHandler))
                            }
                        }
                        base.eventsToUnbind.push(addEvent(base, 'remove', function() {
                            if (this.navigatorSeries) {
                                erase(navigator.series, this.navigatorSeries);
                                if (defined(this.navigatorSeries.options)) {
                                    this.navigatorSeries.remove(!1)
                                }
                                delete this.navigatorSeries
                            }
                        }))
                    }
                )
            }
            getBaseSeriesMin(currentSeriesMin) {
                return this.baseSeries.reduce(function(min, series) {
                    return Math.min(min, series.xData && series.xData.length ? series.xData[0] : min)
                }, currentSeriesMin)
            }
            modifyNavigatorAxisExtremes() {
                const xAxis = this.xAxis;
                if (typeof xAxis.getExtremes !== 'undefined') {
                    const unionExtremes = this.getUnionExtremes(!0);
                    if (unionExtremes && (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
                        xAxis.min = unionExtremes.dataMin;
                        xAxis.max = unionExtremes.dataMax
                    }
                }
            }
            modifyBaseAxisExtremes() {
                const baseXAxis = this
                    , navigator = baseXAxis.chart.navigator
                    , baseExtremes = baseXAxis.getExtremes()
                    , baseMin = baseExtremes.min
                    , baseMax = baseExtremes.max
                    , baseDataMin = baseExtremes.dataMin
                    , baseDataMax = baseExtremes.dataMax
                    , range = baseMax - baseMin
                    , stickToMin = navigator.stickToMin
                    , stickToMax = navigator.stickToMax
                    , overscroll = pick(baseXAxis.options.overscroll, 0)
                    , navigatorSeries = navigator.series && navigator.series[0]
                    , hasSetExtremes = !!baseXAxis.setExtremes
                    , unmutable = baseXAxis.eventArgs && baseXAxis.eventArgs.trigger === 'rangeSelectorButton';
                let newMax, newMin;
                if (!unmutable) {
                    if (stickToMin) {
                        newMin = baseDataMin;
                        newMax = newMin + range
                    }
                    if (stickToMax) {
                        newMax = baseDataMax + overscroll;
                        if (!stickToMin) {
                            newMin = Math.max(baseDataMin, newMax - range, navigator.getBaseSeriesMin(navigatorSeries && navigatorSeries.xData ? navigatorSeries.xData[0] : -Number.MAX_VALUE))
                        }
                    }
                    if (hasSetExtremes && (stickToMin || stickToMax)) {
                        if (isNumber(newMin)) {
                            baseXAxis.min = baseXAxis.userMin = newMin;
                            baseXAxis.max = baseXAxis.userMax = newMax
                        }
                    }
                }
                navigator.stickToMin = navigator.stickToMax = null
            }
            updatedDataHandler() {
                const navigator = this.chart.navigator
                    , baseSeries = this
                    , navigatorSeries = this.navigatorSeries
                    , shouldStickToMax = navigator.reversedExtremes ? Math.round(navigator.zoomedMin) === 0 : Math.round(navigator.zoomedMax) >= Math.round(navigator.size);
                navigator.stickToMax = pick(this.chart.options.navigator && this.chart.options.navigator.stickToMax, shouldStickToMax);
                navigator.stickToMin = navigator.shouldStickToMin(baseSeries, navigator);
                if (navigatorSeries && !navigator.hasNavigatorData) {
                    navigatorSeries.options.pointStart = baseSeries.xData[0];
                    navigatorSeries.setData(baseSeries.options.data, !1, null, !1)
                }
            }
            shouldStickToMin(baseSeries, navigator) {
                const xDataMin = navigator.getBaseSeriesMin(baseSeries.xData[0])
                    , xAxis = baseSeries.xAxis
                    , max = xAxis.max
                    , min = xAxis.min
                    , range = xAxis.options.range;
                let stickToMin = !0;
                if (isNumber(max) && isNumber(min)) {
                    if (range && max - xDataMin > 0) {
                        stickToMin = max - xDataMin < range
                    } else {
                        stickToMin = min <= xDataMin
                    }
                } else {
                    stickToMin = !1
                }
                return stickToMin
            }
            addChartEvents() {
                if (!this.eventsToUnbind) {
                    this.eventsToUnbind = []
                }
                this.eventsToUnbind.push(addEvent(this.chart, 'redraw', function() {
                    const navigator = this.navigator
                        , xAxis = navigator && (navigator.baseSeries && navigator.baseSeries[0] && navigator.baseSeries[0].xAxis || this.xAxis[0]);
                    if (xAxis) {
                        navigator.render(xAxis.min, xAxis.max)
                    }
                }), addEvent(this.chart, 'getMargins', function() {
                    let chart = this
                        , navigator = chart.navigator
                        , marginName = navigator.opposite ? 'plotTop' : 'marginBottom';
                    if (chart.inverted) {
                        marginName = navigator.opposite ? 'marginRight' : 'plotLeft'
                    }
                    chart[marginName] = (chart[marginName] || 0) + (navigator.navigatorEnabled || !chart.inverted ? navigator.height + navigator.scrollbarHeight : 0) + navigator.navigatorOptions.margin
                }))
            }
            destroy() {
                this.removeEvents();
                if (this.xAxis) {
                    erase(this.chart.xAxis, this.xAxis);
                    erase(this.chart.axes, this.xAxis)
                }
                if (this.yAxis) {
                    erase(this.chart.yAxis, this.yAxis);
                    erase(this.chart.axes, this.yAxis)
                }
                (this.series || []).forEach( (s) => {
                        if (s.destroy) {
                            s.destroy()
                        }
                    }
                );
                ['series', 'xAxis', 'yAxis', 'shades', 'outline', 'scrollbarTrack', 'scrollbarRifles', 'scrollbarGroup', 'scrollbar', 'navigatorGroup', 'rendered'].forEach( (prop) => {
                        if (this[prop] && this[prop].destroy) {
                            this[prop].destroy()
                        }
                        this[prop] = null
                    }
                );
                [this.handles].forEach( (coll) => {
                        destroyObjectProperties(coll)
                    }
                )
            }
        }
        return Navigator
    });
    _registerModule(_modules, 'Accessibility/Components/NavigatorComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Stock/Navigator/Navigator.js'], _modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Templating.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/Utils/ChartUtilities.js']], function(AccessibilityComponent, Announcer, KeyboardNavigationHandler, Navigator, A, T, U, HU, CU) {
        const {animObject} = A;
        const {format} = T;
        const {clamp, pick, syncTimeout} = U;
        const {getFakeMouseEvent} = HU;
        const {getAxisRangeDescription, fireEventOnWrappedOrUnwrappedElement} = CU;
        class NavigatorComponent extends AccessibilityComponent {
            constructor() {
                super(...arguments);
                this.announcer = void 0
            }
            init() {
                const chart = this.chart
                    , component = this;
                this.announcer = new Announcer(chart,'polite');
                this.addEvent(Navigator, 'afterRender', function() {
                    if (this.chart === component.chart && this.chart.renderer) {
                        syncTimeout( () => {
                                component.proxyProvider.updateGroupProxyElementPositions('navigator');
                                component.updateHandleValues()
                            }
                            , animObject(pick(this.chart.renderer.globalAnimation, !0)).duration)
                    }
                })
            }
            onChartUpdate() {
                const chart = this.chart
                    , options = chart.options;
                if (options.navigator.accessibility?.enabled) {
                    const verbosity = options.accessibility.landmarkVerbosity
                        , groupFormatStr = options.lang.accessibility?.navigator.groupLabel;
                    this.proxyProvider.removeGroup('navigator');
                    this.proxyProvider.addGroup('navigator', 'div', {
                        role: verbosity === 'all' ? 'region' : 'group',
                        'aria-label': format(groupFormatStr, {
                            chart
                        }, chart)
                    });
                    const handleFormatStr = options.lang.accessibility?.navigator.handleLabel;
                    [0, 1].forEach( (n) => {
                            const handle = this.getHandleByIx(n);
                            if (handle) {
                                const proxyEl = this.proxyProvider.addProxyElement('navigator', {
                                    click: handle
                                }, 'input', {
                                    type: 'range',
                                    'aria-label': format(handleFormatStr, {
                                        handleIx: n,
                                        chart
                                    }, chart)
                                });
                                this[n ? 'maxHandleProxy' : 'minHandleProxy'] = proxyEl.innerElement;
                                proxyEl.innerElement.style.pointerEvents = 'none';
                                proxyEl.innerElement.oninput = () => this.updateNavigator()
                            }
                        }
                    );
                    this.updateHandleValues()
                } else {
                    this.proxyProvider.removeGroup('navigator')
                }
            }
            getNavigatorHandleNavigation(handleIx) {
                const component = this
                    , chart = this.chart
                    , proxyEl = handleIx ? this.maxHandleProxy : this.minHandleProxy
                    , keys = this.keyCodes;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[[keys.left, keys.right, keys.up, keys.down], function(keyCode) {
                        if (proxyEl) {
                            const delta = keyCode === keys.left || keyCode === keys.up ? -1 : 1;
                            proxyEl.value = '' + clamp(parseFloat(proxyEl.value) + delta, 0, 100);
                            component.updateNavigator( () => {
                                    const handle = component.getHandleByIx(handleIx);
                                    if (handle) {
                                        chart.setFocusToElement(handle, proxyEl)
                                    }
                                }
                            )
                        }
                        return this.response.success
                    }
                    ]],
                    init: () => {
                        chart.setFocusToElement(this.getHandleByIx(handleIx), proxyEl)
                    }
                    ,
                    validate: () => !!(this.getHandleByIx(handleIx) && proxyEl && chart.options.navigator.accessibility?.enabled)
                })
            }
            getKeyboardNavigation() {
                return [this.getNavigatorHandleNavigation(0), this.getNavigatorHandleNavigation(1)]
            }
            destroy() {
                if (this.updateNavigatorThrottleTimer) {
                    clearTimeout(this.updateNavigatorThrottleTimer)
                }
                this.proxyProvider.removeGroup('navigator');
                if (this.announcer) {
                    this.announcer.destroy()
                }
            }
            updateHandleValues() {
                const navigator = this.chart.navigator;
                if (navigator && this.minHandleProxy && this.maxHandleProxy) {
                    const length = navigator.size;
                    this.minHandleProxy.value = '' + Math.round(navigator.zoomedMin / length * 100);
                    this.maxHandleProxy.value = '' + Math.round(navigator.zoomedMax / length * 100)
                }
            }
            getHandleByIx(ix) {
                const navigator = this.chart.navigator;
                return navigator && navigator.handles && navigator.handles[ix]
            }
            updateNavigator(beforeAnnounce) {
                const performUpdate = (beforeAnnounce) => {
                        const chart = this.chart
                            , navigator = chart.navigator;
                        if (navigator && this.minHandleProxy && this.maxHandleProxy) {
                            const chartPos = chart.pointer.getChartPosition()
                                , minNewX = parseFloat(this.minHandleProxy.value) / 100 * navigator.size
                                , maxNewX = parseFloat(this.maxHandleProxy.value) / 100 * navigator.size;
                            [[0, 'mousedown', navigator.zoomedMin], [0, 'mousemove', minNewX], [0, 'mouseup', minNewX], [1, 'mousedown', navigator.zoomedMax], [1, 'mousemove', maxNewX], [1, 'mouseup', maxNewX]].forEach( ([handleIx,type,x]) => {
                                    const handle = this.getHandleByIx(handleIx)?.element;
                                    if (handle) {
                                        fireEventOnWrappedOrUnwrappedElement(handle, getFakeMouseEvent(type, {
                                            x: chartPos.left + navigator.left + x,
                                            y: chartPos.top + navigator.top
                                        }, handle))
                                    }
                                }
                            );
                            if (beforeAnnounce) {
                                beforeAnnounce()
                            }
                            const announceFormatStr = chart.options.lang.accessibility?.navigator.changeAnnouncement
                                , axisRangeDescription = getAxisRangeDescription(chart.xAxis[0]);
                            this.announcer.announce(format(announceFormatStr, {
                                axisRangeDescription,
                                chart
                            }, chart))
                        }
                    }
                ;
                if (this.updateNavigatorThrottleTimer) {
                    clearTimeout(this.updateNavigatorThrottleTimer)
                }
                this.updateNavigatorThrottleTimer = setTimeout(performUpdate.bind(this, beforeAnnounce), 20)
            }
        }
        return NavigatorComponent
    });
    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesDescriber.js', [_modules['Accessibility/Components/AnnotationsA11y.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Core/Templating.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Core/Utilities.js']], function(AnnotationsA11y, ChartUtilities, F, HTMLUtilities, U) {
        const {getPointAnnotationTexts} = AnnotationsA11y;
        const {getAxisDescription, getSeriesFirstPointElement, getSeriesA11yElement, unhideChartElementFromAT} = ChartUtilities;
        const {format, numberFormat} = F;
        const {reverseChildNodes, stripHTMLTagsFromString: stripHTMLTags} = HTMLUtilities;
        const {find, isNumber, isString, pick, defined} = U;
        function findFirstPointWithGraphic(point) {
            const sourcePointIndex = point.index;
            if (!point.series || !point.series.data || !defined(sourcePointIndex)) {
                return null
            }
            return find(point.series.data, function(p) {
                return !!(p && typeof p.index !== 'undefined' && p.index > sourcePointIndex && p.graphic && p.graphic.element)
            }) || null
        }
        function shouldAddMockPoint(point) {
            const series = point.series
                , chart = series && series.chart
                , isSunburst = series && series.is('sunburst')
                , isNull = point.isNull
                , shouldDescribeNull = chart && chart.options.accessibility.point.describeNull;
            return isNull && !isSunburst && shouldDescribeNull
        }
        function makeMockElement(point, pos) {
            const renderer = point.series.chart.renderer
                , mock = renderer.rect(pos.x, pos.y, 1, 1);
            mock.attr({
                'class': 'highcharts-a11y-mock-point',
                fill: 'none',
                opacity: 0,
                'fill-opacity': 0,
                'stroke-opacity': 0
            });
            return mock
        }
        function addMockPointElement(point) {
            const series = point.series
                , firstPointWithGraphic = findFirstPointWithGraphic(point)
                , firstGraphic = firstPointWithGraphic && firstPointWithGraphic.graphic
                , parentGroup = firstGraphic ? firstGraphic.parentGroup : series.graph || series.group
                , mockPos = firstPointWithGraphic ? {
                x: pick(point.plotX, firstPointWithGraphic.plotX, 0),
                y: pick(point.plotY, firstPointWithGraphic.plotY, 0)
            } : {
                x: pick(point.plotX, 0),
                y: pick(point.plotY, 0)
            }
                , mockElement = makeMockElement(point, mockPos);
            if (parentGroup && parentGroup.element) {
                point.graphic = mockElement;
                point.hasMockGraphic = !0;
                mockElement.add(parentGroup);
                parentGroup.element.insertBefore(mockElement.element, firstGraphic ? firstGraphic.element : null);
                return mockElement.element
            }
        }
        function hasMorePointsThanDescriptionThreshold(series) {
            const chartA11yOptions = series.chart.options.accessibility
                , threshold = (chartA11yOptions.series.pointDescriptionEnabledThreshold);
            return !!(threshold !== !1 && series.points && series.points.length >= +threshold)
        }
        function shouldSetScreenReaderPropsOnPoints(series) {
            const seriesA11yOptions = series.options.accessibility || {};
            return !hasMorePointsThanDescriptionThreshold(series) && !seriesA11yOptions.exposeAsGroupOnly
        }
        function shouldSetKeyboardNavPropsOnPoints(series) {
            const chartA11yOptions = series.chart.options.accessibility
                , seriesNavOptions = chartA11yOptions.keyboardNavigation.seriesNavigation;
            return !!(series.points && (series.points.length < +seriesNavOptions.pointNavigationEnabledThreshold || seriesNavOptions.pointNavigationEnabledThreshold === !1))
        }
        function shouldDescribeSeriesElement(series) {
            const chart = series.chart
                , chartOptions = chart.options.chart
                , chartHas3d = chartOptions.options3d && chartOptions.options3d.enabled
                , hasMultipleSeries = chart.series.length > 1
                , describeSingleSeriesOption = chart.options.accessibility.series.describeSingleSeries
                , exposeAsGroupOnlyOption = (series.options.accessibility || {}).exposeAsGroupOnly
                , noDescribe3D = chartHas3d && hasMultipleSeries;
            return !noDescribe3D && (hasMultipleSeries || describeSingleSeriesOption || exposeAsGroupOnlyOption || hasMorePointsThanDescriptionThreshold(series))
        }
        function pointNumberToString(point, value) {
            const series = point.series
                , chart = series.chart
                , a11yPointOptions = chart.options.accessibility.point || {}
                , seriesA11yPointOptions = series.options.accessibility && series.options.accessibility.point || {}
                , tooltipOptions = series.tooltipOptions || {}
                , lang = chart.options.lang;
            if (isNumber(value)) {
                return numberFormat(value, seriesA11yPointOptions.valueDecimals || a11yPointOptions.valueDecimals || tooltipOptions.valueDecimals || -1, lang.decimalPoint, lang.accessibility.thousandsSep || lang.thousandsSep)
            }
            return value
        }
        function getSeriesDescriptionText(series) {
            const seriesA11yOptions = series.options.accessibility || {}
                , descOpt = seriesA11yOptions.description;
            return descOpt && series.chart.langFormat('accessibility.series.description', {
                description: descOpt,
                series: series
            }) || ''
        }
        function getSeriesAxisDescriptionText(series, axisCollection) {
            const axis = series[axisCollection];
            return series.chart.langFormat('accessibility.series.' + axisCollection + 'Description', {
                name: getAxisDescription(axis),
                series: series
            })
        }
        function getPointA11yTimeDescription(point) {
            const series = point.series
                , chart = series.chart
                , seriesA11yOptions = series.options.accessibility && series.options.accessibility.point || {}
                , a11yOptions = chart.options.accessibility.point || {}
                , dateXAxis = series.xAxis && series.xAxis.dateTime;
            if (dateXAxis) {
                const tooltipDateFormat = dateXAxis.getXDateFormat(point.x || 0, chart.options.tooltip.dateTimeLabelFormats)
                    , dateFormat = seriesA11yOptions.dateFormatter && seriesA11yOptions.dateFormatter(point) || a11yOptions.dateFormatter && a11yOptions.dateFormatter(point) || seriesA11yOptions.dateFormat || a11yOptions.dateFormat || tooltipDateFormat;
                return chart.time.dateFormat(dateFormat, point.x || 0, void 0)
            }
        }
        function getPointXDescription(point) {
            const timeDesc = getPointA11yTimeDescription(point)
                , xAxis = point.series.xAxis || {}
                , pointCategory = xAxis.categories && defined(point.category) && ('' + point.category).replace('<br/>', ' ')
                , canUseId = defined(point.id) && ('' + point.id).indexOf('highcharts-') < 0
                , fallback = 'x, ' + point.x;
            return point.name || timeDesc || pointCategory || (canUseId ? point.id : fallback)
        }
        function getPointArrayMapValueDescription(point, prefix, suffix) {
            const pre = prefix || ''
                , suf = suffix || ''
                , keyToValStr = function(key) {
                const num = pointNumberToString(point, pick(point[key], point.options[key]));
                return num !== void 0 ? key + ': ' + pre + num + suf : num
            }
                , pointArrayMap = point.series.pointArrayMap;
            return pointArrayMap.reduce(function(desc, key) {
                const propDesc = keyToValStr(key);
                return propDesc ? (desc + (desc.length ? ', ' : '') + propDesc) : desc
            }, '')
        }
        function getPointValue(point) {
            const series = point.series
                , a11yPointOpts = series.chart.options.accessibility.point || {}
                , seriesA11yPointOpts = series.chart.options.accessibility && series.chart.options.accessibility.point || {}
                , tooltipOptions = series.tooltipOptions || {}
                , valuePrefix = seriesA11yPointOpts.valuePrefix || a11yPointOpts.valuePrefix || tooltipOptions.valuePrefix || ''
                , valueSuffix = seriesA11yPointOpts.valueSuffix || a11yPointOpts.valueSuffix || tooltipOptions.valueSuffix || ''
                , fallbackKey = (typeof point.value !== 'undefined' ? 'value' : 'y')
                , fallbackDesc = pointNumberToString(point, point[fallbackKey]);
            if (point.isNull) {
                return series.chart.langFormat('accessibility.series.nullPointValue', {
                    point: point
                })
            }
            if (series.pointArrayMap) {
                return getPointArrayMapValueDescription(point, valuePrefix, valueSuffix)
            }
            return valuePrefix + fallbackDesc + valueSuffix
        }
        function getPointAnnotationDescription(point) {
            const chart = point.series.chart;
            const langKey = 'accessibility.series.pointAnnotationsDescription';
            const annotations = getPointAnnotationTexts(point);
            const context = {
                point,
                annotations
            };
            return annotations.length ? chart.langFormat(langKey, context) : ''
        }
        function getPointValueDescription(point) {
            const series = point.series
                , chart = series.chart
                , seriesA11yOptions = series.options.accessibility
                , seriesValueDescFormat = seriesA11yOptions && seriesA11yOptions.point && seriesA11yOptions.point.valueDescriptionFormat
                , pointValueDescriptionFormat = seriesValueDescFormat || chart.options.accessibility.point.valueDescriptionFormat
                , showXDescription = pick(series.xAxis && series.xAxis.options.accessibility && series.xAxis.options.accessibility.enabled, !chart.angular && series.type !== 'flowmap')
                , xDesc = showXDescription ? getPointXDescription(point) : ''
                , context = {
                point: point,
                index: defined(point.index) ? (point.index + 1) : '',
                xDescription: xDesc,
                value: getPointValue(point),
                separator: showXDescription ? ', ' : ''
            };
            return format(pointValueDescriptionFormat, context, chart)
        }
        function defaultPointDescriptionFormatter(point) {
            const series = point.series
                , shouldExposeSeriesName = series.chart.series.length > 1 || series.options.name
                , valText = getPointValueDescription(point)
                , description = point.options && point.options.accessibility && point.options.accessibility.description
                , userDescText = description ? ' ' + description : ''
                , seriesNameText = shouldExposeSeriesName ? ' ' + series.name + '.' : ''
                , annotationsDesc = getPointAnnotationDescription(point)
                , pointAnnotationsText = annotationsDesc ? ' ' + annotationsDesc : '';
            point.accessibility = point.accessibility || {};
            point.accessibility.valueDescription = valText;
            return valText + userDescText + seriesNameText + pointAnnotationsText
        }
        function setPointScreenReaderAttribs(point, pointElement) {
            const series = point.series
                , seriesPointA11yOptions = series.options.accessibility?.point || {}
                , a11yPointOptions = series.chart.options.accessibility.point || {}
                , label = stripHTMLTags((isString(seriesPointA11yOptions.descriptionFormat) && format(seriesPointA11yOptions.descriptionFormat, point, series.chart)) || seriesPointA11yOptions.descriptionFormatter?.(point) || (isString(a11yPointOptions.descriptionFormat) && format(a11yPointOptions.descriptionFormat, point, series.chart)) || a11yPointOptions.descriptionFormatter?.(point) || defaultPointDescriptionFormatter(point), series.chart.renderer.forExport);
            pointElement.setAttribute('role', 'img');
            pointElement.setAttribute('aria-label', label)
        }
        function describePointsInSeries(series) {
            const setScreenReaderProps = shouldSetScreenReaderPropsOnPoints(series)
                , setKeyboardProps = shouldSetKeyboardNavPropsOnPoints(series)
                , shouldDescribeNullPoints = series.chart.options.accessibility.point.describeNull;
            if (setScreenReaderProps || setKeyboardProps) {
                series.points.forEach( (point) => {
                        const pointEl = point.graphic && point.graphic.element || shouldAddMockPoint(point) && addMockPointElement(point)
                            , pointA11yDisabled = (point.options && point.options.accessibility && point.options.accessibility.enabled === !1);
                        if (pointEl) {
                            if (point.isNull && !shouldDescribeNullPoints) {
                                pointEl.setAttribute('aria-hidden', !0);
                                return
                            }
                            pointEl.setAttribute('tabindex', '-1');
                            if (!series.chart.styledMode) {
                                pointEl.style.outline = 'none'
                            }
                            if (setScreenReaderProps && !pointA11yDisabled) {
                                setPointScreenReaderAttribs(point, pointEl)
                            } else {
                                pointEl.setAttribute('aria-hidden', !0)
                            }
                        }
                    }
                )
            }
        }
        function defaultSeriesDescriptionFormatter(series) {
            const chart = series.chart
                , chartTypes = chart.types || []
                , description = getSeriesDescriptionText(series)
                , shouldDescribeAxis = function(coll) {
                return chart[coll] && chart[coll].length > 1 && series[coll]
            }
                , seriesNumber = series.index + 1
                , xAxisInfo = getSeriesAxisDescriptionText(series, 'xAxis')
                , yAxisInfo = getSeriesAxisDescriptionText(series, 'yAxis')
                , summaryContext = {
                seriesNumber,
                series,
                chart
            }
                , combinationSuffix = chartTypes.length > 1 ? 'Combination' : ''
                , summary = chart.langFormat('accessibility.series.summary.' + series.type + combinationSuffix, summaryContext) || chart.langFormat('accessibility.series.summary.default' + combinationSuffix, summaryContext)
                , axisDescription = (shouldDescribeAxis('yAxis') ? ' ' + yAxisInfo + '.' : '') + (shouldDescribeAxis('xAxis') ? ' ' + xAxisInfo + '.' : '')
                , formatStr = pick(series.options.accessibility && series.options.accessibility.descriptionFormat, chart.options.accessibility.series.descriptionFormat, '');
            return format(formatStr, {
                seriesDescription: summary,
                authorDescription: (description ? ' ' + description : ''),
                axisDescription,
                series,
                chart,
                seriesNumber
            }, void 0)
        }
        function describeSeriesElement(series, seriesElement) {
            const seriesA11yOptions = series.options.accessibility || {}
                , a11yOptions = series.chart.options.accessibility
                , landmarkVerbosity = a11yOptions.landmarkVerbosity;
            if (seriesA11yOptions.exposeAsGroupOnly) {
                seriesElement.setAttribute('role', 'img')
            } else if (landmarkVerbosity === 'all') {
                seriesElement.setAttribute('role', 'region')
            } else {
                seriesElement.setAttribute('role', 'group')
            }
            seriesElement.setAttribute('tabindex', '-1');
            if (!series.chart.styledMode) {
                seriesElement.style.outline = 'none'
            }
            seriesElement.setAttribute('aria-label', stripHTMLTags(a11yOptions.series.descriptionFormatter && a11yOptions.series.descriptionFormatter(series) || defaultSeriesDescriptionFormatter(series), series.chart.renderer.forExport))
        }
        function describeSeries(series) {
            const chart = series.chart
                , firstPointEl = getSeriesFirstPointElement(series)
                , seriesEl = getSeriesA11yElement(series)
                , is3d = chart.is3d && chart.is3d();
            if (seriesEl) {
                if (seriesEl.lastChild === firstPointEl && !is3d) {
                    reverseChildNodes(seriesEl)
                }
                describePointsInSeries(series);
                unhideChartElementFromAT(chart, seriesEl);
                if (shouldDescribeSeriesElement(series)) {
                    describeSeriesElement(series, seriesEl)
                } else {
                    seriesEl.removeAttribute('aria-label')
                }
            }
        }
        const SeriesDescriber = {
            defaultPointDescriptionFormatter,
            defaultSeriesDescriptionFormatter,
            describeSeries
        };
        return SeriesDescriber
    });
    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/NewDataAnnouncer.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js']], function(H, U, Announcer, ChartUtilities, EventProvider, SeriesDescriber) {
        const {addEvent, defined} = U;
        const {getChartTitle} = ChartUtilities;
        const {defaultPointDescriptionFormatter, defaultSeriesDescriptionFormatter} = SeriesDescriber;
        function chartHasAnnounceEnabled(chart) {
            return !!chart.options.accessibility.announceNewData.enabled
        }
        function findPointInDataArray(point) {
            const candidates = point.series.data.filter( (candidate) => (point.x === candidate.x && point.y === candidate.y));
            return candidates.length === 1 ? candidates[0] : point
        }
        function getUniqueSeries(arrayA, arrayB) {
            const uniqueSeries = (arrayA || []).concat(arrayB || []).reduce( (acc, cur) => {
                    acc[cur.name + cur.index] = cur;
                    return acc
                }
                , {});
            return Object.keys(uniqueSeries).map( (ix) => uniqueSeries[ix])
        }
        class NewDataAnnouncer {
            constructor(chart) {
                this.announcer = void 0;
                this.dirty = {
                    allSeries: {}
                };
                this.eventProvider = void 0;
                this.lastAnnouncementTime = 0;
                this.chart = chart
            }
            init() {
                const chart = this.chart;
                const announceOptions = (chart.options.accessibility.announceNewData);
                const announceType = announceOptions.interruptUser ? 'assertive' : 'polite';
                this.lastAnnouncementTime = 0;
                this.dirty = {
                    allSeries: {}
                };
                this.eventProvider = new EventProvider();
                this.announcer = new Announcer(chart,announceType);
                this.addEventListeners()
            }
            destroy() {
                this.eventProvider.removeAddedEvents();
                this.announcer.destroy()
            }
            addEventListeners() {
                const announcer = this
                    , chart = this.chart
                    , e = this.eventProvider;
                e.addEvent(chart, 'afterApplyDrilldown', function() {
                    announcer.lastAnnouncementTime = 0
                });
                e.addEvent(chart, 'afterAddSeries', function(e) {
                    announcer.onSeriesAdded(e.series)
                });
                e.addEvent(chart, 'redraw', function() {
                    announcer.announceDirtyData()
                })
            }
            onSeriesAdded(series) {
                if (chartHasAnnounceEnabled(this.chart)) {
                    this.dirty.hasDirty = !0;
                    this.dirty.allSeries[series.name + series.index] = series;
                    this.dirty.newSeries = defined(this.dirty.newSeries) ? void 0 : series
                }
            }
            announceDirtyData() {
                const chart = this.chart
                    , announcer = this;
                if (chart.options.accessibility.announceNewData && this.dirty.hasDirty) {
                    let newPoint = this.dirty.newPoint;
                    if (newPoint) {
                        newPoint = findPointInDataArray(newPoint)
                    }
                    this.queueAnnouncement(Object.keys(this.dirty.allSeries).map( (ix) => announcer.dirty.allSeries[ix]), this.dirty.newSeries, newPoint);
                    this.dirty = {
                        allSeries: {}
                    }
                }
            }
            queueAnnouncement(dirtySeries, newSeries, newPoint) {
                const chart = this.chart;
                const annOptions = chart.options.accessibility.announceNewData;
                if (annOptions.enabled) {
                    const now = +new Date();
                    const dTime = now - this.lastAnnouncementTime;
                    const time = Math.max(0, annOptions.minAnnounceInterval - dTime);
                    const allSeries = getUniqueSeries(this.queuedAnnouncement && this.queuedAnnouncement.series, dirtySeries);
                    const message = this.buildAnnouncementMessage(allSeries, newSeries, newPoint);
                    if (message) {
                        if (this.queuedAnnouncement) {
                            clearTimeout(this.queuedAnnouncementTimer)
                        }
                        this.queuedAnnouncement = {
                            time: now,
                            message: message,
                            series: allSeries
                        };
                        this.queuedAnnouncementTimer = setTimeout( () => {
                                if (this && this.announcer) {
                                    this.lastAnnouncementTime = +new Date();
                                    this.announcer.announce(this.queuedAnnouncement.message);
                                    delete this.queuedAnnouncement;
                                    delete this.queuedAnnouncementTimer
                                }
                            }
                            , time)
                    }
                }
            }
            buildAnnouncementMessage(dirtySeries, newSeries, newPoint) {
                const chart = this.chart
                    , annOptions = chart.options.accessibility.announceNewData;
                if (annOptions.announcementFormatter) {
                    const formatterRes = annOptions.announcementFormatter(dirtySeries, newSeries, newPoint);
                    if (formatterRes !== !1) {
                        return formatterRes.length ? formatterRes : null
                    }
                }
                const multiple = H.charts && H.charts.length > 1 ? 'Multiple' : 'Single'
                    , langKey = newSeries ? 'newSeriesAnnounce' + multiple : newPoint ? 'newPointAnnounce' + multiple : 'newDataAnnounce'
                    , chartTitle = getChartTitle(chart);
                return chart.langFormat('accessibility.announceNewData.' + langKey, {
                    chartTitle: chartTitle,
                    seriesDesc: newSeries ? defaultSeriesDescriptionFormatter(newSeries) : null,
                    pointDesc: newPoint ? defaultPointDescriptionFormatter(newPoint) : null,
                    point: newPoint,
                    series: newSeries
                })
            }
        }
        (function(NewDataAnnouncer) {
                NewDataAnnouncer.composedMembers = [];
                function compose(SeriesClass) {
                    if (U.pushUnique(NewDataAnnouncer.composedMembers, SeriesClass)) {
                        addEvent(SeriesClass, 'addPoint', seriesOnAddPoint);
                        addEvent(SeriesClass, 'updatedData', seriesOnUpdatedData)
                    }
                }
                NewDataAnnouncer.compose = compose;
                function seriesOnAddPoint(e) {
                    const chart = this.chart
                        , newDataAnnouncer = this.newDataAnnouncer;
                    if (newDataAnnouncer && newDataAnnouncer.chart === chart && chartHasAnnounceEnabled(chart)) {
                        newDataAnnouncer.dirty.newPoint = (defined(newDataAnnouncer.dirty.newPoint) ? void 0 : e.point)
                    }
                }
                function seriesOnUpdatedData() {
                    const chart = this.chart
                        , newDataAnnouncer = this.newDataAnnouncer;
                    if (newDataAnnouncer && newDataAnnouncer.chart === chart && chartHasAnnounceEnabled(chart)) {
                        newDataAnnouncer.dirty.hasDirty = !0;
                        newDataAnnouncer.dirty.allSeries[this.name + this.index] = this
                    }
                }
            }
        )(NewDataAnnouncer || (NewDataAnnouncer = {}));
        return NewDataAnnouncer
    });
    _registerModule(_modules, 'Accessibility/ProxyElement.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js']], function(H, U, EventProvider, ChartUtilities, HTMLUtilities) {
        const {doc} = H;
        const {attr, css, merge} = U;
        const {fireEventOnWrappedOrUnwrappedElement} = ChartUtilities;
        const {cloneMouseEvent, cloneTouchEvent, getFakeMouseEvent, removeElement} = HTMLUtilities;
        class ProxyElement {
            constructor(chart, target, proxyElementType='button', wrapperElementType, attributes) {
                this.chart = chart;
                this.target = target;
                this.eventProvider = new EventProvider();
                const innerEl = this.innerElement = doc.createElement(proxyElementType)
                    , wrapperEl = this.element = wrapperElementType ? doc.createElement(wrapperElementType) : innerEl;
                if (!chart.styledMode) {
                    this.hideElementVisually(innerEl)
                }
                if (wrapperElementType) {
                    if (wrapperElementType === 'li' && !chart.styledMode) {
                        wrapperEl.style.listStyle = 'none'
                    }
                    wrapperEl.appendChild(innerEl);
                    this.element = wrapperEl
                }
                this.updateTarget(target, attributes)
            }
            click() {
                const pos = this.getTargetPosition();
                pos.x += pos.width / 2;
                pos.y += pos.height / 2;
                const fakeEventObject = getFakeMouseEvent('click', pos);
                fireEventOnWrappedOrUnwrappedElement(this.target.click, fakeEventObject)
            }
            updateTarget(target, attributes) {
                this.target = target;
                this.updateCSSClassName();
                const attrs = attributes || {};
                Object.keys(attrs).forEach( (a) => {
                        if (attrs[a] === null) {
                            delete attrs[a]
                        }
                    }
                );
                const targetAriaLabel = this.getTargetAttr(target.click, 'aria-label');
                attr(this.innerElement, merge(targetAriaLabel ? {
                    'aria-label': targetAriaLabel
                } : {}, attrs));
                this.eventProvider.removeAddedEvents();
                this.addProxyEventsToElement(this.innerElement, target.click);
                this.refreshPosition()
            }
            refreshPosition() {
                const bBox = this.getTargetPosition();
                css(this.innerElement, {
                    width: (bBox.width || 1) + 'px',
                    height: (bBox.height || 1) + 'px',
                    left: (Math.round(bBox.x) || 0) + 'px',
                    top: (Math.round(bBox.y) || 0) + 'px'
                })
            }
            remove() {
                this.eventProvider.removeAddedEvents();
                removeElement(this.element)
            }
            updateCSSClassName() {
                const stringHasNoTooltip = (s) => (s.indexOf('highcharts-no-tooltip') > -1);
                const legend = this.chart.legend;
                const groupDiv = legend.group && legend.group.div;
                const noTooltipOnGroup = stringHasNoTooltip(groupDiv && groupDiv.className || '');
                const targetClassName = this.getTargetAttr(this.target.click, 'class') || '';
                const noTooltipOnTarget = stringHasNoTooltip(targetClassName);
                this.innerElement.className = noTooltipOnGroup || noTooltipOnTarget ? 'highcharts-a11y-proxy-element highcharts-no-tooltip' : 'highcharts-a11y-proxy-element'
            }
            addProxyEventsToElement(element, target) {
                ['click', 'touchstart', 'touchend', 'touchcancel', 'touchmove', 'mouseover', 'mouseenter', 'mouseleave', 'mouseout'].forEach( (evtType) => {
                        const isTouchEvent = evtType.indexOf('touch') === 0;
                        this.eventProvider.addEvent(element, evtType, (e) => {
                                const clonedEvent = isTouchEvent ? cloneTouchEvent(e) : cloneMouseEvent(e);
                                if (target) {
                                    fireEventOnWrappedOrUnwrappedElement(target, clonedEvent)
                                }
                                e.stopPropagation();
                                if (!isTouchEvent) {
                                    e.preventDefault()
                                }
                            }
                            , {
                                passive: !1
                            })
                    }
                )
            }
            hideElementVisually(el) {
                css(el, {
                    borderWidth: 0,
                    backgroundColor: 'transparent',
                    cursor: 'pointer',
                    outline: 'none',
                    opacity: 0.001,
                    filter: 'alpha(opacity=1)',
                    zIndex: 999,
                    overflow: 'hidden',
                    padding: 0,
                    margin: 0,
                    display: 'block',
                    position: 'absolute',
                    '-ms-filter': 'progid:DXImageTransform.Microsoft.Alpha(Opacity=1)'
                })
            }
            getTargetPosition() {
                const clickTarget = this.target.click;
                const clickTargetElement = clickTarget.element ? clickTarget.element : clickTarget;
                const posElement = this.target.visual || clickTargetElement;
                const chartDiv = this.chart.renderTo;
                if (chartDiv && posElement && posElement.getBoundingClientRect) {
                    const rectEl = posElement.getBoundingClientRect()
                        , chartPos = this.chart.pointer.getChartPosition();
                    return {
                        x: (rectEl.left - chartPos.left) / chartPos.scaleX,
                        y: (rectEl.top - chartPos.top) / chartPos.scaleY,
                        width: rectEl.right / chartPos.scaleX - rectEl.left / chartPos.scaleX,
                        height: rectEl.bottom / chartPos.scaleY - rectEl.top / chartPos.scaleY
                    }
                }
                return {
                    x: 0,
                    y: 0,
                    width: 1,
                    height: 1
                }
            }
            getTargetAttr(target, key) {
                if (target.element) {
                    return target.element.getAttribute(key)
                }
                return target.getAttribute(key)
            }
        }
        return ProxyElement
    });
    _registerModule(_modules, 'Accessibility/ProxyProvider.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/DOMElementProvider.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/ProxyElement.js']], function(H, U, CU, DOMElementProvider, HU, ProxyElement) {
        const {doc} = H;
        const {attr, css} = U;
        const {unhideChartElementFromAT} = CU;
        const {removeElement, removeChildNodes} = HU;
        class ProxyProvider {
            constructor(chart) {
                this.chart = chart;
                this.domElementProvider = new DOMElementProvider();
                this.groups = {};
                this.groupOrder = [];
                this.beforeChartProxyPosContainer = this.createProxyPosContainer('before');
                this.afterChartProxyPosContainer = this.createProxyPosContainer('after');
                this.update()
            }
            addProxyElement(groupKey, target, proxyElementType='button', attributes) {
                const group = this.groups[groupKey];
                if (!group) {
                    throw new Error('ProxyProvider.addProxyElement: Invalid group key ' + groupKey)
                }
                const wrapperElementType = group.type === 'ul' || group.type === 'ol' ? 'li' : void 0
                    , proxy = new ProxyElement(this.chart,target,proxyElementType,wrapperElementType,attributes);
                group.proxyContainerElement.appendChild(proxy.element);
                group.proxyElements.push(proxy);
                return proxy
            }
            addGroup(groupKey, groupElementType='div', attributes) {
                const existingGroup = this.groups[groupKey];
                if (existingGroup) {
                    return existingGroup.groupElement
                }
                const proxyContainer = this.domElementProvider.createElement(groupElementType);
                let groupElement;
                if (attributes && attributes.role && groupElementType !== 'div') {
                    groupElement = this.domElementProvider.createElement('div');
                    groupElement.appendChild(proxyContainer)
                } else {
                    groupElement = proxyContainer
                }
                groupElement.className = 'highcharts-a11y-proxy-group highcharts-a11y-proxy-group-' + groupKey.replace(/\W/g, '-');
                this.groups[groupKey] = {
                    proxyContainerElement: proxyContainer,
                    groupElement,
                    type: groupElementType,
                    proxyElements: []
                };
                attr(groupElement, attributes || {});
                if (groupElementType === 'ul') {
                    proxyContainer.setAttribute('role', 'list')
                }
                this.afterChartProxyPosContainer.appendChild(groupElement);
                this.updateGroupOrder(this.groupOrder);
                return groupElement
            }
            updateGroupAttrs(groupKey, attributes) {
                const group = this.groups[groupKey];
                if (!group) {
                    throw new Error('ProxyProvider.updateGroupAttrs: Invalid group key ' + groupKey)
                }
                attr(group.groupElement, attributes)
            }
            updateGroupOrder(groupKeys) {
                this.groupOrder = groupKeys.slice();
                if (this.isDOMOrderGroupOrder()) {
                    return
                }
                const seriesIx = groupKeys.indexOf('series');
                const beforeKeys = seriesIx > -1 ? groupKeys.slice(0, seriesIx) : groupKeys;
                const afterKeys = seriesIx > -1 ? groupKeys.slice(seriesIx + 1) : [];
                const activeElement = doc.activeElement;
                ['before', 'after'].forEach( (pos) => {
                        const posContainer = this[pos === 'before' ? 'beforeChartProxyPosContainer' : 'afterChartProxyPosContainer'];
                        const keys = pos === 'before' ? beforeKeys : afterKeys;
                        removeChildNodes(posContainer);
                        keys.forEach( (groupKey) => {
                                const group = this.groups[groupKey];
                                if (group) {
                                    posContainer.appendChild(group.groupElement)
                                }
                            }
                        )
                    }
                );
                if ((this.beforeChartProxyPosContainer.contains(activeElement) || this.afterChartProxyPosContainer.contains(activeElement)) && activeElement && activeElement.focus) {
                    activeElement.focus()
                }
            }
            clearGroup(groupKey) {
                const group = this.groups[groupKey];
                if (!group) {
                    throw new Error('ProxyProvider.clearGroup: Invalid group key ' + groupKey)
                }
                removeChildNodes(group.proxyContainerElement)
            }
            removeGroup(groupKey) {
                const group = this.groups[groupKey];
                if (group) {
                    removeElement(group.groupElement);
                    delete this.groups[groupKey]
                }
            }
            update() {
                this.updatePosContainerPositions();
                this.updateGroupOrder(this.groupOrder);
                this.updateProxyElementPositions()
            }
            updateProxyElementPositions() {
                Object.keys(this.groups).forEach(this.updateGroupProxyElementPositions.bind(this))
            }
            updateGroupProxyElementPositions(groupKey) {
                const group = this.groups[groupKey];
                if (group) {
                    group.proxyElements.forEach( (el) => el.refreshPosition())
                }
            }
            destroy() {
                this.domElementProvider.destroyCreatedElements()
            }
            createProxyPosContainer(classNamePostfix) {
                const el = this.domElementProvider.createElement('div');
                el.setAttribute('aria-hidden', 'false');
                el.className = 'highcharts-a11y-proxy-container' + (classNamePostfix ? '-' + classNamePostfix : '');
                css(el, {
                    top: '0',
                    left: '0'
                });
                if (!this.chart.styledMode) {
                    el.style.whiteSpace = 'nowrap';
                    el.style.position = 'absolute'
                }
                return el
            }
            getCurrentGroupOrderInDOM() {
                const getGroupKeyFromElement = (el) => {
                        const allGroups = Object.keys(this.groups);
                        let i = allGroups.length;
                        while (i--) {
                            const groupKey = allGroups[i];
                            const group = this.groups[groupKey];
                            if (group && el === group.groupElement) {
                                return groupKey
                            }
                        }
                    }
                ;
                const getChildrenGroupOrder = (el) => {
                        const childrenOrder = [];
                        const children = el.children;
                        for (let i = 0; i < children.length; ++i) {
                            const groupKey = getGroupKeyFromElement(children[i]);
                            if (groupKey) {
                                childrenOrder.push(groupKey)
                            }
                        }
                        return childrenOrder
                    }
                ;
                const before = getChildrenGroupOrder(this.beforeChartProxyPosContainer);
                const after = getChildrenGroupOrder(this.afterChartProxyPosContainer);
                before.push('series');
                return before.concat(after)
            }
            isDOMOrderGroupOrder() {
                const domOrder = this.getCurrentGroupOrderInDOM();
                const groupOrderWithGroups = this.groupOrder.filter( (x) => x === 'series' || !!this.groups[x]);
                let i = domOrder.length;
                if (i !== groupOrderWithGroups.length) {
                    return !1
                }
                while (i--) {
                    if (domOrder[i] !== groupOrderWithGroups[i]) {
                        return !1
                    }
                }
                return !0
            }
            updatePosContainerPositions() {
                const chart = this.chart;
                if (chart.renderer.forExport) {
                    return
                }
                const rendererSVGEl = chart.renderer.box;
                chart.container.insertBefore(this.afterChartProxyPosContainer, rendererSVGEl.nextSibling);
                chart.container.insertBefore(this.beforeChartProxyPosContainer, rendererSVGEl);
                unhideChartElementFromAT(this.chart, this.afterChartProxyPosContainer);
                unhideChartElementFromAT(this.chart, this.beforeChartProxyPosContainer)
            }
        }
        return ProxyProvider
    });
    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorDefaults.js', [], function() {
        const lang = {
            rangeSelectorZoom: 'Zoom',
            rangeSelectorFrom: '',
            rangeSelectorTo: '→'
        };
        const rangeSelector = {
            allButtonsEnabled: !1,
            buttons: void 0,
            buttonSpacing: 5,
            dropdown: 'responsive',
            enabled: void 0,
            verticalAlign: 'top',
            buttonTheme: {
                width: 28,
                height: 18,
                padding: 2,
                zIndex: 7
            },
            floating: !1,
            x: 0,
            y: 0,
            height: void 0,
            inputBoxBorderColor: 'none',
            inputBoxHeight: 17,
            inputBoxWidth: void 0,
            inputDateFormat: '%e %b %Y',
            inputDateParser: void 0,
            inputEditDateFormat: '%Y-%m-%d',
            inputEnabled: !0,
            inputPosition: {
                align: 'right',
                x: 0,
                y: 0
            },
            inputSpacing: 5,
            selected: void 0,
            buttonPosition: {
                align: 'left',
                x: 0,
                y: 0
            },
            inputStyle: {
                color: "#334eff",
                cursor: 'pointer',
                fontSize: '0.8em'
            },
            labelStyle: {
                color: "#666666",
                fontSize: '0.8em'
            }
        };
        const RangeSelectorDefaults = {
            lang,
            rangeSelector
        };
        return RangeSelectorDefaults
    });
    _registerModule(_modules, 'Stock/RangeSelector/RangeSelectorComposition.js', [_modules['Core/Defaults.js'], _modules['Stock/RangeSelector/RangeSelectorDefaults.js'], _modules['Core/Utilities.js']], function(D, RangeSelectorDefaults, U) {
        const {defaultOptions, setOptions} = D;
        const {addEvent, defined, extend, find, isNumber, merge, pick} = U;
        const chartDestroyEvents = [];
        const composedMembers = [];
        let RangeSelectorConstructor;
        function axisMinFromRange() {
            const rangeOptions = this.range
                , type = rangeOptions.type
                , max = this.max
                , time = this.chart.time
                , getTrueRange = function(base, count) {
                const timeName = type === 'year' ? 'FullYear' : 'Month';
                const date = new time.Date(base);
                const basePeriod = time.get(timeName, date);
                time.set(timeName, date, basePeriod + count);
                if (basePeriod === time.get(timeName, date)) {
                    time.set('Date', date, 0)
                }
                return date.getTime() - base
            };
            let min, range;
            if (isNumber(rangeOptions)) {
                min = max - rangeOptions;
                range = rangeOptions
            } else if (rangeOptions) {
                min = max + getTrueRange(max, -(rangeOptions.count || 1));
                if (this.chart) {
                    this.chart.fixedRange = max - min
                }
            }
            const dataMin = pick(this.dataMin, Number.MIN_VALUE);
            if (!isNumber(min)) {
                min = dataMin
            }
            if (min <= dataMin) {
                min = dataMin;
                if (typeof range === 'undefined') {
                    range = getTrueRange(min, rangeOptions.count)
                }
                this.newMax = Math.min(min + range, pick(this.dataMax, Number.MAX_VALUE))
            }
            if (!isNumber(max)) {
                min = void 0
            } else if (!isNumber(rangeOptions) && rangeOptions && rangeOptions._offsetMin) {
                min += rangeOptions._offsetMin
            }
            return min
        }
        function compose(AxisClass, ChartClass, RangeSelectorClass) {
            RangeSelectorConstructor = RangeSelectorClass;
            if (U.pushUnique(composedMembers, AxisClass)) {
                AxisClass.prototype.minFromRange = axisMinFromRange
            }
            if (U.pushUnique(composedMembers, ChartClass)) {
                addEvent(ChartClass, 'afterGetContainer', onChartAfterGetContainer);
                addEvent(ChartClass, 'beforeRender', onChartBeforeRender);
                addEvent(ChartClass, 'destroy', onChartDestroy);
                addEvent(ChartClass, 'getMargins', onChartGetMargins);
                addEvent(ChartClass, 'render', onChartRender);
                addEvent(ChartClass, 'update', onChartUpdate);
                const chartProto = ChartClass.prototype;
                chartProto.callbacks.push(onChartCallback)
            }
            if (U.pushUnique(composedMembers, setOptions)) {
                extend(defaultOptions, {
                    rangeSelector: RangeSelectorDefaults.rangeSelector
                });
                extend(defaultOptions.lang, RangeSelectorDefaults.lang)
            }
        }
        function onChartAfterGetContainer() {
            if (this.options.rangeSelector && this.options.rangeSelector.enabled) {
                this.rangeSelector = new RangeSelectorConstructor(this)
            }
        }
        function onChartBeforeRender() {
            const chart = this
                , axes = chart.axes
                , rangeSelector = chart.rangeSelector;
            if (rangeSelector) {
                if (isNumber(rangeSelector.deferredYTDClick)) {
                    rangeSelector.clickButton(rangeSelector.deferredYTDClick);
                    delete rangeSelector.deferredYTDClick
                }
                axes.forEach( (axis) => {
                        axis.updateNames();
                        axis.setScale()
                    }
                );
                chart.getAxisMargins();
                rangeSelector.render();
                const verticalAlign = rangeSelector.options.verticalAlign;
                if (!rangeSelector.options.floating) {
                    if (verticalAlign === 'bottom') {
                        this.extraBottomMargin = !0
                    } else if (verticalAlign !== 'middle') {
                        this.extraTopMargin = !0
                    }
                }
            }
        }
        function onChartCallback(chart) {
            let extremes, legend, alignTo, verticalAlign;
            const rangeSelector = chart.rangeSelector
                , redraw = () => {
                    if (rangeSelector) {
                        extremes = chart.xAxis[0].getExtremes();
                        legend = chart.legend;
                        verticalAlign = (rangeSelector && rangeSelector.options.verticalAlign);
                        if (isNumber(extremes.min)) {
                            rangeSelector.render(extremes.min, extremes.max)
                        }
                        if (legend.display && verticalAlign === 'top' && verticalAlign === legend.options.verticalAlign) {
                            alignTo = merge(chart.spacingBox);
                            if (legend.options.layout === 'vertical') {
                                alignTo.y = chart.plotTop
                            } else {
                                alignTo.y += rangeSelector.getHeight()
                            }
                            legend.group.placed = !1;
                            legend.align(alignTo)
                        }
                    }
                }
            ;
            if (rangeSelector) {
                const events = find(chartDestroyEvents, (e) => e[0] === chart);
                if (!events) {
                    chartDestroyEvents.push([chart, [addEvent(chart.xAxis[0], 'afterSetExtremes', function(e) {
                        if (rangeSelector) {
                            rangeSelector.render(e.min, e.max)
                        }
                    }), addEvent(chart, 'redraw', redraw)]])
                }
                redraw()
            }
        }
        function onChartDestroy() {
            for (let i = 0, iEnd = chartDestroyEvents.length; i < iEnd; ++i) {
                const events = chartDestroyEvents[i];
                if (events[0] === this) {
                    events[1].forEach( (unbind) => unbind());
                    chartDestroyEvents.splice(i, 1);
                    return
                }
            }
        }
        function onChartGetMargins() {
            const rangeSelector = this.rangeSelector;
            if (rangeSelector) {
                const rangeSelectorHeight = rangeSelector.getHeight();
                if (this.extraTopMargin) {
                    this.plotTop += rangeSelectorHeight
                }
                if (this.extraBottomMargin) {
                    this.marginBottom += rangeSelectorHeight
                }
            }
        }
        function onChartRender() {
            const chart = this
                , rangeSelector = chart.rangeSelector;
            if (rangeSelector && !rangeSelector.options.floating) {
                rangeSelector.render();
                const verticalAlign = rangeSelector.options.verticalAlign;
                if (verticalAlign === 'bottom') {
                    this.extraBottomMargin = !0
                } else if (verticalAlign !== 'middle') {
                    this.extraTopMargin = !0
                }
            }
        }
        function onChartUpdate(e) {
            const chart = this
                , options = e.options
                , optionsRangeSelector = options.rangeSelector
                , extraBottomMarginWas = this.extraBottomMargin
                , extraTopMarginWas = this.extraTopMargin;
            let rangeSelector = chart.rangeSelector;
            if (optionsRangeSelector && optionsRangeSelector.enabled && !defined(rangeSelector) && this.options.rangeSelector) {
                this.options.rangeSelector.enabled = !0;
                this.rangeSelector = rangeSelector = new RangeSelectorConstructor(this)
            }
            this.extraBottomMargin = !1;
            this.extraTopMargin = !1;
            if (rangeSelector) {
                onChartCallback(this);
                const verticalAlign = (optionsRangeSelector && optionsRangeSelector.verticalAlign) || (rangeSelector.options && rangeSelector.options.verticalAlign);
                if (!rangeSelector.options.floating) {
                    if (verticalAlign === 'bottom') {
                        this.extraBottomMargin = !0
                    } else if (verticalAlign !== 'middle') {
                        this.extraTopMargin = !0
                    }
                }
                if (this.extraBottomMargin !== extraBottomMarginWas || this.extraTopMargin !== extraTopMarginWas) {
                    this.isDirtyBox = !0
                }
            }
        }
        const RangeSelectorComposition = {
            compose
        };
        return RangeSelectorComposition
    });
    _registerModule(_modules, 'Stock/RangeSelector/RangeSelector.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Stock/RangeSelector/RangeSelectorComposition.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function(Axis, D, H, RangeSelectorComposition, SVGElement, U) {
        const {defaultOptions} = D;
        const {addEvent, createElement, css, defined, destroyObjectProperties, discardElement, extend, fireEvent, isNumber, merge, objectEach, pad, pick, pInt, splat} = U;
        function preferredInputType(format) {
            const ms = format.indexOf('%L') !== -1;
            if (ms) {
                return 'text'
            }
            const date = ['a', 'A', 'd', 'e', 'w', 'b', 'B', 'm', 'o', 'y', 'Y'].some( (char) => format.indexOf('%' + char) !== -1);
            const time = ['H', 'k', 'I', 'l', 'M', 'S'].some( (char) => format.indexOf('%' + char) !== -1);
            if (date && time) {
                return 'datetime-local'
            }
            if (date) {
                return 'date'
            }
            if (time) {
                return 'time'
            }
            return 'text'
        }
        class RangeSelector {
            static compose(AxisClass, ChartClass) {
                RangeSelectorComposition.compose(AxisClass, ChartClass, RangeSelector)
            }
            constructor(chart) {
                this.buttons = void 0;
                this.buttonOptions = RangeSelector.prototype.defaultButtons;
                this.initialButtonGroupWidth = 0;
                this.options = void 0;
                this.chart = chart;
                this.init(chart)
            }
            clickButton(i, redraw) {
                const rangeSelector = this
                    , chart = rangeSelector.chart
                    , rangeOptions = rangeSelector.buttonOptions[i]
                    , baseAxis = chart.xAxis[0]
                    , unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis || {}
                    , type = rangeOptions.type
                    , dataGrouping = rangeOptions.dataGrouping;
                let dataMin = unionExtremes.dataMin, dataMax = unionExtremes.dataMax, newMin, newMax = baseAxis && Math.round(Math.min(baseAxis.max, pick(dataMax, baseAxis.max))), baseXAxisOptions, range = rangeOptions._range, rangeMin, minSetting, rangeSetting, ctx, ytdExtremes, addOffsetMin = !0;
                if (dataMin === null || dataMax === null) {
                    return
                }
                chart.fixedRange = range;
                rangeSelector.setSelected(i);
                if (dataGrouping) {
                    this.forcedDataGrouping = !0;
                    Axis.prototype.setDataGrouping.call(baseAxis || {
                        chart: this.chart
                    }, dataGrouping, !1);
                    this.frozenStates = rangeOptions.preserveDataGrouping
                }
                if (type === 'month' || type === 'year') {
                    if (!baseAxis) {
                        range = rangeOptions
                    } else {
                        ctx = {
                            range: rangeOptions,
                            max: newMax,
                            chart: chart,
                            dataMin: dataMin,
                            dataMax: dataMax
                        };
                        newMin = baseAxis.minFromRange.call(ctx);
                        if (isNumber(ctx.newMax)) {
                            newMax = ctx.newMax
                        }
                        addOffsetMin = !1
                    }
                } else if (range) {
                    newMin = Math.max(newMax - range, dataMin);
                    newMax = Math.min(newMin + range, dataMax);
                    addOffsetMin = !1
                } else if (type === 'ytd') {
                    if (baseAxis) {
                        if (typeof dataMax === 'undefined' || typeof dataMin === 'undefined') {
                            dataMin = Number.MAX_VALUE;
                            dataMax = Number.MIN_VALUE;
                            chart.series.forEach( (series) => {
                                    const xData = series.xData;
                                    if (xData) {
                                        dataMin = Math.min(xData[0], dataMin);
                                        dataMax = Math.max(xData[xData.length - 1], dataMax)
                                    }
                                }
                            );
                            redraw = !1
                        }
                        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC);
                        newMin = rangeMin = ytdExtremes.min;
                        newMax = ytdExtremes.max
                    } else {
                        rangeSelector.deferredYTDClick = i;
                        return
                    }
                } else if (type === 'all' && baseAxis) {
                    if (chart.navigator && chart.navigator.baseSeries[0]) {
                        chart.navigator.baseSeries[0].xAxis.options.range = void 0
                    }
                    newMin = dataMin;
                    newMax = dataMax
                }
                if (addOffsetMin && rangeOptions._offsetMin && defined(newMin)) {
                    newMin += rangeOptions._offsetMin
                }
                if (rangeOptions._offsetMax && defined(newMax)) {
                    newMax += rangeOptions._offsetMax
                }
                if (this.dropdown) {
                    this.dropdown.selectedIndex = i + 1
                }
                if (!baseAxis) {
                    baseXAxisOptions = splat(chart.options.xAxis)[0];
                    rangeSetting = baseXAxisOptions.range;
                    baseXAxisOptions.range = range;
                    minSetting = baseXAxisOptions.min;
                    baseXAxisOptions.min = rangeMin;
                    addEvent(chart, 'load', function resetMinAndRange() {
                        baseXAxisOptions.range = rangeSetting;
                        baseXAxisOptions.min = minSetting
                    })
                } else {
                    baseAxis.setExtremes(newMin, newMax, pick(redraw, !0), void 0, {
                        trigger: 'rangeSelectorButton',
                        rangeSelectorButton: rangeOptions
                    })
                }
                fireEvent(this, 'afterBtnClick')
            }
            setSelected(selected) {
                this.selected = this.options.selected = selected
            }
            init(chart) {
                const rangeSelector = this
                    , options = chart.options.rangeSelector
                    , buttonOptions = (options.buttons || rangeSelector.defaultButtons.slice())
                    , selectedOption = options.selected
                    , blurInputs = function() {
                    const minInput = rangeSelector.minInput
                        , maxInput = rangeSelector.maxInput;
                    if (minInput && !!minInput.blur) {
                        fireEvent(minInput, 'blur')
                    }
                    if (maxInput && !!maxInput.blur) {
                        fireEvent(maxInput, 'blur')
                    }
                };
                rangeSelector.chart = chart;
                rangeSelector.options = options;
                rangeSelector.buttons = [];
                rangeSelector.buttonOptions = buttonOptions;
                this.eventsToUnbind = [];
                this.eventsToUnbind.push(addEvent(chart.container, 'mousedown', blurInputs));
                this.eventsToUnbind.push(addEvent(chart, 'resize', blurInputs));
                buttonOptions.forEach(rangeSelector.computeButtonRange);
                if (typeof selectedOption !== 'undefined' && buttonOptions[selectedOption]) {
                    this.clickButton(selectedOption, !1)
                }
                this.eventsToUnbind.push(addEvent(chart, 'load', function() {
                    if (chart.xAxis && chart.xAxis[0]) {
                        addEvent(chart.xAxis[0], 'setExtremes', function(e) {
                            if (this.max - this.min !== chart.fixedRange && e.trigger !== 'rangeSelectorButton' && e.trigger !== 'updatedData' && rangeSelector.forcedDataGrouping && !rangeSelector.frozenStates) {
                                this.setDataGrouping(!1, !1)
                            }
                        })
                    }
                }))
            }
            updateButtonStates() {
                const rangeSelector = this
                    , chart = this.chart
                    , dropdown = this.dropdown
                    , baseAxis = chart.xAxis[0]
                    , actualRange = Math.round(baseAxis.max - baseAxis.min)
                    , hasNoData = !baseAxis.hasVisibleSeries
                    , day = 24 * 36e5
                    , unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || baseAxis
                    , dataMin = unionExtremes.dataMin
                    , dataMax = unionExtremes.dataMax
                    , ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, chart.time.useUTC)
                    , ytdMin = ytdExtremes.min
                    , ytdMax = ytdExtremes.max
                    , selected = rangeSelector.selected
                    , allButtonsEnabled = rangeSelector.options.allButtonsEnabled
                    , buttons = rangeSelector.buttons;
                let selectedExists = isNumber(selected);
                rangeSelector.buttonOptions.forEach( (rangeOptions, i) => {
                        const range = rangeOptions._range
                            , type = rangeOptions.type
                            , count = rangeOptions.count || 1
                            , button = buttons[i]
                            , offsetRange = rangeOptions._offsetMax - rangeOptions._offsetMin
                            , isSelected = i === selected
                            , isTooGreatRange = range > dataMax - dataMin
                            , isTooSmallRange = range < baseAxis.minRange;
                        let state = 0
                            , isYTDButNotSelected = !1
                            , isAllButAlreadyShowingAll = !1
                            , isSameRange = range === actualRange;
                        if ((type === 'month' || type === 'year') && (actualRange + 36e5 >= {
                            month: 28,
                            year: 365
                        }[type] * day * count - offsetRange) && (actualRange - 36e5 <= {
                            month: 31,
                            year: 366
                        }[type] * day * count + offsetRange)) {
                            isSameRange = !0
                        } else if (type === 'ytd') {
                            isSameRange = (ytdMax - ytdMin + offsetRange) === actualRange;
                            isYTDButNotSelected = !isSelected
                        } else if (type === 'all') {
                            isSameRange = (baseAxis.max - baseAxis.min >= dataMax - dataMin);
                            isAllButAlreadyShowingAll = (!isSelected && selectedExists && isSameRange)
                        }
                        const disable = (!allButtonsEnabled && (isTooGreatRange || isTooSmallRange || isAllButAlreadyShowingAll || hasNoData));
                        const select = ((isSelected && isSameRange) || (isSameRange && !selectedExists && !isYTDButNotSelected) || (isSelected && rangeSelector.frozenStates));
                        if (disable) {
                            state = 3
                        } else if (select) {
                            selectedExists = !0;
                            state = 2
                        }
                        if (button.state !== state) {
                            button.setState(state);
                            if (dropdown) {
                                dropdown.options[i + 1].disabled = disable;
                                if (state === 2) {
                                    dropdown.selectedIndex = i + 1
                                }
                            }
                            if (state === 0 && selected === i) {
                                rangeSelector.setSelected()
                            }
                        }
                    }
                )
            }
            computeButtonRange(rangeOptions) {
                const type = rangeOptions.type
                    , count = rangeOptions.count || 1
                    , fixedTimes = {
                    millisecond: 1,
                    second: 1000,
                    minute: 60 * 1000,
                    hour: 3600 * 1000,
                    day: 24 * 3600 * 1000,
                    week: 7 * 24 * 3600 * 1000
                };
                if (fixedTimes[type]) {
                    rangeOptions._range = fixedTimes[type] * count
                } else if (type === 'month' || type === 'year') {
                    rangeOptions._range = {
                        month: 30,
                        year: 365
                    }[type] * 24 * 36e5 * count
                }
                rangeOptions._offsetMin = pick(rangeOptions.offsetMin, 0);
                rangeOptions._offsetMax = pick(rangeOptions.offsetMax, 0);
                rangeOptions._range += rangeOptions._offsetMax - rangeOptions._offsetMin
            }
            getInputValue(name) {
                const input = name === 'min' ? this.minInput : this.maxInput;
                const options = this.chart.options.rangeSelector;
                const time = this.chart.time;
                if (input) {
                    return ((input.type === 'text' && options.inputDateParser) || this.defaultInputDateParser)(input.value, time.useUTC, time)
                }
                return 0
            }
            setInputValue(name, inputTime) {
                const options = this.options
                    , time = this.chart.time
                    , input = name === 'min' ? this.minInput : this.maxInput
                    , dateBox = name === 'min' ? this.minDateBox : this.maxDateBox;
                if (input) {
                    const hcTimeAttr = input.getAttribute('data-hc-time');
                    let updatedTime = defined(hcTimeAttr) ? Number(hcTimeAttr) : void 0;
                    if (defined(inputTime)) {
                        const previousTime = updatedTime;
                        if (defined(previousTime)) {
                            input.setAttribute('data-hc-time-previous', previousTime)
                        }
                        input.setAttribute('data-hc-time', inputTime);
                        updatedTime = inputTime
                    }
                    input.value = time.dateFormat((this.inputTypeFormats[input.type] || options.inputEditDateFormat), updatedTime);
                    if (dateBox) {
                        dateBox.attr({
                            text: time.dateFormat(options.inputDateFormat, updatedTime)
                        })
                    }
                }
            }
            setInputExtremes(name, min, max) {
                const input = name === 'min' ? this.minInput : this.maxInput;
                if (input) {
                    const format = this.inputTypeFormats[input.type];
                    const time = this.chart.time;
                    if (format) {
                        const newMin = time.dateFormat(format, min);
                        if (input.min !== newMin) {
                            input.min = newMin
                        }
                        const newMax = time.dateFormat(format, max);
                        if (input.max !== newMax) {
                            input.max = newMax
                        }
                    }
                }
            }
            showInput(name) {
                const dateBox = name === 'min' ? this.minDateBox : this.maxDateBox
                    , input = name === 'min' ? this.minInput : this.maxInput;
                if (input && dateBox && this.inputGroup) {
                    const isTextInput = input.type === 'text'
                        , {translateX=0, translateY=0} = this.inputGroup
                        , {x=0, width=0, height=0} = dateBox
                        , {inputBoxWidth} = this.options;
                    css(input, {
                        width: isTextInput ? ((width + (inputBoxWidth ? -2 : 20)) + 'px') : 'auto',
                        height: (height - 2) + 'px',
                        border: '2px solid silver'
                    });
                    if (isTextInput && inputBoxWidth) {
                        css(input, {
                            left: (translateX + x) + 'px',
                            top: translateY + 'px'
                        })
                    } else {
                        css(input, {
                            left: Math.min(Math.round(x + translateX - (input.offsetWidth - width) / 2), this.chart.chartWidth - input.offsetWidth) + 'px',
                            top: (translateY - (input.offsetHeight - height) / 2) + 'px'
                        })
                    }
                }
            }
            hideInput(name) {
                const input = name === 'min' ? this.minInput : this.maxInput;
                if (input) {
                    css(input, {
                        top: '-9999em',
                        border: 0,
                        width: '1px',
                        height: '1px'
                    })
                }
            }
            defaultInputDateParser(inputDate, useUTC, time) {
                const hasTimezone = (str) => str.length > 6 && (str.lastIndexOf('-') === str.length - 6 || str.lastIndexOf('+') === str.length - 6);
                let input = inputDate.split('/').join('-').split(' ').join('T');
                if (input.indexOf('T') === -1) {
                    input += 'T00:00'
                }
                if (useUTC) {
                    input += 'Z'
                } else if (H.isSafari && !hasTimezone(input)) {
                    const offset = new Date(input).getTimezoneOffset() / 60;
                    input += offset <= 0 ? `+${pad(-offset)}:00` : `-${pad(offset)}:00`
                }
                let date = Date.parse(input);
                if (!isNumber(date)) {
                    const parts = inputDate.split('-');
                    date = Date.UTC(pInt(parts[0]), pInt(parts[1]) - 1, pInt(parts[2]))
                }
                if (time && useUTC && isNumber(date)) {
                    date += time.getTimezoneOffset(date)
                }
                return date
            }
            drawInput(name) {
                const {chart, div, inputGroup} = this;
                const rangeSelector = this
                    , chartStyle = chart.renderer.style || {}
                    , renderer = chart.renderer
                    , options = chart.options.rangeSelector
                    , lang = defaultOptions.lang
                    , isMin = name === 'min';
                function updateExtremes() {
                    const {maxInput, minInput} = rangeSelector
                        , chartAxis = chart.xAxis[0]
                        , unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || chartAxis
                        , dataMin = unionExtremes.dataMin
                        , dataMax = unionExtremes.dataMax;
                    let value = rangeSelector.getInputValue(name);
                    if (value !== Number(input.getAttribute('data-hc-time-previous')) && isNumber(value)) {
                        input.setAttribute('data-hc-time-previous', value);
                        if (isMin && maxInput && isNumber(dataMin)) {
                            if (value > Number(maxInput.getAttribute('data-hc-time'))) {
                                value = void 0
                            } else if (value < dataMin) {
                                value = dataMin
                            }
                        } else if (minInput && isNumber(dataMax)) {
                            if (value < Number(minInput.getAttribute('data-hc-time'))) {
                                value = void 0
                            } else if (value > dataMax) {
                                value = dataMax
                            }
                        }
                        if (typeof value !== 'undefined') {
                            chartAxis.setExtremes(isMin ? value : chartAxis.min, isMin ? chartAxis.max : value, void 0, void 0, {
                                trigger: 'rangeSelectorInput'
                            })
                        }
                    }
                }
                const text = lang[isMin ? 'rangeSelectorFrom' : 'rangeSelectorTo'] || '';
                const label = renderer.label(text, 0).addClass('highcharts-range-label').attr({
                    padding: text ? 2 : 0,
                    height: text ? options.inputBoxHeight : 0
                }).add(inputGroup);
                const dateBox = renderer.label('', 0).addClass('highcharts-range-input').attr({
                    padding: 2,
                    width: options.inputBoxWidth,
                    height: options.inputBoxHeight,
                    'text-align': 'center'
                }).on('click', function() {
                    rangeSelector.showInput(name);
                    rangeSelector[name + 'Input'].focus()
                });
                if (!chart.styledMode) {
                    dateBox.attr({
                        stroke: options.inputBoxBorderColor,
                        'stroke-width': 1
                    })
                }
                dateBox.add(inputGroup);
                const input = createElement('input', {
                    name: name,
                    className: 'highcharts-range-selector'
                }, void 0, div);
                input.setAttribute('type', preferredInputType(options.inputDateFormat || '%e %b %Y'));
                if (!chart.styledMode) {
                    label.css(merge(chartStyle, options.labelStyle));
                    dateBox.css(merge({
                        color: "#333333"
                    }, chartStyle, options.inputStyle));
                    css(input, extend({
                        position: 'absolute',
                        border: 0,
                        boxShadow: '0 0 15px rgba(0,0,0,0.3)',
                        width: '1px',
                        height: '1px',
                        padding: 0,
                        textAlign: 'center',
                        fontSize: chartStyle.fontSize,
                        fontFamily: chartStyle.fontFamily,
                        top: '-9999em'
                    }, options.inputStyle))
                }
                input.onfocus = () => {
                    rangeSelector.showInput(name)
                }
                ;
                input.onblur = () => {
                    if (input === H.doc.activeElement) {
                        updateExtremes()
                    }
                    rangeSelector.hideInput(name);
                    rangeSelector.setInputValue(name);
                    input.blur()
                }
                ;
                let keyDown = !1;
                input.onchange = () => {
                    if (!keyDown) {
                        updateExtremes();
                        rangeSelector.hideInput(name);
                        input.blur()
                    }
                }
                ;
                input.onkeypress = (event) => {
                    if (event.keyCode === 13) {
                        updateExtremes()
                    }
                }
                ;
                input.onkeydown = (event) => {
                    keyDown = !0;
                    if (event.keyCode === 38 || event.keyCode === 40) {
                        updateExtremes()
                    }
                }
                ;
                input.onkeyup = () => {
                    keyDown = !1
                }
                ;
                return {
                    dateBox,
                    input,
                    label
                }
            }
            getPosition() {
                const chart = this.chart
                    , options = chart.options.rangeSelector
                    , top = options.verticalAlign === 'top' ? chart.plotTop - chart.axisOffset[0] : 0;
                return {
                    buttonTop: top + options.buttonPosition.y,
                    inputTop: top + options.inputPosition.y - 10
                }
            }
            getYTDExtremes(dataMax, dataMin, useUTC) {
                const time = this.chart.time
                    , now = new time.Date(dataMax)
                    , year = time.get('FullYear', now)
                    , startOfYear = useUTC ? time.Date.UTC(year, 0, 1) : +new time.Date(year,0,1)
                    , min = Math.max(dataMin, startOfYear)
                    , ts = now.getTime();
                return {
                    max: Math.min(dataMax || ts, ts),
                    min
                }
            }
            render(min, max) {
                const chart = this.chart
                    , renderer = chart.renderer
                    , container = chart.container
                    , chartOptions = chart.options
                    , options = chartOptions.rangeSelector
                    , inputsZIndex = pick(chartOptions.chart.style && chartOptions.chart.style.zIndex, 0) + 1
                    , inputEnabled = options.inputEnabled
                    , rendered = this.rendered;
                if (options.enabled === !1) {
                    return
                }
                if (!rendered) {
                    this.group = renderer.g('range-selector-group').attr({
                        zIndex: 7
                    }).add();
                    this.div = createElement('div', void 0, {
                        position: 'relative',
                        height: 0,
                        zIndex: inputsZIndex
                    });
                    if (this.buttonOptions.length) {
                        this.renderButtons()
                    }
                    if (container.parentNode) {
                        container.parentNode.insertBefore(this.div, container)
                    }
                    if (inputEnabled) {
                        this.inputGroup = renderer.g('input-group').add(this.group);
                        const minElems = this.drawInput('min');
                        this.minDateBox = minElems.dateBox;
                        this.minLabel = minElems.label;
                        this.minInput = minElems.input;
                        const maxElems = this.drawInput('max');
                        this.maxDateBox = maxElems.dateBox;
                        this.maxLabel = maxElems.label;
                        this.maxInput = maxElems.input
                    }
                }
                if (inputEnabled) {
                    this.setInputValue('min', min);
                    this.setInputValue('max', max);
                    const unionExtremes = (chart.scroller && chart.scroller.getUnionExtremes()) || chart.xAxis[0] || {};
                    if (defined(unionExtremes.dataMin) && defined(unionExtremes.dataMax)) {
                        const minRange = chart.xAxis[0].minRange || 0;
                        this.setInputExtremes('min', unionExtremes.dataMin, Math.min(unionExtremes.dataMax, this.getInputValue('max')) - minRange);
                        this.setInputExtremes('max', Math.max(unionExtremes.dataMin, this.getInputValue('min')) + minRange, unionExtremes.dataMax)
                    }
                    if (this.inputGroup) {
                        let x = 0;
                        [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach( (label) => {
                                if (label) {
                                    const {width} = label.getBBox();
                                    if (width) {
                                        label.attr({
                                            x
                                        });
                                        x += width + options.inputSpacing
                                    }
                                }
                            }
                        )
                    }
                }
                this.alignElements();
                this.rendered = !0
            }
            renderButtons() {
                const {buttons, chart, options} = this;
                const lang = defaultOptions.lang;
                const renderer = chart.renderer;
                const buttonTheme = merge(options.buttonTheme);
                const states = buttonTheme && buttonTheme.states;
                const width = buttonTheme.width || 28;
                delete buttonTheme.width;
                delete buttonTheme.states;
                this.buttonGroup = renderer.g('range-selector-buttons').add(this.group);
                const dropdown = this.dropdown = createElement('select', void 0, {
                    position: 'absolute',
                    width: '1px',
                    height: '1px',
                    padding: 0,
                    border: 0,
                    top: '-9999em',
                    cursor: 'pointer',
                    opacity: 0.0001
                }, this.div);
                addEvent(dropdown, 'touchstart', () => {
                        dropdown.style.fontSize = '16px'
                    }
                );
                [[H.isMS ? 'mouseover' : 'mouseenter'], [H.isMS ? 'mouseout' : 'mouseleave'], ['change', 'click']].forEach( ([from,to]) => {
                        addEvent(dropdown, from, () => {
                                const button = buttons[this.currentButtonIndex()];
                                if (button) {
                                    fireEvent(button.element, to || from)
                                }
                            }
                        )
                    }
                );
                this.zoomText = renderer.label((lang && lang.rangeSelectorZoom) || '', 0).attr({
                    padding: options.buttonTheme.padding,
                    height: options.buttonTheme.height,
                    paddingLeft: 0,
                    paddingRight: 0
                }).add(this.buttonGroup);
                if (!this.chart.styledMode) {
                    this.zoomText.css(options.labelStyle);
                    buttonTheme['stroke-width'] = pick(buttonTheme['stroke-width'], 0)
                }
                createElement('option', {
                    textContent: this.zoomText.textStr,
                    disabled: !0
                }, void 0, dropdown);
                this.buttonOptions.forEach( (rangeOptions, i) => {
                        createElement('option', {
                            textContent: rangeOptions.title || rangeOptions.text
                        }, void 0, dropdown);
                        buttons[i] = renderer.button(rangeOptions.text, 0, 0, (e) => {
                                const buttonEvents = (rangeOptions.events && rangeOptions.events.click);
                                let callDefaultEvent;
                                if (buttonEvents) {
                                    callDefaultEvent = buttonEvents.call(rangeOptions, e)
                                }
                                if (callDefaultEvent !== !1) {
                                    this.clickButton(i)
                                }
                                this.isActive = !0
                            }
                            , buttonTheme, states && states.hover, states && states.select, states && states.disabled).attr({
                            'text-align': 'center',
                            width
                        }).add(this.buttonGroup);
                        if (rangeOptions.title) {
                            buttons[i].attr('title', rangeOptions.title)
                        }
                    }
                )
            }
            alignElements() {
                const {buttonGroup, buttons, chart, group, inputGroup, options, zoomText} = this;
                const chartOptions = chart.options;
                const navButtonOptions = (chartOptions.exporting && chartOptions.exporting.enabled !== !1 && chartOptions.navigation && chartOptions.navigation.buttonOptions);
                const {buttonPosition, inputPosition, verticalAlign} = options;
                const getXOffsetForExportButton = (group, position) => {
                        if (navButtonOptions && this.titleCollision(chart) && verticalAlign === 'top' && position.align === 'right' && ((position.y - group.getBBox().height - 12) < ((navButtonOptions.y || 0) + (navButtonOptions.height || 0) + chart.spacing[0]))) {
                            return -40
                        }
                        return 0
                    }
                ;
                let plotLeft = chart.plotLeft;
                if (group && buttonPosition && inputPosition) {
                    let translateX = buttonPosition.x - chart.spacing[3];
                    if (buttonGroup) {
                        this.positionButtons();
                        if (!this.initialButtonGroupWidth) {
                            let width = 0;
                            if (zoomText) {
                                width += zoomText.getBBox().width + 5
                            }
                            buttons.forEach( (button, i) => {
                                    width += button.width || 0;
                                    if (i !== buttons.length - 1) {
                                        width += options.buttonSpacing
                                    }
                                }
                            );
                            this.initialButtonGroupWidth = width
                        }
                        plotLeft -= chart.spacing[3];
                        this.updateButtonStates();
                        const xOffsetForExportButton = getXOffsetForExportButton(buttonGroup, buttonPosition);
                        this.alignButtonGroup(xOffsetForExportButton);
                        group.placed = buttonGroup.placed = chart.hasLoaded
                    }
                    let xOffsetForExportButton = 0;
                    if (inputGroup) {
                        xOffsetForExportButton = getXOffsetForExportButton(inputGroup, inputPosition);
                        if (inputPosition.align === 'left') {
                            translateX = plotLeft
                        } else if (inputPosition.align === 'right') {
                            translateX = -Math.max(chart.axisOffset[1], -xOffsetForExportButton)
                        }
                        inputGroup.align({
                            y: inputPosition.y,
                            width: inputGroup.getBBox().width,
                            align: inputPosition.align,
                            x: inputPosition.x + translateX - 2
                        }, !0, chart.spacingBox);
                        inputGroup.placed = chart.hasLoaded
                    }
                    this.handleCollision(xOffsetForExportButton);
                    group.align({
                        verticalAlign
                    }, !0, chart.spacingBox);
                    const alignTranslateY = group.alignAttr.translateY;
                    let groupHeight = group.getBBox().height + 20;
                    let translateY = 0;
                    if (verticalAlign === 'bottom') {
                        const legendOptions = chart.legend && chart.legend.options;
                        const legendHeight = (legendOptions && legendOptions.verticalAlign === 'bottom' && legendOptions.enabled && !legendOptions.floating ? (chart.legend.legendHeight + pick(legendOptions.margin, 10)) : 0);
                        groupHeight = groupHeight + legendHeight - 20;
                        translateY = (alignTranslateY - groupHeight - (options.floating ? 0 : options.y) - (chart.titleOffset ? chart.titleOffset[2] : 0) - 10)
                    }
                    if (verticalAlign === 'top') {
                        if (options.floating) {
                            translateY = 0
                        }
                        if (chart.titleOffset && chart.titleOffset[0]) {
                            translateY = chart.titleOffset[0]
                        }
                        translateY += ((chart.margin[0] - chart.spacing[0]) || 0)
                    } else if (verticalAlign === 'middle') {
                        if (inputPosition.y === buttonPosition.y) {
                            translateY = alignTranslateY
                        } else if (inputPosition.y || buttonPosition.y) {
                            if (inputPosition.y < 0 || buttonPosition.y < 0) {
                                translateY -= Math.min(inputPosition.y, buttonPosition.y)
                            } else {
                                translateY = alignTranslateY - groupHeight
                            }
                        }
                    }
                    group.translate(options.x, options.y + Math.floor(translateY));
                    const {minInput, maxInput, dropdown} = this;
                    if (options.inputEnabled && minInput && maxInput) {
                        minInput.style.marginTop = group.translateY + 'px';
                        maxInput.style.marginTop = group.translateY + 'px'
                    }
                    if (dropdown) {
                        dropdown.style.marginTop = group.translateY + 'px'
                    }
                }
            }
            alignButtonGroup(xOffsetForExportButton, width) {
                const {chart, options, buttonGroup, buttons} = this;
                const {buttonPosition} = options;
                const plotLeft = chart.plotLeft - chart.spacing[3];
                let translateX = buttonPosition.x - chart.spacing[3];
                if (buttonPosition.align === 'right') {
                    translateX += xOffsetForExportButton - plotLeft
                } else if (buttonPosition.align === 'center') {
                    translateX -= plotLeft / 2
                }
                if (buttonGroup) {
                    buttonGroup.align({
                        y: buttonPosition.y,
                        width: pick(width, this.initialButtonGroupWidth),
                        align: buttonPosition.align,
                        x: translateX
                    }, !0, chart.spacingBox)
                }
            }
            positionButtons() {
                const {buttons, chart, options, zoomText} = this;
                const verb = chart.hasLoaded ? 'animate' : 'attr';
                const {buttonPosition} = options;
                const plotLeft = chart.plotLeft;
                let buttonLeft = plotLeft;
                if (zoomText && zoomText.visibility !== 'hidden') {
                    zoomText[verb]({
                        x: pick(plotLeft + buttonPosition.x, plotLeft)
                    });
                    buttonLeft += buttonPosition.x + zoomText.getBBox().width + 5
                }
                for (let i = 0, iEnd = this.buttonOptions.length; i < iEnd; ++i) {
                    if (buttons[i].visibility !== 'hidden') {
                        buttons[i][verb]({
                            x: buttonLeft
                        });
                        buttonLeft += (buttons[i].width || 0) + options.buttonSpacing
                    } else {
                        buttons[i][verb]({
                            x: plotLeft
                        })
                    }
                }
            }
            handleCollision(xOffsetForExportButton) {
                const {chart, buttonGroup, inputGroup} = this;
                const {buttonPosition, dropdown, inputPosition} = this.options;
                const maxButtonWidth = () => {
                        let buttonWidth = 0;
                        this.buttons.forEach( (button) => {
                                const bBox = button.getBBox();
                                if (bBox.width > buttonWidth) {
                                    buttonWidth = bBox.width
                                }
                            }
                        );
                        return buttonWidth
                    }
                ;
                const groupsOverlap = (buttonGroupWidth) => {
                        if (inputGroup && buttonGroup) {
                            const inputGroupX = (inputGroup.alignAttr.translateX + inputGroup.alignOptions.x - xOffsetForExportButton + inputGroup.getBBox().x + 2);
                            const inputGroupWidth = inputGroup.alignOptions.width;
                            const buttonGroupX = buttonGroup.alignAttr.translateX + buttonGroup.getBBox().x;
                            return (buttonGroupX + buttonGroupWidth > inputGroupX) && (inputGroupX + inputGroupWidth > buttonGroupX) && (buttonPosition.y < (inputPosition.y + inputGroup.getBBox().height))
                        }
                        return !1
                    }
                ;
                const moveInputsDown = () => {
                        if (inputGroup && buttonGroup) {
                            inputGroup.attr({
                                translateX: inputGroup.alignAttr.translateX + (chart.axisOffset[1] >= -xOffsetForExportButton ? 0 : -xOffsetForExportButton),
                                translateY: inputGroup.alignAttr.translateY + buttonGroup.getBBox().height + 10
                            })
                        }
                    }
                ;
                if (buttonGroup) {
                    if (dropdown === 'always') {
                        this.collapseButtons(xOffsetForExportButton);
                        if (groupsOverlap(maxButtonWidth())) {
                            moveInputsDown()
                        }
                        return
                    }
                    if (dropdown === 'never') {
                        this.expandButtons()
                    }
                }
                if (inputGroup && buttonGroup) {
                    if ((inputPosition.align === buttonPosition.align) || groupsOverlap(this.initialButtonGroupWidth + 20)) {
                        if (dropdown === 'responsive') {
                            this.collapseButtons(xOffsetForExportButton);
                            if (groupsOverlap(maxButtonWidth())) {
                                moveInputsDown()
                            }
                        } else {
                            moveInputsDown()
                        }
                    } else if (dropdown === 'responsive') {
                        this.expandButtons()
                    }
                } else if (buttonGroup && dropdown === 'responsive') {
                    if (this.initialButtonGroupWidth > chart.plotWidth) {
                        this.collapseButtons(xOffsetForExportButton)
                    } else {
                        this.expandButtons()
                    }
                }
            }
            collapseButtons(xOffsetForExportButton) {
                const {buttons, buttonOptions, chart, dropdown, options, zoomText} = this;
                const userButtonTheme = (chart.userOptions.rangeSelector && chart.userOptions.rangeSelector.buttonTheme) || {};
                const getAttribs = (text) => ({
                    text: text ? `${text} ▾` : '▾',
                    width: 'auto',
                    paddingLeft: pick(options.buttonTheme.paddingLeft, userButtonTheme.padding, 8),
                    paddingRight: pick(options.buttonTheme.paddingRight, userButtonTheme.padding, 8)
                });
                if (zoomText) {
                    zoomText.hide()
                }
                let hasActiveButton = !1;
                buttonOptions.forEach( (rangeOptions, i) => {
                        const button = buttons[i];
                        if (button.state !== 2) {
                            button.hide()
                        } else {
                            button.show();
                            button.attr(getAttribs(rangeOptions.text));
                            hasActiveButton = !0
                        }
                    }
                );
                if (!hasActiveButton) {
                    if (dropdown) {
                        dropdown.selectedIndex = 0
                    }
                    buttons[0].show();
                    buttons[0].attr(getAttribs(this.zoomText && this.zoomText.textStr))
                }
                const {align} = options.buttonPosition;
                this.positionButtons();
                if (align === 'right' || align === 'center') {
                    this.alignButtonGroup(xOffsetForExportButton, buttons[this.currentButtonIndex()].getBBox().width)
                }
                this.showDropdown()
            }
            expandButtons() {
                const {buttons, buttonOptions, options, zoomText} = this;
                this.hideDropdown();
                if (zoomText) {
                    zoomText.show()
                }
                buttonOptions.forEach( (rangeOptions, i) => {
                        const button = buttons[i];
                        button.show();
                        button.attr({
                            text: rangeOptions.text,
                            width: options.buttonTheme.width || 28,
                            paddingLeft: pick(options.buttonTheme.paddingLeft, 'unset'),
                            paddingRight: pick(options.buttonTheme.paddingRight, 'unset')
                        });
                        if (button.state < 2) {
                            button.setState(0)
                        }
                    }
                );
                this.positionButtons()
            }
            currentButtonIndex() {
                const {dropdown} = this;
                if (dropdown && dropdown.selectedIndex > 0) {
                    return dropdown.selectedIndex - 1
                }
                return 0
            }
            showDropdown() {
                const {buttonGroup, buttons, chart, dropdown} = this;
                if (buttonGroup && dropdown) {
                    const {translateX=0, translateY=0} = buttonGroup
                        , bBox = buttons[this.currentButtonIndex()].getBBox();
                    css(dropdown, {
                        left: (chart.plotLeft + translateX) + 'px',
                        top: (translateY + 0.5) + 'px',
                        width: bBox.width + 'px',
                        height: bBox.height + 'px'
                    });
                    this.hasVisibleDropdown = !0
                }
            }
            hideDropdown() {
                const {dropdown} = this;
                if (dropdown) {
                    css(dropdown, {
                        top: '-9999em',
                        width: '1px',
                        height: '1px'
                    });
                    this.hasVisibleDropdown = !1
                }
            }
            getHeight() {
                const rangeSelector = this
                    , options = rangeSelector.options
                    , rangeSelectorGroup = rangeSelector.group
                    , inputPosition = options.inputPosition
                    , buttonPosition = options.buttonPosition
                    , yPosition = options.y
                    , buttonPositionY = buttonPosition.y
                    , inputPositionY = inputPosition.y;
                let rangeSelectorHeight = 0;
                if (options.height) {
                    return options.height
                }
                this.alignElements();
                rangeSelectorHeight = rangeSelectorGroup ? (rangeSelectorGroup.getBBox(!0).height) + 13 + yPosition : 0;
                const minPosition = Math.min(inputPositionY, buttonPositionY);
                if ((inputPositionY < 0 && buttonPositionY < 0) || (inputPositionY > 0 && buttonPositionY > 0)) {
                    rangeSelectorHeight += Math.abs(minPosition)
                }
                return rangeSelectorHeight
            }
            titleCollision(chart) {
                return !(chart.options.title.text || chart.options.subtitle.text)
            }
            update(options) {
                const chart = this.chart;
                merge(!0, chart.options.rangeSelector, options);
                this.destroy();
                this.init(chart);
                this.render()
            }
            destroy() {
                const rSelector = this
                    , minInput = rSelector.minInput
                    , maxInput = rSelector.maxInput;
                if (rSelector.eventsToUnbind) {
                    rSelector.eventsToUnbind.forEach( (unbind) => unbind());
                    rSelector.eventsToUnbind = void 0
                }
                destroyObjectProperties(rSelector.buttons);
                if (minInput) {
                    minInput.onfocus = minInput.onblur = minInput.onchange = null
                }
                if (maxInput) {
                    maxInput.onfocus = maxInput.onblur = maxInput.onchange = null
                }
                objectEach(rSelector, function(val, key) {
                    if (val && key !== 'chart') {
                        if (val instanceof SVGElement) {
                            val.destroy()
                        } else if (val instanceof window.HTMLElement) {
                            discardElement(val)
                        }
                    }
                    if (val !== RangeSelector.prototype[key]) {
                        rSelector[key] = null
                    }
                }, this)
            }
        }
        extend(RangeSelector.prototype, {
            defaultButtons: [{
                type: 'month',
                count: 1,
                text: '1m',
                title: 'View 1 month'
            }, {
                type: 'month',
                count: 3,
                text: '3m',
                title: 'View 3 months'
            }, {
                type: 'month',
                count: 6,
                text: '6m',
                title: 'View 6 months'
            }, {
                type: 'ytd',
                text: 'YTD',
                title: 'View year to date'
            }, {
                type: 'year',
                count: 1,
                text: '1y',
                title: 'View 1 year'
            }, {
                type: 'all',
                text: 'All',
                title: 'View all'
            }],
            inputTypeFormats: {
                'datetime-local': '%Y-%m-%dT%H:%M:%S',
                'date': '%Y-%m-%d',
                'time': '%H:%M:%S'
            }
        });
        ('');
        return RangeSelector
    });
    _registerModule(_modules, 'Accessibility/Components/RangeSelectorComponent.js', [_modules['Stock/RangeSelector/RangeSelector.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/Announcer.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Core/Utilities.js']], function(RangeSelector, AccessibilityComponent, ChartUtilities, Announcer, KeyboardNavigationHandler, U) {
        const {unhideChartElementFromAT, getAxisRangeDescription} = ChartUtilities;
        const {addEvent, attr} = U;
        function shouldRunInputNavigation(chart) {
            return Boolean(chart.rangeSelector && chart.rangeSelector.inputGroup && chart.rangeSelector.inputGroup.element.style.visibility !== 'hidden' && chart.options.rangeSelector.inputEnabled !== !1 && chart.rangeSelector.minInput && chart.rangeSelector.maxInput)
        }
        class RangeSelectorComponent extends AccessibilityComponent {
            constructor() {
                super(...arguments);
                this.announcer = void 0
            }
            init() {
                const chart = this.chart;
                this.announcer = new Announcer(chart,'polite')
            }
            onChartUpdate() {
                const chart = this.chart
                    , component = this
                    , rangeSelector = chart.rangeSelector;
                if (!rangeSelector) {
                    return
                }
                this.updateSelectorVisibility();
                this.setDropdownAttrs();
                if (rangeSelector.buttons && rangeSelector.buttons.length) {
                    rangeSelector.buttons.forEach( (button) => {
                            component.setRangeButtonAttrs(button)
                        }
                    )
                }
                if (rangeSelector.maxInput && rangeSelector.minInput) {
                    ['minInput', 'maxInput'].forEach(function(key, i) {
                        const input = rangeSelector[key];
                        if (input) {
                            unhideChartElementFromAT(chart, input);
                            component.setRangeInputAttrs(input, 'accessibility.rangeSelector.' + (i ? 'max' : 'min') + 'InputLabel')
                        }
                    })
                }
            }
            updateSelectorVisibility() {
                const chart = this.chart;
                const rangeSelector = chart.rangeSelector;
                const dropdown = (rangeSelector && rangeSelector.dropdown);
                const buttons = (rangeSelector && rangeSelector.buttons || []);
                const hideFromAT = (el) => el.setAttribute('aria-hidden', !0);
                if (rangeSelector && rangeSelector.hasVisibleDropdown && dropdown) {
                    unhideChartElementFromAT(chart, dropdown);
                    buttons.forEach( (btn) => hideFromAT(btn.element))
                } else {
                    if (dropdown) {
                        hideFromAT(dropdown)
                    }
                    buttons.forEach( (btn) => unhideChartElementFromAT(chart, btn.element))
                }
            }
            setDropdownAttrs() {
                const chart = this.chart;
                const dropdown = (chart.rangeSelector && chart.rangeSelector.dropdown);
                if (dropdown) {
                    const label = chart.langFormat('accessibility.rangeSelector.dropdownLabel', {
                        rangeTitle: chart.options.lang.rangeSelectorZoom
                    });
                    dropdown.setAttribute('aria-label', label);
                    dropdown.setAttribute('tabindex', -1)
                }
            }
            setRangeButtonAttrs(button) {
                attr(button.element, {
                    tabindex: -1,
                    role: 'button'
                })
            }
            setRangeInputAttrs(input, langKey) {
                const chart = this.chart;
                attr(input, {
                    tabindex: -1,
                    'aria-label': chart.langFormat(langKey, {
                        chart: chart
                    })
                })
            }
            onButtonNavKbdArrowKey(keyboardNavigationHandler, keyCode) {
                const response = keyboardNavigationHandler.response
                    , keys = this.keyCodes
                    , chart = this.chart
                    , wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround
                    , direction = (keyCode === keys.left || keyCode === keys.up) ? -1 : 1
                    , didHighlight = chart.highlightRangeSelectorButton(chart.highlightedRangeSelectorItemIx + direction);
                if (!didHighlight) {
                    if (wrapAround) {
                        keyboardNavigationHandler.init(direction);
                        return response.success
                    }
                    return response[direction > 0 ? 'next' : 'prev']
                }
                return response.success
            }
            onButtonNavKbdClick(keyboardNavigationHandler) {
                const response = keyboardNavigationHandler.response
                    , chart = this.chart
                    , wasDisabled = chart.oldRangeSelectorItemState === 3;
                if (!wasDisabled) {
                    this.fakeClickEvent(chart.rangeSelector.buttons[chart.highlightedRangeSelectorItemIx].element)
                }
                return response.success
            }
            onAfterBtnClick() {
                const chart = this.chart;
                const axisRangeDescription = getAxisRangeDescription(chart.xAxis[0]);
                const announcement = chart.langFormat('accessibility.rangeSelector.clickButtonAnnouncement', {
                    chart,
                    axisRangeDescription
                });
                if (announcement) {
                    this.announcer.announce(announcement)
                }
            }
            onInputKbdMove(direction) {
                const chart = this.chart;
                const rangeSel = chart.rangeSelector;
                const newIx = chart.highlightedInputRangeIx = (chart.highlightedInputRangeIx || 0) + direction;
                const newIxOutOfRange = newIx > 1 || newIx < 0;
                if (newIxOutOfRange) {
                    if (chart.accessibility) {
                        chart.accessibility.keyboardNavigation.exiting = !0;
                        chart.accessibility.keyboardNavigation.tabindexContainer.focus();
                        return chart.accessibility.keyboardNavigation.move(direction)
                    }
                } else if (rangeSel) {
                    const svgEl = rangeSel[newIx ? 'maxDateBox' : 'minDateBox'];
                    const inputEl = rangeSel[newIx ? 'maxInput' : 'minInput'];
                    if (svgEl && inputEl) {
                        chart.setFocusToElement(svgEl, inputEl)
                    }
                }
                return !0
            }
            onInputNavInit(direction) {
                const component = this;
                const chart = this.chart;
                const buttonIxToHighlight = direction > 0 ? 0 : 1;
                const rangeSel = chart.rangeSelector;
                const svgEl = (rangeSel && rangeSel[buttonIxToHighlight ? 'maxDateBox' : 'minDateBox']);
                const minInput = (rangeSel && rangeSel.minInput);
                const maxInput = (rangeSel && rangeSel.maxInput);
                const inputEl = buttonIxToHighlight ? maxInput : minInput;
                chart.highlightedInputRangeIx = buttonIxToHighlight;
                if (svgEl && minInput && maxInput) {
                    chart.setFocusToElement(svgEl, inputEl);
                    if (this.removeInputKeydownHandler) {
                        this.removeInputKeydownHandler()
                    }
                    const keydownHandler = (e) => {
                            const isTab = (e.which || e.keyCode) === this.keyCodes.tab;
                            if (isTab && component.onInputKbdMove(e.shiftKey ? -1 : 1)) {
                                e.preventDefault();
                                e.stopPropagation()
                            }
                        }
                    ;
                    const minRemover = addEvent(minInput, 'keydown', keydownHandler);
                    const maxRemover = addEvent(maxInput, 'keydown', keydownHandler);
                    this.removeInputKeydownHandler = () => {
                        minRemover();
                        maxRemover()
                    }
                }
            }
            onInputNavTerminate() {
                const rangeSel = (this.chart.rangeSelector || {});
                if (rangeSel.maxInput) {
                    rangeSel.hideInput('max')
                }
                if (rangeSel.minInput) {
                    rangeSel.hideInput('min')
                }
                if (this.removeInputKeydownHandler) {
                    this.removeInputKeydownHandler();
                    delete this.removeInputKeydownHandler
                }
            }
            initDropdownNav() {
                const chart = this.chart;
                const rangeSelector = chart.rangeSelector;
                const dropdown = (rangeSelector && rangeSelector.dropdown);
                if (rangeSelector && dropdown) {
                    chart.setFocusToElement(rangeSelector.buttonGroup, dropdown);
                    if (this.removeDropdownKeydownHandler) {
                        this.removeDropdownKeydownHandler()
                    }
                    this.removeDropdownKeydownHandler = addEvent(dropdown, 'keydown', (e) => {
                            const isTab = (e.which || e.keyCode) === this.keyCodes.tab
                                , a11y = chart.accessibility;
                            if (isTab) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (a11y) {
                                    a11y.keyboardNavigation.tabindexContainer.focus();
                                    a11y.keyboardNavigation.move(e.shiftKey ? -1 : 1)
                                }
                            }
                        }
                    )
                }
            }
            getRangeSelectorButtonNavigation() {
                const chart = this.chart;
                const keys = this.keyCodes;
                const component = this;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[[keys.left, keys.right, keys.up, keys.down], function(keyCode) {
                        return component.onButtonNavKbdArrowKey(this, keyCode)
                    }
                    ], [[keys.enter, keys.space], function() {
                        return component.onButtonNavKbdClick(this)
                    }
                    ]],
                    validate: function() {
                        return !!(chart.rangeSelector && chart.rangeSelector.buttons && chart.rangeSelector.buttons.length)
                    },
                    init: function(direction) {
                        const rangeSelector = chart.rangeSelector;
                        if (rangeSelector && rangeSelector.hasVisibleDropdown) {
                            component.initDropdownNav()
                        } else if (rangeSelector) {
                            const lastButtonIx = rangeSelector.buttons.length - 1;
                            chart.highlightRangeSelectorButton(direction > 0 ? 0 : lastButtonIx)
                        }
                    },
                    terminate: function() {
                        if (component.removeDropdownKeydownHandler) {
                            component.removeDropdownKeydownHandler();
                            delete component.removeDropdownKeydownHandler
                        }
                    }
                })
            }
            getRangeSelectorInputNavigation() {
                const chart = this.chart;
                const component = this;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [],
                    validate: function() {
                        return shouldRunInputNavigation(chart)
                    },
                    init: function(direction) {
                        component.onInputNavInit(direction)
                    },
                    terminate: function() {
                        component.onInputNavTerminate()
                    }
                })
            }
            getKeyboardNavigation() {
                return [this.getRangeSelectorButtonNavigation(), this.getRangeSelectorInputNavigation()]
            }
            destroy() {
                if (this.removeDropdownKeydownHandler) {
                    this.removeDropdownKeydownHandler()
                }
                if (this.removeInputKeydownHandler) {
                    this.removeInputKeydownHandler()
                }
                if (this.announcer) {
                    this.announcer.destroy()
                }
            }
        }
        (function(RangeSelectorComponent) {
                const composedMembers = [];
                function chartHighlightRangeSelectorButton(ix) {
                    const buttons = (this.rangeSelector && this.rangeSelector.buttons || []);
                    const curHighlightedIx = this.highlightedRangeSelectorItemIx;
                    const curSelectedIx = (this.rangeSelector && this.rangeSelector.selected);
                    if (typeof curHighlightedIx !== 'undefined' && buttons[curHighlightedIx] && curHighlightedIx !== curSelectedIx) {
                        buttons[curHighlightedIx].setState(this.oldRangeSelectorItemState || 0)
                    }
                    this.highlightedRangeSelectorItemIx = ix;
                    if (buttons[ix]) {
                        this.setFocusToElement(buttons[ix].box, buttons[ix].element);
                        if (ix !== curSelectedIx) {
                            this.oldRangeSelectorItemState = buttons[ix].state;
                            buttons[ix].setState(1)
                        }
                        return !0
                    }
                    return !1
                }
                function compose(ChartClass, RangeSelectorClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.highlightRangeSelectorButton = (chartHighlightRangeSelectorButton)
                    }
                    if (U.pushUnique(composedMembers, RangeSelectorClass)) {
                        addEvent(RangeSelector, 'afterBtnClick', rangeSelectorAfterBtnClick)
                    }
                }
                RangeSelectorComponent.compose = compose;
                function rangeSelectorAfterBtnClick() {
                    const a11y = this.chart.accessibility;
                    if (a11y && a11y.components.rangeSelector) {
                        return a11y.components.rangeSelector.onAfterBtnClick()
                    }
                }
            }
        )(RangeSelectorComponent || (RangeSelectorComponent = {}));
        return RangeSelectorComponent
    });
    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/ForcedMarkers.js', [_modules['Core/Utilities.js']], function(U) {
        const {addEvent, merge} = U;
        var ForcedMarkersComposition;
        (function(ForcedMarkersComposition) {
                const composedMembers = [];
                function compose(SeriesClass) {
                    if (U.pushUnique(composedMembers, SeriesClass)) {
                        addEvent(SeriesClass, 'afterSetOptions', seriesOnAfterSetOptions);
                        addEvent(SeriesClass, 'render', seriesOnRender);
                        addEvent(SeriesClass, 'afterRender', seriesOnAfterRender)
                    }
                }
                ForcedMarkersComposition.compose = compose;
                function forceZeroOpacityMarkerOptions(options) {
                    merge(!0, options, {
                        marker: {
                            enabled: !0,
                            states: {
                                normal: {
                                    opacity: 0
                                }
                            }
                        }
                    })
                }
                function getPointMarkerOpacity(pointOptions) {
                    return pointOptions.marker.states && pointOptions.marker.states.normal && pointOptions.marker.states.normal.opacity
                }
                function handleForcePointMarkers(series) {
                    let i = series.points.length;
                    while (i--) {
                        const point = series.points[i];
                        const pointOptions = point.options;
                        const hadForcedMarker = point.hasForcedA11yMarker;
                        delete point.hasForcedA11yMarker;
                        if (pointOptions.marker) {
                            const isStillForcedMarker = hadForcedMarker && getPointMarkerOpacity(pointOptions) === 0;
                            if (pointOptions.marker.enabled && !isStillForcedMarker) {
                                unforcePointMarkerOptions(pointOptions);
                                point.hasForcedA11yMarker = !1
                            } else if (pointOptions.marker.enabled === !1) {
                                forceZeroOpacityMarkerOptions(pointOptions);
                                point.hasForcedA11yMarker = !0
                            }
                        }
                    }
                }
                function hasIndividualPointMarkerOptions(series) {
                    return !!(series._hasPointMarkers && series.points && series.points.length)
                }
                function isWithinDescriptionThreshold(series) {
                    const a11yOptions = series.chart.options.accessibility;
                    return series.points.length < a11yOptions.series.pointDescriptionEnabledThreshold || a11yOptions.series.pointDescriptionEnabledThreshold === !1
                }
                function seriesOnAfterRender() {
                    const series = this;
                    if (series.chart.styledMode) {
                        if (series.markerGroup) {
                            series.markerGroup[series.a11yMarkersForced ? 'addClass' : 'removeClass']('highcharts-a11y-markers-hidden')
                        }
                        if (hasIndividualPointMarkerOptions(series)) {
                            series.points.forEach( (point) => {
                                    if (point.graphic) {
                                        point.graphic[point.hasForcedA11yMarker ? 'addClass' : 'removeClass']('highcharts-a11y-marker-hidden');
                                        point.graphic[point.hasForcedA11yMarker === !1 ? 'addClass' : 'removeClass']('highcharts-a11y-marker-visible')
                                    }
                                }
                            )
                        }
                    }
                }
                function seriesOnAfterSetOptions(e) {
                    this.resetA11yMarkerOptions = merge(e.options.marker || {}, this.userOptions.marker || {})
                }
                function seriesOnRender() {
                    const series = this
                        , options = series.options;
                    if (shouldForceMarkers(series)) {
                        if (options.marker && options.marker.enabled === !1) {
                            series.a11yMarkersForced = !0;
                            forceZeroOpacityMarkerOptions(series.options)
                        }
                        if (hasIndividualPointMarkerOptions(series)) {
                            handleForcePointMarkers(series)
                        }
                    } else if (series.a11yMarkersForced) {
                        delete series.a11yMarkersForced;
                        unforceSeriesMarkerOptions(series);
                        delete series.resetA11yMarkerOptions
                    }
                }
                function shouldForceMarkers(series) {
                    const chart = series.chart
                        , chartA11yEnabled = chart.options.accessibility.enabled
                        , seriesA11yEnabled = (series.options.accessibility && series.options.accessibility.enabled) !== !1;
                    return (chartA11yEnabled && seriesA11yEnabled && isWithinDescriptionThreshold(series))
                }
                function unforcePointMarkerOptions(pointOptions) {
                    merge(!0, pointOptions.marker, {
                        states: {
                            normal: {
                                opacity: getPointMarkerOpacity(pointOptions) || 1
                            }
                        }
                    })
                }
                function unforceSeriesMarkerOptions(series) {
                    const resetMarkerOptions = series.resetA11yMarkerOptions;
                    if (resetMarkerOptions) {
                        const originalOpactiy = resetMarkerOptions.states && resetMarkerOptions.states.normal && resetMarkerOptions.states.normal.opacity;
                        if (series.userOptions && series.userOptions.marker) {
                            series.userOptions.marker.enabled = !0
                        }
                        series.update({
                            marker: {
                                enabled: resetMarkerOptions.enabled,
                                states: {
                                    normal: {
                                        opacity: originalOpactiy
                                    }
                                }
                            }
                        })
                    }
                }
            }
        )(ForcedMarkersComposition || (ForcedMarkersComposition = {}));
        return ForcedMarkersComposition
    });
    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/Series.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Utils/EventProvider.js'], _modules['Accessibility/Utils/ChartUtilities.js']], function(Point, Series, SeriesRegistry, H, U, KeyboardNavigationHandler, EventProvider, ChartUtilities) {
        const {seriesTypes} = SeriesRegistry;
        const {doc} = H;
        const {defined, fireEvent} = U;
        const {getPointFromXY, getSeriesFromName, scrollAxisToPoint} = ChartUtilities;
        function getPointIndex(point) {
            const index = point.index
                , points = point.series.points;
            let i = points.length;
            if (points[index] !== point) {
                while (i--) {
                    if (points[i] === point) {
                        return i
                    }
                }
            } else {
                return index
            }
        }
        function isSkipSeries(series) {
            const a11yOptions = series.chart.options.accessibility
                , seriesNavOptions = a11yOptions.keyboardNavigation.seriesNavigation
                , seriesA11yOptions = series.options.accessibility || {}
                , seriesKbdNavOptions = seriesA11yOptions.keyboardNavigation;
            return seriesKbdNavOptions && seriesKbdNavOptions.enabled === !1 || seriesA11yOptions.enabled === !1 || series.options.enableMouseTracking === !1 || !series.visible || (seriesNavOptions.pointNavigationEnabledThreshold && +seriesNavOptions.pointNavigationEnabledThreshold <= series.points.length)
        }
        function isSkipPoint(point) {
            const a11yOptions = point.series.chart.options.accessibility;
            const pointA11yDisabled = (point.options.accessibility && point.options.accessibility.enabled === !1);
            return point.isNull && a11yOptions.keyboardNavigation.seriesNavigation.skipNullPoints || point.visible === !1 || point.isInside === !1 || pointA11yDisabled || isSkipSeries(point.series)
        }
        function getFirstValidPointInSeries(series) {
            const points = series.points || []
                , len = points.length;
            for (let i = 0; i < len; ++i) {
                if (!isSkipPoint(points[i])) {
                    return points[i]
                }
            }
            return null
        }
        function getFirstValidPointInChart(chart) {
            const series = chart.series || []
                , len = series.length;
            for (let i = 0; i < len; ++i) {
                if (!isSkipSeries(series[i])) {
                    const point = getFirstValidPointInSeries(series[i]);
                    if (point) {
                        return point
                    }
                }
            }
            return null
        }
        function highlightLastValidPointInChart(chart) {
            const numSeries = chart.series.length;
            let i = numSeries
                , res = !1;
            while (i--) {
                chart.highlightedPoint = chart.series[i].points[chart.series[i].points.length - 1];
                res = chart.series[i].highlightNextValidPoint();
                if (res) {
                    break
                }
            }
            return res
        }
        function updateChartFocusAfterDrilling(chart) {
            const point = getFirstValidPointInChart(chart);
            if (point) {
                point.highlight(!1)
            }
        }
        function highlightFirstValidPointInChart(chart) {
            delete chart.highlightedPoint;
            const point = getFirstValidPointInChart(chart);
            return point ? point.highlight() : !1
        }
        class SeriesKeyboardNavigation {
            constructor(chart, keyCodes) {
                this.keyCodes = keyCodes;
                this.chart = chart
            }
            init() {
                const keyboardNavigation = this
                    , chart = this.chart
                    , e = this.eventProvider = new EventProvider();
                e.addEvent(Series, 'destroy', function() {
                    return keyboardNavigation.onSeriesDestroy(this)
                });
                e.addEvent(chart, 'afterApplyDrilldown', function() {
                    updateChartFocusAfterDrilling(this)
                });
                e.addEvent(chart, 'drilldown', function(e) {
                    const point = e.point
                        , series = point.series;
                    keyboardNavigation.lastDrilledDownPoint = {
                        x: point.x,
                        y: point.y,
                        seriesName: series ? series.name : ''
                    }
                });
                e.addEvent(chart, 'drillupall', function() {
                    setTimeout(function() {
                        keyboardNavigation.onDrillupAll()
                    }, 10)
                });
                e.addEvent(Point, 'afterSetState', function() {
                    const point = this;
                    const pointEl = point.graphic && point.graphic.element;
                    const focusedElement = doc.activeElement;
                    const focusedElClassName = (focusedElement && focusedElement.getAttribute('class'));
                    const isProxyFocused = focusedElClassName && focusedElClassName.indexOf('highcharts-a11y-proxy-element') > -1;
                    if (chart.highlightedPoint === point && focusedElement !== pointEl && !isProxyFocused && pointEl && pointEl.focus) {
                        pointEl.focus()
                    }
                })
            }
            onDrillupAll() {
                const last = this.lastDrilledDownPoint
                    , chart = this.chart
                    , series = last && getSeriesFromName(chart, last.seriesName);
                let point;
                if (last && series && defined(last.x) && defined(last.y)) {
                    point = getPointFromXY(series, last.x, last.y)
                }
                point = point || getFirstValidPointInChart(chart);
                if (chart.container) {
                    chart.container.focus()
                }
                if (point && point.highlight) {
                    point.highlight(!1)
                }
            }
            getKeyboardNavigationHandler() {
                const keyboardNavigation = this
                    , keys = this.keyCodes
                    , chart = this.chart
                    , inverted = chart.inverted;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[inverted ? [keys.up, keys.down] : [keys.left, keys.right], function(keyCode) {
                        return keyboardNavigation.onKbdSideways(this, keyCode)
                    }
                    ], [inverted ? [keys.left, keys.right] : [keys.up, keys.down], function(keyCode) {
                        return keyboardNavigation.onKbdVertical(this, keyCode)
                    }
                    ], [[keys.enter, keys.space], function(keyCode, event) {
                        const point = chart.highlightedPoint;
                        if (point) {
                            event.point = point;
                            fireEvent(point.series, 'click', event);
                            point.firePointEvent('click')
                        }
                        return this.response.success
                    }
                    ], [[keys.home], function() {
                        highlightFirstValidPointInChart(chart);
                        return this.response.success
                    }
                    ], [[keys.end], function() {
                        highlightLastValidPointInChart(chart);
                        return this.response.success
                    }
                    ], [[keys.pageDown, keys.pageUp], function(keyCode) {
                        chart.highlightAdjacentSeries(keyCode === keys.pageDown);
                        return this.response.success
                    }
                    ]],
                    init: function() {
                        return keyboardNavigation.onHandlerInit(this)
                    },
                    validate: function() {
                        return !!getFirstValidPointInChart(chart)
                    },
                    terminate: function() {
                        return keyboardNavigation.onHandlerTerminate()
                    }
                })
            }
            onKbdSideways(handler, keyCode) {
                const keys = this.keyCodes
                    , isNext = keyCode === keys.right || keyCode === keys.down;
                return this.attemptHighlightAdjacentPoint(handler, isNext)
            }
            onHandlerInit(handler) {
                const chart = this.chart
                    , kbdNavOptions = chart.options.accessibility.keyboardNavigation;
                if (kbdNavOptions.seriesNavigation.rememberPointFocus && chart.highlightedPoint) {
                    chart.highlightedPoint.highlight()
                } else {
                    highlightFirstValidPointInChart(chart)
                }
                return handler.response.success
            }
            onKbdVertical(handler, keyCode) {
                const chart = this.chart
                    , keys = this.keyCodes
                    , isNext = keyCode === keys.down || keyCode === keys.right
                    , navOptions = chart.options.accessibility.keyboardNavigation.seriesNavigation;
                if (navOptions.mode && navOptions.mode === 'serialize') {
                    return this.attemptHighlightAdjacentPoint(handler, isNext)
                }
                const highlightMethod = (chart.highlightedPoint && chart.highlightedPoint.series.keyboardMoveVertical) ? 'highlightAdjacentPointVertical' : 'highlightAdjacentSeries';
                chart[highlightMethod](isNext);
                return handler.response.success
            }
            onHandlerTerminate() {
                const chart = this.chart
                    , kbdNavOptions = chart.options.accessibility.keyboardNavigation;
                if (chart.tooltip) {
                    chart.tooltip.hide(0)
                }
                const hoverSeries = (chart.highlightedPoint && chart.highlightedPoint.series);
                if (hoverSeries && hoverSeries.onMouseOut) {
                    hoverSeries.onMouseOut()
                }
                if (chart.highlightedPoint && chart.highlightedPoint.onMouseOut) {
                    chart.highlightedPoint.onMouseOut()
                }
                if (!kbdNavOptions.seriesNavigation.rememberPointFocus) {
                    delete chart.highlightedPoint
                }
            }
            attemptHighlightAdjacentPoint(handler, directionIsNext) {
                const chart = this.chart
                    , wrapAround = chart.options.accessibility.keyboardNavigation.wrapAround
                    , highlightSuccessful = chart.highlightAdjacentPoint(directionIsNext);
                if (!highlightSuccessful) {
                    if (wrapAround && (directionIsNext ? highlightFirstValidPointInChart(chart) : highlightLastValidPointInChart(chart))) {
                        return handler.response.success
                    }
                    return handler.response[directionIsNext ? 'next' : 'prev']
                }
                return handler.response.success
            }
            onSeriesDestroy(series) {
                const chart = this.chart
                    , currentHighlightedPointDestroyed = chart.highlightedPoint && chart.highlightedPoint.series === series;
                if (currentHighlightedPointDestroyed) {
                    delete chart.highlightedPoint;
                    if (chart.focusElement) {
                        chart.focusElement.removeFocusBorder()
                    }
                }
            }
            destroy() {
                this.eventProvider.removeAddedEvents()
            }
        }
        (function(SeriesKeyboardNavigation) {
                const composedMembers = [];
                function chartHighlightAdjacentPoint(next) {
                    const chart = this
                        , series = chart.series
                        , curPoint = chart.highlightedPoint
                        , curPointIndex = curPoint && getPointIndex(curPoint) || 0
                        , curPoints = curPoint && curPoint.series.points || []
                        , lastSeries = chart.series && chart.series[chart.series.length - 1]
                        , lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
                    let newSeries, newPoint;
                    if (!series[0] || !series[0].points) {
                        return !1
                    }
                    if (!curPoint) {
                        newPoint = next ? series[0].points[0] : lastPoint
                    } else {
                        newSeries = series[curPoint.series.index + (next ? 1 : -1)];
                        newPoint = curPoints[curPointIndex + (next ? 1 : -1)];
                        if (!newPoint && newSeries) {
                            newPoint = newSeries.points[next ? 0 : newSeries.points.length - 1]
                        }
                        if (!newPoint) {
                            return !1
                        }
                    }
                    if (isSkipPoint(newPoint)) {
                        newSeries = newPoint.series;
                        if (isSkipSeries(newSeries)) {
                            chart.highlightedPoint = next ? newSeries.points[newSeries.points.length - 1] : newSeries.points[0]
                        } else {
                            chart.highlightedPoint = newPoint
                        }
                        return chart.highlightAdjacentPoint(next)
                    }
                    return newPoint.highlight()
                }
                function chartHighlightAdjacentPointVertical(down) {
                    const curPoint = this.highlightedPoint;
                    let minDistance = Infinity, bestPoint;
                    if (!defined(curPoint.plotX) || !defined(curPoint.plotY)) {
                        return !1
                    }
                    this.series.forEach( (series) => {
                            if (isSkipSeries(series)) {
                                return
                            }
                            series.points.forEach( (point) => {
                                    if (!defined(point.plotY) || !defined(point.plotX) || point === curPoint) {
                                        return
                                    }
                                    let yDistance = point.plotY - curPoint.plotY;
                                    const width = Math.abs(point.plotX - curPoint.plotX)
                                        , distance = Math.abs(yDistance) * Math.abs(yDistance) + width * width * 4;
                                    if (series.yAxis && series.yAxis.reversed) {
                                        yDistance *= -1
                                    }
                                    if (yDistance <= 0 && down || yDistance >= 0 && !down || distance < 5 || isSkipPoint(point)) {
                                        return
                                    }
                                    if (distance < minDistance) {
                                        minDistance = distance;
                                        bestPoint = point
                                    }
                                }
                            )
                        }
                    );
                    return bestPoint ? bestPoint.highlight() : !1
                }
                function chartHighlightAdjacentSeries(down) {
                    const chart = this
                        , curPoint = chart.highlightedPoint
                        , lastSeries = chart.series && chart.series[chart.series.length - 1]
                        , lastPoint = lastSeries && lastSeries.points && lastSeries.points[lastSeries.points.length - 1];
                    let newSeries, newPoint, adjacentNewPoint;
                    if (!chart.highlightedPoint) {
                        newSeries = down ? (chart.series && chart.series[0]) : lastSeries;
                        newPoint = down ? (newSeries && newSeries.points && newSeries.points[0]) : lastPoint;
                        return newPoint ? newPoint.highlight() : !1
                    }
                    newSeries = (chart.series[curPoint.series.index + (down ? -1 : 1)]);
                    if (!newSeries) {
                        return !1
                    }
                    newPoint = getClosestPoint(curPoint, newSeries, 4);
                    if (!newPoint) {
                        return !1
                    }
                    if (isSkipSeries(newSeries)) {
                        newPoint.highlight();
                        adjacentNewPoint = chart.highlightAdjacentSeries(down);
                        if (!adjacentNewPoint) {
                            curPoint.highlight();
                            return !1
                        }
                        return adjacentNewPoint
                    }
                    newPoint.highlight();
                    return newPoint.series.highlightNextValidPoint()
                }
                function compose(ChartClass, PointClass, SeriesClass) {
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.highlightAdjacentPoint = chartHighlightAdjacentPoint;
                        chartProto.highlightAdjacentPointVertical = (chartHighlightAdjacentPointVertical);
                        chartProto.highlightAdjacentSeries = chartHighlightAdjacentSeries
                    }
                    if (U.pushUnique(composedMembers, PointClass)) {
                        const pointProto = PointClass.prototype;
                        pointProto.highlight = pointHighlight
                    }
                    if (U.pushUnique(composedMembers, SeriesClass)) {
                        const seriesProto = SeriesClass.prototype;
                        seriesProto.keyboardMoveVertical = !0;
                        ['column', 'gantt', 'pie'].forEach( (type) => {
                                if (seriesTypes[type]) {
                                    seriesTypes[type].prototype.keyboardMoveVertical = !1
                                }
                            }
                        );
                        seriesProto.highlightNextValidPoint = (seriesHighlightNextValidPoint)
                    }
                }
                SeriesKeyboardNavigation.compose = compose;
                function getClosestPoint(point, series, xWeight, yWeight) {
                    let minDistance = Infinity, dPoint, minIx, distance, i = series.points.length;
                    const hasUndefinedPosition = (point) => (!(defined(point.plotX) && defined(point.plotY)));
                    if (hasUndefinedPosition(point)) {
                        return
                    }
                    while (i--) {
                        dPoint = series.points[i];
                        if (hasUndefinedPosition(dPoint)) {
                            continue
                        }
                        distance = (point.plotX - dPoint.plotX) * (point.plotX - dPoint.plotX) * (xWeight || 1) + (point.plotY - dPoint.plotY) * (point.plotY - dPoint.plotY) * (yWeight || 1);
                        if (distance < minDistance) {
                            minDistance = distance;
                            minIx = i
                        }
                    }
                    return defined(minIx) ? series.points[minIx] : void 0
                }
                function pointHighlight(highlightVisually=!0) {
                    const chart = this.series.chart
                        , tooltipElement = chart.tooltip?.label?.element;
                    if (!this.isNull && highlightVisually) {
                        this.onMouseOver()
                    } else {
                        if (chart.tooltip) {
                            chart.tooltip.hide(0)
                        }
                    }
                    scrollAxisToPoint(this);
                    if (this.graphic) {
                        chart.setFocusToElement(this.graphic);
                        if (!highlightVisually && chart.focusElement) {
                            chart.focusElement.removeFocusBorder()
                        }
                    }
                    chart.highlightedPoint = this;
                    const tooltipTop = tooltipElement?.getBoundingClientRect().top;
                    if (tooltipElement && tooltipTop && tooltipTop < 0) {
                        const scrollTop = window.scrollY
                            , newScrollTop = scrollTop + tooltipTop;
                        window.scrollTo({
                            behavior: 'smooth',
                            top: newScrollTop
                        })
                    }
                    return this
                }
                function seriesHighlightNextValidPoint() {
                    const curPoint = this.chart.highlightedPoint
                        , start = (curPoint && curPoint.series) === this ? getPointIndex(curPoint) : 0
                        , points = this.points
                        , len = points.length;
                    if (points && len) {
                        for (let i = start; i < len; ++i) {
                            if (!isSkipPoint(points[i])) {
                                return points[i].highlight()
                            }
                        }
                        for (let j = start; j >= 0; --j) {
                            if (!isSkipPoint(points[j])) {
                                return points[j].highlight()
                            }
                        }
                    }
                    return !1
                }
            }
        )(SeriesKeyboardNavigation || (SeriesKeyboardNavigation = {}));
        return SeriesKeyboardNavigation
    });
    _registerModule(_modules, 'Accessibility/Components/SeriesComponent/SeriesComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Components/SeriesComponent/ForcedMarkers.js'], _modules['Accessibility/Components/SeriesComponent/NewDataAnnouncer.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js'], _modules['Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js']], function(AccessibilityComponent, ChartUtilities, ForcedMarkers, NewDataAnnouncer, SeriesDescriber, SeriesKeyboardNavigation) {
        const {hideSeriesFromAT} = ChartUtilities;
        const {describeSeries} = SeriesDescriber;
        class SeriesComponent extends AccessibilityComponent {
            static compose(ChartClass, PointClass, SeriesClass) {
                NewDataAnnouncer.compose(SeriesClass);
                ForcedMarkers.compose(SeriesClass);
                SeriesKeyboardNavigation.compose(ChartClass, PointClass, SeriesClass)
            }
            init() {
                this.newDataAnnouncer = new NewDataAnnouncer(this.chart);
                this.newDataAnnouncer.init();
                this.keyboardNavigation = new SeriesKeyboardNavigation(this.chart,this.keyCodes);
                this.keyboardNavigation.init();
                this.hideTooltipFromATWhenShown();
                this.hideSeriesLabelsFromATWhenShown()
            }
            hideTooltipFromATWhenShown() {
                const component = this;
                if (this.chart.tooltip) {
                    this.addEvent(this.chart.tooltip.constructor, 'refresh', function() {
                        if (this.chart === component.chart && this.label && this.label.element) {
                            this.label.element.setAttribute('aria-hidden', !0)
                        }
                    })
                }
            }
            hideSeriesLabelsFromATWhenShown() {
                this.addEvent(this.chart, 'afterDrawSeriesLabels', function() {
                    this.series.forEach(function(series) {
                        if (series.labelBySeries) {
                            series.labelBySeries.attr('aria-hidden', !0)
                        }
                    })
                })
            }
            onChartRender() {
                const chart = this.chart;
                chart.series.forEach(function(series) {
                    const shouldDescribeSeries = (series.options.accessibility && series.options.accessibility.enabled) !== !1 && series.visible;
                    if (shouldDescribeSeries) {
                        describeSeries(series)
                    } else {
                        hideSeriesFromAT(series)
                    }
                })
            }
            getKeyboardNavigation() {
                return this.keyboardNavigation.getKeyboardNavigationHandler()
            }
            destroy() {
                this.newDataAnnouncer.destroy();
                this.keyboardNavigation.destroy()
            }
        }
        return SeriesComponent
    });
    _registerModule(_modules, 'Accessibility/Components/ZoomComponent.js', [_modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Core/Utilities.js']], function(AccessibilityComponent, CU, HU, KeyboardNavigationHandler, U) {
        const {unhideChartElementFromAT} = CU;
        const {getFakeMouseEvent} = HU;
        const {attr, pick} = U;
        function chartHasMapZoom(chart) {
            return !!((chart.mapView) && chart.mapNavigation && chart.mapNavigation.navButtons.length)
        }
        class ZoomComponent extends AccessibilityComponent {
            constructor() {
                super(...arguments);
                this.focusedMapNavButtonIx = -1
            }
            init() {
                const component = this
                    , chart = this.chart;
                this.proxyProvider.addGroup('zoom', 'div');
                ['afterShowResetZoom', 'afterApplyDrilldown', 'drillupall'].forEach( (eventType) => {
                        component.addEvent(chart, eventType, function() {
                            component.updateProxyOverlays()
                        })
                    }
                )
            }
            onChartUpdate() {
                const chart = this.chart
                    , component = this;
                if (chart.mapNavigation) {
                    chart.mapNavigation.navButtons.forEach( (button, i) => {
                            unhideChartElementFromAT(chart, button.element);
                            component.setMapNavButtonAttrs(button.element, 'accessibility.zoom.mapZoom' + (i ? 'Out' : 'In'))
                        }
                    )
                }
            }
            setMapNavButtonAttrs(button, labelFormatKey) {
                const chart = this.chart
                    , label = chart.langFormat(labelFormatKey, {
                    chart: chart
                });
                attr(button, {
                    tabindex: -1,
                    role: 'button',
                    'aria-label': label
                })
            }
            onChartRender() {
                this.updateProxyOverlays()
            }
            updateProxyOverlays() {
                const chart = this.chart;
                this.proxyProvider.clearGroup('zoom');
                if (chart.resetZoomButton) {
                    this.createZoomProxyButton(chart.resetZoomButton, 'resetZoomProxyButton', chart.langFormat('accessibility.zoom.resetZoomButton', {
                        chart: chart
                    }))
                }
                if (chart.drillUpButton && chart.breadcrumbs && chart.breadcrumbs.list) {
                    const lastBreadcrumb = chart.breadcrumbs.list[chart.breadcrumbs.list.length - 1];
                    this.createZoomProxyButton(chart.drillUpButton, 'drillUpProxyButton', chart.langFormat('accessibility.drillUpButton', {
                        chart: chart,
                        buttonText: chart.breadcrumbs.getButtonText(lastBreadcrumb)
                    }))
                }
            }
            createZoomProxyButton(buttonEl, buttonProp, label) {
                this[buttonProp] = this.proxyProvider.addProxyElement('zoom', {
                    click: buttonEl
                }, 'button', {
                    'aria-label': label,
                    tabindex: -1
                })
            }
            getMapZoomNavigation() {
                const keys = this.keyCodes
                    , chart = this.chart
                    , component = this;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[[keys.up, keys.down, keys.left, keys.right], function(keyCode) {
                        return component.onMapKbdArrow(this, keyCode)
                    }
                    ], [[keys.tab], function(_keyCode, e) {
                        return component.onMapKbdTab(this, e)
                    }
                    ], [[keys.space, keys.enter], function() {
                        return component.onMapKbdClick(this)
                    }
                    ]],
                    validate: function() {
                        return chartHasMapZoom(chart)
                    },
                    init: function(direction) {
                        return component.onMapNavInit(direction)
                    }
                })
            }
            onMapKbdArrow(keyboardNavigationHandler, keyCode) {
                const chart = this.chart
                    , keys = this.keyCodes
                    , target = chart.container
                    , isY = keyCode === keys.up || keyCode === keys.down
                    , stepDirection = (keyCode === keys.left || keyCode === keys.up) ? 1 : -1
                    , granularity = 10
                    , diff = (isY ? chart.plotHeight : chart.plotWidth) / granularity * stepDirection
                    , r = Math.random() * 10
                    , startPos = {
                    x: target.offsetLeft + chart.plotLeft + chart.plotWidth / 2 + r,
                    y: target.offsetTop + chart.plotTop + chart.plotHeight / 2 + r
                }
                    , endPos = isY ? {
                    x: startPos.x,
                    y: startPos.y + diff
                } : {
                    x: startPos.x + diff,
                    y: startPos.y
                };
                [getFakeMouseEvent('mousedown', startPos), getFakeMouseEvent('mousemove', endPos), getFakeMouseEvent('mouseup', endPos)].forEach( (e) => target.dispatchEvent(e));
                return keyboardNavigationHandler.response.success
            }
            onMapKbdTab(keyboardNavigationHandler, event) {
                const chart = this.chart;
                const response = keyboardNavigationHandler.response;
                const isBackwards = event.shiftKey;
                const isMoveOutOfRange = isBackwards && !this.focusedMapNavButtonIx || !isBackwards && this.focusedMapNavButtonIx;
                chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(0);
                if (isMoveOutOfRange) {
                    if (chart.mapView) {
                        chart.mapView.zoomBy()
                    }
                    return response[isBackwards ? 'prev' : 'next']
                }
                this.focusedMapNavButtonIx += isBackwards ? -1 : 1;
                const button = chart.mapNavigation.navButtons[this.focusedMapNavButtonIx];
                chart.setFocusToElement(button.box, button.element);
                button.setState(2);
                return response.success
            }
            onMapKbdClick(keyboardNavigationHandler) {
                const el = this.chart.mapNavigation.navButtons[this.focusedMapNavButtonIx].element;
                this.fakeClickEvent(el);
                return keyboardNavigationHandler.response.success
            }
            onMapNavInit(direction) {
                const chart = this.chart
                    , zoomIn = chart.mapNavigation.navButtons[0]
                    , zoomOut = chart.mapNavigation.navButtons[1]
                    , initialButton = direction > 0 ? zoomIn : zoomOut;
                chart.setFocusToElement(initialButton.box, initialButton.element);
                initialButton.setState(2);
                this.focusedMapNavButtonIx = direction > 0 ? 0 : 1
            }
            simpleButtonNavigation(buttonProp, proxyProp, onClick) {
                const keys = this.keyCodes
                    , component = this
                    , chart = this.chart;
                return new KeyboardNavigationHandler(chart,{
                    keyCodeMap: [[[keys.tab, keys.up, keys.down, keys.left, keys.right], function(keyCode, e) {
                        const isBackwards = (keyCode === keys.tab && e.shiftKey || keyCode === keys.left || keyCode === keys.up);
                        return this.response[isBackwards ? 'prev' : 'next']
                    }
                    ], [[keys.space, keys.enter], function() {
                        const res = onClick(this, chart);
                        return pick(res, this.response.success)
                    }
                    ]],
                    validate: function() {
                        const hasButton = (chart[buttonProp] && chart[buttonProp].box && component[proxyProp].innerElement);
                        return hasButton
                    },
                    init: function() {
                        chart.setFocusToElement(chart[buttonProp].box, component[proxyProp].innerElement)
                    }
                })
            }
            getKeyboardNavigation() {
                return [this.simpleButtonNavigation('resetZoomButton', 'resetZoomProxyButton', function(_handler, chart) {
                    chart.zoomOut()
                }), this.simpleButtonNavigation('drillUpButton', 'drillUpProxyButton', function(handler, chart) {
                    chart.drillUp();
                    return handler.response.prev
                }), this.getMapZoomNavigation()]
            }
        }
        return ZoomComponent
    });
    _registerModule(_modules, 'Accessibility/HighContrastMode.js', [_modules['Core/Globals.js']], function(H) {
        const {doc, isMS, win} = H;
        function isHighContrastModeActive() {
            const isEdge = /(Edg)/.test(win.navigator.userAgent);
            if (win.matchMedia && isEdge) {
                return win.matchMedia('(-ms-high-contrast: active)').matches
            }
            if (isMS && win.getComputedStyle) {
                const testDiv = doc.createElement('div');
                const imageSrc = 'data:image/gif;base64,' + 'R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
                testDiv.style.backgroundImage = `url(${imageSrc})`;
                doc.body.appendChild(testDiv);
                const bi = (testDiv.currentStyle || win.getComputedStyle(testDiv)).backgroundImage;
                doc.body.removeChild(testDiv);
                return bi === 'none'
            }
            return win.matchMedia && win.matchMedia('(forced-colors: active)').matches
        }
        function setHighContrastTheme(chart) {
            chart.highContrastModeActive = !0;
            const theme = (chart.options.accessibility.highContrastTheme);
            chart.update(theme, !1);
            chart.series.forEach(function(s) {
                const plotOpts = theme.plotOptions[s.type] || {};
                s.update({
                    color: plotOpts.color || 'windowText',
                    colors: [plotOpts.color || 'windowText'],
                    borderColor: plotOpts.borderColor || 'window'
                });
                s.points.forEach(function(p) {
                    if (p.options && p.options.color) {
                        p.update({
                            color: plotOpts.color || 'windowText',
                            borderColor: plotOpts.borderColor || 'window'
                        }, !1)
                    }
                })
            });
            chart.redraw()
        }
        const whcm = {
            isHighContrastModeActive,
            setHighContrastTheme
        };
        return whcm
    });
    _registerModule(_modules, 'Accessibility/HighContrastTheme.js', [], function() {
        const theme = {
            chart: {
                backgroundColor: 'window'
            },
            title: {
                style: {
                    color: 'windowText'
                }
            },
            subtitle: {
                style: {
                    color: 'windowText'
                }
            },
            colorAxis: {
                minColor: 'windowText',
                maxColor: 'windowText',
                stops: []
            },
            colors: ['windowText'],
            xAxis: {
                gridLineColor: 'windowText',
                labels: {
                    style: {
                        color: 'windowText'
                    }
                },
                lineColor: 'windowText',
                minorGridLineColor: 'windowText',
                tickColor: 'windowText',
                title: {
                    style: {
                        color: 'windowText'
                    }
                }
            },
            yAxis: {
                gridLineColor: 'windowText',
                labels: {
                    style: {
                        color: 'windowText'
                    }
                },
                lineColor: 'windowText',
                minorGridLineColor: 'windowText',
                tickColor: 'windowText',
                title: {
                    style: {
                        color: 'windowText'
                    }
                }
            },
            tooltip: {
                backgroundColor: 'window',
                borderColor: 'windowText',
                style: {
                    color: 'windowText'
                }
            },
            plotOptions: {
                series: {
                    lineColor: 'windowText',
                    fillColor: 'window',
                    borderColor: 'windowText',
                    edgeColor: 'windowText',
                    borderWidth: 1,
                    dataLabels: {
                        connectorColor: 'windowText',
                        color: 'windowText',
                        style: {
                            color: 'windowText',
                            textOutline: 'none'
                        }
                    },
                    marker: {
                        lineColor: 'windowText',
                        fillColor: 'windowText'
                    }
                },
                pie: {
                    color: 'window',
                    colors: ['window'],
                    borderColor: 'windowText',
                    borderWidth: 1
                },
                boxplot: {
                    fillColor: 'window'
                },
                candlestick: {
                    lineColor: 'windowText',
                    fillColor: 'window'
                },
                errorbar: {
                    fillColor: 'window'
                }
            },
            legend: {
                backgroundColor: 'window',
                itemStyle: {
                    color: 'windowText'
                },
                itemHoverStyle: {
                    color: 'windowText'
                },
                itemHiddenStyle: {
                    color: '#555'
                },
                title: {
                    style: {
                        color: 'windowText'
                    }
                }
            },
            credits: {
                style: {
                    color: 'windowText'
                }
            },
            drilldown: {
                activeAxisLabelStyle: {
                    color: 'windowText'
                },
                activeDataLabelStyle: {
                    color: 'windowText'
                }
            },
            navigation: {
                buttonOptions: {
                    symbolStroke: 'windowText',
                    theme: {
                        fill: 'window'
                    }
                }
            },
            rangeSelector: {
                buttonTheme: {
                    fill: 'window',
                    stroke: 'windowText',
                    style: {
                        color: 'windowText'
                    },
                    states: {
                        hover: {
                            fill: 'window',
                            stroke: 'windowText',
                            style: {
                                color: 'windowText'
                            }
                        },
                        select: {
                            fill: '#444',
                            stroke: 'windowText',
                            style: {
                                color: 'windowText'
                            }
                        }
                    }
                },
                inputBoxBorderColor: 'windowText',
                inputStyle: {
                    backgroundColor: 'window',
                    color: 'windowText'
                },
                labelStyle: {
                    color: 'windowText'
                }
            },
            navigator: {
                handles: {
                    backgroundColor: 'window',
                    borderColor: 'windowText'
                },
                outlineColor: 'windowText',
                maskFill: 'transparent',
                series: {
                    color: 'windowText',
                    lineColor: 'windowText'
                },
                xAxis: {
                    gridLineColor: 'windowText'
                }
            },
            scrollbar: {
                barBackgroundColor: '#444',
                barBorderColor: 'windowText',
                buttonArrowColor: 'windowText',
                buttonBackgroundColor: 'window',
                buttonBorderColor: 'windowText',
                rifleColor: 'windowText',
                trackBackgroundColor: 'window',
                trackBorderColor: 'windowText'
            }
        };
        return theme
    });
    _registerModule(_modules, 'Accessibility/Options/A11yDefaults.js', [], function() {
        const Options = {
            accessibility: {
                enabled: !0,
                screenReaderSection: {
                    beforeChartFormat: '<{headingTagName}>{chartTitle}</{headingTagName}>' + '<div>{typeDescription}</div>' + '<div>{chartSubtitle}</div>' + '<div>{chartLongdesc}</div>' + '<div>{playAsSoundButton}</div>' + '<div>{viewTableButton}</div>' + '<div>{xAxisDescription}</div>' + '<div>{yAxisDescription}</div>' + '<div>{annotationsTitle}{annotationsList}</div>',
                    afterChartFormat: '{endOfChartMarker}',
                    axisRangeDateFormat: '%Y-%m-%d %H:%M:%S'
                },
                series: {
                    descriptionFormat: '{seriesDescription}{authorDescription}{axisDescription}',
                    describeSingleSeries: !1,
                    pointDescriptionEnabledThreshold: 200
                },
                point: {
                    valueDescriptionFormat: '{xDescription}{separator}{value}.',
                    describeNull: !0
                },
                landmarkVerbosity: 'all',
                linkedDescription: '*[data-highcharts-chart="{index}"] + .highcharts-description',
                keyboardNavigation: {
                    enabled: !0,
                    focusBorder: {
                        enabled: !0,
                        hideBrowserFocusOutline: !0,
                        style: {
                            color: "#334eff",
                            lineWidth: 2,
                            borderRadius: 3
                        },
                        margin: 2
                    },
                    order: ['series', 'zoom', 'rangeSelector', 'navigator', 'legend', 'chartMenu'],
                    wrapAround: !0,
                    seriesNavigation: {
                        skipNullPoints: !0,
                        pointNavigationEnabledThreshold: !1,
                        rememberPointFocus: !1
                    }
                },
                announceNewData: {
                    enabled: !1,
                    minAnnounceInterval: 5000,
                    interruptUser: !1
                }
            },
            legend: {
                accessibility: {
                    enabled: !0,
                    keyboardNavigation: {
                        enabled: !0
                    }
                }
            },
            exporting: {
                accessibility: {
                    enabled: !0
                }
            },
            navigator: {
                accessibility: {
                    enabled: !0
                }
            }
        };
        return Options
    });
    _registerModule(_modules, 'Accessibility/Options/LangDefaults.js', [], function() {
        const langOptions = {
            accessibility: {
                defaultChartTitle: 'Chart',
                chartContainerLabel: '{title}. Highcharts interactive chart.',
                svgContainerLabel: 'Interactive chart',
                drillUpButton: '{buttonText}',
                credits: 'Chart credits: {creditsStr}',
                thousandsSep: ',',
                svgContainerTitle: '',
                graphicContainerLabel: '',
                screenReaderSection: {
                    beforeRegionLabel: '',
                    afterRegionLabel: '',
                    annotations: {
                        heading: 'Chart annotations summary',
                        descriptionSinglePoint: ('{annotationText}. Related to {annotationPoint}'),
                        descriptionMultiplePoints: ('{annotationText}. Related to {annotationPoint}' + '{#each additionalAnnotationPoints}' + ', also related to {this}' + '{/each}'),
                        descriptionNoPoints: '{annotationText}'
                    },
                    endOfChartMarker: 'End of interactive chart.'
                },
                sonification: {
                    playAsSoundButtonText: 'Play as sound, {chartTitle}',
                    playAsSoundClickAnnouncement: 'Play'
                },
                legend: {
                    legendLabelNoTitle: 'Toggle series visibility, {chartTitle}',
                    legendLabel: 'Chart legend: {legendTitle}',
                    legendItem: 'Show {itemName}'
                },
                zoom: {
                    mapZoomIn: 'Zoom chart',
                    mapZoomOut: 'Zoom out chart',
                    resetZoomButton: 'Reset zoom'
                },
                rangeSelector: {
                    dropdownLabel: '{rangeTitle}',
                    minInputLabel: 'Select start date.',
                    maxInputLabel: 'Select end date.',
                    clickButtonAnnouncement: 'Viewing {axisRangeDescription}'
                },
                navigator: {
                    handleLabel: '{#eq handleIx 0}Start, percent{else}End, percent{/eq}',
                    groupLabel: 'Axis zoom',
                    changeAnnouncement: '{axisRangeDescription}'
                },
                table: {
                    viewAsDataTableButtonText: 'View as data table, {chartTitle}',
                    tableSummary: 'Table representation of chart.'
                },
                announceNewData: {
                    newDataAnnounce: 'Updated data for chart {chartTitle}',
                    newSeriesAnnounceSingle: 'New data series: {seriesDesc}',
                    newPointAnnounceSingle: 'New data point: {pointDesc}',
                    newSeriesAnnounceMultiple: 'New data series in chart {chartTitle}: {seriesDesc}',
                    newPointAnnounceMultiple: 'New data point in chart {chartTitle}: {pointDesc}'
                },
                seriesTypeDescriptions: {
                    boxplot: 'Box plot charts are typically used to display ' + 'groups of statistical data. Each data point in the ' + 'chart can have up to 5 values: minimum, lower quartile, ' + 'median, upper quartile, and maximum.',
                    arearange: 'Arearange charts are line charts displaying a ' + 'range between a lower and higher value for each point.',
                    areasplinerange: 'These charts are line charts displaying a ' + 'range between a lower and higher value for each point.',
                    bubble: 'Bubble charts are scatter charts where each data ' + 'point also has a size value.',
                    columnrange: 'Columnrange charts are column charts ' + 'displaying a range between a lower and higher value for ' + 'each point.',
                    errorbar: 'Errorbar series are used to display the ' + 'variability of the data.',
                    funnel: 'Funnel charts are used to display reduction of data ' + 'in stages.',
                    pyramid: 'Pyramid charts consist of a single pyramid with ' + 'item heights corresponding to each point value.',
                    waterfall: 'A waterfall chart is a column chart where each ' + 'column contributes towards a total end value.'
                },
                chartTypes: {
                    emptyChart: 'Empty chart',
                    mapTypeDescription: 'Map of {mapTitle} with {numSeries} data series.',
                    unknownMap: 'Map of unspecified region with {numSeries} data series.',
                    combinationChart: 'Combination chart with {numSeries} data series.',
                    defaultSingle: 'Chart with {numPoints} data ' + '{#eq numPoints 1}point{else}points{/eq}.',
                    defaultMultiple: 'Chart with {numSeries} data series.',
                    splineSingle: 'Line chart with {numPoints} data ' + '{#eq numPoints 1}point{else}points{/eq}.',
                    splineMultiple: 'Line chart with {numSeries} lines.',
                    lineSingle: 'Line chart with {numPoints} data ' + '{#eq numPoints 1}point{else}points{/eq}.',
                    lineMultiple: 'Line chart with {numSeries} lines.',
                    columnSingle: 'Bar chart with {numPoints} ' + '{#eq numPoints 1}bar{else}bars{/eq}.',
                    columnMultiple: 'Bar chart with {numSeries} data series.',
                    barSingle: 'Bar chart with {numPoints} ' + '{#eq numPoints 1}bar{else}bars{/eq}.',
                    barMultiple: 'Bar chart with {numSeries} data series.',
                    pieSingle: 'Pie chart with {numPoints} ' + '{#eq numPoints 1}slice{else}slices{/eq}.',
                    pieMultiple: 'Pie chart with {numSeries} pies.',
                    scatterSingle: 'Scatter chart with {numPoints} ' + '{#eq numPoints 1}point{else}points{/eq}.',
                    scatterMultiple: 'Scatter chart with {numSeries} data series.',
                    boxplotSingle: 'Boxplot with {numPoints} ' + '{#eq numPoints 1}box{else}boxes{/eq}.',
                    boxplotMultiple: 'Boxplot with {numSeries} data series.',
                    bubbleSingle: 'Bubble chart with {numPoints} ' + '{#eq numPoints 1}bubbles{else}bubble{/eq}.',
                    bubbleMultiple: 'Bubble chart with {numSeries} data series.'
                },
                axis: {
                    xAxisDescriptionSingular: 'The chart has 1 X axis displaying {names[0]}. {ranges[0]}',
                    xAxisDescriptionPlural: 'The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.',
                    yAxisDescriptionSingular: 'The chart has 1 Y axis displaying {names[0]}. {ranges[0]}',
                    yAxisDescriptionPlural: 'The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.',
                    timeRangeDays: 'Data range: {range} days.',
                    timeRangeHours: 'Data range: {range} hours.',
                    timeRangeMinutes: 'Data range: {range} minutes.',
                    timeRangeSeconds: 'Data range: {range} seconds.',
                    rangeFromTo: 'Data ranges from {rangeFrom} to {rangeTo}.',
                    rangeCategories: 'Data range: {numCategories} categories.'
                },
                exporting: {
                    chartMenuLabel: 'Chart menu',
                    menuButtonLabel: 'View chart menu, {chartTitle}'
                },
                series: {
                    summary: {
                        'default': '{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        defaultCombination: '{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        line: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        lineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        spline: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        splineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        column: '{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',
                        columnCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',
                        bar: '{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',
                        barCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.',
                        pie: '{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.',
                        pieCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.',
                        scatter: '{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.',
                        scatterCombination: '{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.',
                        boxplot: '{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.',
                        boxplotCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.',
                        bubble: '{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.',
                        bubbleCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.',
                        map: '{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.',
                        mapCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.',
                        mapline: '{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        maplineCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.',
                        mapbubble: '{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.',
                        mapbubbleCombination: '{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.'
                    },
                    description: '{description}',
                    xAxisDescription: 'X axis, {name}',
                    yAxisDescription: 'Y axis, {name}',
                    nullPointValue: 'No value',
                    pointAnnotationsDescription: '{#each annotations}' + 'Annotation: {this}{/each}'
                }
            }
        };
        return langOptions
    });
    _registerModule(_modules, 'Accessibility/Options/DeprecatedOptions.js', [_modules['Core/Utilities.js']], function(U) {
        const {error, pick} = U;
        function traverseSetOption(root, optionAsArray, val) {
            let opt = root, prop, i = 0;
            for (; i < optionAsArray.length - 1; ++i) {
                prop = optionAsArray[i];
                opt = opt[prop] = pick(opt[prop], {})
            }
            opt[optionAsArray[optionAsArray.length - 1]] = val
        }
        function deprecateFromOptionsMap(chart, rootOldAsArray, rootNewAsArray, mapToNewOptions) {
            function getChildProp(root, propAsArray) {
                return propAsArray.reduce(function(acc, cur) {
                    return acc[cur]
                }, root)
            }
            const rootOld = getChildProp(chart.options, rootOldAsArray)
                , rootNew = getChildProp(chart.options, rootNewAsArray);
            Object.keys(mapToNewOptions).forEach(function(oldOptionKey) {
                const val = rootOld[oldOptionKey];
                if (typeof val !== 'undefined') {
                    traverseSetOption(rootNew, mapToNewOptions[oldOptionKey], val);
                    error(32, !1, chart, {
                        [rootOldAsArray.join('.') + '.' + oldOptionKey]: (rootNewAsArray.join('.') + '.' + mapToNewOptions[oldOptionKey].join('.'))
                    })
                }
            })
        }
        function copyDeprecatedChartOptions(chart) {
            const chartOptions = chart.options.chart
                , a11yOptions = chart.options.accessibility || {};
            ['description', 'typeDescription'].forEach(function(prop) {
                if (chartOptions[prop]) {
                    a11yOptions[prop] = chartOptions[prop];
                    error(32, !1, chart, {
                        [`chart.${prop}`]: `use accessibility.${prop}`
                    })
                }
            })
        }
        function copyDeprecatedAxisOptions(chart) {
            chart.axes.forEach(function(axis) {
                const opts = axis.options;
                if (opts && opts.description) {
                    opts.accessibility = opts.accessibility || {};
                    opts.accessibility.description = opts.description;
                    error(32, !1, chart, {
                        'axis.description': 'use axis.accessibility.description'
                    })
                }
            })
        }
        function copyDeprecatedSeriesOptions(chart) {
            const oldToNewSeriesOptions = {
                description: ['accessibility', 'description'],
                exposeElementToA11y: ['accessibility', 'exposeAsGroupOnly'],
                pointDescriptionFormatter: ['accessibility', 'point', 'descriptionFormatter'],
                skipKeyboardNavigation: ['accessibility', 'keyboardNavigation', 'enabled'],
                'accessibility.pointDescriptionFormatter': ['accessibility', 'point', 'descriptionFormatter']
            };
            chart.series.forEach(function(series) {
                Object.keys(oldToNewSeriesOptions).forEach(function(oldOption) {
                    let optionVal = series.options[oldOption];
                    if (oldOption === 'accessibility.pointDescriptionFormatter') {
                        optionVal = (series.options.accessibility && series.options.accessibility.pointDescriptionFormatter)
                    }
                    if (typeof optionVal !== 'undefined') {
                        traverseSetOption(series.options, oldToNewSeriesOptions[oldOption], oldOption === 'skipKeyboardNavigation' ? !optionVal : optionVal);
                        error(32, !1, chart, {
                            [`series.${oldOption}`]: ('series.' + oldToNewSeriesOptions[oldOption].join('.'))
                        })
                    }
                })
            })
        }
        function copyDeprecatedTopLevelAccessibilityOptions(chart) {
            deprecateFromOptionsMap(chart, ['accessibility'], ['accessibility'], {
                pointDateFormat: ['point', 'dateFormat'],
                pointDateFormatter: ['point', 'dateFormatter'],
                pointDescriptionFormatter: ['point', 'descriptionFormatter'],
                pointDescriptionThreshold: ['series', 'pointDescriptionEnabledThreshold'],
                pointNavigationThreshold: ['keyboardNavigation', 'seriesNavigation', 'pointNavigationEnabledThreshold'],
                pointValueDecimals: ['point', 'valueDecimals'],
                pointValuePrefix: ['point', 'valuePrefix'],
                pointValueSuffix: ['point', 'valueSuffix'],
                screenReaderSectionFormatter: ['screenReaderSection', 'beforeChartFormatter'],
                describeSingleSeries: ['series', 'describeSingleSeries'],
                seriesDescriptionFormatter: ['series', 'descriptionFormatter'],
                onTableAnchorClick: ['screenReaderSection', 'onViewDataTableClick'],
                axisRangeDateFormat: ['screenReaderSection', 'axisRangeDateFormat']
            })
        }
        function copyDeprecatedKeyboardNavigationOptions(chart) {
            deprecateFromOptionsMap(chart, ['accessibility', 'keyboardNavigation'], ['accessibility', 'keyboardNavigation', 'seriesNavigation'], {
                skipNullPoints: ['skipNullPoints'],
                mode: ['mode']
            })
        }
        function copyDeprecatedLangOptions(chart) {
            deprecateFromOptionsMap(chart, ['lang', 'accessibility'], ['lang', 'accessibility'], {
                legendItem: ['legend', 'legendItem'],
                legendLabel: ['legend', 'legendLabel'],
                mapZoomIn: ['zoom', 'mapZoomIn'],
                mapZoomOut: ['zoom', 'mapZoomOut'],
                resetZoomButton: ['zoom', 'resetZoomButton'],
                screenReaderRegionLabel: ['screenReaderSection', 'beforeRegionLabel'],
                rangeSelectorButton: ['rangeSelector', 'buttonText'],
                rangeSelectorMaxInput: ['rangeSelector', 'maxInputLabel'],
                rangeSelectorMinInput: ['rangeSelector', 'minInputLabel'],
                svgContainerEnd: ['screenReaderSection', 'endOfChartMarker'],
                viewAsDataTable: ['table', 'viewAsDataTableButtonText'],
                tableSummary: ['table', 'tableSummary']
            })
        }
        function copyDeprecatedOptions(chart) {
            copyDeprecatedChartOptions(chart);
            copyDeprecatedAxisOptions(chart);
            if (chart.series) {
                copyDeprecatedSeriesOptions(chart)
            }
            copyDeprecatedTopLevelAccessibilityOptions(chart);
            copyDeprecatedKeyboardNavigationOptions(chart);
            copyDeprecatedLangOptions(chart)
        }
        return copyDeprecatedOptions
    });
    _registerModule(_modules, 'Accessibility/Accessibility.js', [_modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/A11yI18n.js'], _modules['Accessibility/Components/ContainerComponent.js'], _modules['Accessibility/FocusBorder.js'], _modules['Accessibility/Components/InfoRegionsComponent.js'], _modules['Accessibility/KeyboardNavigation.js'], _modules['Accessibility/Components/LegendComponent.js'], _modules['Accessibility/Components/MenuComponent.js'], _modules['Accessibility/Components/NavigatorComponent.js'], _modules['Accessibility/Components/SeriesComponent/NewDataAnnouncer.js'], _modules['Accessibility/ProxyProvider.js'], _modules['Accessibility/Components/RangeSelectorComponent.js'], _modules['Accessibility/Components/SeriesComponent/SeriesComponent.js'], _modules['Accessibility/Components/ZoomComponent.js'], _modules['Accessibility/HighContrastMode.js'], _modules['Accessibility/HighContrastTheme.js'], _modules['Accessibility/Options/A11yDefaults.js'], _modules['Accessibility/Options/LangDefaults.js'], _modules['Accessibility/Options/DeprecatedOptions.js']], function(D, H, U, HU, A11yI18n, ContainerComponent, FocusBorder, InfoRegionsComponent, KeyboardNavigation, LegendComponent, MenuComponent, NavigatorComponent, NewDataAnnouncer, ProxyProvider, RangeSelectorComponent, SeriesComponent, ZoomComponent, whcm, highContrastTheme, defaultOptionsA11Y, defaultLangOptions, copyDeprecatedOptions) {
        const {defaultOptions} = D;
        const {doc} = H;
        const {addEvent, extend, fireEvent, merge} = U;
        const {removeElement} = HU;
        class Accessibility {
            constructor(chart) {
                this.chart = void 0;
                this.components = void 0;
                this.keyboardNavigation = void 0;
                this.proxyProvider = void 0;
                this.init(chart)
            }
            init(chart) {
                this.chart = chart;
                if (!doc.addEventListener) {
                    this.zombie = !0;
                    this.components = {};
                    chart.renderTo.setAttribute('aria-hidden', !0);
                    return
                }
                copyDeprecatedOptions(chart);
                this.proxyProvider = new ProxyProvider(this.chart);
                this.initComponents();
                this.keyboardNavigation = new KeyboardNavigation(chart,this.components)
            }
            initComponents() {
                const chart = this.chart;
                const proxyProvider = this.proxyProvider;
                const a11yOptions = chart.options.accessibility;
                this.components = {
                    container: new ContainerComponent(),
                    infoRegions: new InfoRegionsComponent(),
                    legend: new LegendComponent(),
                    chartMenu: new MenuComponent(),
                    rangeSelector: new RangeSelectorComponent(),
                    series: new SeriesComponent(),
                    zoom: new ZoomComponent(),
                    navigator: new NavigatorComponent()
                };
                if (a11yOptions.customComponents) {
                    extend(this.components, a11yOptions.customComponents)
                }
                const components = this.components;
                this.getComponentOrder().forEach(function(componentName) {
                    components[componentName].initBase(chart, proxyProvider);
                    components[componentName].init()
                })
            }
            getComponentOrder() {
                if (!this.components) {
                    return []
                }
                if (!this.components.series) {
                    return Object.keys(this.components)
                }
                const componentsExceptSeries = Object.keys(this.components).filter( (c) => c !== 'series');
                return ['series'].concat(componentsExceptSeries)
            }
            update() {
                const components = this.components
                    , chart = this.chart
                    , a11yOptions = chart.options.accessibility;
                fireEvent(chart, 'beforeA11yUpdate');
                chart.types = this.getChartTypes();
                const kbdNavOrder = a11yOptions.keyboardNavigation.order;
                this.proxyProvider.updateGroupOrder(kbdNavOrder);
                this.getComponentOrder().forEach(function(componentName) {
                    components[componentName].onChartUpdate();
                    fireEvent(chart, 'afterA11yComponentUpdate', {
                        name: componentName,
                        component: components[componentName]
                    })
                });
                this.keyboardNavigation.update(kbdNavOrder);
                if (!chart.highContrastModeActive && whcm.isHighContrastModeActive()) {
                    whcm.setHighContrastTheme(chart)
                }
                fireEvent(chart, 'afterA11yUpdate', {
                    accessibility: this
                })
            }
            destroy() {
                const chart = this.chart || {};
                const components = this.components;
                Object.keys(components).forEach(function(componentName) {
                    components[componentName].destroy();
                    components[componentName].destroyBase()
                });
                if (this.proxyProvider) {
                    this.proxyProvider.destroy()
                }
                if (chart.announcerContainer) {
                    removeElement(chart.announcerContainer)
                }
                if (this.keyboardNavigation) {
                    this.keyboardNavigation.destroy()
                }
                if (chart.renderTo) {
                    chart.renderTo.setAttribute('aria-hidden', !0)
                }
                if (chart.focusElement) {
                    chart.focusElement.removeFocusBorder()
                }
            }
            getChartTypes() {
                const types = {};
                this.chart.series.forEach(function(series) {
                    types[series.type] = 1
                });
                return Object.keys(types)
            }
        }
        (function(Accessibility) {
                const composedMembers = [];
                Accessibility.i18nFormat = A11yI18n.i18nFormat;
                function chartOnDestroy() {
                    if (this.accessibility) {
                        this.accessibility.destroy()
                    }
                }
                function chartOnRender() {
                    if (this.a11yDirty && this.renderTo) {
                        delete this.a11yDirty;
                        this.updateA11yEnabled()
                    }
                    const a11y = this.accessibility;
                    if (a11y && !a11y.zombie) {
                        a11y.proxyProvider.updateProxyElementPositions();
                        a11y.getComponentOrder().forEach(function(componentName) {
                            a11y.components[componentName].onChartRender()
                        })
                    }
                }
                function chartOnUpdate(e) {
                    const newOptions = e.options.accessibility;
                    if (newOptions) {
                        if (newOptions.customComponents) {
                            this.options.accessibility.customComponents = newOptions.customComponents;
                            delete newOptions.customComponents
                        }
                        merge(!0, this.options.accessibility, newOptions);
                        if (this.accessibility && this.accessibility.destroy) {
                            this.accessibility.destroy();
                            delete this.accessibility
                        }
                    }
                    this.a11yDirty = !0
                }
                function chartUpdateA11yEnabled() {
                    let a11y = this.accessibility;
                    const accessibilityOptions = this.options.accessibility;
                    if (accessibilityOptions && accessibilityOptions.enabled) {
                        if (a11y && !a11y.zombie) {
                            a11y.update()
                        } else {
                            this.accessibility = a11y = new Accessibility(this);
                            if (a11y && !a11y.zombie) {
                                a11y.update()
                            }
                        }
                    } else if (a11y) {
                        if (a11y.destroy) {
                            a11y.destroy()
                        }
                        delete this.accessibility
                    } else {
                        this.renderTo.setAttribute('aria-hidden', !0)
                    }
                }
                function compose(ChartClass, LegendClass, PointClass, SeriesClass, SVGElementClass, RangeSelectorClass) {
                    KeyboardNavigation.compose(ChartClass);
                    NewDataAnnouncer.compose(SeriesClass);
                    LegendComponent.compose(ChartClass, LegendClass);
                    MenuComponent.compose(ChartClass);
                    SeriesComponent.compose(ChartClass, PointClass, SeriesClass);
                    A11yI18n.compose(ChartClass);
                    FocusBorder.compose(ChartClass, SVGElementClass);
                    if (RangeSelectorClass) {
                        RangeSelectorComponent.compose(ChartClass, RangeSelectorClass)
                    }
                    if (U.pushUnique(composedMembers, ChartClass)) {
                        const chartProto = ChartClass.prototype;
                        chartProto.updateA11yEnabled = chartUpdateA11yEnabled;
                        addEvent(ChartClass, 'destroy', chartOnDestroy);
                        addEvent(ChartClass, 'render', chartOnRender);
                        addEvent(ChartClass, 'update', chartOnUpdate);
                        ['addSeries', 'init'].forEach( (event) => {
                                addEvent(ChartClass, event, function() {
                                    this.a11yDirty = !0
                                })
                            }
                        );
                        ['afterApplyDrilldown', 'drillupall'].forEach( (event) => {
                                addEvent(ChartClass, event, function chartOnAfterDrilldown() {
                                    const a11y = this.accessibility;
                                    if (a11y && !a11y.zombie) {
                                        a11y.update()
                                    }
                                })
                            }
                        )
                    }
                    if (U.pushUnique(composedMembers, PointClass)) {
                        addEvent(PointClass, 'update', pointOnUpdate)
                    }
                    if (U.pushUnique(composedMembers, SeriesClass)) {
                        ['update', 'updatedData', 'remove'].forEach( (event) => {
                                addEvent(SeriesClass, event, function() {
                                    if (this.chart.accessibility) {
                                        this.chart.a11yDirty = !0
                                    }
                                })
                            }
                        )
                    }
                }
                Accessibility.compose = compose;
                function pointOnUpdate() {
                    if (this.series.chart.accessibility) {
                        this.series.chart.a11yDirty = !0
                    }
                }
            }
        )(Accessibility || (Accessibility = {}));
        merge(!0, defaultOptions, defaultOptionsA11Y, {
            accessibility: {
                highContrastTheme: highContrastTheme
            },
            lang: defaultLangOptions
        });
        return Accessibility
    });
    _registerModule(_modules, 'masters/modules/accessibility.src.js', [_modules['Core/Globals.js'], _modules['Accessibility/Accessibility.js'], _modules['Accessibility/AccessibilityComponent.js'], _modules['Accessibility/Utils/ChartUtilities.js'], _modules['Accessibility/Utils/HTMLUtilities.js'], _modules['Accessibility/KeyboardNavigationHandler.js'], _modules['Accessibility/Components/SeriesComponent/SeriesDescriber.js']], function(Highcharts, Accessibility, AccessibilityComponent, ChartUtilities, HTMLUtilities, KeyboardNavigationHandler, SeriesDescriber) {
        const G = Highcharts;
        G.i18nFormat = Accessibility.i18nFormat;
        G.A11yChartUtilities = ChartUtilities;
        G.A11yHTMLUtilities = HTMLUtilities;
        G.AccessibilityComponent = AccessibilityComponent;
        G.KeyboardNavigationHandler = KeyboardNavigationHandler;
        G.SeriesAccessibilityDescriber = SeriesDescriber;
        Accessibility.compose(G.Chart, G.Legend, G.Point, G.Series, G.SVGElement, G.RangeSelector)
    })
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Sankey diagram module
 *
 * (c) 2010-2021 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/sankey', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Series/NodesComposition.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(SeriesRegistry, U) {
        const {series: {prototype: seriesProto, prototype: {pointClass: {prototype: pointProto}}}} = SeriesRegistry;
        const {defined, extend, find, merge, pick} = U;
        var NodesComposition;
        (function(NodesComposition) {
                const composedMembers = [];
                function compose(PointClass, SeriesClass) {
                    if (U.pushUnique(composedMembers, PointClass)) {
                        const pointProto = PointClass.prototype;
                        pointProto.setNodeState = setNodeState;
                        pointProto.setState = setNodeState;
                        pointProto.update = updateNode
                    }
                    if (U.pushUnique(composedMembers, SeriesClass)) {
                        const seriesProto = SeriesClass.prototype;
                        seriesProto.destroy = destroy;
                        seriesProto.setData = setData
                    }
                    return SeriesClass
                }
                NodesComposition.compose = compose;
                function createNode(id) {
                    const PointClass = this.pointClass
                        , findById = (nodes, id) => find(nodes, (node) => node.id === id);
                    let node = findById(this.nodes, id), options;
                    if (!node) {
                        options = this.options.nodes && findById(this.options.nodes, id);
                        const newNode = (new PointClass()).init(this, extend({
                            className: 'highcharts-node',
                            isNode: !0,
                            id: id,
                            y: 1
                        }, options));
                        newNode.linksTo = [];
                        newNode.linksFrom = [];
                        newNode.getSum = function() {
                            let sumTo = 0
                                , sumFrom = 0;
                            newNode.linksTo.forEach( (link) => {
                                    sumTo += link.weight || 0
                                }
                            );
                            newNode.linksFrom.forEach( (link) => {
                                    sumFrom += link.weight || 0
                                }
                            );
                            return Math.max(sumTo, sumFrom)
                        }
                        ;
                        newNode.offset = function(point, coll) {
                            let offset = 0;
                            for (let i = 0; i < newNode[coll].length; i++) {
                                if (newNode[coll][i] === point) {
                                    return offset
                                }
                                offset += newNode[coll][i].weight
                            }
                        }
                        ;
                        newNode.hasShape = function() {
                            let outgoing = 0;
                            newNode.linksTo.forEach( (link) => {
                                    if (link.outgoing) {
                                        outgoing++
                                    }
                                }
                            );
                            return (!newNode.linksTo.length || outgoing !== newNode.linksTo.length)
                        }
                        ;
                        newNode.index = this.nodes.push(newNode) - 1;
                        node = newNode
                    }
                    node.formatPrefix = 'node';
                    node.name = node.name || node.options.id || '';
                    node.mass = pick(node.options.mass, node.options.marker && node.options.marker.radius, this.options.marker && this.options.marker.radius, 4);
                    return node
                }
                NodesComposition.createNode = createNode;
                function destroy() {
                    this.data = [].concat(this.points || [], this.nodes);
                    return seriesProto.destroy.apply(this, arguments)
                }
                NodesComposition.destroy = destroy;
                function generatePoints() {
                    const chart = this.chart
                        , nodeLookup = {};
                    seriesProto.generatePoints.call(this);
                    if (!this.nodes) {
                        this.nodes = []
                    }
                    this.colorCounter = 0;
                    this.nodes.forEach( (node) => {
                            node.linksFrom.length = 0;
                            node.linksTo.length = 0;
                            node.level = node.options.level
                        }
                    );
                    this.points.forEach( (point) => {
                            if (defined(point.from)) {
                                if (!nodeLookup[point.from]) {
                                    nodeLookup[point.from] = this.createNode(point.from)
                                }
                                nodeLookup[point.from].linksFrom.push(point);
                                point.fromNode = nodeLookup[point.from];
                                if (chart.styledMode) {
                                    point.colorIndex = pick(point.options.colorIndex, nodeLookup[point.from].colorIndex)
                                } else {
                                    point.color = point.options.color || nodeLookup[point.from].color
                                }
                            }
                            if (defined(point.to)) {
                                if (!nodeLookup[point.to]) {
                                    nodeLookup[point.to] = this.createNode(point.to)
                                }
                                nodeLookup[point.to].linksTo.push(point);
                                point.toNode = nodeLookup[point.to]
                            }
                            point.name = point.name || point.id
                        }
                        , this);
                    this.nodeLookup = nodeLookup
                }
                NodesComposition.generatePoints = generatePoints;
                function setData() {
                    if (this.nodes) {
                        this.nodes.forEach( (node) => {
                                node.destroy()
                            }
                        );
                        this.nodes.length = 0
                    }
                    seriesProto.setData.apply(this, arguments)
                }
                function setNodeState(state) {
                    const args = arguments
                        , others = this.isNode ? this.linksTo.concat(this.linksFrom) : [this.fromNode, this.toNode];
                    if (state !== 'select') {
                        others.forEach( (linkOrNode) => {
                                if (linkOrNode && linkOrNode.series) {
                                    pointProto.setState.apply(linkOrNode, args);
                                    if (!linkOrNode.isNode) {
                                        if (linkOrNode.fromNode.graphic) {
                                            pointProto.setState.apply(linkOrNode.fromNode, args)
                                        }
                                        if (linkOrNode.toNode && linkOrNode.toNode.graphic) {
                                            pointProto.setState.apply(linkOrNode.toNode, args)
                                        }
                                    }
                                }
                            }
                        )
                    }
                    pointProto.setState.apply(this, args)
                }
                NodesComposition.setNodeState = setNodeState;
                function updateNode(options, redraw, animation, runEvent) {
                    const nodes = this.series.options.nodes
                        , data = this.series.options.data
                        , dataLength = data && data.length || 0
                        , linkConfig = data && data[this.index];
                    pointProto.update.call(this, options, this.isNode ? !1 : redraw, animation, runEvent);
                    if (this.isNode) {
                        const nodeIndex = (nodes || []).reduce( (prevIndex, n, index) => (this.id === n.id ? index : prevIndex), -1)
                            , nodeConfig = merge(nodes && nodes[nodeIndex] || {}, data && data[this.index] || {});
                        if (data) {
                            if (linkConfig) {
                                data[this.index] = linkConfig
                            } else {
                                data.length = dataLength
                            }
                        }
                        if (nodes) {
                            if (nodeIndex >= 0) {
                                nodes[nodeIndex] = nodeConfig
                            } else {
                                nodes.push(nodeConfig)
                            }
                        } else {
                            this.series.options.nodes = [nodeConfig]
                        }
                        if (pick(redraw, !0)) {
                            this.series.chart.redraw(animation)
                        }
                    }
                }
                NodesComposition.updateNode = updateNode
            }
        )(NodesComposition || (NodesComposition = {}));
        return NodesComposition
    });
    _registerModule(_modules, 'Series/Sankey/SankeyPoint.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(Point, SeriesRegistry, U) {
        const {column: ColumnSeries} = SeriesRegistry.seriesTypes;
        const {defined} = U;
        class SankeyPoint extends ColumnSeries.prototype.pointClass {
            constructor() {
                super(...arguments);
                this.className = void 0;
                this.fromNode = void 0;
                this.level = void 0;
                this.linkBase = void 0;
                this.linkColorMode = void 0;
                this.linksFrom = void 0;
                this.linksTo = void 0;
                this.mass = void 0;
                this.nodeX = void 0;
                this.nodeY = void 0;
                this.options = void 0;
                this.series = void 0;
                this.toNode = void 0
            }
            applyOptions(options, x) {
                Point.prototype.applyOptions.call(this, options, x);
                if (defined(this.options.level)) {
                    this.options.column = this.column = this.options.level
                }
                return this
            }
            getClassName() {
                return (this.isNode ? 'highcharts-node ' : 'highcharts-link ') + Point.prototype.getClassName.call(this)
            }
            getFromNode() {
                const node = this;
                let fromColumn = -1, fromNode;
                for (let i = 0; i < node.linksTo.length; i++) {
                    const point = node.linksTo[i];
                    if (point.fromNode.column > fromColumn && point.fromNode !== node) {
                        fromNode = point.fromNode;
                        fromColumn = fromNode.column
                    }
                }
                return {
                    fromNode,
                    fromColumn
                }
            }
            setNodeColumn() {
                const node = this;
                if (!defined(node.options.column)) {
                    if (node.linksTo.length === 0) {
                        node.column = 0
                    } else {
                        node.column = node.getFromNode().fromColumn + 1
                    }
                }
            }
            isValid() {
                return this.isNode || typeof this.weight === 'number'
            }
        }
        return SankeyPoint
    });
    _registerModule(_modules, 'Series/Sankey/SankeySeriesDefaults.js', [], function() {
        const SankeySeriesDefaults = {
            borderWidth: 0,
            colorByPoint: !0,
            curveFactor: 0.33,
            dataLabels: {
                enabled: !0,
                backgroundColor: 'none',
                crop: !1,
                nodeFormat: void 0,
                nodeFormatter: function() {
                    return this.point.name
                },
                format: void 0,
                formatter: function() {
                    return
                },
                inside: !0
            },
            inactiveOtherPoints: !0,
            linkColorMode: 'from',
            linkOpacity: 0.5,
            opacity: 1,
            minLinkWidth: 0,
            nodeAlignment: 'center',
            nodeWidth: 20,
            nodePadding: 10,
            showInLegend: !1,
            states: {
                hover: {
                    linkOpacity: 1,
                    opacity: 1
                },
                inactive: {
                    linkOpacity: 0.1,
                    opacity: 0.1,
                    animation: {
                        duration: 50
                    }
                }
            },
            tooltip: {
                followPointer: !0,
                headerFormat: '<span style="font-size: 0.8em">{series.name}</span><br/>',
                pointFormat: '{point.fromNode.name} \u2192 {point.toNode.name}: <b>{point.weight}</b><br/>',
                nodeFormat: '{point.name}: <b>{point.sum}</b><br/>'
            }
        };
        '';
        return SankeySeriesDefaults
    });
    _registerModule(_modules, 'Series/Sankey/SankeyColumnComposition.js', [_modules['Core/Utilities.js']], function(U) {
        const {defined, pushUnique, relativeLength} = U;
        var SankeyColumnComposition;
        (function(SankeyColumnComposition) {
                function compose(points, series) {
                    const sankeyColumnArray = points;
                    sankeyColumnArray.sankeyColumn = new SankeyColumnAdditions(sankeyColumnArray,series);
                    return sankeyColumnArray
                }
                SankeyColumnComposition.compose = compose;
                class SankeyColumnAdditions {
                    constructor(points, series) {
                        this.points = points;
                        this.series = series
                    }
                    getTranslationFactor(series) {
                        const column = this.points
                            , nodes = column.slice()
                            , chart = series.chart
                            , minLinkWidth = series.options.minLinkWidth || 0;
                        let skipPoint, factor = 0, i, remainingHeight = ((chart.plotSizeY || 0) - (series.options.borderWidth || 0) - (column.length - 1) * series.nodePadding);
                        while (column.length) {
                            factor = remainingHeight / column.sankeyColumn.sum();
                            skipPoint = !1;
                            i = column.length;
                            while (i--) {
                                if (column[i].getSum() * factor < minLinkWidth) {
                                    column.splice(i, 1);
                                    remainingHeight = Math.max(0, remainingHeight - minLinkWidth);
                                    skipPoint = !0
                                }
                            }
                            if (!skipPoint) {
                                break
                            }
                        }
                        column.length = 0;
                        for (const node of nodes) {
                            column.push(node)
                        }
                        return factor
                    }
                    top(factor) {
                        const series = this.series
                            , nodePadding = series.nodePadding
                            , height = this.points.reduce( (height, node) => {
                                if (height > 0) {
                                    height += nodePadding
                                }
                                const nodeHeight = Math.max(node.getSum() * factor, series.options.minLinkWidth || 0);
                                height += nodeHeight;
                                return height
                            }
                            , 0);
                        return {
                            top: 0,
                            center: 0.5,
                            bottom: 1
                        }[series.options.nodeAlignment || 'center'] * ((series.chart.plotSizeY || 0) - height)
                    }
                    left(factor) {
                        const series = this.series
                            , chart = series.chart
                            , equalNodes = series.options.equalNodes
                            , maxNodesLength = (chart.inverted ? chart.plotHeight : chart.plotWidth)
                            , nodePadding = series.nodePadding
                            , width = this.points.reduce( (width, node) => {
                                if (width > 0) {
                                    width += nodePadding
                                }
                                const nodeWidth = equalNodes ? maxNodesLength / node.series.nodes.length - nodePadding : Math.max(node.getSum() * factor, series.options.minLinkWidth || 0);
                                width += nodeWidth;
                                return width
                            }
                            , 0);
                        return ((chart.plotSizeX || 0) - Math.round(width)) / 2
                    }
                    sum() {
                        return this.points.reduce( (sum, node) => (sum + node.getSum()), 0)
                    }
                    offset(node, factor) {
                        const column = this.points
                            , series = this.series
                            , nodePadding = series.nodePadding;
                        let offset = 0, totalNodeOffset;
                        if (series.is('organization') && node.hangsFrom) {
                            return {
                                absoluteTop: node.hangsFrom.nodeY
                            }
                        }
                        for (let i = 0; i < column.length; i++) {
                            const sum = column[i].getSum();
                            const height = Math.max(sum * factor, series.options.minLinkWidth || 0);
                            const directionOffset = node.options[series.chart.inverted ? 'offsetHorizontal' : 'offsetVertical']
                                , optionOffset = node.options.offset || 0;
                            if (sum) {
                                totalNodeOffset = height + nodePadding
                            } else {
                                totalNodeOffset = 0
                            }
                            if (column[i] === node) {
                                return {
                                    relativeTop: offset + (defined(directionOffset) ? relativeLength(directionOffset, height) : relativeLength(optionOffset, totalNodeOffset))
                                }
                            }
                            offset += totalNodeOffset
                        }
                    }
                }
                SankeyColumnComposition.SankeyColumnAdditions = SankeyColumnAdditions
            }
        )(SankeyColumnComposition || (SankeyColumnComposition = {}));
        return SankeyColumnComposition
    });
    _registerModule(_modules, 'Series/TreeUtilities.js', [_modules['Core/Color/Color.js'], _modules['Core/Utilities.js']], function(Color, U) {
        const {extend, isArray, isNumber, isObject, merge, pick} = U;
        function getColor(node, options) {
            const index = options.index
                , mapOptionsToLevel = options.mapOptionsToLevel
                , parentColor = options.parentColor
                , parentColorIndex = options.parentColorIndex
                , series = options.series
                , colors = options.colors
                , siblings = options.siblings
                , points = series.points
                , chartOptionsChart = series.chart.options.chart;
            let getColorByPoint, point, level, colorByPoint, colorIndexByPoint, color, colorIndex;
            const variateColor = (color) => {
                    const colorVariation = level && level.colorVariation;
                    if (colorVariation && colorVariation.key === 'brightness' && index && siblings) {
                        return Color.parse(color).brighten(colorVariation.to * (index / siblings)).get()
                    }
                    return color
                }
            ;
            if (node) {
                point = points[node.i];
                level = mapOptionsToLevel[node.level] || {};
                getColorByPoint = point && level.colorByPoint;
                if (getColorByPoint) {
                    colorIndexByPoint = point.index % (colors ? colors.length : chartOptionsChart.colorCount);
                    colorByPoint = colors && colors[colorIndexByPoint]
                }
                if (!series.chart.styledMode) {
                    color = pick(point && point.options.color, level && level.color, colorByPoint, parentColor && variateColor(parentColor), series.color)
                }
                colorIndex = pick(point && point.options.colorIndex, level && level.colorIndex, colorIndexByPoint, parentColorIndex, options.colorIndex)
            }
            return {
                color: color,
                colorIndex: colorIndex
            }
        }
        function getLevelOptions(params) {
            let result = {}, defaults, converted, i, from, to, levels;
            if (isObject(params)) {
                from = isNumber(params.from) ? params.from : 1;
                levels = params.levels;
                converted = {};
                defaults = isObject(params.defaults) ? params.defaults : {};
                if (isArray(levels)) {
                    converted = levels.reduce( (obj, item) => {
                            let level, levelIsConstant, options;
                            if (isObject(item) && isNumber(item.level)) {
                                options = merge({}, item);
                                levelIsConstant = pick(options.levelIsConstant, defaults.levelIsConstant);
                                delete options.levelIsConstant;
                                delete options.level;
                                level = item.level + (levelIsConstant ? 0 : from - 1);
                                if (isObject(obj[level])) {
                                    merge(!0, obj[level], options)
                                } else {
                                    obj[level] = options
                                }
                            }
                            return obj
                        }
                        , {})
                }
                to = isNumber(params.to) ? params.to : 1;
                for (i = 0; i <= to; i++) {
                    result[i] = merge({}, defaults, isObject(converted[i]) ? converted[i] : {})
                }
            }
            return result
        }
        function setTreeValues(tree, options) {
            const before = options.before
                , idRoot = options.idRoot
                , mapIdToNode = options.mapIdToNode
                , nodeRoot = mapIdToNode[idRoot]
                , levelIsConstant = (options.levelIsConstant !== !1)
                , points = options.points
                , point = points[tree.i]
                , optionsPoint = point && point.options || {}
                , children = [];
            let childrenTotal = 0;
            tree.levelDynamic = tree.level - (levelIsConstant ? 0 : nodeRoot.level);
            tree.name = pick(point && point.name, '');
            tree.visible = (idRoot === tree.id || options.visible === !0);
            if (typeof before === 'function') {
                tree = before(tree, options)
            }
            tree.children.forEach( (child, i) => {
                    const newOptions = extend({}, options);
                    extend(newOptions, {
                        index: i,
                        siblings: tree.children.length,
                        visible: tree.visible
                    });
                    child = setTreeValues(child, newOptions);
                    children.push(child);
                    if (child.visible) {
                        childrenTotal += child.val
                    }
                }
            );
            const value = pick(optionsPoint.value, childrenTotal);
            tree.visible = value >= 0 && (childrenTotal > 0 || tree.visible);
            tree.children = children;
            tree.childrenTotal = childrenTotal;
            tree.isLeaf = tree.visible && !childrenTotal;
            tree.val = value;
            return tree
        }
        function updateRootId(series) {
            let rootId, options;
            if (isObject(series)) {
                options = isObject(series.options) ? series.options : {};
                rootId = pick(series.rootNode, options.rootId, '');
                if (isObject(series.userOptions)) {
                    series.userOptions.rootId = rootId
                }
                series.rootNode = rootId
            }
            return rootId
        }
        const TreeUtilities = {
            getColor,
            getLevelOptions,
            setTreeValues,
            updateRootId
        };
        return TreeUtilities
    });
    _registerModule(_modules, 'Series/Sankey/SankeySeries.js', [_modules['Core/Globals.js'], _modules['Series/NodesComposition.js'], _modules['Series/Sankey/SankeyPoint.js'], _modules['Series/Sankey/SankeySeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/Sankey/SankeyColumnComposition.js'], _modules['Core/Color/Color.js'], _modules['Series/TreeUtilities.js'], _modules['Core/Utilities.js']], function(H, NodesComposition, SankeyPoint, SankeySeriesDefaults, SeriesRegistry, SankeyColumnComposition, Color, TU, U) {
        const {column: ColumnSeries, line: LineSeries} = SeriesRegistry.seriesTypes;
        const {parse: color} = Color;
        const {getLevelOptions} = TU;
        const {clamp, extend, isObject, merge, pick, relativeLength, stableSort} = U;
        class SankeySeries extends ColumnSeries {
            constructor() {
                super(...arguments);
                this.colDistance = void 0;
                this.data = void 0;
                this.group = void 0;
                this.nodeLookup = void 0;
                this.nodePadding = void 0;
                this.nodes = void 0;
                this.nodeWidth = void 0;
                this.options = void 0;
                this.points = void 0;
                this.translationFactor = void 0
            }
            static getDLOptions(params) {
                const optionsPoint = (isObject(params.optionsPoint) ? params.optionsPoint.dataLabels : {})
                    , optionsLevel = (isObject(params.level) ? params.level.dataLabels : {})
                    , options = merge({
                    style: {}
                }, optionsLevel, optionsPoint);
                return options
            }
            createNodeColumns() {
                const columns = [];
                for (const node of this.nodes) {
                    node.setNodeColumn();
                    if (!columns[node.column]) {
                        columns[node.column] = SankeyColumnComposition.compose([], this)
                    }
                    columns[node.column].push(node)
                }
                for (let i = 0; i < columns.length; i++) {
                    if (typeof columns[i] === 'undefined') {
                        columns[i] = SankeyColumnComposition.compose([], this)
                    }
                }
                return columns
            }
            order(node, level) {
                const series = this;
                if (typeof node.level === 'undefined') {
                    node.level = level;
                    for (const link of node.linksFrom) {
                        if (link.toNode) {
                            series.order(link.toNode, level + 1)
                        }
                    }
                }
            }
            generatePoints() {
                NodesComposition.generatePoints.apply(this, arguments);
                if (this.orderNodes) {
                    for (const node of this.nodes) {
                        if (node.linksTo.length === 0) {
                            this.order(node, 0)
                        }
                    }
                    stableSort(this.nodes, (a, b) => (a.level - b.level))
                }
            }
            getNodePadding() {
                let nodePadding = this.options.nodePadding || 0;
                if (this.nodeColumns) {
                    const maxLength = this.nodeColumns.reduce( (acc, col) => Math.max(acc, col.length), 0);
                    if (maxLength * nodePadding > this.chart.plotSizeY) {
                        nodePadding = this.chart.plotSizeY / maxLength
                    }
                }
                return nodePadding
            }
            hasData() {
                return !!this.processedXData.length
            }
            pointAttribs(point, state) {
                if (!point) {
                    return {}
                }
                const series = this
                    , level = point.isNode ? point.level : point.fromNode.level
                    , levelOptions = series.mapOptionsToLevel[level || 0] || {}
                    , options = point.options
                    , stateOptions = (levelOptions.states && levelOptions.states[state || '']) || {}
                    , values = ['colorByPoint', 'borderColor', 'borderWidth', 'linkOpacity', 'opacity'].reduce( (obj, key) => {
                        obj[key] = pick(stateOptions[key], options[key], levelOptions[key], series.options[key]);
                        return obj
                    }
                    , {})
                    , color = pick(stateOptions.color, options.color, values.colorByPoint ? point.color : levelOptions.color);
                if (point.isNode) {
                    return {
                        fill: color,
                        stroke: values.borderColor,
                        'stroke-width': values.borderWidth,
                        opacity: values.opacity
                    }
                }
                return {
                    fill: Color.parse(color).setOpacity(values.linkOpacity).get()
                }
            }
            drawTracker() {
                ColumnSeries.prototype.drawTracker.call(this, this.points);
                ColumnSeries.prototype.drawTracker.call(this, this.nodes)
            }
            drawPoints() {
                ColumnSeries.prototype.drawPoints.call(this, this.points);
                ColumnSeries.prototype.drawPoints.call(this, this.nodes)
            }
            drawDataLabels() {
                ColumnSeries.prototype.drawDataLabels.call(this, this.points);
                ColumnSeries.prototype.drawDataLabels.call(this, this.nodes)
            }
            translate() {
                if (!this.processedXData) {
                    this.processData()
                }
                this.generatePoints();
                this.nodeColumns = this.createNodeColumns();
                this.nodeWidth = relativeLength(this.options.nodeWidth, this.chart.plotSizeX);
                const series = this
                    , chart = this.chart
                    , options = this.options
                    , nodeWidth = this.nodeWidth
                    , nodeColumns = this.nodeColumns;
                this.nodePadding = this.getNodePadding();
                this.translationFactor = nodeColumns.reduce( (translationFactor, column) => Math.min(translationFactor, column.sankeyColumn.getTranslationFactor(series)), Infinity);
                this.colDistance = (chart.plotSizeX - nodeWidth - options.borderWidth) / Math.max(1, nodeColumns.length - 1);
                series.mapOptionsToLevel = getLevelOptions({
                    from: 1,
                    levels: options.levels,
                    to: nodeColumns.length - 1,
                    defaults: {
                        borderColor: options.borderColor,
                        borderRadius: options.borderRadius,
                        borderWidth: options.borderWidth,
                        color: series.color,
                        colorByPoint: options.colorByPoint,
                        levelIsConstant: !0,
                        linkColor: options.linkColor,
                        linkLineWidth: options.linkLineWidth,
                        linkOpacity: options.linkOpacity,
                        states: options.states
                    }
                });
                for (const column of nodeColumns) {
                    for (const node of column) {
                        series.translateNode(node, column)
                    }
                }
                for (const node of this.nodes) {
                    for (const linkPoint of node.linksFrom) {
                        if ((linkPoint.weight || linkPoint.isNull) && linkPoint.to) {
                            series.translateLink(linkPoint);
                            linkPoint.allowShadow = !1
                        }
                    }
                }
            }
            translateLink(point) {
                const getY = (node, fromOrTo) => {
                        const linkTop = (node.offset(point, fromOrTo) * translationFactor);
                        const y = Math.min(node.nodeY + linkTop, node.nodeY + (node.shapeArgs && node.shapeArgs.height || 0) - linkHeight);
                        return y
                    }
                ;
                const fromNode = point.fromNode
                    , toNode = point.toNode
                    , chart = this.chart
                    , {inverted} = chart
                    , translationFactor = this.translationFactor
                    , options = this.options
                    , linkColorMode = pick(point.linkColorMode, options.linkColorMode)
                    , curvy = ((chart.inverted ? -this.colDistance : this.colDistance) * options.curveFactor)
                    , nodeLeft = fromNode.nodeX
                    , right = toNode.nodeX
                    , outgoing = point.outgoing;
                let linkHeight = Math.max(point.weight * translationFactor, this.options.minLinkWidth)
                    , fromY = getY(fromNode, 'linksFrom')
                    , toY = getY(toNode, 'linksTo')
                    , nodeW = this.nodeWidth
                    , straight = right > nodeLeft + nodeW;
                if (chart.inverted) {
                    fromY = chart.plotSizeY - fromY;
                    toY = (chart.plotSizeY || 0) - toY;
                    nodeW = -nodeW;
                    linkHeight = -linkHeight;
                    straight = nodeLeft > right
                }
                point.shapeType = 'path';
                point.linkBase = [fromY, fromY + linkHeight, toY, toY + linkHeight];
                if (straight && typeof toY === 'number') {
                    point.shapeArgs = {
                        d: [['M', nodeLeft + nodeW, fromY], ['C', nodeLeft + nodeW + curvy, fromY, right - curvy, toY, right, toY], ['L', right + (outgoing ? nodeW : 0), toY + linkHeight / 2], ['L', right, toY + linkHeight], ['C', right - curvy, toY + linkHeight, nodeLeft + nodeW + curvy, fromY + linkHeight, nodeLeft + nodeW, fromY + linkHeight], ['Z']]
                    }
                } else if (typeof toY === 'number') {
                    const bend = 20
                        , vDist = chart.plotHeight - fromY - linkHeight
                        , x1 = right - bend - linkHeight
                        , x2 = right - bend
                        , x3 = right
                        , x4 = nodeLeft + nodeW
                        , x5 = x4 + bend
                        , x6 = x5 + linkHeight
                        , fy1 = fromY
                        , fy2 = fromY + linkHeight
                        , fy3 = fy2 + bend
                        , y4 = fy3 + vDist
                        , y5 = y4 + bend
                        , y6 = y5 + linkHeight
                        , ty1 = toY
                        , ty2 = ty1 + linkHeight
                        , ty3 = ty2 + bend
                        , cfy1 = fy2 - linkHeight * 0.7
                        , cy2 = y5 + linkHeight * 0.7
                        , cty1 = ty2 - linkHeight * 0.7
                        , cx1 = x3 - linkHeight * 0.7
                        , cx2 = x4 + linkHeight * 0.7;
                    point.shapeArgs = {
                        d: [['M', x4, fy1], ['C', cx2, fy1, x6, cfy1, x6, fy3], ['L', x6, y4], ['C', x6, cy2, cx2, y6, x4, y6], ['L', x3, y6], ['C', cx1, y6, x1, cy2, x1, y4], ['L', x1, ty3], ['C', x1, cty1, cx1, ty1, x3, ty1], ['L', x3, ty2], ['C', x2, ty2, x2, ty2, x2, ty3], ['L', x2, y4], ['C', x2, y5, x2, y5, x3, y5], ['L', x4, y5], ['C', x5, y5, x5, y5, x5, y4], ['L', x5, fy3], ['C', x5, fy2, x5, fy2, x4, fy2], ['Z']]
                    }
                }
                point.dlBox = {
                    x: nodeLeft + (right - nodeLeft + nodeW) / 2,
                    y: fromY + (toY - fromY) / 2,
                    height: linkHeight,
                    width: 0
                };
                point.tooltipPos = chart.inverted ? [chart.plotSizeY - point.dlBox.y - linkHeight / 2, chart.plotSizeX - point.dlBox.x] : [point.dlBox.x, point.dlBox.y + linkHeight / 2];
                point.y = point.plotY = 1;
                point.x = point.plotX = 1;
                if (!point.options.color) {
                    if (linkColorMode === 'from') {
                        point.color = fromNode.color
                    } else if (linkColorMode === 'to') {
                        point.color = toNode.color
                    } else if (linkColorMode === 'gradient') {
                        const fromColor = color(fromNode.color).get()
                            , toColor = color(toNode.color).get();
                        point.color = {
                            linearGradient: {
                                x1: 1,
                                x2: 0,
                                y1: 0,
                                y2: 0
                            },
                            stops: [[0, inverted ? fromColor : toColor], [1, inverted ? toColor : fromColor]]
                        }
                    }
                }
            }
            translateNode(node, column) {
                const translationFactor = this.translationFactor
                    , chart = this.chart
                    , options = this.options
                    , {borderRadius, borderWidth=0} = options
                    , sum = node.getSum()
                    , nodeHeight = Math.max(Math.round(sum * translationFactor), this.options.minLinkWidth)
                    , nodeWidth = Math.round(this.nodeWidth)
                    , crisp = Math.round(borderWidth) % 2 / 2
                    , nodeOffset = column.sankeyColumn.offset(node, translationFactor)
                    , fromNodeTop = Math.floor(pick(nodeOffset.absoluteTop, (column.sankeyColumn.top(translationFactor) + nodeOffset.relativeTop))) + crisp
                    , left = Math.floor(this.colDistance * node.column + borderWidth / 2) + relativeLength(node.options[chart.inverted ? 'offsetVertical' : 'offsetHorizontal'] || 0, nodeWidth) + crisp
                    , nodeLeft = chart.inverted ? chart.plotSizeX - left : left;
                node.sum = sum;
                if (sum) {
                    node.shapeType = 'roundedRect';
                    node.nodeX = nodeLeft;
                    node.nodeY = fromNodeTop;
                    let x = nodeLeft
                        , y = fromNodeTop
                        , width = node.options.width || options.width || nodeWidth
                        , height = node.options.height || options.height || nodeHeight;
                    const r = clamp(relativeLength((typeof borderRadius === 'object' ? borderRadius.radius : borderRadius || 0), width), 0, nodeHeight / 2);
                    if (chart.inverted) {
                        x = nodeLeft - nodeWidth;
                        y = chart.plotSizeY - fromNodeTop - nodeHeight;
                        width = node.options.height || options.height || nodeWidth;
                        height = node.options.width || options.width || nodeHeight
                    }
                    node.dlOptions = SankeySeries.getDLOptions({
                        level: this.mapOptionsToLevel[node.level],
                        optionsPoint: node.options
                    });
                    node.plotX = 1;
                    node.plotY = 1;
                    node.tooltipPos = chart.inverted ? [chart.plotSizeY - y - height / 2, chart.plotSizeX - x - width / 2] : [x + width / 2, y + height / 2];
                    node.shapeArgs = {
                        x,
                        y,
                        width,
                        height,
                        r,
                        display: node.hasShape() ? '' : 'none'
                    }
                } else {
                    node.dlOptions = {
                        enabled: !1
                    }
                }
            }
        }
        SankeySeries.defaultOptions = merge(ColumnSeries.defaultOptions, SankeySeriesDefaults);
        NodesComposition.compose(SankeyPoint, SankeySeries);
        extend(SankeySeries.prototype, {
            animate: LineSeries.prototype.animate,
            createNode: NodesComposition.createNode,
            forceDL: !0,
            invertible: !0,
            isCartesian: !1,
            orderNodes: !0,
            noSharedTooltip: !0,
            pointArrayMap: ['from', 'to', 'weight'],
            pointClass: SankeyPoint,
            searchPoint: H.noop
        });
        SeriesRegistry.registerSeriesType('sankey', SankeySeries);
        '';
        return SankeySeries
    });
    _registerModule(_modules, 'masters/modules/sankey.src.js', [], function() {})
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * (c) 2009-2021 Sebastian Bochan, Rafal Sebestjanski
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/dumbbell', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Series/AreaRange/AreaRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function(SeriesRegistry, U) {
        const {area: {prototype: {pointClass: AreaPoint, pointClass: {prototype: areaProto}}}} = SeriesRegistry.seriesTypes;
        const {defined, isNumber, merge} = U;
        class AreaRangePoint extends AreaPoint {
            constructor() {
                super(...arguments);
                this.high = void 0;
                this.low = void 0;
                this.options = void 0;
                this.plotX = void 0;
                this.series = void 0
            }
            setState() {
                const prevState = this.state
                    , series = this.series
                    , isPolar = series.chart.polar
                    , seriesOptionsMarker = series.options.marker
                    , seriesDefaultSymbol = series.symbol;
                if (!defined(this.plotHigh)) {
                    this.plotHigh = series.yAxis.toPixels(this.high, !0)
                }
                if (!defined(this.plotLow)) {
                    this.plotLow = this.plotY = series.yAxis.toPixels(this.low, !0)
                }
                series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
                series.stateMarkerGraphic = series.upperStateMarkerGraphic;
                this.graphic = this.graphics && this.graphics[1];
                this.plotY = this.plotHigh;
                if (isPolar && isNumber(this.plotHighX)) {
                    this.plotX = this.plotHighX
                }
                areaProto.setState.apply(this, arguments);
                this.state = prevState;
                this.plotY = this.plotLow;
                this.graphic = this.graphics && this.graphics[0];
                if (isPolar && isNumber(this.plotLowX)) {
                    this.plotX = this.plotLowX
                }
                series.upperStateMarkerGraphic = series.stateMarkerGraphic;
                series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
                series.lowerStateMarkerGraphic = void 0;
                const originalSettings = series.modifyMarkerSettings();
                areaProto.setState.apply(this, arguments);
                series.restoreMarkerSettings(originalSettings)
            }
            haloPath() {
                const isPolar = this.series.chart.polar;
                let path = [];
                this.plotY = this.plotLow;
                if (isPolar && isNumber(this.plotLowX)) {
                    this.plotX = this.plotLowX
                }
                if (this.isInside) {
                    path = areaProto.haloPath.apply(this, arguments)
                }
                this.plotY = this.plotHigh;
                if (isPolar && isNumber(this.plotHighX)) {
                    this.plotX = this.plotHighX
                }
                if (this.isTopInside) {
                    path = path.concat(areaProto.haloPath.apply(this, arguments))
                }
                return path
            }
            isValid() {
                return isNumber(this.low) && isNumber(this.high)
            }
        }
        return AreaRangePoint
    });
    _registerModule(_modules, 'Series/Dumbbell/DumbbellPoint.js', [_modules['Series/AreaRange/AreaRangePoint.js'], _modules['Core/Utilities.js']], function(AreaRangePoint, U) {
        const {extend, pick} = U;
        class DumbbellPoint extends AreaRangePoint {
            constructor() {
                super(...arguments);
                this.series = void 0;
                this.options = void 0;
                this.pointWidth = void 0
            }
            setState() {
                const point = this
                    , series = point.series
                    , chart = series.chart
                    , seriesLowColor = series.options.lowColor
                    , seriesMarker = series.options.marker
                    , seriesLowMarker = series.options.lowMarker
                    , pointOptions = point.options
                    , pointLowColor = pointOptions.lowColor
                    , zoneColor = point.zone && point.zone.color
                    , lowerGraphicColor = pick(pointLowColor, seriesLowMarker?.fillColor, seriesLowColor, pointOptions.color, zoneColor, point.color, series.color);
                let verb = 'attr', upperGraphicColor, origProps;
                this.pointSetState.apply(point, arguments);
                if (!point.state) {
                    verb = 'animate';
                    const [lowerGraphic,upperGraphic] = point.graphics || [];
                    if (lowerGraphic && !chart.styledMode) {
                        lowerGraphic.attr({
                            fill: lowerGraphicColor
                        });
                        if (upperGraphic) {
                            origProps = {
                                y: point.y,
                                zone: point.zone
                            };
                            point.y = point.high;
                            point.zone = point.zone ? point.getZone() : void 0;
                            upperGraphicColor = pick(point.marker ? point.marker.fillColor : void 0, seriesMarker ? seriesMarker.fillColor : void 0, pointOptions.color, point.zone ? point.zone.color : void 0, point.color);
                            upperGraphic.attr({
                                fill: upperGraphicColor
                            });
                            extend(point, origProps)
                        }
                    }
                }
                point.connector?.[verb](series.getConnectorAttribs(point))
            }
            destroy() {
                const point = this;
                if (!point.graphic) {
                    point.graphic = point.connector;
                    point.connector = void 0
                }
                return super.destroy()
            }
        }
        extend(DumbbellPoint.prototype, {
            pointSetState: AreaRangePoint.prototype.setState
        });
        return DumbbellPoint
    });
    _registerModule(_modules, 'Series/Dumbbell/DumbbellSeriesDefaults.js', [], function() {
        const DumbbellSeriesDefaults = {
            trackByArea: !1,
            fillColor: 'none',
            lineWidth: 0,
            pointRange: 1,
            connectorWidth: 1,
            stickyTracking: !1,
            groupPadding: 0.2,
            crisp: !1,
            pointPadding: 0.1,
            lowColor: "#333333",
            states: {
                hover: {
                    lineWidthPlus: 0,
                    connectorWidthPlus: 1,
                    halo: !1
                }
            }
        };
        '';
        return DumbbellSeriesDefaults
    });
    _registerModule(_modules, 'Series/Dumbbell/DumbbellSeries.js', [_modules['Series/Dumbbell/DumbbellPoint.js'], _modules['Series/Dumbbell/DumbbellSeriesDefaults.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Utilities.js']], function(DumbbellPoint, DumbbellSeriesDefaults, H, SeriesRegistry, SVGRenderer, U) {
        const {noop} = H;
        const {arearange: AreaRangeSeries, column: ColumnSeries, columnrange: ColumnRangeSeries} = SeriesRegistry.seriesTypes;
        const {extend, merge, pick} = U;
        class DumbbellSeries extends AreaRangeSeries {
            constructor() {
                super(...arguments);
                this.data = void 0;
                this.options = void 0;
                this.points = void 0;
                this.columnMetrics = void 0
            }
            getConnectorAttribs(point) {
                const series = this
                    , chart = series.chart
                    , pointOptions = point.options
                    , seriesOptions = series.options
                    , xAxis = series.xAxis
                    , yAxis = series.yAxis
                    , connectorWidthPlus = pick(seriesOptions.states && seriesOptions.states.hover && seriesOptions.states.hover.connectorWidthPlus, 1)
                    , dashStyle = pick(pointOptions.dashStyle, seriesOptions.dashStyle)
                    , pxThreshold = yAxis.toPixels(seriesOptions.threshold || 0, !0)
                    , pointHeight = chart.inverted ? yAxis.len - pxThreshold : pxThreshold;
                let connectorWidth = pick(pointOptions.connectorWidth, seriesOptions.connectorWidth), connectorColor = pick(pointOptions.connectorColor, seriesOptions.connectorColor, pointOptions.color, point.zone ? point.zone.color : void 0, point.color), pointTop = pick(point.plotLow, point.plotY), pointBottom = pick(point.plotHigh, pointHeight), origProps;
                if (typeof pointTop !== 'number') {
                    return {}
                }
                if (point.state) {
                    connectorWidth = connectorWidth + connectorWidthPlus
                }
                if (pointTop < 0) {
                    pointTop = 0
                } else if (pointTop >= yAxis.len) {
                    pointTop = yAxis.len
                }
                if (pointBottom < 0) {
                    pointBottom = 0
                } else if (pointBottom >= yAxis.len) {
                    pointBottom = yAxis.len
                }
                if (point.plotX < 0 || point.plotX > xAxis.len) {
                    connectorWidth = 0
                }
                if (point.graphics && point.graphics[1]) {
                    origProps = {
                        y: point.y,
                        zone: point.zone
                    };
                    point.y = point.high;
                    point.zone = point.zone ? point.getZone() : void 0;
                    connectorColor = pick(pointOptions.connectorColor, seriesOptions.connectorColor, pointOptions.color, point.zone ? point.zone.color : void 0, point.color);
                    extend(point, origProps)
                }
                const attribs = {
                    d: SVGRenderer.prototype.crispLine([['M', point.plotX, pointTop], ['L', point.plotX, pointBottom]], connectorWidth, 'ceil')
                };
                if (!chart.styledMode) {
                    attribs.stroke = connectorColor;
                    attribs['stroke-width'] = connectorWidth;
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle
                    }
                }
                return attribs
            }
            drawConnector(point) {
                const series = this
                    , animationLimit = pick(series.options.animationLimit, 250)
                    , verb = point.connector && series.chart.pointCount < animationLimit ? 'animate' : 'attr';
                if (!point.connector) {
                    point.connector = series.chart.renderer.path().addClass('highcharts-lollipop-stem').attr({
                        zIndex: -1
                    }).add(series.group)
                }
                point.connector[verb](this.getConnectorAttribs(point))
            }
            getColumnMetrics() {
                const metrics = ColumnSeries.prototype.getColumnMetrics.apply(this, arguments);
                metrics.offset += metrics.width / 2;
                return metrics
            }
            translate() {
                const series = this
                    , inverted = series.chart.inverted;
                this.setShapeArgs.apply(series);
                this.translatePoint.apply(series, arguments);
                for (const point of series.points) {
                    const {pointWidth, shapeArgs={}, tooltipPos} = point;
                    point.plotX = shapeArgs.x || 0;
                    shapeArgs.x = point.plotX - pointWidth / 2;
                    if (tooltipPos) {
                        if (inverted) {
                            tooltipPos[1] = series.xAxis.len - point.plotX
                        } else {
                            tooltipPos[0] = point.plotX
                        }
                    }
                }
                series.columnMetrics.offset -= series.columnMetrics.width / 2
            }
            drawPoints() {
                const series = this
                    , chart = series.chart
                    , pointLength = series.points.length
                    , seriesLowColor = series.lowColor = series.options.lowColor
                    , seriesLowMarker = series.options.lowMarker;
                let i = 0, lowerGraphicColor, point, zoneColor;
                this.seriesDrawPoints.apply(series, arguments);
                while (i < pointLength) {
                    point = series.points[i];
                    const [lowerGraphic,upperGraphic] = point.graphics || [];
                    series.drawConnector(point);
                    if (upperGraphic) {
                        upperGraphic.element.point = point;
                        upperGraphic.addClass('highcharts-lollipop-high')
                    }
                    (point.connector?.element).point = point;
                    if (lowerGraphic) {
                        zoneColor = point.zone && point.zone.color;
                        lowerGraphicColor = pick(point.options.lowColor, seriesLowMarker?.fillColor, seriesLowColor, point.options.color, zoneColor, point.color, series.color);
                        if (!chart.styledMode) {
                            lowerGraphic.attr({
                                fill: lowerGraphicColor
                            })
                        }
                        lowerGraphic.addClass('highcharts-lollipop-low')
                    }
                    i++
                }
            }
            markerAttribs() {
                const ret = super.markerAttribs.apply(this, arguments);
                ret.x = Math.floor(ret.x || 0);
                ret.y = Math.floor(ret.y || 0);
                return ret
            }
            pointAttribs(point, state) {
                const pointAttribs = super.pointAttribs.apply(this, arguments);
                if (state === 'hover') {
                    delete pointAttribs.fill
                }
                return pointAttribs
            }
            setShapeArgs() {
                ColumnSeries.prototype.translate.apply(this);
                ColumnRangeSeries.prototype.afterColumnTranslate.apply(this)
            }
        }
        DumbbellSeries.defaultOptions = merge(AreaRangeSeries.defaultOptions, DumbbellSeriesDefaults);
        extend(DumbbellSeries.prototype, {
            crispCol: ColumnSeries.prototype.crispCol,
            drawGraph: noop,
            drawTracker: ColumnSeries.prototype.drawTracker,
            pointClass: DumbbellPoint,
            seriesDrawPoints: AreaRangeSeries.prototype.drawPoints,
            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
            translatePoint: AreaRangeSeries.prototype.translate
        });
        SeriesRegistry.registerSeriesType('dumbbell', DumbbellSeries);
        return DumbbellSeries
    });
    _registerModule(_modules, 'masters/modules/dumbbell.src.js', [], function() {})
}));
/**
 * @license Highcharts JS v11.2.0 (2023-10-30)
 *
 * Module for adding patterns and images as point fills.
 *
 * (c) 2010-2021 Highsoft AS
 * Author: Torstein Hønsi, Øystein Moseng
 *
 * License: www.highcharts.com/license
 */
(function(factory) {
    if (typeof module === 'object' && module.exports) {
        factory['default'] = factory;
        module.exports = factory
    } else if (typeof define === 'function' && define.amd) {
        define('highcharts/modules/pattern-fill', ['highcharts'], function(Highcharts) {
            factory(Highcharts);
            factory.Highcharts = Highcharts;
            return factory
        })
    } else {
        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined)
    }
}(function(Highcharts) {
    'use strict';
    var _modules = Highcharts ? Highcharts._modules : {};
    function _registerModule(obj, path, args, fn) {
        if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === 'function') {
                window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded',{
                    detail: {
                        path: path,
                        module: obj[path]
                    }
                }))
            }
        }
    }
    _registerModule(_modules, 'Extensions/PatternFill.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Globals.js'], _modules['Core/Defaults.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/Series.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Utilities.js']], function(A, Chart, H, D, Point, Series, SVGRenderer, U) {
        const {animObject} = A;
        const {getOptions} = D;
        const {addEvent, defined, erase, merge, pick, removeEvent, wrap} = U;
        const patterns = H.patterns = ( () => {
                const patterns = []
                    , colors = getOptions().colors;
                ['M 0 0 L 5 5 M 4.5 -0.5 L 5.5 0.5 M -0.5 4.5 L 0.5 5.5', 'M 0 5 L 5 0 M -0.5 0.5 L 0.5 -0.5 M 4.5 5.5 L 5.5 4.5', 'M 2 0 L 2 5 M 4 0 L 4 5', 'M 0 2 L 5 2 M 0 4 L 5 4', 'M 0 1.5 L 2.5 1.5 L 2.5 0 M 2.5 5 L 2.5 3.5 L 5 3.5'].forEach( (pattern, i) => {
                        patterns.push({
                            path: pattern,
                            color: colors[i],
                            width: 5,
                            height: 5,
                            patternTransform: 'scale(1.4 1.4)'
                        })
                    }
                );
                ['M 0 0 L 5 10 L 10 0', 'M 3 3 L 8 3 L 8 8 L 3 8 Z', 'M 5 5 m -4 0 a 4 4 0 1 1 8 0 a 4 4 0 1 1 -8 0', 'M 0 0 L 10 10 M 9 -1 L 11 1 M -1 9 L 1 11', 'M 0 10 L 10 0 M -1 1 L 1 -1 M 9 11 L 11 9'].forEach( (pattern, i) => {
                        patterns.push({
                            path: pattern,
                            color: colors[i + 5],
                            width: 10,
                            height: 10
                        })
                    }
                );
                return patterns
            }
        )();
        function hashFromObject(obj, preSeed) {
            const str = JSON.stringify(obj)
                , strLen = str.length || 0;
            let hash = 0, i = 0, char, seedStep;
            if (preSeed) {
                seedStep = Math.max(Math.floor(strLen / 500), 1);
                for (let a = 0; a < strLen; a += seedStep) {
                    hash += str.charCodeAt(a)
                }
                hash = hash & hash
            }
            for (; i < strLen; ++i) {
                char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash
            }
            return hash.toString(16).replace('-', '1')
        }
        Point.prototype.calculatePatternDimensions = function(pattern) {
            if (pattern.width && pattern.height) {
                return
            }
            const bBox = this.graphic && (this.graphic.getBBox && this.graphic.getBBox(!0) || this.graphic.element && this.graphic.element.getBBox()) || {}
                , shapeArgs = this.shapeArgs;
            if (shapeArgs) {
                bBox.width = shapeArgs.width || bBox.width;
                bBox.height = shapeArgs.height || bBox.height;
                bBox.x = shapeArgs.x || bBox.x;
                bBox.y = shapeArgs.y || bBox.y
            }
            if (pattern.image) {
                if (!bBox.width || !bBox.height) {
                    pattern._width = 'defer';
                    pattern._height = 'defer';
                    const scaleY = this.series.chart.mapView && this.series.chart.mapView.getSVGTransform().scaleY;
                    if (defined(scaleY) && scaleY < 0) {
                        pattern._inverted = !0
                    }
                    return
                }
                if (pattern.aspectRatio) {
                    bBox.aspectRatio = bBox.width / bBox.height;
                    if (pattern.aspectRatio > bBox.aspectRatio) {
                        bBox.aspectWidth = bBox.height * pattern.aspectRatio
                    } else {
                        bBox.aspectHeight = bBox.width / pattern.aspectRatio
                    }
                }
                pattern._width = pattern.width || Math.ceil(bBox.aspectWidth || bBox.width);
                pattern._height = pattern.height || Math.ceil(bBox.aspectHeight || bBox.height)
            }
            if (!pattern.width) {
                pattern._x = pattern.x || 0;
                pattern._x += bBox.x - Math.round(bBox.aspectWidth ? Math.abs(bBox.aspectWidth - bBox.width) / 2 : 0)
            }
            if (!pattern.height) {
                pattern._y = pattern.y || 0;
                pattern._y += bBox.y - Math.round(bBox.aspectHeight ? Math.abs(bBox.aspectHeight - bBox.height) / 2 : 0)
            }
        }
        ;
        SVGRenderer.prototype.addPattern = function(options, animation) {
            let pattern, animate = pick(animation, !0), animationOptions = animObject(animate), path, defaultSize = 32, width = options.width || options._width || defaultSize, height = (options.height || options._height || defaultSize), color = options.color || '#343434', id = options.id, ren = this, rect = function(fill) {
                ren.rect(0, 0, width, height).attr({
                    fill
                }).add(pattern)
            }, attribs;
            if (!id) {
                this.idCounter = this.idCounter || 0;
                id = ('highcharts-pattern-' + this.idCounter + '-' + (this.chartIndex || 0));
                ++this.idCounter
            }
            if (this.forExport) {
                id += '-export'
            }
            this.defIds = this.defIds || [];
            if (this.defIds.indexOf(id) > -1) {
                return
            }
            this.defIds.push(id);
            const attrs = {
                id: id,
                patternUnits: 'userSpaceOnUse',
                patternContentUnits: options.patternContentUnits || 'userSpaceOnUse',
                width: width,
                height: height,
                x: options._x || options.x || 0,
                y: options._y || options.y || 0
            };
            if (options._inverted) {
                attrs.patternTransform = 'scale(1, -1)';
                if (options.patternTransform) {
                    options.patternTransform += ' scale(1, -1)'
                }
            }
            if (options.patternTransform) {
                attrs.patternTransform = options.patternTransform
            }
            pattern = this.createElement('pattern').attr(attrs).add(this.defs);
            pattern.id = id;
            if (options.path) {
                path = U.isObject(options.path) ? options.path : {
                    d: options.path
                };
                if (options.backgroundColor) {
                    rect(options.backgroundColor)
                }
                attribs = {
                    'd': path.d
                };
                if (!this.styledMode) {
                    attribs.stroke = path.stroke || color;
                    attribs['stroke-width'] = pick(path.strokeWidth, 2);
                    attribs.fill = path.fill || 'none'
                }
                if (path.transform) {
                    attribs.transform = path.transform
                }
                this.createElement('path').attr(attribs).add(pattern);
                pattern.color = color
            } else if (options.image) {
                if (animate) {
                    this.image(options.image, 0, 0, width, height, function() {
                        this.animate({
                            opacity: pick(options.opacity, 1)
                        }, animationOptions);
                        removeEvent(this.element, 'load')
                    }).attr({
                        opacity: 0
                    }).add(pattern)
                } else {
                    this.image(options.image, 0, 0, width, height).add(pattern)
                }
            }
            if (!(options.image && animate) && typeof options.opacity !== 'undefined') {
                [].forEach.call(pattern.element.childNodes, function(child) {
                    child.setAttribute('opacity', options.opacity)
                })
            }
            this.patternElements = this.patternElements || {};
            this.patternElements[id] = pattern;
            return pattern
        }
        ;
        wrap(Series.prototype, 'getColor', function(proceed) {
            const oldColor = this.options.color;
            if (oldColor && oldColor.pattern && !oldColor.pattern.color) {
                delete this.options.color;
                proceed.apply(this, Array.prototype.slice.call(arguments, 1));
                oldColor.pattern.color = this.color;
                this.color = this.options.color = oldColor
            } else {
                proceed.apply(this, Array.prototype.slice.call(arguments, 1))
            }
        });
        addEvent(Series, 'render', function() {
            const isResizing = this.chart.isResizing;
            if (this.isDirtyData || isResizing || !this.chart.hasRendered) {
                (this.points || []).forEach(function(point) {
                    const colorOptions = point.options && point.options.color;
                    if (colorOptions && colorOptions.pattern) {
                        if (isResizing && !(point.shapeArgs && point.shapeArgs.width && point.shapeArgs.height)) {
                            colorOptions.pattern._width = 'defer';
                            colorOptions.pattern._height = 'defer'
                        } else {
                            point.calculatePatternDimensions(colorOptions.pattern)
                        }
                    }
                })
            }
        });
        addEvent(Point, 'afterInit', function() {
            const point = this
                , colorOptions = point.options.color;
            if (colorOptions && colorOptions.pattern) {
                if (typeof colorOptions.pattern.path === 'string') {
                    colorOptions.pattern.path = {
                        d: colorOptions.pattern.path
                    }
                }
                point.color = point.options.color = merge(point.series.options.color, colorOptions)
            }
        });
        addEvent(SVGRenderer, 'complexColor', function(args) {
            const color = args.args[0]
                , prop = args.args[1]
                , element = args.args[2]
                , chartIndex = (this.chartIndex || 0);
            let pattern = color.pattern
                , value = '#343434';
            if (typeof color.patternIndex !== 'undefined' && patterns) {
                pattern = patterns[color.patternIndex]
            }
            if (!pattern) {
                return !0
            }
            if (pattern.image || typeof pattern.path === 'string' || pattern.path && pattern.path.d) {
                let forceHashId = element.parentNode && element.parentNode.getAttribute('class');
                forceHashId = forceHashId && forceHashId.indexOf('highcharts-legend') > -1;
                if (pattern._width === 'defer' || pattern._height === 'defer') {
                    Point.prototype.calculatePatternDimensions.call({
                        graphic: {
                            element: element
                        }
                    }, pattern)
                }
                if (forceHashId || !pattern.id) {
                    pattern = merge({}, pattern);
                    pattern.id = 'highcharts-pattern-' + chartIndex + '-' + hashFromObject(pattern) + hashFromObject(pattern, !0)
                }
                this.addPattern(pattern, !this.forExport && pick(pattern.animation, this.globalAnimation, {
                    duration: 100
                }));
                value = `url(${this.url}#${pattern.id + (this.forExport ? '-export' : '')})`
            } else {
                value = pattern.color || value
            }
            element.setAttribute(prop, value);
            color.toString = function() {
                return value
            }
            ;
            return !1
        });
        addEvent(Chart, 'endResize', function() {
            if ((this.renderer && this.renderer.defIds || []).filter(function(id) {
                return (id && id.indexOf && id.indexOf('highcharts-pattern-') === 0)
            }).length) {
                this.series.forEach(function(series) {
                    if (series.visible) {
                        series.points.forEach(function(point) {
                            const colorOptions = point.options && point.options.color;
                            if (colorOptions && colorOptions.pattern) {
                                colorOptions.pattern._width = 'defer';
                                colorOptions.pattern._height = 'defer'
                            }
                        })
                    }
                });
                this.redraw(!1)
            }
        });
        addEvent(Chart, 'redraw', function() {
            const usedIds = {}
                , renderer = this.renderer
                , patterns = (renderer.defIds || []).filter(function(pattern) {
                return (pattern.indexOf && pattern.indexOf('highcharts-pattern-') === 0)
            });
            if (patterns.length) {
                [].forEach.call(this.renderTo.querySelectorAll('[color^="url("], [fill^="url("], [stroke^="url("]'), function(node) {
                    const id = node.getAttribute('fill') || node.getAttribute('color') || node.getAttribute('stroke');
                    if (id) {
                        const sanitizedId = id.replace(renderer.url, '').replace('url(#', '').replace(')', '');
                        usedIds[sanitizedId] = !0
                    }
                });
                patterns.forEach(function(id) {
                    if (!usedIds[id]) {
                        erase(renderer.defIds, id);
                        if (renderer.patternElements[id]) {
                            renderer.patternElements[id].destroy();
                            delete renderer.patternElements[id]
                        }
                    }
                })
            }
        });
        ''
    });
    _registerModule(_modules, 'masters/modules/pattern-fill.src.js', [], function() {})
}));
class DefaultChart {
    constructor() {
        this.enableCategories = !1;
        this.enableSeries = !1;
        this.enabledGroups = !1;
        this.enableSocialButtons = !1;
        this.aliasing = {};
        this.config = {
            title: {
                text: ""
            },
            data: {
                csv: null
            },
            tooltip: {
                valueDecimals: null,
                valuePrefix: null,
                valueSuffix: null
            },
            credits: {
                enabled: !1
            },
            exporting: {
                enabled: !1,
                url: $wt.root + "/rest/charts/export/pdf/",
                libURL: $wt.root + "/libs/highcharts/lib",
                fallbackToExportServer: !1,
                pdfFont: {
                    normal: $wt.root + "/css/fonts/NotoSans-Regular.ttf",
                    bold: $wt.root + "/css/fonts/NotoSans-Bold.ttf",
                    italic: $wt.root + "/css/fonts/NotoSans-Italic.ttf",
                    bolditalic: $wt.root + "/css/fonts/NotoSans-BoldItalic.ttf"
                }
            },
            responsive: {
                rules: [{
                    condition: {
                        maxWidth: 500
                    },
                    chartOptions: {
                        chart: {
                            spacingRight: 10,
                            spacingBottom: 10,
                            spacingLeft: 10,
                            spacingTop: 10
                        },
                        title: {
                            style: {
                                fontSize: "20px"
                            }
                        },
                        plotOptions: {
                            series: {
                                dataLabels: {
                                    style: {
                                        fontSize: "14px",
                                        fontWeight: "600"
                                    }
                                }
                            }
                        },
                        xAxis: {
                            labels: {
                                useHTML: !0,
                                allowOverlap: !0,
                                style: {
                                    wordWrap: 'break-word',
                                    textOverflow: 'allow',
                                    width: '100px',
                                    fontSize: "14px"
                                }
                            }
                        }
                    }
                }]
            }
        }
    }
    static async createChartInstance(container) {
        if (container?.params?.service === 'estatcharts') {
            let lib = new EstatChart(container);
            await lib.addCustomTranslations(container);
            return lib
        }
        return new DefaultChart()
    }
    exporting = {
        csv: (data) => {
            return data.replace(/([\t\n\r])?([^\t\n\r]+)([\t\n\r])?/g, "$1\"$2\"$3").replace(/\t/g, ",")
        }
        ,
        html: (data) => {
            return data.replace(/([\t\n\r])?([^\t\n\r]+)([\t\n\r])?/g, "$1<td>$2</td>$3").replace(/(\r|\n|\r\n)+/g, "</tr><tr>").replace(/\t/g, "").replace(/^/g, "<table><tr>").replace(/$/g, "</tr></table>")
        }
        ,
        content: (type, content, extra) => {
            let prepend = extra?.prepend ?? "";
            let append = extra?.append ?? "";
            if ("html" === type || "xls" === type) {
                let dom = new DOMParser().parseFromString(content, 'text/html');
                [...dom.querySelectorAll('tr')].map(row => {
                        if (!row.innerText) {
                            $wt.remove(row)
                        }
                    }
                );
                content = dom.querySelector("body").innerHTML
            }
            if ("csv" === type) {
                content = content.split("\n").filter(row => row !== '"",').join("\n");
                return (prepend ? this.exporting.csv(prepend) + "\n" : "") + content + (append ? "\n" + this.exporting.csv(append) : "")
            } else if ("html" === type) {
                return (prepend ? this.exporting.html(prepend) + "<br />" : "") + content + (append ? "<br />" + this.exporting.html(append) : "")
            } else if ("xls-bin" === type) {
                let rows = content.slice(0);
                if (prepend) {
                    rows.unshift([]);
                    prepend.split("\n").reverse().map( (row) => rows.unshift(row.split("\t")))
                }
                if (append) {
                    rows.push([]);
                    append.split("\n").map( (row) => rows.push(row.split("\t")))
                }
                rows = rows.map( (row) => row.map( (column) => {
                        return {
                            type: typeof column === "number" ? Number : String,
                            value: column
                        }
                    }
                ));
                return rows
            } else if ("xls" === type) {
                return $wt.template(`<html xmlns:o="urn:schemas-microsoft-com:office:office"
          xmlns:x="urn:schemas-microsoft-com:office:excel"
          xmlns="http://www.w3.org/TR/REC-html40">
          <head>
            <xml>
              <x:ExcelWorkbook>
                <x:ExcelWorksheets>
                  <x:ExcelWorksheet>
                    <x:WorksheetOptions>
                      <x:DisplayGridlines/>
                    </x:WorksheetOptions>
                  </x:ExcelWorksheet>
                </x:ExcelWorksheets>
              </x:ExcelWorkbook>
            </xml>
            <style>
              td{border:none;font-family: Calibri, sans-serif;}
              .number{mso-number-format:"0.00";}
              .text{ mso-number-format:"\@";}
            </style>
            <meta name="ProgId" content="Excel.Sheet">
            <meta charset="UTF-8">
          </head>
          <body>{prepend}{content}{append}</body>
        </html>`, {
                    content: content,
                    prepend: (prepend ? this.exporting.html(prepend) + "<br />" : ""),
                    append: (append ? "<br />" + this.exporting.html(append) : "")
                }, null)
            }
        }
        ,
        extra: (container, data) => {
            const output = {};
            for (let key in data) {
                const item = data[key];
                output[key] = (typeof window[item] === "function") ? window[item](container) : item
            }
            return output
        }
    };
    transform = {
        align: (container) => {
            const params = container.params;
            const dataset = params.dataset;
            if (!params?.data) {
                container.params.data = {}
            }
            if (dataset.raw) {
                if ("csv" === dataset.format) {
                    const isDotComma = dataset.raw.split("\n")[0].indexOf(';') > -1;
                    if (isDotComma) {
                        dataset.raw = dataset.raw.replace(/;/g, '|').replace(/,/g, '.').replace(/\|/g, ',');
                        console.warn("WTINFO: Your CSV data was rewritten to use the comma separator:\nhttps://europa.eu/!c3R3FR")
                    }
                    params.data = $wt.mergeParams(params.data, {
                        data: {
                            csv: dataset.raw,
                            parseDate: (date) => {
                                return date + ""
                            }
                        }
                    }, null);
                    if (dataset?.options?.decimal && dataset.options.decimal.point !== 'auto') {
                        params.data = $wt.mergeParams(params.data, {
                            data: {
                                decimalPoint: dataset.options.decimal.point
                            }
                        }, null)
                    }
                } else if ("json" === dataset.format) {
                    params.data = $wt.mergeParams(params.data, {
                        "series": dataset.raw
                    }, null)
                } else if (/(lasko|xlsx?|ods)/i.test(dataset.format)) {
                    dataset.lasko = dataset.raw;
                    let options = params?.dataset?.options || {};
                    if (options.categories || options.sheets || options.series) {
                        container.params.dataset.lasko = $wt.toLasko({
                            from: "lasko",
                            data: dataset.lasko,
                            options: params.dataset.options
                        })
                    }
                    this.transform.processLasko(container)
                } else if ("jsonstat" === dataset.format) {
                    const options = {
                        from: dataset.raw,
                        to: "lasko",
                        ready: (lasko) => {
                            dataset.lasko = lasko;
                            this.transform.processLasko(container)
                        }
                    };
                    $wt.jsonstat($wt.mergeParams(dataset.options, options, null))
                }
            }
        }
        ,
        processLasko: function(container) {
            const params = container.params;
            const data = params.data;
            const dataset = params.dataset;
            const lasko = dataset.lasko;
            const options = dataset.options;
            $wt.charts.utils.translate.sheets(container);
            $wt.charts.utils.sort.sheets(container);
            const output = {};
            const title = (data?.title?.text) ? data.title.text : "";
            output.title = {
                text: title
            };
            if (!data.title) {
                data.title = {
                    text: title
                }
            }
            lasko.categories = lasko.categories.map(item => {
                    return {
                        id: item.id,
                        label: item.label,
                        groupId: item.label
                    }
                }
            );
            output.xAxis = {};
            if (lasko.categories) {
                output.xAxis.type = "category";
                output.xAxis.categories = lasko.categories.map(row => row.label)
            }
            output.series = [];
            if (lasko.sheets) {
                const index = options.sheets_index;
                let sheet = lasko.sheets.find( (sheet, laskoIndex) => {
                        if (sheet.sheets_index) {
                            return Number(sheet.sheets_index) === Number(index)
                        }
                        return index === laskoIndex
                    }
                );
                if (sheet && sheet.series) {
                    for (let j = 0; j < sheet.series.length; j++) {
                        const datas = sheet.series[j].data.slice(0);
                        for (let d = 0; d < datas.length; d++) {
                            const dataObj = {};
                            let parsedValue = parseFloat(datas[d].value);
                            dataObj.y = !isNaN(parsedValue) ? parsedValue : null;
                            if (lasko.categories && lasko.categories[d] && lasko.categories[d].label) {
                                dataObj.id = lasko.categories[d].id;
                                dataObj.name = lasko.categories[d].label
                            }
                            datas[d] = dataObj
                        }
                        let currentSeries = undefined;
                        if (lasko?.series) {
                            currentSeries = lasko.series.find(obj => obj.label === sheet.series[j].label)
                        }
                        output.series[j] = {
                            "name": sheet.series[j].label,
                            "id": (currentSeries) ? currentSeries.id : undefined,
                            "data": datas
                        }
                    }
                }
            }
            params.data = $wt.mergeParams(data, output, null)
        },
        sort: function(container) {
            const params = container.params;
            const lang = params.lang;
            const data = params.data;
            const dataset = params.dataset;
            const options = dataset.options;
            const sort = options.sort;
            function override(data, i) {
                let e;
                for (let z in data) {
                    if (typeof data[z].x !== "undefined" && i === data[z].x) {
                        e = z
                    }
                    if (typeof data[z][1] !== "undefined" && i === data[z][0]) {
                        e = z
                    }
                }
                return e
            }
            if (!data.series || !data.series.length || !data.series[0]?.data?.length) {
                return
            }
            if (!sort || (sort?.by === null && sort?.order === null)) {
                return
            }
            let by = "serie";
            let order = "desc";
            let bySeries = null;
            let sortable = [];
            let is_multiseries = !1;
            if (sort.by) {
                const by_tmp = (sort.by).toLowerCase();
                if (/category|serie/g.test(by_tmp)) {
                    by = by_tmp
                }
            }
            if (sort.order) {
                const order_tmp = (sort.order).toLowerCase();
                if (/asc|desc/g.test(order_tmp)) {
                    order = order_tmp
                }
            }
            if (sort.bySeries !== null && sort.bySeries !== undefined) {
                const integerSortBySeries = Number(sort.bySeries);
                if (Number.isInteger(integerSortBySeries) && integerSortBySeries >= 0 && integerSortBySeries < data.series.length) {
                    bySeries = integerSortBySeries
                }
            }
            if (by === "serie" && data.series.length > 1 && bySeries === null) {
                console.log("WTERROR: [CHART], can't sort multiple series if no series is selected");
                return
            } else if (by === "serie" && data.series.length === 1) {
                bySeries = 0
            }
            if ((data.plotOptions && data.plotOptions.series && data.plotOptions.series.stacking && /percent|normal/g.test(data.plotOptions.series.stacking)) || (data.series.length > 1)) {
                is_multiseries = !0
            }
            const serie = data.series[0].data;
            if (data.xAxis && data.xAxis.categories) {
                const serie_type = typeof serie[0];
                for (let i = 0; i < data.xAxis.categories.length; i++) {
                    let tmp = {
                        "category": data.xAxis.categories[i]
                    };
                    if (serie_type === "object") {
                        if (is_multiseries) {
                            tmp.serie = [];
                            tmp.serieFull = [];
                            for (let j = 0; j < data.series.length; j++) {
                                tmp.serie[j] = data.series[j].data[i].y;
                                tmp.serieFull[j] = data.series[j].data[i]
                            }
                        } else {
                            let e = override(serie, i);
                            if (serie[e]) {
                                tmp.serie = serie[e].y || serie[e][1] || !1;
                                tmp.serieFull = serie[e] || serie[i]
                            } else {
                                tmp.serie = serie[i];
                                tmp.serieFull = serie[i]
                            }
                        }
                    } else {
                        if (is_multiseries) {
                            tmp.serie = [];
                            for (let j = 0; j < data.series.length; j++) {
                                tmp.serie[j] = data.series[j].data[i]
                            }
                        } else {
                            tmp.serie = serie[i]
                        }
                    }
                    sortable.push(tmp)
                }
                sortable = $wt.charts.utils.sort.byKey(sortable, by, order, lang, bySeries);
                for (let i = 0; i < sortable.length; i++) {
                    data.xAxis.categories[i] = sortable[i].category;
                    if (serie_type === "object") {
                        if (is_multiseries) {
                            for (let j = 0; j < sortable[i].serie.length; j++) {
                                data.series[j].data[i] = sortable[i].serieFull[j]
                            }
                        } else {
                            serie[i] = sortable[i].serieFull
                        }
                    } else {
                        if (is_multiseries) {
                            for (let j = 0; j < sortable[i].serie.length; j++) {
                                data.series[j].data[i] = sortable[i].serie[j]
                            }
                        } else {
                            serie[i] = sortable[i].serie
                        }
                    }
                }
            } else if ((data.xAxis && data.xAxis.type && data.xAxis.type === "category" && serie[0].name) || (!data.xAxis && serie[0].name)) {
                for (let i = 0; i < serie.length; i++) {
                    let tmp = {
                        "category": serie[i].name
                    };
                    if (is_multiseries) {
                        tmp.serie = [];
                        tmp.serieFull = [];
                        for (let j = 0; j < data.series.length; j++) {
                            tmp.serie[j] = data.series[j].data[i].y;
                            tmp.serieFull[j] = data.series[j].data[i]
                        }
                    } else {
                        let e = override(serie, i);
                        if (serie[e]) {
                            tmp.serie = serie[e].y || serie[e][1] || !1;
                            tmp.serieFull = serie[e] || serie[i]
                        } else {
                            tmp.serie = serie[i];
                            tmp.serieFull = serie[i]
                        }
                    }
                    sortable.push(tmp)
                }
                sortable = $wt.charts.utils.sort.byKey(sortable, by, order, lang, bySeries);
                for (let i = 0; i < sortable.length; i++) {
                    if (is_multiseries) {
                        for (let j = 0; j < sortable[i].serie.length; j++) {
                            data.series[j].data[i] = sortable[i].serieFull[j]
                        }
                    } else {
                        serie[i] = sortable[i].serieFull
                    }
                }
            }
        },
        filter: function(container) {
            const params = container.params;
            const data = params.data;
            const dataset = params.dataset;
            const options = dataset.options;
            const filters = options.filters;
            const valid_filters = {
                "category": [],
                "serie": []
            };
            if (!data.series || !data.series.length || !data.series[0].data || !data.series[0].data.length) {
                return
            }
            if (filters && typeof filters === "object") {
                for (let i = 0; i < filters.length; i++) {
                    const filter = filters[i];
                    let filter_valid = !0;
                    if (!filter.by) {
                        filter_valid = !1
                    } else {
                        if (!new RegExp("category|serie","g").test(filter.by.toLowerCase())) {
                            filter_valid = !1
                        }
                    }
                    if (!filter.operator) {
                        filter_valid = !1
                    } else {
                        if (!new RegExp("<|<=|>|>=|~","g").test(filter.operator.toLowerCase())) {
                            filter_valid = !1
                        }
                    }
                    if (typeof filter.value === "undefined") {
                        filter_valid = !1
                    } else {
                        if (!(typeof filter.value === "string" || (typeof filter.value !== "string" && !isNaN(filter.value)))) {
                            filter_valid = !1
                        }
                    }
                    if (filter_valid) {
                        valid_filters[filter.by.toLowerCase()].push({
                            "operator": filter.operator,
                            "value": (!isNaN(filter.value) ? filter.value : '"' + filter.value + '"')
                        })
                    }
                }
                function toBeFiltered(filters, value) {
                    if (typeof value === "string") {
                        value = value.toLowerCase()
                    }
                    for (let i = 0; i < filters.length; i++) {
                        if (filters[i].operator !== "~") {
                            value = (isNaN(value) ? '"' + value + '"' : value);
                            switch (filters[i].operator) {
                                case "<":
                                    if (!(value < filters[i].value)) {
                                        return !0
                                    }
                                    break;
                                case "<=":
                                    if (!(value <= filters[i].value)) {
                                        return !0
                                    }
                                    break;
                                case ">":
                                    if (!(value > filters[i].value)) {
                                        return !0
                                    }
                                    break;
                                case ">=":
                                    if (!(value >= filters[i].value)) {
                                        return !0
                                    }
                                    break
                            }
                        } else {
                            if (typeof filters[i] === "string") {
                                filters[i] = filters[i].toLowerCase()
                            }
                            if (typeof value === "string" && value.indexOf(filters[i].value.substring(1, filters[i].value.length - 1)) === -1) {
                                return !0
                            }
                        }
                    }
                    return !1
                }
                function getSeriesValue(data) {
                    let value = data;
                    if (typeof data === "object") {
                        if (data.hasOwnProperty('y')) {
                            value = data.y
                        } else if (Array.isArray(data)) {
                            value = data[1]
                        }
                    }
                    return value
                }
                if (valid_filters.category.length) {
                    if (data.xAxis && data.xAxis.categories) {
                        for (let i = data.xAxis.categories.length - 1; i > -1; i--) {
                            if (toBeFiltered(valid_filters.category, data.xAxis.categories[i])) {
                                data.xAxis.categories.splice(i, 1);
                                for (let j = 0; j < data.series.length; j++) {
                                    data.series[j].data.splice(i, 1)
                                }
                            }
                        }
                    } else if (data.xAxis && data.xAxis.type && data.xAxis.type === "category" && data.series[0].data[0].name) {
                        for (let i = data.series[0].data.length - 1; i > -1; i--) {
                            if (toBeFiltered(valid_filters.category, data.series[0].data[i].name)) {
                                for (let j = 0; j < data.series.length; j++) {
                                    data.series[j].data.splice(i, 1)
                                }
                            }
                        }
                    } else if (typeof data.series[0].data[0] === "object" && Array.isArray(data.series[0].data[0])) {
                        for (let i = data.series[0].data.length - 1; i > -1; i--) {
                            if (toBeFiltered(valid_filters.category, data.series[0].data[i][0])) {
                                for (let j = 0; j < data.series.length; j++) {
                                    data.series[j].data.splice(i, 1)
                                }
                            }
                        }
                    }
                }
                if (valid_filters.serie.length) {
                    if (data.series.length > 1) {
                        console.log("WTWARNING: [CHART], using series filters on multiple series may have unexpected behaviour");
                        const currentCategories = new Map();
                        for (let j = 0; j < data.series.length; j++) {
                            for (let i = data.series[j].data.length - 1; i > -1; i--) {
                                let value = getSeriesValue(data.series[j].data[i]);
                                if (toBeFiltered(valid_filters.serie, value)) {
                                    const currentCount = currentCategories.get(data.series[j].data[i].name) || 0;
                                    currentCategories.set(data.series[j].data[i].name, currentCount + 1)
                                }
                            }
                        }
                        for (const [name,value] of currentCategories.entries()) {
                            if (value === data.series.length) {
                                data.xAxis.categories = data.xAxis.categories.filter(category => {
                                        return category !== name
                                    }
                                );
                                for (let j = 0; j < data.series.length; j++) {
                                    for (let i = data.series[j].data.length - 1; i > -1; i--) {
                                        data.series[j].data = data.series[j].data.filter(dataset => dataset.name !== name)
                                    }
                                }
                            }
                        }
                    } else {
                        for (let i = data.series[0].data.length - 1; i > -1; i--) {
                            let value = getSeriesValue(data.series[0].data[i]);
                            if (toBeFiltered(valid_filters.serie, value)) {
                                data.series[0].data.splice(i, 1);
                                if (data.xAxis && data.xAxis.categories && data.xAxis.categories[i]) {
                                    data.xAxis.categories.splice(i, 1)
                                }
                            }
                        }
                    }
                }
            }
        },
        categories: (container) => {
            if (!container.params?.toolbar?.categories || !this.enableCategories) {
                return
            }
            container.params.data.series = container.params.data.seriesOriginal;
            let toolbar = container.ui.toolbar;
            let checkedId = [...toolbar.querySelectorAll('.wt-charts--categories input:checked')].map(row => row.getAttribute('data-id'));
            let axis = [];
            if (container.params.toolbar.categories.mode === 'single-select') {
                let cat = toolbar.querySelector(".wt-charts--categories select").value;
                if (!cat) {
                    return
                }
                checkedId = [cat]
            }
            let alias = container.params.data.series.slice().map(serie => {
                    if (Array.isArray(serie.data) && typeof serie.data[0] !== 'number') {
                        let refine = serie.data.filter(data => {
                                let isSelected = checkedId.indexOf(data.id) > -1;
                                if (data.id === null) {
                                    axis.push('')
                                } else if (isSelected && axis.indexOf(data.id) < 0) {
                                    axis.push(data.name)
                                }
                                return isSelected
                            }
                        );
                        serie.data = refine
                    }
                    return serie
                }
            ).filter(serie => serie.data.length);
            container.params.data.series = alias;
            container.params.data.xAxis.categories = axis
        }
        ,
        series: (container) => {
            if (!container.params?.toolbar?.series || !this.enableSeries) {
                return
            }
            container.params.data.series = container.params.data.seriesOriginal;
            let toolbar = container.ui.toolbar;
            let checkedId = [...toolbar.querySelectorAll('.wt-charts--series input:checked')].map(row => row.getAttribute('data-id'));
            if (container.params.toolbar.series.mode === 'single-select') {
                let serie = toolbar.querySelector(".wt-charts--series select").value;
                if (!serie) {
                    return
                }
                checkedId = [serie]
            }
            container.params.data.series = container.params.data.series.filter(series => {
                    return checkedId.includes(series.id)
                }
            )
        }
        ,
        groups: (container) => {
            if ((container.params?.data?.chart?.type !== 'column' && container.params?.data?.chart?.type !== 'high-low' && (!container.params?.data?.chart?.originalType || container.params?.data?.chart?.originalType !== 'high-low')) || !container.params?.dataset?.options?.groups || container.params.dataset.options.groups.length === 0 || !this.enabledGroups) {
                return
            }
            let ref = container.params.data.series.slice();
            if (Array.isArray(ref) && ref.length >= 1) {
                let groups = container.params.dataset.options.groups;
                let lasko = container.params.dataset.lasko;
                let categories = [];
                for (let i = 0; i < ref.length; i++) {
                    let series = (ref[i]) ? ref[i].data : !1;
                    let newSeries = [];
                    let newAxis = [];
                    let alreadyProcess = {};
                    if (!series) {
                        return
                    }
                    let dimensionList = lasko.categories.reduce( (aggr, row) => {
                            aggr[row.id] = row.groupId;
                            return aggr
                        }
                        , {});
                    let flat = groups.flat(3);
                    let useOthers = flat.indexOf(":OTHERS:") > -1;
                    if (!useOthers) {
                        groups.push([":OTHERS:"])
                    }
                    groups.map( (group, index) => {
                            let aliasToItem = [];
                            group.map(row => {
                                    this.validateGroups({
                                        item: row,
                                        dimensions: dimensionList,
                                        process: alreadyProcess,
                                        flat: flat,
                                        items: aliasToItem
                                    })
                                }
                            );
                            let finding = 0;
                            series.map(serie => {
                                    let found = aliasToItem.filter(id => serie.name === dimensionList[id]);
                                    if (found.length) {
                                        finding++;
                                        newAxis.push(found[0])
                                    }
                                }
                            );
                            if (index < (groups.length - 1) && finding) {
                                newAxis.push('')
                            }
                        }
                    );
                    if (newAxis[0] === '') {
                        newAxis.shift()
                    }
                    if (newAxis[newAxis.length - 1] === '') {
                        newAxis = newAxis.slice(0, -1)
                    }
                    newAxis.map(what => {
                            if (!what) {
                                newSeries.push({
                                    y: null,
                                    name: null
                                })
                            } else {
                                let exist = series.filter(row => row.name === what);
                                if (exist[0]) {
                                    newSeries.push(exist[0])
                                }
                            }
                        }
                    );
                    container.params.data.series[i].data = newSeries;
                    categories[i] = newAxis
                }
                container.params.data.xAxis.categories = categories[0]
            }
        }
        ,
        pattern: (container) => {
            if (!container.hasOwnProperty('usePattern')) {
                return
            }
            if (container.usePattern === !1) {
                while (container.obj.series.length > 0) {
                    container.obj.series[0].remove()
                }
                let copy = null;
                if (!container.params.data?.data?.csv) {
                    copy = container.params.data.series.map(serie => {
                            let temp = serie.data.map(data => {
                                    if (typeof data === 'number' || data === null) {
                                        return data
                                    }
                                    data.color = data.RESTORE_COLOR || null;
                                    return data
                                }
                            );
                            serie.data = temp;
                            serie.color = null;
                            return serie
                        }
                    )
                }
                container.params.data.series = copy;
                container.params.data.seriesOriginal = copy;
                return
            }
            let patterns = Highcharts.patterns;
            let countPattern = 0;
            let isData = container.params.data?.series?.data;
            let data = isData || container.params.data?.series;
            if (data) {
                let series = data.map(serie => {
                        if (typeof serie !== "object") {
                            serie = {
                                value: serie
                            }
                        }
                        serie.color = {
                            pattern: patterns[countPattern]
                        };
                        countPattern++;
                        if (countPattern > (patterns.length - 1)) {
                            countPattern = 0
                        }
                        return serie
                    }
                );
                if (series.length === 1) {
                    series.map(what => {
                            countPattern = 0;
                            what.data.map(row => {
                                    if (!row || typeof row !== "object") {
                                        return row
                                    }
                                    row.RESTORE_COLOR = row.color || null;
                                    if (typeof row === "number") {
                                        row.color = patterns[countPattern].color
                                    } else {
                                        row.color = {
                                            pattern: patterns[countPattern]
                                        }
                                    }
                                    countPattern++;
                                    if (countPattern > (patterns.length - 1)) {
                                        countPattern = 0
                                    }
                                    return row
                                }
                            )
                        }
                    )
                }
                if (isData) {
                    container.params.data.series.data = series
                } else {
                    container.params.data.series = series
                }
            } else if (container.params.data?.data?.csv) {
                container.params.data.series = [];
                let csv = container.params.data.data.csv.split("\n")[0].split(',').filter(n => n.trim());
                container.params.data.series = csv.map( () => {
                        let ref = {
                            color: {
                                pattern: patterns[countPattern]
                            }
                        };
                        countPattern++;
                        if (countPattern > (patterns.length - 1)) {
                            countPattern = 0
                        }
                        return ref
                    }
                )
            }
        }
    };
    aliasToArray(arr) {
        let temp = [];
        arr.map(entry => {
                let alias = entry.replace(/:/ig, '');
                if (this.aliasing[alias]) {
                    temp = temp.concat(this.aliasing[alias])
                } else {
                    temp.push(alias)
                }
            }
        );
        return [...new Set(temp)]
    }
    validateGroups(config) {
        let row = config.item;
        let dimensions = config.dimensions;
        let process = config.process;
        let flat = config.flat;
        let aliasToItem = config.items;
        let upper = row.toUpperCase();
        let lower = row.toLowerCase();
        let aliasL = lower.replace(/:/ig, '');
        let aliasU = upper.replace(/:/ig, '');
        if (aliasL === 'others') {
            Object.keys(dimensions).map(item => {
                    if (!process[item] && flat.indexOf(item) < 0) {
                        aliasToItem.push(item);
                        process[item] = !0
                    }
                }
            )
        } else if (Array.isArray(this.aliasing[aliasU])) {
            this.aliasing[aliasU].map(item => {
                    if (dimensions[item] && !process[item] && flat.indexOf(item) < 0) {
                        aliasToItem.push(item);
                        process[item] = !0
                    }
                }
            )
        } else if (dimensions[upper] && !process[upper]) {
            aliasToItem.push(upper);
            process[upper] = !0
        }
    }
    buildSimpleSelector(container, options) {
        let itmSlct = options.selected ? options.selected[0] : !1;
        let items = options.items.map(itm => {
                let slct = (itmSlct && itmSlct === itm.id) ? "selected" : "";
                return `<option value="${itm.id}" ${slct}>${itm.label}</option>`
            }
        ).join('');
        options.container.innerHTML = `<div class="wt-custom-select"><select class="wt-select">
      ${items}
    </select></div>`;
        options.container.querySelector('select').onchange = () => {
            container.obj.render(container, container.params.dataset)
        }
    }
    buildMenuSelector(container, options) {
        let id = $wt.id();
        let formReference = options.container;
        let selected = options.selected;
        let label = options.label;
        let dimensionList = options.items.reduce( (aggr, row) => {
                aggr[row.id] = row.label;
                return aggr
            }
            , {});
        if (Array.isArray(selected)) {
            selected = this.aliasToArray(selected)
        }
        const getItems = (cat_id) => {
                let name = dimensionList[cat_id];
                let range = (selected) ? selected.map(i => i.toUpperCase()) : Object.keys(dimensionList);
                let isChecked = (range).indexOf(cat_id) > -1 || (range).indexOf(cat_id.toUpperCase()) > -1;
                return name ? $wt.template(`
        <li>
          <input type="checkbox" id="{name}_{id}" value="{name}" data-id="{cat_id}" {checked} />
          <label for="{name}_{id}">{name}</label>
        </li>
      `, {
                    name: name,
                    id: id,
                    cat_id: cat_id,
                    checked: isChecked ? 'checked' : ''
                }) : ''
            }
        ;
        let catList = '';
        let groups = options.groups;
        if (groups) {
            let flat = groups.flat(3);
            let alreadyProcess = {};
            catList = groups.map(list => {
                    let aliasToItem = [];
                    list.map(row => {
                            this.validateGroups({
                                item: row,
                                dimensions: dimensionList,
                                process: alreadyProcess,
                                flat: flat,
                                items: aliasToItem
                            })
                        }
                    );
                    return (aliasToItem.map(item => getItems(item)).join(''))
                }
            ).filter(row => row.trim()).join('</ul><ul class="wt-form--list-separator">')
        } else {
            catList = Object.keys(dimensionList).map(getItems).join('')
        }
        formReference.innerHTML += `
      <div class="wt-multiple--container">
        <button type="button"
          aria-controls="wt-charts--filter_${id}"
          aria-expanded="false"
          title="${$wt.filterHtml(label)}"
          class="wt-multiple--button"
        >
          <span>${label}</span>
        </button>
        <div
          hidden
          id="wt-charts--filter_${id}"
          role="dialog"
          class="wt-multiple-selector--dialog">

          <form class="wt-multiple-selector--dialog-form">

            <div class="wt-multiple-selector--dialog-topbar">
              <button type="button" data-selectall="true">
                ${$wt.label("charts", "select_all", container.params.lang)}
              </button>
              <button type="button" data-unselectall="true">
                ${$wt.label("charts", "unselect_all", container.params.lang)}
              </button>
              <button type="reset" data-reset="true">
                ${$wt.label("charts", "reset", container.params.lang)}
              </button>
              <button type="button" aria-controls="wt-charts--filter_${id}">
                ${$wt.label("charts", "close", container.params.lang)}
              </button>
            </div>

            <fieldset class="wt-ecl-form-group">
              <legend class="wt-ecl-form-label">${label}</legend>
              <ul>${catList}</ul>
            </fieldset>

          </form>
        </div>
      </div>
    `;
        $wt.aria.init(formReference);
        const updateCounter = () => {
                let total = [...formReference.querySelectorAll('input:checked')].length;
                let tmpl = $wt.template(label, {
                    nbr: total
                });
                formReference.querySelector('.wt-multiple--button span').innerHTML = tmpl;
                formReference.querySelector('.wt-multiple--button').setAttribute('title', $wt.filterHtml(tmpl));
                formReference.querySelector('legend').innerHTML = tmpl
            }
        ;
        updateCounter();
        formReference.onclick = (evt) => {
            let src = evt.target;
            let attr = src.attributes;
            if (attr["data-selectall"]) {
                [...formReference.querySelectorAll('input')].map(inp => inp.checked = !0);
                updateCounter();
                container.obj.render(container, container.params.dataset)
            } else if (attr["data-unselectall"]) {
                [...formReference.querySelectorAll('input')].map(inp => inp.checked = !1);
                updateCounter();
                container.obj.render(container, container.params.dataset)
            } else if (attr["data-reset"]) {
                setTimeout( () => {
                        updateCounter();
                        container.obj.render(container, container.params.dataset)
                    }
                    , 50)
            } else if (src.tagName === 'LABEL' || src.tagName === 'INPUT') {
                setTimeout( () => {
                        updateCounter();
                        container.obj.render(container, container.params.dataset)
                    }
                    , 50)
            }
        }
    }
    buildCategoriesSelector(container) {
        if (!container.params?.toolbar?.categories || !this.enableCategories) {
            return
        }
        let target = container.ui.toolbar.querySelector('.wt-charts--categories');
        let selected = container.params.toolbar.categories?.selected;
        let items = this.getCategorySelectorItems(container);
        let groups = container.params.toolbar.categories?.groups;
        let label = container.params.toolbar.categories?.label || $wt.label("charts", "selected_categories", container.params.lang);
        if (container.params.toolbar.categories.mode === 'single-select') {
            return this.buildSimpleSelector(container, {
                container: target,
                selected: selected,
                items: items,
                groups: groups,
                label: label
            })
        }
        this.buildMenuSelector(container, {
            container: target,
            selected: selected,
            items: items,
            groups: groups,
            label: label
        })
    }
    buildSeriesSelector(container) {
        if (!container.params?.toolbar?.series || !this.enableSeries) {
            return
        }
        let target = container.ui.toolbar.querySelector('.wt-charts--series');
        let selected = container.params.toolbar.series?.selected;
        let items = container.params.dataset.lasko.series;
        let label = container.params.toolbar.series?.label || $wt.label("charts", "selected_series", container.params.lang);
        if (container.params.toolbar.series.mode === 'single-select') {
            return this.buildSimpleSelector(container, {
                container: target,
                selected: selected,
                items: items,
                groups: !1,
                label: label
            })
        }
        this.buildMenuSelector(container, {
            container: target,
            selected: selected,
            items: items,
            groups: !1,
            label: label
        })
    }
    buildSheetsSelector(container) {
        let id = $wt.id();
        let params = container.params;
        let dataset = params?.dataset;
        let lasko = dataset?.lasko;
        let toolbar = container.ui.toolbar;
        let options = dataset.options;
        let invalid = options.sheets && (options.sheets === options.series || options.sheets === options.categories);
        if (lasko?.sheets && lasko.sheets.length > 1 && !invalid) {
            let slct = document.createElement("select");
            slct.className = "wt-select";
            slct.id = "wt-select-" + id;
            slct.title = "Switch to another data series:";
            slct.innerHTML = buildSelectOptions(lasko.sheets, dataset.options.sheets_index);
            slct.onchange = function() {
                container.params.dataset.options.sheets_index = this.options[this.options.selectedIndex].value;
                slct.innerHTML = buildSelectOptions(lasko.sheets, this.options[this.options.selectedIndex].value);
                container.obj.render(container)
            }
            ;
            function buildSelectOptions(laskoSheets, selectedOption) {
                return laskoSheets.map( (row) => {
                        let i = Number(row.sheets_index);
                        return `
          <option value="${i}" ${(i === Number(selectedOption)) ? 'selected' : ''}>
            ${row.label}
          </option>
        `
                    }
                ).join('')
            }
            toolbar.querySelector('.wt-charts--sheets').appendChild(slct)
        } else {
            container.ui.toolbar.querySelector('.wt-charts--sheets').remove()
        }
    }
    buildMenu(container, racing) {
        const toolbar = container.ui.toolbar;
        const params = container.params;
        const id = $wt.id();
        const labels = $wt.label("charts", "highcharts.lang", params.lang);
        let patternCompliant = !(params.plugins.filter(item => {
                return ["arc-diagram", "sankey", "drilldown", "heatmap"].filter(what => item.indexOf(what) > -1).length
            }
        ).length);
        let series = container.params.data.series;
        let usePattern = series ? JSON.stringify(series).search(/\"pattern\":|\"dashStyle\":/i) > -1 : !1;
        let menu = {
            table: {
                xhtml: `<a class="wt-link" href="#chart-html-${id}" data-action="html" target="_blank" role="menuitem">
          ${labels.viewData}
          <span class="wt-offscreen"> (${$wt.label("charts", "new_window", params.lang)})</span>
          <span class="wt-icon--external wt-icon--fluid"></span>
        </a>`
            },
            fullscreen: {
                xhtml: `<button class="wt-link wt-toggle" data-action="fullscreen" role="menuitem" aria-pressed="false">
          ${labels.viewFullscreen}
        </button>`
            },
            pattern: {
                xhtml: `<button class="wt-link wt-toggle" data-action="pattern" role="menuitem" aria-pressed="false">
          ${$wt.label("charts", "use_patterns", params.lang)}
        </button>`
            },
            pdf: {
                xhtml: `<a class="wt-link" href="#chart-pdf-${id}" data-action="pdf" role="menuitem">${labels.downloadPDF}</a>`
            },
            xls: {
                xhtml: `<a class="wt-link" href="#chart-xls-${id}" data-action="xls" role="menuitem">${labels.downloadXLS}</a>`
            },
            svg: {
                xhtml: `<a class="wt-link" href="#chart-svg-${id}" data-action="svg" role="menuitem">${labels.downloadSVG}</a>`
            },
            png: {
                xhtml: `<a class="wt-link" href="#chart-png-${id}" data-action="png" role="menuitem">${labels.downloadPNG}</a>`
            },
            csv: {
                xhtml: `<a class="wt-link" href="#chart-csv-${id}" data-action="csv" role="menuitem">${labels.downloadCSV}</a>`
            },
            print: {
                xhtml: `<a class="wt-link" href="#chart-print-${id}" data-action="print" role="menuitem">${labels.printChart}</a>`,
                separator: !0
            }
        };
        let mandatory = ["table", "fullscreen", "pattern"];
        let menuCleanup = (params.menu || []).filter(node => !mandatory.includes(node?.name || node));
        if ((!patternCompliant && usePattern) || racing) {
            mandatory = mandatory.slice(0, -1)
        }
        let menuUser = mandatory.concat(menuCleanup);
        let menuNoPrint = menuUser.filter(item => item === 'print' || item?.name === 'print');
        if (menuNoPrint.length === 0) {
            menuUser = menuUser.concat(['print'])
        }
        let menuContent = menuUser.map( (item, index) => {
                let itm = menu[item] || item;
                let xhtml = itm?.xhtml || !1;
                let separator = itm?.separator ? 'wt-separator-' + itm?.separator : '';
                if ((mandatory.length - 1) === index) {
                    separator = 'wt-separator-bottom'
                }
                return xhtml ? `<li class="wt-li ${$wt.filterXss(separator)}">${$wt.filterXss(xhtml)}</li>` : '--'
            }
        ).filter(item => item !== '--').join('');
        toolbar.innerHTML += `
      <div class="wt-charts--menu">
        <button
          class="wt-btn"
          type="button"
          aria-haspopup="true"
          title="${labels.contextButtonTitle}"
          aria-controls="wt-charts-menu-${id}"
          aria-expanded="false"
          id="wt-charts-button-${id}"
        ><span class="wt-icon--hamburger wt-icon--lg"></span></button>
        <ul
          class="wt-charts--menu-dialog"
          id="wt-charts-menu-${id}"
          aria-labelledby="wt-charts-button-${id}"
          role="menu"
          hidden
        >${menuContent}</ul>
      </div>`;
        [...toolbar.querySelectorAll('ul a, ul button')].forEach(elm => {
                elm.classList.add('wt-link');
                elm.setAttribute('role', 'menuitem')
            }
        );
        if (racing) {
            toolbar.innerHTML += `<div class="wt-charts--filters"></div>`
        } else {
            toolbar.innerHTML += `<div class="wt-charts--filters">
        <div class="wt-charts--sheets"></div>
        <div class="wt-charts--categories"></div>
        <div class="wt-charts--series"></div>
      </div>`
        }
        $wt.aria.menu(toolbar.querySelector('.wt-charts--menu [aria-controls]'), event => {
                const elm = event.currentTarget;
                const what = elm.getAttribute('data-action');
                this.actionsMenu(container, what, event)
            }
        );
        document.body.addEventListener("keydown", (event) => {
                const isFullscreen = container.classList.contains("wt-charts-fullscreen");
                if (event.key === 'Escape' && isFullscreen) {
                    this.actionsMenu(container, "fullscreen", event)
                }
            }
        )
    }
    buildChartHeader(container) {
        if (container.header_done) {
            return
        }
        container.header_done = !0;
        let header = container.params.header;
        let social = header?.social;
        let networks = social?.networks ? social?.networks : [];
        let info = social?.info || header?.info;
        let title = social?.title || container.params.data?.title?.text || document.title;
        let via = social?.via || "EU_Commission";
        let id = $wt.id();
        let infoHtml = info ? `
      <div class="wt-charts--info-container">
        <button
          class="wt-charts--info-button"
          type="button"
          aria-controls="wt-info-${id}"
          aria-label="Info"
          aria-expanded="false"
        >
          <span class="wt-icon--information wt-icon--l"></span>
        </button>
        <div role="menu" id="wt-info-${id}" class="wt-charts--info-content" hidden>
          ${info}
        </div>
      </div>` : '';
        let shareHtml = networks.length ? `<script type="application/json">{
      "service": "sbkm",
      "version": "2.0",
      "display": "icons",
      "more": ${JSON.stringify(networks)},
      "menutitle": true,
      "title": "${title}",
      "via": "${via}"
    }</script>` : '';
        container.ui.header.innerHTML = infoHtml + shareHtml;
        info ? $wt.aria.init(container.ui.header.querySelector('.wt-charts--info-container')) : ''
    }
    buildToolbar(container) {
        if (container.done) {
            return
        }
        container.done = !0;
        let toolbar = container.ui.toolbar;
        let params = container.params;
        let data = params.data;
        let racing = params.racing;
        let title = $wt.filterHtml(data.title?.text || '');
        let subtitle = $wt.filterHtml(data.subtitle?.text || '');
        let id = $wt.id();
        container.size = container.ui.charts.offsetHeight;
        toolbar.innerHTML = `
      <a class="wt-charts--skip" id="backChart_${id}" href="#skipChart_${id}">
        Skip chart
      </a>
    `;
        let skip = toolbar.querySelector("a");
        if (title || subtitle) {
            skip.innerHTML += $wt.template(`<span class="wt-offscreen"> ({title}{subtitle})</span>`, {
                title: title,
                subtitle: (title) ? ' - ' + subtitle : subtitle
            })
        }
        let jump = document.createElement("a");
        jump.id = "skipChart_" + id;
        jump.href = "#backChart_" + id;
        jump.className = "wt-offscreen";
        jump.innerHTML = "Back to previous chart.";
        $wt.after(jump, container);
        this.buildMenu(container, racing);
        if (racing) {
            return $wt.racing.buildToolbar(container, params)
        }
        this.buildSheetsSelector(container);
        this.buildCategoriesSelector(container);
        this.buildSeriesSelector(container)
    }
    actionsMenu(container, what, event) {
        let content = '';
        let open = !1;
        let libRef = container.obj;
        let binary = container.params.dataset.options.export.binary;
        let labels = $wt.label("charts", "highcharts.lang", container.params.lang);
        let menuText = container.ui.toolbar.querySelector('[data-action="fullscreen"]');
        let srcHeight = null;
        const exitHandler = () => {
                if (open) {
                    container.classList.remove("wt-charts-fullscreen");
                    menuText.innerHTML = labels.viewFullscreen;
                    menuText.setAttribute('aria-pressed', !1);
                    document.removeEventListener('fullscreenchange', exitHandler, !1);
                    document.removeEventListener('mozfullscreenchange', exitHandler, !1);
                    document.removeEventListener('MSFullscreenChange', exitHandler, !1);
                    document.removeEventListener('webkitfullscreenchange', exitHandler, !1);
                    libRef.setSize(container.params?.data?.chart?.width || null, srcHeight || null, !1)
                }
            }
        ;
        if (what === 'pattern') {
            let menuText = container.ui.toolbar.querySelector('[data-action="pattern"]');
            let isPressed = menuText.getAttribute('aria-pressed') === 'true';
            if (isPressed) {
                container.usePattern = !1;
                menuText.setAttribute('aria-pressed', !1);
                container.obj.render(container)
            } else {
                container.usePattern = !0;
                menuText.setAttribute('aria-pressed', !0);
                container.obj.render(container)
            }
        } else if (what === 'fullscreen') {
            container.classList.toggle("wt-charts-fullscreen");
            if (!container.classList.contains("wt-charts-fullscreen")) {
                let cancelFullscreen = document.cancelFullScreen || document.webkitCancelFullScreen || document.mozCancelFullScreen || document.exitFullscreen;
                if (cancelFullscreen) {
                    cancelFullscreen.call(document)
                }
                exitHandler();
                open = !1
            } else {
                menuText.innerHTML = labels.exitFullscreen;
                menuText.setAttribute('aria-pressed', !0);
                let elm = container;
                let switchTo = elm.requestFullScreen || elm.webkitRequestFullScreen || elm.mozRequestFullScreen || elm.msRequestFullScreen;
                if (switchTo) {
                    switchTo.call(elm)
                }
                document.addEventListener('fullscreenchange', exitHandler, !1);
                document.addEventListener('mozfullscreenchange', exitHandler, !1);
                document.addEventListener('MSFullscreenChange', exitHandler, !1);
                document.addEventListener('webkitfullscreenchange', exitHandler, !1);
                srcHeight = libRef.chartHeight;
                setTimeout( () => {
                        libRef.setSize(null, null, !1);
                        open = !0
                    }
                    , 500)
            }
            libRef.reflow();
            container.ui.charts.removeAttribute('style');
            $wt.trigger(window, "wtChartFullscreen", {
                ui: container.ui,
                instance: libRef
            })
        } else if (what === 'csv') {
            event.preventDefault();
            content = this.exporting.content(what, libRef.getCSV(), this.exporting.extra(container, container.params.dataset.options.export));
            this.useSmlExporter(container, content, what)
        } else if (what === 'xls' && binary) {
            event.preventDefault();
            content = this.exporting.content(`${what}-bin`, libRef.getDataRows(!0).slice(1), this.exporting.extra(container, container.params.dataset.options.export));
            this.useBinaryExporter(container, content, what)
        } else if (what === 'html' || what === 'xls') {
            event.preventDefault();
            this.downloadHtmlAndXls(container, what)
        } else if (what === 'svg') {
            this.downloadSVG(container)
        } else if (what === 'png') {
            this.downloadPNG(container)
        } else if (what === 'jpg') {
            this.downloadJPG(container)
        } else if (what === 'pdf') {
            this.downloadPDF(container)
        } else if (what === 'print') {
            this.printChart(container)
        } else {
            $wt.trigger(window, "wtChartMenuAction", what)
        }
    }
    printChart(container) {
        $wt.print(container, {
            filter: (dom) => {
                if (dom.classList) {
                    return !dom.classList.contains('wt-charts--toolbar') && !dom.classList.contains('sbkm')
                }
                return !0
            }
        }).then( () => {}
        ).catch( () => {}
        )
    }
    downloadPDF(container) {
        let libRef = container.obj;
        let title = libRef?.options?.title?.text || document.title;
        $wt.print(container, {
            download: !0,
            filetype: 'pdf',
            filename: title,
            filter: (dom) => {
                if (dom.classList) {
                    return !dom.classList.contains('wt-charts--toolbar') && !dom.classList.contains('sbkm')
                }
                return !0
            }
        }).then( () => {}
        ).catch( () => {}
        )
    }
    downloadPNG(container) {
        container.obj.exportChartLocal({
            type: 'image/png'
        })
    }
    downloadJPG(container) {
        container.obj.exportChartLocal({
            type: 'image/jpeg'
        })
    }
    downloadSVG(container) {
        container.obj.exportChartLocal({
            type: 'image/svg+xml'
        })
    }
    downloadHtmlAndXls(container, what) {
        let libRef = container.obj;
        let content = this.exporting.content(what, libRef.getTable(), this.exporting.extra(container, container.params.dataset.options.export));
        this.useSmlExporter(container, content, what)
    }
    useSmlExporter(container, content, what) {
        $wt.post($wt.root + "/rest/charts/export/" + what + "/", {
            output: "download",
            target: "_self",
            back_to_prev: encodeURIComponent($wt.charts.utils.i18n.label("back_to_prev", container.params.lang)),
            content: (what === "html" ? encodeURIComponent(content) : content),
            title: encodeURIComponent(container.params?.data?.title?.text || ""),
            subtitle: encodeURIComponent(container.params?.data?.subtitle?.text || ""),
            ref: encodeURI(location.href),
            filename: container.params.dataset.options.export.filename || ""
        })
    }
    useBinaryExporter(container, content) {
        let libRef = container.obj;
        const xlsBinaryExport = () => {
                if (Highcharts.getOptions().exporting) {
                    let name;
                    if (container.params.dataset.options.export.filename) {
                        name = container.params.dataset.options.export.filename
                    } else if (libRef.options.exporting.filename) {
                        name = libRef.options.exporting.filename
                    } else if (libRef.title && libRef.title.textStr) {
                        name = libRef.title.textStr.replace(/ /g, '-').toLowerCase()
                    } else {
                        name = "chart"
                    }
                    writeXlsxFile(content, {
                        fileName: `${name}.xlsx`
                    })
                }
            }
        ;
        $wt.include($wt.root + "/libs/write-excel-file/write-excel-file.min.js", xlsBinaryExport)
    }
    setupPre(container) {
        const options = container.params.options || {};
        const translations = options.translations;
        const separator = options.separator;
        if (translations !== !1) {
            Highcharts.setOptions({
                lang: $wt.label("charts", "highcharts.lang", container.params.lang)
            })
        }
        if (separator.decimals) {
            Highcharts.setOptions({
                lang: {
                    decimalPoint: separator.decimals
                }
            })
        }
        if (separator.thousands) {
            Highcharts.setOptions({
                lang: {
                    thousandsSep: separator.thousands
                }
            })
        }
        Highcharts.SVGRenderer.prototype.symbols.cross = function(x, y, w, h) {
            const angle1 = 45 * (Math.PI / 180);
            const angle2 = -45 * (Math.PI / 180);
            const cx = x + w / 2;
            const cy = y + h / 2;
            const thickness = Math.min(w, h) * 0.15;
            const halfW = w / 2;
            const halfT = thickness / 2;
            function rotatePoint(px, py, angle) {
                const dx = px - cx;
                const dy = py - cy;
                return [cx + dx * Math.cos(angle) - dy * Math.sin(angle), cy + dx * Math.sin(angle) + dy * Math.cos(angle)]
            }
            const p1 = rotatePoint(cx - halfW, cy - halfT, angle1);
            const p2 = rotatePoint(cx + halfW, cy - halfT, angle1);
            const p3 = rotatePoint(cx + halfW, cy + halfT, angle1);
            const p4 = rotatePoint(cx - halfW, cy + halfT, angle1);
            const p5 = rotatePoint(cx - halfW, cy - halfT, angle2);
            const p6 = rotatePoint(cx + halfW, cy - halfT, angle2);
            const p7 = rotatePoint(cx + halfW, cy + halfT, angle2);
            const p8 = rotatePoint(cx - halfW, cy + halfT, angle2);
            return ['M', p1[0], p1[1], 'L', p2[0], p2[1], 'L', p3[0], p3[1], 'L', p4[0], p4[1], 'Z', 'M', p5[0], p5[1], 'L', p6[0], p6[1], 'L', p7[0], p7[1], 'L', p8[0], p8[1], 'Z']
        }
        ;
        Highcharts.SVGRenderer.prototype.symbols.star = function(x, y, w, h) {
            const scale = 1.5;
            const cx = x + w / 2;
            const cy = y + h / 2;
            const outerRadius = (w / 2) * scale;
            const innerRadius = outerRadius / 2.5;
            const points = 5;
            const angle = Math.PI / points;
            let path = [];
            for (let i = 0; i < 2 * points; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const xPoint = cx + radius * Math.sin(i * angle);
                const yPoint = cy - radius * Math.cos(i * angle);
                path.push(i === 0 ? 'M' : 'L', xPoint, yPoint)
            }
            path.push('Z');
            return path
        }
    }
    setupPost(container) {
        const lib = container.obj;
        const exporting = Highcharts.getOptions().exporting;
        if (exporting) {
            Highcharts.setOptions({
                exporting: {
                    buttons: {
                        contextButton: {
                            menuItems: exporting.buttons.contextButton.menuItems.filter(function(item) {
                                return item !== 'openInCloud'
                            })
                        }
                    }
                }
            })
        }
        if (container.params?.data?.responsive) {
            Highcharts.addEvent(lib, "update", function(event) {
                if (event.options && event.options.responsive) {
                    this.userOptions.responsive = this.options.responsive = event.options.responsive
                }
            })
        }
        if (container.params?.events?.resize) {
            Highcharts.addEvent(lib, "resize", function() {
                container.params.events.resize(container)
            })
        }
        window.addEventListener('resizeCharts', () => {
                try {
                    lib.reflow()
                } catch (e) {}
            }
        )
    }
    extend(container) {
        const lib = container.obj;
        let params = container.params;
        lib.extend = function(o) {
            for (let i in o) {
                this[i] = o[i]
            }
        }
        ;
        lib.extend({
            ui: container,
            refresh: (data) => {
                container.params.data = data;
                lib.render(container);
                return lib
            }
            ,
            getUEC: (name, fallback) => {
                if (params && name) {
                    params = params[name]
                }
                return params || fallback
            }
            ,
            getPath: () => {
                const wcloud = lib.getUEC("wcloud")?.root;
                if (wcloud) {
                    return wcloud
                }
                const custom = lib.getUEC("_custom");
                if (Array.isArray(custom) && custom.length) {
                    return $wt.absolute(custom.pop()).split("/").slice(0, -1).join('/') + '/'
                }
                return $wt.absolute(custom || "./")
            }
            ,
            onready: (func) => {
                $wt.charts._dataset(params, (dataset) => {
                        func(dataset)
                    }
                )
            }
            ,
            onerror: (func) => func(),
            render: (container, callback) => {
                try {
                    this.transform.align(container);
                    this.afterLaskoProcessingHook(container);
                    this.transform.filter(container);
                    this.transform.sort(container);
                    this.afterSortHook(container);
                    if (Array.isArray(container.params.data.series)) {
                        container.params.data.seriesOriginal = container.params.data.series.slice()
                    }
                    this.buildToolbar(container);
                    this.transform.categories(container);
                    this.transform.series(container);
                    this.transform.groups(container);
                    this.transform.pattern(container);
                    this.afterTransformHook(container);
                    this.translator(container);
                    while (lib.series.length > 0) {
                        lib.series[0].remove(!0)
                    }
                    lib.update(container.params.data, !0, !0, !0);
                    this.buildChartHeader(container);
                    [...container.querySelectorAll('[aria-hidden], [tabindex]')].forEach(elm => {
                            if (elm.getAttribute('tabindex') === "0") {
                                elm.removeAttribute('tabindex')
                            }
                            if (elm.getAttribute('aria-hidden') === "false") {
                                elm.removeAttribute('aria-hidden')
                            }
                        }
                    );
                    if (typeof callback === "function") {
                        callback()
                    }
                } catch (e) {
                    console.error(e)
                }
            }
            ,
            remove: function() {
                lib.destroy()
            },
            loading: {
                show: () => {
                    container.ui.loader.style.display = "block"
                }
                ,
                hide: () => {
                    container.ui.loader.style.display = "none"
                }
            }
        })
    }
    translator(container) {
        const params = container.params;
        const data = params.data;
        const lang = params.lang;
        const translations = params.options.translations;
        if (translations === !1) {
            return
        }
        function translate(key={}, type) {
            const prop = typeof type !== "undefined" ? type : "text";
            if (key && key.hasOwnProperty(prop)) {
                key[prop] = $wt.charts.utils.i18n.label(key[prop], lang)
            }
        }
        ["title", "subtitle", "credits", "caption"].forEach( (property) => {
                if (data.hasOwnProperty(property)) {
                    translate(data[property])
                }
            }
        );
        ["legend", "xAxis", "yAxis", "zAxis"].forEach( (property) => {
                if (!data.hasOwnProperty(property)) {
                    return
                }
                if (data[property].title) {
                    translate(data[property].title)
                }
                if (Array.isArray(data[property])) {
                    data[property].forEach( (axis) => {
                            if (axis.title) {
                                translate(axis.title)
                            }
                        }
                    )
                }
            }
        );
        (data.annotations || []).forEach( (annotation) => {
                if (annotation.labels) {
                    annotation.labels.forEach( (label) => translate(label))
                }
            }
        );
        if (data?.labels?.items) {
            data.labels.items.forEach( (item) => {
                    translate(item, "html")
                }
            )
        }
        if (data?.credits?.href) {
            translate(data.credits, "href")
        }
        if (data?.tooltip) {
            ["valuePrefix", "valueSuffix"].forEach( (property) => {
                    translate(data.tooltip, property)
                }
            )
        }
        if (data?.plotOptions) {
            let props = ["series"];
            if (data?.chart?.type) {
                props.push(data.chart.type)
            }
            props.forEach( (property) => {
                    if (data.plotOptions[property]?.dataLabels?.format) {
                        translate(data.plotOptions[property].dataLabels, "format")
                    }
                }
            )
        }
        ["xAxis", "yAxis", "zAxis"].forEach( (property) => {
                if (data.hasOwnProperty(property)) {
                    ["plotBands", "plotLines"].forEach( (propertySub) => {
                            if (data[property].hasOwnProperty(propertySub)) {
                                data[property][propertySub].forEach( (plot) => {
                                        if (plot.label) {
                                            translate(plot.label)
                                        }
                                    }
                                )
                            }
                        }
                    )
                }
            }
        );
        if (data?.xAxis?.categories) {
            data.xAxis.categories.forEach( (category, index) => {
                    translate(data.xAxis.categories, index)
                }
            )
        }
        function translateCustom(custom) {
            if (custom) {
                if (typeof custom === "object") {
                    for (let key in custom) {
                        if (typeof custom[key] === "string") {
                            translate(custom, key)
                        }
                    }
                }
            }
        }
        function translateSeries(series, withDrilldown) {
            if (series) {
                if (typeof series === "object" && !Array.isArray(series)) {
                    series = [series]
                }
                series.forEach( (serie) => {
                        translate(serie, "name");
                        translateCustom(serie?.custom);
                        if (serie.data) {
                            serie.data.forEach( (data) => {
                                    translateCustom(data?.custom);
                                    if (typeof data === "object" && !Array.isArray(data)) {
                                        translate(data, "name")
                                    } else if (withDrilldown && Array.isArray(data)) {
                                        if (typeof data[0] === "string") {
                                            data[0] = $wt.charts.utils.i18n.label(data[0], lang)
                                        }
                                    }
                                }
                            )
                        }
                    }
                )
            }
        }
        translateSeries(data.series);
        if (data?.drilldown?.series) {
            translateSeries(data.drilldown.series, !0)
        }
    }
    afterLaskoProcessingHook() {}
    afterSortHook() {}
    afterTransformHook() {}
    getCategorySelectorItems(container) {
        return container.params.dataset.lasko.categories.map(category => {
                category.label = $wt.charts.utils.i18n.label(category.label, container.params.lang);
                return category
            }
        )
    }
}
( (c, h, a, r, t, s) => {
        $wt.charts.highcharts = {
            run: async (container) => {
                let lib = {};
                let dom = container.ui.charts;
                let instance = await DefaultChart.createChartInstance(container);
                instance.setupPre(container);
                if (Highcharts.ganttChart) {
                    lib = Highcharts.ganttChart(dom, instance.config)
                } else if (Highcharts.stockChart) {
                    if (container?.params?.instantiator === "chart") {
                        lib = Highcharts.chart(dom, instance.config)
                    } else {
                        lib = Highcharts.stockChart(dom, instance.config)
                    }
                } else {
                    lib = Highcharts.chart(dom, instance.config)
                }
                container.obj = lib;
                instance.setupPost(container);
                instance.extend(container);
                return lib
            }
            ,
            ui: {
                menu: {
                    overwrite: {
                        download: () => {}
                    }
                }
            }
        }
    }
)();
class EstatChart extends DefaultChart {
    static LOGO_SRC = "https://webtools.europa.eu/images/eurostat_4.png?t=e22da071";
    constructor(container) {
        super();
        this.enableCategories = !0;
        this.enableSeries = !0;
        if (ScatterChart.isScatterChart(container)) {
            this.enableSeries = !1
        }
        if (container.params.data.chart?.type === 'treemap') {
            this.enableSeries = !1;
            this.enableCategories = !1
        }
        this.enabledGroups = !0;
        this.enableSocialButtons = !0;
        this.aliasing = {
            EU_AGGREGATES: ["EU27_2020", "EU", "EA20", "EA"],
            MEMBER_STATES: ["AT", "BE", "BG", "CY", "CZ", "DE", "DK", "EE", "EL", "ES", "FI", "FR", "HR", "HU", "IE", "IT", "LT", "LU", "LV", "MT", "NL", "PL", "PT", "RO", "SE", "SI", "SK"],
            EFTA_STATES: ["CH", "IS", "NO", "LI"],
            CANDIDATES: ["AL", "BA", "GE", "MD", "ME", "MK", "RS", "TR", "UA"]
        };
        container.params.menu = ["pdf", "xls", "png", "csv", "svg"];
        this.config = $wt.mergeParams(this.config, this.updateConfig(container), null)
    }
    async addCustomTranslations(container) {
        return await CountryLabelFeature.addCountryLabels(container)
    }
    updateConfig(container) {
        let color = container.params?.data?.chart?.type === "pie" ? "point" : "series";
        let estatConfig = {
            title: {
                align: "left",
                style: {
                    fontFamily: "Arial",
                    fontSize: "1.4rem",
                    color: "#262B38",
                    fontWeight: "bold",
                }
            },
            subtitle: {
                align: "left",
                style: {
                    fontFamily: "Arial",
                    fontSize: "1.2rem",
                    color: "#262B38",
                }
            },
            caption: {
                style: {
                    fontFamily: "Arial",
                    fontSize: "1rem",
                    color: "#000000",
                },
                align: "left",
                verticalAlign: "bottom",
                useHTML: !0,
            },
            tooltip: {
                shared: !0,
                useHTML: !0,
                headerFormat: '<table class="wt-charts--tooltip"><tr><th colspan="2" class="tooltip-header">{point.key}</th></tr>',
                pointFormat: `<tr>
          <td>
            <div class="wt-charts--tooltip-color">
              <span class="wt-charts--tooltip-background" style="background: {${color}.color};">&nbsp;</span>
              <span>{series.name}</span>
            </div>
          </td>
          <td>
            <span>{point.y}</span>
          </td>
        </tr>`,
                footerFormat: '</table>',
                borderColor: "#d1d1d1",
                borderWidth: 1,
                borderRadius: 0,
                padding: 0,
                valueDecimals: 2
            },
            xAxis: {
                type: "category",
                gridLineColor: "#e6e6e6",
                tickColor: "#ccd5eb",
                tickLength: 10,
                tickWidth: 1,
                title: {
                    style: {
                        fontFamily: "Arial",
                        fontSize: "1.4rem",
                        color: "#000000",
                        fontWeight: "bold",
                    }
                },
                labels: {
                    rotation: 0,
                    y: null,
                    style: {
                        fontFamily: 'Arial',
                        fontSize: "0.55rem",
                        color: "#000000",
                        fontWeight: "bold",
                        fontStyle: ""
                    }
                }
            },
            yAxis: {
                gridLineWidth: 0.8,
                gridLineDashStyle: "LongDash",
                gridLineColor: "#A8AAAF",
                tickColor: "#ccd5eb",
                tickWidth: 1,
                tickLength: 10,
                title: {
                    style: {
                        fontFamily: "Arial",
                        fontSize: "1rem",
                        color: "#000000"
                    }
                },
                labels: {
                    rotation: 0,
                    x: 0,
                    y: 15,
                    style: {
                        fontFamily: 'Arial',
                        fontSize: "0.55rem",
                        color: "#000000",
                        fontWeight: "bold",
                        fontStyle: ""
                    }
                }
            },
            colors: ["#2644A7", "#B09120", "#E04040", "#208486", "#388AE2", "#AA5F18", "#738CE5", "#C6AF5D", "#FF8080", "#5FADAD", "#80BFFA", "#C19062", "#9CC1FA", "#EFD18C", "#FFA3A3", "#92C1C0", "#A5DAF9", "#DFB18B"],
            legend: {
                enabled: !0,
                layout: "vertical",
                align: "right",
                verticalAlign: "middle",
                itemStyle: {
                    fontFamily: "Arial",
                    fontSize: "1rem",
                    color: "#000000"
                },
                backgroundColor: "#ffffff",
                borderColor: "#000000"
            },
            plotOptions: {
                pie: {
                    showInLegend: !0,
                    allowPointSelect: !1,
                    point: {
                        events: {
                            legendItemClick: function(e) {
                                e.preventDefault();
                                return !1
                            }
                        }
                    }
                },
                series: {
                    dataLabels: {
                        enabled: !1,
                        style: {
                            fontSize: "12px",
                        }
                    },
                    events: {
                        legendItemClick: function(e) {
                            e.preventDefault();
                            return !1
                        }
                    },
                    states: {
                        hover: {
                            borderColor: "black"
                        }
                    }
                }
            }
        };
        return estatConfig
    }
    cleanupTags(container) {
        let tooltip = container.params.data?.tooltip || {};
        ["headerFormat", "pointFormat", "footerFormat", "valuePrefix", "valueSuffix"].forEach(prop => {
                if (tooltip[prop]) {
                    tooltip[prop] = tooltip[prop].replace(/<img[^>]*>/g, "")
                }
            }
        )
    }
    getEstatColors(numberOfElements, primaryColors, lightColors, lightestColors) {
        let colors = [];
        if (numberOfElements <= 3) {
            colors = primaryColors.slice(0, 3)
        }
        if (numberOfElements > 3 && numberOfElements <= 6) {
            for (let i = 0; i <= 2; i++) {
                colors.push(primaryColors[i]);
                colors.push(lightColors[i])
            }
        }
        if (numberOfElements === 7) {
            for (let i = 0; i <= 2; i++) {
                colors.push(primaryColors[i]);
                colors.push(lightColors[i]);
                if (i === 0) {
                    colors.push(lightestColors[i])
                }
            }
        }
        if (numberOfElements > 7 && numberOfElements <= 9) {
            for (let i = 0; i <= 2; i++) {
                colors.push(primaryColors[i]);
                colors.push(lightColors[i]);
                colors.push(lightestColors[i])
            }
        }
        if (numberOfElements > 9) {
            colors = this.getEstatColors(9, primaryColors, lightColors, lightestColors);
            let remainingElements = numberOfElements - 9;
            colors.push(...this.getEstatColors(remainingElements <= 9 ? remainingElements : 9, primaryColors.slice(3, 6), lightColors.slice(3, 6), lightestColors.slice(3, 6)))
        }
        return colors
    }
    generateColors(container) {
        let ref = container.params?.data?.series?.slice();
        if (!ref) {
            return
        }
        let series = (ref[0]) ? ref[0].data : !1;
        let type = container.params.data?.chart?.type;
        if (container.params.data.colorsOriginal) {
            container.params.data.colors = container.params.data.colorsOriginal
        }
        let rangeColors = container.params.data.colors;
        if (rangeColors?.length === 18) {
            if (!container.params.data.colorsOriginal) {
                container.params.data.colorsOriginal = rangeColors
            }
            let primaryColors = rangeColors.slice(0, 6);
            let lightColors = rangeColors.slice(6, 12);
            let lightestColors = rangeColors.slice(12, 18);
            let numberOfElements = (series && ref && (type === "pie" || type === "treemap")) ? series.length : ref.length;
            container.params.data.colors = this.getEstatColors(numberOfElements, primaryColors, lightColors, lightestColors)
        }
    }
    setChartSkin(container) {
        const skin = container.params?.options?.skin;
        container.classList.add("wt-charts--estat");
        if (skin) {
            container.classList.remove("wt-charts--estat");
            container.classList.add(skin)
        }
    }
    getCustomExportSettings(container) {
        Highcharts.AST.allowedTags.push('image');
        Highcharts.AST.allowedAttributes.push('preserveAspectRatio');
        let config = {
            title: {
                style: {
                    fontSize: "16px"
                }
            },
            subtitle: {
                style: {
                    fontSize: "14px"
                }
            },
            caption: {
                style: {
                    fontSize: "10px",
                }
            },
            legend: {
                itemStyle: {
                    fontSize: "14px",
                }
            },
            xAxis: {
                title: {
                    style: {
                        fontSize: "14px",
                    }
                },
                labels: {
                    style: {
                        fontSize: "10px",
                    }
                }
            },
            yAxis: {
                title: {
                    style: {
                        fontSize: "14px",
                    }
                },
                labels: {
                    style: {
                        fontSize: "10px",
                    }
                }
            }
        };
        const logo = container.params.options.logo;
        const heightImage = 21;
        const widthImage = 155;
        if (logo.visible) {
            config.chart = {
                spacingTop: 10,
                spacingBottom: 10,
                events: {
                    render() {
                        const chart = this;
                        if (chart.customLogo) {
                            chart.customLogo.destroy()
                        }
                        chart.customLogo = chart.renderer.g('customLogo').add();
                        const x = chart.chartWidth - widthImage - 10;
                        const y = logo.position === 'top' ? 10 : chart.chartHeight - heightImage - 10;
                        chart.renderer.image(EstatChart.LOGO_SRC, x, y, widthImage, heightImage).add(chart.customLogo)
                    },
                },
            };
            config.chart.spacingTop = logo.position === 'top' ? 45 : 10;
            config.chart.spacingBottom = logo.position === 'bottom' ? 45 : 10
        }
        return config
    }
    setPermanentColors(container) {
        if (!container.params?.options?.permanent_colors || !Array.isArray(container.params.data.series) || !Array.isArray(container.params.data.colors)) {
            return
        }
        let colorList = container.params.data.colors.slice();
        while (colorList.length < 100) {
            colorList.push(...container.params.data.colors)
        }
        let type = container.params.data?.chart?.type;
        let cachedColors = (container.params.data?.cachedColors) ? container.params.data.cachedColors : {};
        let series = container.params.data.series.slice();
        if (type === 'pie') {
            series[0].data = series[0].data.slice().map( (record, index) => {
                    record.color = (cachedColors[record.name]) ? cachedColors[record.name] : colorList[index];
                    cachedColors[record.name] = record.color;
                    return record
                }
            )
        }
        if (!type || type === 'line' || type === 'column') {
            series = series.slice().map( (record, index) => {
                    record.color = (cachedColors[record.name]) ? cachedColors[record.name] : colorList[index];
                    cachedColors[record.name] = record.color;
                    return record
                }
            )
        }
        let categories = container.params.dataset?.options?.categories;
        if (type === 'column' && categories === 'geo' && series.length === 1) {
            const colors = {
                EA: '#F56426',
                EU: '#003399'
            };
            series[0].data.forEach(column => {
                    if (colors.hasOwnProperty(column.name)) {
                        column.color = colors[column.name]
                    }
                }
            )
        }
        container.params.data.cachedColors = cachedColors;
        container.params.data.series = series
    }
    downloadSVG(container) {
        const libRef = container.obj;
        libRef.exportChartLocal({
            type: 'image/svg+xml'
        }, this.getCustomExportSettings(container))
    }
    downloadPNG(container) {
        this.customEstatDownload(container, 'png')
    }
    downloadPDF(container) {
        this.customEstatDownload(container, 'pdf')
    }
    downloadHtmlAndXls(container, what) {
        let libRef = container.obj;
        let librefTable = libRef.getTable();
        if (ScatterChart.isScatterChart(container)) {
            librefTable = ScatterChart.updateContentHeaders(container, librefTable)
        }
        let content = this.exporting.content(what, librefTable, this.exporting.extra(container, container.params.dataset.options.export));
        this.useSmlExporter(container, content, what)
    }
    printChart(container) {
        $wt.print(container, {
            filter: (dom) => {
                if (dom.classList) {
                    if (dom.classList.contains('wt-charts--toolbar')) {
                        return !!dom.querySelector('select')
                    }
                    if (dom.classList.contains('sbkm') || dom.classList.contains('wt-charts--menu')) {
                        return !1
                    }
                }
                return !0
            }
        }).then( () => {}
        ).catch( () => {}
        )
    }
    customEstatDownload(container, type) {
        let libRef = container.obj;
        let title = libRef?.options?.title?.text || document.title;
        $wt.print(container, {
            download: !0,
            filetype: type,
            filename: title,
            filter: (dom) => {
                if (dom.classList) {
                    if (dom.classList.contains('wt-charts--toolbar')) {
                        return !!dom.querySelector('select')
                    }
                    if (dom.classList.contains('sbkm') || dom.classList.contains('wt-charts--menu')) {
                        return !1
                    }
                }
                return !0
            }
        }).then( () => {}
        ).catch( () => {}
        )
    }
    afterLaskoProcessingHook(container) {
        this.additionalLaskoProcessing(container)
    }
    afterSortHook(container) {
        this.generateColors(container);
        this.setPermanentColors(container)
    }
    afterTransformHook(container) {
        this.cleanupTags(container);
        TreeMapChart.processChart(container);
        CountryLabelFeature.applyInXAxis(container);
        CountryLabelFeature.applyInTooltip(container);
        ScatterChart.processChart(container);
        HighLowChart.processChart(container)
    }
    getCategorySelectorItems(container) {
        return CountryLabelFeature.getCategoryFilterValues(container)
    }
    buildChartHeader(container) {
        if (container.header_done) {
            return
        }
        super.buildChartHeader(container);
        const logo = container.params.options.logo;
        if (logo.visible) {
            const position = logo.position === 'top' ? 'header' : 'footer';
            let logoContainer = document.createElement('div');
            logoContainer.classList.add("wt-charts--estatcharts-logo");
            logoContainer.innerHTML = `<img height="26" alt="EUROSTAT LOGO" src="${EstatChart.LOGO_SRC}">`;
            container.ui[position].appendChild(logoContainer)
        }
    }
    useSmlExporter(container, content, what) {
        if (what === 'xls') {
            let doc = (new DOMParser).parseFromString(content, "text/html");
            function getMaxColumns(table) {
                let maxColumns = 0;
                for (const row of table.rows) {
                    maxColumns = Math.max(maxColumns, row.cells.length)
                }
                return maxColumns
            }
            function insertFootnote(container, tableElement) {
                const caption = container.params?.data?.caption?.text || "";
                if (caption === "") {
                    return
                }
                let captionDOM = new DOMParser().parseFromString(caption, 'text/html');
                let bookmarkSource = captionDOM.querySelector(`[class="wt-charts--estat-bookmark-source"]`)?.innerText;
                let footnote = captionDOM.querySelector(`[class="wt-charts--estat-footnote"]`)?.innerText;
                let sources = Array.from(captionDOM.getElementsByTagName('a')).map(function(anchor) {
                    return {
                        url: anchor.href,
                        label: anchor.innerText
                    }
                });
                if (Array.isArray(sources)) {
                    const labels = sources.map(obj => obj.label).join(", ");
                    if (labels !== "") {
                        bookmarkSource += ": " + labels
                    }
                }
                const tfoot = document.createElement("tfoot");
                tfoot.appendChild(addTableFooterRow(tfoot, footnote, getMaxColumns(tableElement)));
                tfoot.appendChild(addTableFooterRow(tfoot, bookmarkSource, getMaxColumns(tableElement)));
                tableElement.appendChild(tfoot)
            }
            function addTableFooterRow(tfoot, message, colspan) {
                const tr = document.createElement("tr");
                const th = document.createElement("th");
                th.colSpan = colspan;
                th.textContent = message;
                th.style.fontWeight = "normal";
                tr.appendChild(th);
                return tr
            }
            function insertSubtitle(container, tableElement) {
                const subtitle = container.params?.data?.subtitle?.text || "";
                if (subtitle === "") {
                    return
                }
                let thead = tableElement.querySelector("thead");
                if (!thead) {
                    thead = document.createElement("thead");
                    tableElement.appendChild(thead)
                }
                const newRow = document.createElement("tr");
                const th = document.createElement("th");
                th.colSpan = getMaxColumns(tableElement);
                th.style.fontWeight = "normal";
                th.textContent = subtitle;
                newRow.appendChild(th);
                thead.insertBefore(newRow, thead.firstChild)
            }
            const tables = doc.getElementsByTagName("table");
            insertFootnote(container, tables[0]);
            insertSubtitle(container, tables[0]);
            super.useSmlExporter(container, doc.body.outerHTML, what)
        } else {
            super.useSmlExporter(container, content, what)
        }
    }
    additionalLaskoProcessing(container) {
        const params = container.params;
        const data = params.data;
        const dataset = params.dataset;
        const lasko = dataset.lasko;
        const options = dataset.options;
        const categories = options.categories;
        if (categories === 'geo') {
            lasko.categories = lasko.categories.map(item => {
                    let id = item.id || item.label;
                    id = id ? String(id).replace(/^(EA|EU).*$/, '$1') : null;
                    return {
                        id: id,
                        label: item.label,
                        groupId: id
                    }
                }
            );
            data.xAxis.categories = lasko.categories.map(row => row.id);
            data.series.forEach(series => {
                    series.data.forEach( (data, index) => {
                            data.id = lasko.categories[index].id;
                            data.name = data.id;
                            let estatTranslation = $wt.label("estatcharts", data.id, container.params.lang, null, null, !0);
                            data.country_label = $wt.label("charts", estatTranslation, container.params.lang, null, null, !0);
                            data.country_code = data.id
                        }
                    );
                    series.tooltip = {
                        followPointer: !0
                    }
                }
            )
        }
    }
    extend(container) {
        super.extend(container);
        this.setChartSkin(container);
        let lib = container.obj;
        lib.extend({
            getSvgWithOptions: () => {
                return lib.getSVGForExport({}, this.getCustomExportSettings(container))
            }
            ,
        })
    }
}
class CountryLabelFeature {
    static async addCountryLabels(container) {
        return new Promise( (resolve) => {
                if (this.isEnabled(container)) {
                    if ($wt.dictionary?.estatcharts?.en?.ACP) {
                        resolve()
                    }
                    let version = container.params.options.country_labels?.version;
                    $wt.loadTranslations($wt.root + "/js/estatcodes_" + version + ".json?t=" + $wt.token, () => {
                            resolve()
                        }
                        , "estatcharts")
                } else {
                    resolve()
                }
            }
        )
    }
    static isEnabled(container) {
        return container.params?.dataset?.options?.categories === 'geo'
    }
    static applyInXAxis(container) {
        if (this.isEnabled(container)) {
            if (container.params.options.country_labels?.xAxis) {
                container.params.data.xAxis.categories = container.params.data.xAxis.categories.map( (category) => {
                        if (category) {
                            category = $wt.label("estatcharts", category, container.params.lang, null, null, !0);
                            return $wt.label("charts", category, container.params.lang, null, null, !0)
                        }
                        return category
                    }
                );
                container.params.data.series = container.params.data.series.map(series => {
                        series.data = series.data.map(row => {
                                if (row?.y === null && row?.name === null) {
                                    return row
                                }
                                let changedSeries = {
                                    ...row
                                };
                                changedSeries.name = row.country_label;
                                return changedSeries
                            }
                        );
                        return series
                    }
                )
            }
        }
    }
    static applyInTooltip(container) {
        if (this.isEnabled(container)) {
            let defaultTooltipFormat = container.params.data.tooltip?.headerFormat || '<table class="wt-charts--tooltip"><tr><th colspan="2" class="tooltip-header">{point.key}</th></tr>';
            const tooltipFormat = defaultTooltipFormat.replace('{point.key}', '{point.point.options.country_label}');
            container.params.data.tooltip = {
                ...container.params.data.tooltip,
                headerFormat: tooltipFormat
            }
        }
    }
    static getCategoryFilterValues(container) {
        let items = container.params.dataset.lasko.categories;
        if (!this.isEnabled(container)) {
            items.forEach( (category) => {
                    category.label = $wt.charts.utils.i18n.label(category.label, container.params.lang, null, null, !0)
                }
            )
        } else {
            items.forEach(item => {
                    item.label = `[${item.id}] ` + $wt.label("charts", $wt.label("estatcharts", item.id, container.params.lang, null, null, !0), container.params.lang, null, null, !0)
                }
            )
        }
        return items
    }
}
class HighLowChart {
    static processChart(container) {
        const params = container.params;
        const data = params.data;
        const colors = data.colors;
        if (data.chart?.type === 'high-low' || data.chart?.originalType === 'high-low') {
            container.params.data.chart.type = 'scatter';
            container.params.data.chart.originalType = 'high-low';
            if (container.params?.options?.series_markers) {
                let seriesMarkers = container.params.options.series_markers;
                let markersTransparentColor = container.params.options.marker_transparent_color;
                data.series.forEach( (seriesItem, index) => {
                        if (seriesMarkers[index]) {
                            const markerObj = {
                                radius: seriesMarkers[index].radius,
                                symbol: seriesMarkers[index].symbol
                            };
                            if (seriesMarkers[index].symbol !== 'cross' && markersTransparentColor) {
                                markerObj.fillColor = 'transparent';
                                markerObj.lineWidth = 2;
                                markerObj.lineColor = colors[index]
                            }
                            if (seriesMarkers[index]?.states) {
                                markerObj.states = seriesMarkers[index].states
                            }
                            seriesItem.marker = markerObj;
                            seriesItem.zIndex = seriesMarkers[index].zIndex
                        }
                    }
                )
            }
            const verticalLineSeries = {
                name: 'Vertical Lines',
                type: 'line',
                data: [],
                color: 'gray',
                enableMouseTracking: !1,
                showInLegend: !1,
                zIndex: 0,
                marker: {
                    enabled: !1
                }
            };
            const connectingLines = data.xAxis.categories.map( (country, index) => {
                    let maxY = -Infinity;
                    let minY = Infinity;
                    data.series.forEach(series => {
                            const point = series.data[index];
                            if (point && typeof point.y === 'number') {
                                if (point.y > maxY) {
                                    maxY = point.y
                                }
                                if (point.y < minY) {
                                    minY = point.y
                                }
                            }
                        }
                    );
                    return {
                        x: index,
                        y1: maxY,
                        y2: minY
                    }
                }
            );
            connectingLines.forEach(line => {
                    if (line.y1 !== -Infinity && line.y2 !== Infinity) {
                        verticalLineSeries.data.push({
                            x: line.x,
                            y: line.y1
                        }, {
                            x: line.x,
                            y: line.y2
                        }, null)
                    }
                }
            );
            data.series.push(verticalLineSeries)
        }
    }
}
class ScatterChart {
    static isScatterChart(container) {
        const params = container.params;
        const data = params.data;
        return data.chart?.type === 'scatter' && data.chart?.originalType !== 'high-low'
    }
    static processChart(container) {
        const params = container.params;
        const data = params.data;
        if (ScatterChart.isScatterChart(container)) {
            let xData = data.series[0].data;
            let yData = data.series[1].data;
            let xName = data.series[0].name;
            let yName = data.series[1].name;
            const transformedData = xData.map( (xPoint, index) => {
                    const yPoint = yData[index];
                    return {
                        x: xPoint.y,
                        y: yPoint.y,
                        name: container.params?.dataset?.options?.categories === 'geo' ? xPoint.country_label : xPoint.name,
                        countryName: container.params?.dataset?.options?.categories === 'geo' ? xPoint.country_label : xPoint.name,
                        id: xPoint.id
                    }
                }
            );
            data.series = [{
                name: xName + '/' + yName,
                xName: xName,
                yName: yName,
                data: transformedData
            }];
            data.originalCategory = container.params?.dataset?.options?.categories.toUpperCase();
            if (!data.xAxis.title) {
                data.xAxis.title = {
                    text: xName.toUpperCase()
                }
            }
            if (data.xAxis.categories) {
                delete data.xAxis.categories
            }
            data.xAxis.type = 'linear';
            if (!data.yAxis) {
                data.yAxis = {}
            }
            if (!data.yAxis.title || data.yAxis.title?.text.trim() === '') {
                data.yAxis.title = {
                    text: yName.toUpperCase()
                }
            }
            if (container.params?.options?.series_markers) {
                let seriesMarkers = container.params.options.series_markers;
                data.series.forEach( (seriesItem, index) => {
                        if (seriesMarkers[index]) {
                            seriesItem.marker = {
                                radius: seriesMarkers[index].radius,
                                symbol: seriesMarkers[index].symbol
                            }
                        }
                    }
                )
            }
        }
    }
    static stripHtmlTags(htmlString) {
        const tmp = document.createElement('div');
        tmp.innerHTML = htmlString;
        return tmp.innerText || ''
    }
    static updateContentHeaders(container, content) {
        const params = container.params;
        const data = params.data;
        if (ScatterChart.isScatterChart(container)) {
            if (data.originalCategory) {
                let originalHeaders = [data.originalCategory, ScatterChart.stripHtmlTags(data.xAxis?.title?.text), ScatterChart.stripHtmlTags(data.yAxis?.title?.text)];
                const wrapper = document.createElement('div');
                wrapper.innerHTML = content;
                const table = wrapper.querySelector('table');
                const thead = table.querySelector('thead');
                thead.innerHTML = '';
                const tr = document.createElement('tr');
                originalHeaders.forEach(headerText => {
                        const th = document.createElement('th');
                        th.className = 'highcharts-text highcharts-table-topheading';
                        th.setAttribute('scope', 'col');
                        th.textContent = headerText;
                        tr.appendChild(th)
                    }
                );
                thead.appendChild(tr);
                return table.outerHTML
            }
        }
        return content
    }
}
class TreeMapChart {
    static processChart(container) {
        if (container.params.data.chart?.type !== 'treemap') {
            return
        }
        const params = container.params;
        const data = params.data;
        const dataset = params.dataset;
        if (dataset.format === 'jsonstat') {
            let valueData = data.series[0].data;
            const transformedData = valueData.map( (valuePoint, index) => {
                    const point = {
                        value: valuePoint.y,
                        name: valuePoint.name
                    };
                    if (valuePoint.country_label != null) {
                        point.country_label = valuePoint.country_label
                    }
                    return point
                }
            );
            let seriesName = data.series[0].name;
            data.series = [{
                colorByPoint: !0,
                colors: data.colors,
                data: transformedData,
                name: seriesName,
            }]
        }
        if (dataset.format === 'xls') {
            let nameData = dataset.raw.sheets[0].series[0].data;
            let valueData = dataset.raw.sheets[0].series[1].data;
            let parentData = dataset.raw.sheets[0].series[2].data;
            let idData = dataset.raw.categories;
            const transformedData = idData.map( (idPoint, index) => {
                    if (valueData[index].value !== ':') {
                        if (parentData[index].value) {
                            return {
                                value: valueData[index].value,
                                name: nameData[index].value,
                                id: idPoint['label'],
                                parent: parentData[index].value,
                            }
                        } else {
                            return {
                                value: valueData[index].value,
                                name: nameData[index].value,
                                id: idPoint['label'],
                                parent: "root"
                            }
                        }
                    }
                }
            ).filter(entry => entry !== undefined);
            const parentNodes = transformedData.filter(point => point.parent === "root");
            const childNodes = transformedData.filter(point => point.parent !== "root");
            parentNodes.sort( (a, b) => Number(b.value) - Number(a.value));
            parentNodes.forEach( (point, index) => {
                    point.color = data.colors[index % data.colors.length]
                }
            );
            const sortedTransformedData = parentNodes.concat(childNodes);
            let seriesName = data.series[0].name;
            data.series = [{
                turboThreshold: 0,
                data: sortedTransformedData,
                name: seriesName,
                colors: data.colors,
                allowTraversingTree: !0,
                breadcrumbs: {
                    showFullPath: !0,
                    separator: {
                        text: '>'
                    },
                    buttonTheme: {
                        style: {
                            textDecoration: 'underline'
                        }
                    }
                },
                events: {
                    setRootNode: function(eventArguments) {
                        const newRootId = eventArguments.newRootId;
                        if (newRootId === '') {
                            data.plotOptions.treemap.levels[0].colorByPoint = !0;
                            data.plotOptions.treemap.levels[0].color = undefined
                        } else {
                            data.plotOptions.treemap.levels[0].colorByPoint = !1;
                            const node = this.data.find(point => point.id === newRootId);
                            if (node) {
                                data.plotOptions.treemap.levels[0].color = node.color
                            }
                        }
                    }
                },
            }]
        }
    }
}
